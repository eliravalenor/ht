<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>EVE Chat</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>💬</text></svg>">
    <link rel="shortcut icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>💬</text></svg>">
    <script src="https://unpkg.com/dexie@3.2.4/dist/dexie.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@400;500;600;700&family=Comic+Neue:wght@400;700&family=Fredoka+One&family=Nunito:wght@400;500;600;700&family=Montserrat:wght@400;500;600&family=Inter:wght@400;500;600&family=Roboto:wght@400;500&family=Raleway:wght@400;500;600&family=Lato:wght@400;700&family=Poppins:wght@400;500;600&family=Quicksand:wght@400;500;600&family=Varela+Round&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css?v=20250805-duration-spacing">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <!-- 🔥【新增】状态指示器样式 -->
    <style>
        /* 角色列表状态指示器 */
        .contact-status-indicator {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            z-index: 10;
        }

        /* 已拉黑状态 - 红色 */
        .contact-status-indicator.blocked {
            background-color: #ff4444;
            color: white;
        }

        /* 被拉黑状态 - 深橙色 */
        .contact-status-indicator.blocked-by {
            background-color: #ff8800;
            color: white;
        }

        /* 已屏蔽群聊状态 - 橙色 */
        .contact-status-indicator.muted {
            background-color: #ff9500;
            color: white;
        }

        /* 确保角色项有相对定位 */
        .contact-item {
            position: relative;
        }

        /* 🔥【新增】足迹新增高亮样式 */
        .footprint-item.new-footprint {
            animation: slideInFromTop 0.5s ease-out;
        }

        .footprint-item.highlight-new {
            background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
            border-left: 4px solid #2196f3;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2);
            transform: scale(1.02);
            transition: all 0.3s ease;
        }

        .footprint-mood {
            color: #e91e63;
            font-size: 0.9em;
            margin-top: 5px;
        }

        @keyframes slideInFromTop {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* 🔥【新增】消息列表状态指示器样式 */
        .message-avatar-container {
            position: relative;
            display: inline-block;
        }

        .message-status-indicator {
            position: absolute;
            right: 2px;
            bottom: 1px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            z-index: 10;
        }

        /* 已拉黑状态 - 红色 */
        .message-status-indicator.blocked {
            background-color: #ff4444;
            color: white;
        }

        /* 被拉黑状态 - 深橙色 */
        .message-status-indicator.blocked-by {
            background-color: #ff8800;
            color: white;
        }

        /* 已屏蔽群聊状态 - 橙色 */
        .message-status-indicator.muted {
            background-color: #ff9500;
            color: white;
        }

        /* 🔥【新增】未读消息提示样式 */
        .unread-badge {
            position: absolute;
            right: -2px;
            top: -2px;
            min-width: 16px;
            height: 16px;
            border-radius: 50%;
            background-color: #ff4444;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            z-index: 15;
            padding: 0 4px;
            box-sizing: border-box;
        }

        /* 当数字超过99时，显示99+ */
        .unread-badge.large-count {
            font-size: 8px;
            min-width: 20px;
            border-radius: 10px;
        }

        /* 🔥【新增】危险操作样式 */
        .danger-item {
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .danger-item:hover {
            background-color: rgba(255, 59, 48, 0.05);
        }

        .danger-color {
            color: #ff3b30 !important;
        }

        .danger-section-title {
            color: #ff3b30 !important;
        }

        .danger-section-icon {
            color: #ff3b30 !important;
        }

        /* 🔥【重新设计】消息列表多选模式按钮 - 放在app-header中 */
        .chat-header-multiselect-actions {
            display: flex;
            gap: 6px;
            align-items: center;
        }





        /* 🔥【重新设计】置顶对话的视觉标识 - 主题化颜色 */
        .message-item.pinned {
            background: rgba(74, 132, 193, 0.08);
            border-left: 3px solid rgba(74, 132, 193, 0.3);
        }

        /* 可爱主题下的置顶对话样式 */
        body[data-theme="cute"] .message-item.pinned {
            background: rgba(255, 182, 193, 0.08);
            border-left: 3px solid rgba(255, 182, 193, 0.3);
        }

        .pin-indicator {
            position: absolute;
            top: 5px;
            right: 5px;
            color: #ffd700;
            font-size: 12px;
            z-index: 5;
        }

        /* 🎮【新增】游戏选择模态框样式 - 毛玻璃风格莫兰迪色系 */
        .game-modal-content {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            max-width: 450px;
            width: 85%;
            max-height: 70vh;
        }

        /* 等待模态框样式 */
        .waiting-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .waiting-modal-content {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            padding: 40px 30px;
            text-align: center;
            max-width: 300px;
            width: 80%;
        }

        .waiting-spinner {
            width: 40px;
            height: 40px;
            margin: 0 auto 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            border-style: dashed;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .waiting-text {
            color: #666;
            font-size: 16px;
            margin: 0;
        }

        .game-modal-header {
            padding: 20px 20px 10px 20px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }

        .game-modal-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 18px;
            font-weight: 600;
            color: #5a5a5a;
        }

        .game-modal-title i {
            color: #8b9dc3;
        }

        .game-modal-close {
            background: none;
            border: none;
            font-size: 24px;
            color: #999;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .game-modal-close:hover {
            background: rgba(0, 0, 0, 0.05);
            color: #666;
        }

        .game-modal-body {
            padding: 15px 20px 25px 20px;
        }

        .game-buttons-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .game-button {
            display: flex;
            align-items: center;
            padding: 16px 20px;
            border: none;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
            width: 100%;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .game-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
        }

        .game-button:active {
            transform: translateY(0);
        }

        /* 莫兰迪色系游戏按钮 */
        .game-button.gomoku {
            background: linear-gradient(135deg, rgba(139, 157, 195, 0.3), rgba(139, 157, 195, 0.1));
            color: #4a5568;
        }

        .game-button.turtle-soup {
            background: linear-gradient(135deg, rgba(168, 162, 158, 0.3), rgba(168, 162, 158, 0.1));
            color: #4a5568;
        }

        .game-button.werewolf {
            background: linear-gradient(135deg, rgba(147, 125, 135, 0.3), rgba(147, 125, 135, 0.1));
            color: #4a5568;
        }

        .game-button.monopoly {
            background: linear-gradient(135deg, rgba(162, 152, 140, 0.3), rgba(162, 152, 140, 0.1));
            color: #4a5568;
        }

        .game-button.disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .game-button.disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .game-button-icon {
            width: 40px;
            height: 40px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            font-size: 18px;
            background: rgba(255, 255, 255, 0.4);
            color: inherit;
        }

        .game-button-content {
            flex: 1;
        }

        .game-button-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 4px;
            color: inherit;
        }

        .game-button-desc {
            font-size: 13px;
            opacity: 0.8;
            color: inherit;
        }

        .game-button-badge {
            position: absolute;
            top: 8px;
            right: 12px;
            background: rgba(255, 255, 255, 0.8);
            color: #666;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 500;
        }

        .game-button-badge.recommended {
            background: rgba(255, 193, 7, 0.8);
            color: #856404;
        }

        .game-button-badge.coming-soon {
            background: rgba(108, 117, 125, 0.8);
            color: white;
        }

        /* 🎮【删除】游戏信息按钮样式已移除 */

        /* 🔥【新增】约定完成按钮样式 */
        .appointment-action-btn.appointment-complete-btn.completed {
            background-color: #e0e0e0 !important;
            color: #999 !important;
            cursor: not-allowed !important;
            opacity: 0.6 !important;
        }

        .appointment-action-btn.appointment-complete-btn.completed:hover {
            background-color: #e0e0e0 !important;
            color: #999 !important;
        }

        /* 🔥【新增】约定倒计时样式 */
        .appointment-countdown {
            font-size: 14px;
            font-weight: 500;
            padding: 4px 8px;
            border-radius: 12px;
            background-color: #f0f0f0;
            color: #666;
        }

        .appointment-countdown.pending {
            background-color: #e3f2fd;
            color: #1976d2;
        }

        .appointment-countdown.completed {
            background-color: #e8f5e8;
            color: #4caf50;
        }

        .appointment-countdown.overdue {
            background-color: #ffebee;
            color: #f44336;
        }

        /* 🔥【新增】约定详情头部样式 */
        .appointment-detail-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
        }

        .appointment-detail-left {
            flex: 1;
        }

        .appointment-detail-name {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
        }

        .appointment-detail-time {
            font-size: 14px;
            color: #666;
        }

        .appointment-detail-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .appointment-type-tag {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 12px;
            background-color: #ff9800;
            color: white;
            white-space: nowrap;
        }

        /* 🛒【新增】购物小票样式 */
        .order-receipt-container {
            margin: 8px 0;
            display: flex;
            justify-content: flex-end;
        }

        .receipt-card {
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
            max-width: 280px;
            width: 100%;
            overflow: hidden;
            border: 1px solid #e8e8e8;
        }



        .receipt-header {
            background: #ffffff;
            padding: 16px;
            text-align: center;
            border-bottom: 1px solid #e8e8e8;
        }

        .receipt-icon {
            font-size: 24px;
            margin-bottom: 8px;
        }

        .receipt-title {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            margin: 0;
        }

        .receipt-divider {
            height: 1px;
            background: linear-gradient(to right, transparent, #e8e8e8, transparent);
            margin: 0 16px;
        }

        .receipt-info {
            padding: 16px;
        }

        .receipt-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            padding: 2px 0;
            font-size: 12px;
            line-height: 1.2;
        }

        .receipt-row:last-child {
            margin-bottom: 0;
        }

        .receipt-row .label {
            color: #666;
            font-weight: 400;
            font-size: 12px;
        }

        .receipt-row .value {
            color: #333;
            font-weight: 400;
            font-size: 12px;
        }

        .receipt-items {
            padding: 0 16px 16px;
        }

        .items-header {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px dashed #e8e8e8;
        }

        .receipt-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .receipt-item:last-child {
            margin-bottom: 0;
        }

        .item-name {
            flex: 1;
            color: #333;
            margin-right: 8px;
        }

        .item-quantity {
            color: #666;
            margin-right: 8px;
            min-width: 30px;
            text-align: center;
        }

        .item-price {
            color: #333;
            font-weight: 600;
            min-width: 60px;
            text-align: right;
        }

        .receipt-total {
            padding: 16px;
            background: #f8f9fa;
            border-top: 1px solid #e8e8e8;
        }

        .total-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .total-row:last-child {
            margin-bottom: 0;
        }

        .total-row.final {
            border-top: 1px solid #e8e8e8;
            padding-top: 8px;
            font-size: 16px;
            font-weight: 700;
        }

        .total-label {
            color: #666;
        }

        .total-row.final .total-label {
            color: #333;
        }

        .total-amount {
            color: #ff6b6b;
            font-weight: 700;
        }

        .receipt-footer {
            padding: 12px 16px;
            text-align: center;
            background: #f8f9fa;
            border-top: 1px solid #e8e8e8;
        }

        .thank-you {
            font-size: 12px;
            color: #999;
            font-style: italic;
        }

        /* 🛒【新增】购物小票动画效果 */
        .receipt-card {
            animation: receiptSlideIn 0.3s ease-out;
        }

        @keyframes receiptSlideIn {
            from {
                opacity: 0;
                transform: translateX(20px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateX(0) scale(1);
            }
        }
















    </style>

</head>
<body>
     <div id="auth-overlay">
        <div class="auth-box">
            <h1>应用激活</h1>
            <p>请将下面的“请求码”发送给作者，以获取专属于您的激活码。</p>
            <div class="code-display-box"><strong id="request-code">...</strong></div>
            <input type="text" id="license-input" placeholder="在此输入获取的激活码">
            <button id="activate-button">激活</button>
        </div>
    </div>
    <div id="notification-container"></div>
        <!-- 推送通知容器 -->
        <div id="notification-container"></div>
   <div id="phone-screen" class="phone-screen">
        <div class="wallpaper" id="wallpaper-element">
            <!-- 主屏幕状态栏 -->
            <div id="status-bar">
                <span id="status-bar-time">14:25</span>
                <div class="status-bar-right">
                    <div id="status-bar-signal" class="signal-icon">
                        <div class="signal-row">
                            <div class="signal-bar"></div>
                            <div class="signal-bar"></div>
                            <div class="signal-bar"></div>
                            <div class="signal-bar"></div>
                        </div>
                    </div>
                    <div id="status-bar-battery" class="battery-container">
                        <div class="battery-icon">
                            <div class="battery-level"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 音乐显示区域（类似灵动岛） - 独立于状态栏 -->
            <div id="music-status-display" class="music-status-display" style="display: none;" onclick="openMusicModal()">
                <i class="fas fa-headphones music-icon"></i>
                <div class="music-lyrics-scroll">
                    <span id="current-lyric">♪ 点击开始听歌</span>
                </div>
            </div>

            <!-- 时钟容器 -->
            <div id="clock-container">
                <div id="main-date">12月18日 星期一</div>
                <div id="main-time">14:25</div>
            </div>

            <div id="worldbook-screen" class="app-screen">
                <div class="app-top-container">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-status-right">
                            <div class="app-signal-icon signal-icon">
                                <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('worldbook-screen')">‹</button>
                        <div class="app-title">世界书</div>
                        <div class="add-worldbook-btn worldbook-add-btn" onclick="onWorldbookAddClick()">
                            <i class="fas fa-plus"></i>
                        </div>
                    </div>
                </div>

                <div class="app-content">
                    <div id="global-worldbooks-content" class="worldbook-content-pane">
                        </div>
                    <div id="local-worldbooks-content" class="worldbook-content-pane" style="display: none;">
                        </div>

                </div>



                <div class="worldbook-tabs">
                    <div class="worldbook-tab active" onclick="switchWorldbookTab('global')">
                        <i class="fas fa-globe-asia"></i>
                        <span>全局设定</span>
                    </div>
                    <div class="worldbook-tab" onclick="switchWorldbookTab('local')">
                        <i class="fas fa-comment-dots"></i>
                        <span>局部设定</span>
                    </div>

                </div>
            </div>

                <!-- 主屏幕四块布局 -->
                <div id="home-grid">
                    <!-- 左上角：图片小组件 -->
                    <div class="home-section top-left">
                        <div class="widget photo-widget" onclick="showPhotoWidgetOptions()">
                            <div class="photo-widget-content" id="photo-widget-content">
                                <div class="photo-placeholder" id="photo-placeholder">
                                    <i class="fas fa-image"></i>
                                    <span>点击添加图片</span>
                                </div>
                                <img class="photo-widget-image" id="photo-widget-image" style="display: none;">
                            </div>
                        </div>
                    </div>

                    <!-- 右上角：两个应用 -->
                    <div class="home-section top-right">
                        <div class="apps-grid-2">
                            <a href="#" class="mini-app" onclick="showApp('chat-screen')">
                                <div class="mini-app-icon">
                                    <i class="fas fa-comment-dots"></i>
                                </div>
                                <span>Chat</span>
                            </a>
                            <a href="#" class="mini-app" onclick="showApp('worldbook-screen'); switchWorldbookTab('global');">
                                <div class="mini-app-icon">
                                    <i class="fas fa-globe-americas"></i>
                                </div>
                                <span>世界书</span>
                            </a>
                        </div>
                    </div>

                    <!-- 左下角：两个应用 -->
                    <div class="home-section bottom-left">
                        <div class="apps-grid-2">
                            <a href="#" class="mini-app" onclick="showApp('anniversary-screen')">
                                <div class="mini-app-icon">
                                    <i class="fas fa-heart"></i>
                                </div>
                                <span>纪念日</span>
                            </a>
                            <a href="#" class="mini-app" onclick="showApp('forum-screen')">
                                <div class="mini-app-icon">
                                    <i class="fas fa-comments"></i>
                                </div>
                                <span>论坛</span>
                            </a>
                        </div>
                    </div>

                    <!-- 右下角：纪念日小组件 -->
                    <div class="home-section bottom-right">
                        <div class="widget anniversary-widget">
                            <div class="anniversary-widget-content" id="anniversary-widget-content">
                                <div class="anniversary-placeholder" id="anniversary-placeholder">
                                    <i class="fas fa-heart"></i>
                                    <span>暂无纪念日</span>
                                </div>
                                <div class="anniversary-display" id="anniversary-display" style="display: none;">
                                    <div class="anniversary-name" id="widget-anniversary-name"></div>
                                    <div class="anniversary-countdown" id="widget-anniversary-countdown"></div>
                                    <div class="anniversary-date" id="widget-anniversary-date"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- iPhone风格Dock栏 -->
                <div id="dock-bar">
                    <div class="dock-container">
                        <a href="#" class="dock-app" onclick="showApp('messages-screen')">
                            <div class="dock-app-icon">
                                <i class="fas fa-envelope"></i>
                            </div>
                            <span>短信</span>
                        </a>
                        <a href="#" class="dock-app" onclick="showApp('settings-screen')">
                            <div class="dock-app-icon">
                                <i class="fas fa-cog"></i>
                            </div>
                            <span>设置</span>
                        </a>
                        <a href="#" class="dock-app" onclick="showApp('memory-viewer-screen')">
                            <div class="dock-app-icon">
                                <i class="fas fa-brain"></i>
                            </div>
                            <span>记忆</span>
                        </a>
                    </div>
                </div>


                <!-- 纪念日界面 -->
                <div id="anniversary-screen" class="app-screen">
                    <div class="app-top-container">
                        <div class="app-status-bar">
                            <div class="app-status-time"></div>
                            <div class="app-status-right">
                                <div class="app-signal-icon signal-icon">
                                    <div class="signal-row">
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                    </div>
                                </div>
                                <div class="app-battery-container">
                                    <div class="app-battery-icon">
                                        <div class="app-battery-level"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="app-header">
                            <button class="back-button" onclick="hideApp('anniversary-screen')">‹</button>
                            <div class="app-title">纪念日</div>
                        <div class="add-anniversary-btn" onclick="showAnniversaryForm()">
                            <i class="fas fa-plus"></i>
                        </div>
                    </div>
                    </div>
                    <div class="app-content">
                        <!-- 纪念日内容区域 -->
                        <div id="anniversary-content" class="anniversary-content-pane">
                            <!-- 置顶纪念日显示区域 -->
                            <div id="pinned-anniversary-section" class="pinned-anniversary-section" style="display: none;">
                                <div id="pinned-anniversary-card" class="pinned-anniversary-card">
                                    <!-- 置顶纪念日内容将通过JS动态生成 -->
                                </div>
                            </div>

                            <div id="anniversary-list" class="anniversary-list">
                                <!-- 纪念日列表将通过JS动态生成 -->
                                <div class="anniversary-empty-state">
                                    <i class="fas fa-heart"></i>
                                    <p>还没有纪念日</p>
                                    <p>点击右上角 + 添加重要的日子</p>
                                </div>
                            </div>
                        </div>

                        <!-- 约定内容区域 -->
                        <div id="appointment-content" class="anniversary-content-pane" style="display: none;">
                            <!-- 置顶约定显示区域 -->
                            <div id="pinned-appointment-section" class="pinned-appointment-section" style="display: none;">
                                <div id="pinned-appointment-card" class="pinned-appointment-card">
                                    <!-- 置顶约定内容将通过JS动态生成 -->
                                </div>
                            </div>

                            <div id="appointment-list" class="appointment-list">
                                <!-- 约定列表将通过JS动态生成 -->
                                <div class="appointment-empty-state">
                                    <i class="fas fa-calendar-check"></i>
                                    <p>还没有约定</p>
                                    <p>点击右上角 + 添加新约定</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 底部分栏 -->
                    <div class="anniversary-tabs">
                        <div class="anniversary-tab active" onclick="switchAnniversaryTab('anniversary')">
                            <i class="fas fa-heart"></i>
                            <span>纪念日</span>
                        </div>
                        <div class="anniversary-tab" onclick="switchAnniversaryTab('appointment')">
                            <i class="fas fa-calendar-check"></i>
                            <span>约定</span>
                        </div>
                    </div>
                </div>

                <!-- 购物界面 -->
                <div id="shopping-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-status-right">
                            <div class="app-signal-icon signal-icon">
                                <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="handleShoppingBack()" id="shopping-back-btn">‹</button>
                        <div class="app-title">购物</div>
                        <div class="shopping-header-actions">
                            <div class="shopping-cart-btn" onclick="openShoppingCart()" title="购物车">
                                <i class="fas fa-shopping-cart"></i>
                                <span class="cart-badge" id="cart-badge" style="display: none;">0</span>
                            </div>
                        </div>
                    </div>
                    <div class="app-content shopping-content">
                        <!-- 搜索框 -->
                        <div class="shopping-search-container">
                            <div class="shopping-search-box">
                                <i class="fas fa-search shopping-search-icon"></i>
                                <input type="text" id="shopping-search-input" class="shopping-search-input" placeholder="搜索商品..." maxlength="100">
                            </div>
                        </div>

                        <!-- 分类区域 -->
                        <div class="shopping-categories" id="shopping-categories">
                            <!-- 外卖分类 -->
                            <div class="category-list" id="takeout-categories">
                                <div class="category-item" onclick="showCategoryProducts('美食')">
                                    <i class="fas fa-utensils"></i>
                                    <span>美食</span>
                                </div>
                                <div class="category-item" onclick="showCategoryProducts('甜点饮品')">
                                    <i class="fas fa-coffee"></i>
                                    <span>甜点饮品</span>
                                </div>
                                <div class="category-item" onclick="showCategoryProducts('蔬菜水果')">
                                    <i class="fas fa-apple-alt"></i>
                                    <span>蔬菜水果</span>
                                </div>
                                <div class="category-item" onclick="showCategoryProducts('看病买药')">
                                    <i class="fas fa-pills"></i>
                                    <span>看病买药</span>
                                </div>
                                <div class="category-item custom-item" onclick="addCustomItem()">
                                    <i class="fas fa-plus"></i>
                                    <span>添加自定义商品</span>
                                </div>
                            </div>

                            <!-- 购物分类 -->
                            <div class="category-list" id="shopping-categories-list" style="display: none;">
                                <div class="category-item" onclick="showCategoryProducts('数码产品')">
                                    <i class="fas fa-laptop"></i>
                                    <span>数码产品</span>
                                </div>
                                <div class="category-item" onclick="showCategoryProducts('家居百货')">
                                    <i class="fas fa-home"></i>
                                    <span>家居百货</span>
                                </div>
                                <div class="category-item" onclick="showCategoryProducts('女装男装')">
                                    <i class="fas fa-tshirt"></i>
                                    <span>女装男装</span>
                                </div>
                                <div class="category-item" onclick="showCategoryProducts('饰品箱包')">
                                    <i class="fas fa-gem"></i>
                                    <span>饰品箱包</span>
                                </div>
                                <div class="category-item custom-item" onclick="addCustomItem()">
                                    <i class="fas fa-plus"></i>
                                    <span>添加自定义商品</span>
                                </div>
                            </div>
                        </div>

                        <!-- 商品展示区域 -->
                        <div class="products-container" id="products-container" style="display: none;">
                            <div class="products-grid" id="products-grid">
                                <!-- 商品将通过JavaScript动态生成 -->
                            </div>
                        </div>
                    </div>

                    <!-- 底部导航栏 -->
                    <div class="shopping-tabs">
                        <div class="shopping-tab active" onclick="switchShoppingTab('takeout')">
                            <i class="fas fa-utensils"></i>
                            <span>外卖</span>
                        </div>
                        <div class="shopping-tab" onclick="switchShoppingTab('shopping')">
                            <i class="fas fa-shopping-cart"></i>
                            <span>购物</span>
                        </div>
                    </div>
                </div>

                <!-- 购物车界面 -->
                <div id="shopping-cart-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-status-right">
                            <div class="app-signal-icon signal-icon">
                                <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="handleShoppingCartBack()">‹</button>
                        <div class="app-title">购物车</div>
                        <div class="cart-header-actions">
                            <div class="clear-cart-btn" onclick="clearShoppingCart()" title="清空购物车">
                                <i class="fas fa-trash"></i>
                            </div>
                        </div>
                    </div>
                    <div class="app-content cart-content">
                        <!-- 购物车商品列表 -->
                        <div class="cart-items-container" id="cart-items-container">
                            <!-- 购物车商品将通过JavaScript动态生成 -->
                        </div>

                        <!-- 购物车为空时的提示 -->
                        <div class="cart-empty-state" id="cart-empty-state">
                            <i class="fas fa-shopping-cart"></i>
                            <p>购物车是空的</p>
                            <p>去添加一些商品吧</p>
                            <button class="go-shopping-btn" onclick="hideApp('shopping-cart-screen'); openShoppingScreen();">
                                去购物
                            </button>
                        </div>
                    </div>

                    <!-- 购物车底部结算区域 -->
                    <div class="cart-footer" id="cart-footer" style="display: none;">
                        <div class="cart-summary">
                            <div class="cart-total">
                                <span class="total-label">总计：</span>
                                <span class="total-price" id="cart-total-price">¥0</span>
                            </div>
                            <div class="cart-actions">
                                <button class="pay-for-me-btn" onclick="requestPayment()">
                                    请Ta代付
                                </button>
                                <button class="checkout-btn" onclick="proceedToCheckout()">
                                    结算 (<span id="cart-items-count">0</span>)
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 短信界面 -->
                <div id="messages-screen" class="app-screen">
                    <div class="app-top-container">
                        <div class="app-status-bar">
                            <div class="app-status-time"></div>
                            <div class="app-status-right">
                                <div class="app-signal-icon signal-icon">
                                    <div class="signal-row">
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                    </div>
                                </div>
                                <div class="app-battery-container">
                                    <div class="app-battery-icon">
                                        <div class="app-battery-level"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="app-header">
                            <button class="back-button" onclick="hideApp('messages-screen')">‹</button>
                            <div class="app-title">短信</div>
                        <div class="messages-header-actions" id="sms-normal-actions">
                            <div class="sms-manage-btn" onclick="showSMSManageOptions()" title="管理短信">
                                <i class="fas fa-ellipsis-h"></i>
                            </div>
                            <div class="add-message-btn" onclick="showNewMessageForm()">
                                <i class="fas fa-edit"></i>
                            </div>
                        </div>
                        <!-- 🔥【新增】短信列表多选模式按钮 -->
                        <div class="messages-multiselect-actions" id="sms-list-multiselect-actions" style="display: none;">
                            <button class="multiselect-btn cancel-btn" onclick="exitSMSListMultiSelectMode()">
                                <span>取消</span>
                            </button>
                            <button class="multiselect-btn delete-btn" onclick="deleteSelectedSMSConversations()">
                                <span>删除</span>
                            </button>
                        </div>
                    </div>
                    </div>
                    <div class="app-content">
                        <div id="messages-list" class="messages-list">
                            <!-- 短信列表将通过JS动态生成 -->
                            <div class="messages-empty-state">
                                <i class="fas fa-comment-dots"></i>
                                <p>暂无短信</p>
                                <p>点击右上角编辑按钮创建新信息</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 短信聊天界面 -->
                <div id="sms-chat-screen" class="app-screen" style="display: none;">
                    <div class="app-top-container">
                        <div class="app-status-bar">
                            <div class="app-status-time"></div>
                            <div class="app-status-right">
                                <div class="app-signal-icon signal-icon">
                                    <div class="signal-row">
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                    </div>
                                </div>
                                <div class="app-battery-container">
                                    <div class="app-battery-icon">
                                        <div class="app-battery-level"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="app-header">
                            <button class="back-button" onclick="hideSMSChat()">‹</button>
                        <div class="sms-chat-header-center">
                            <div class="sms-chat-avatar" id="sms-chat-avatar">
                                <i class="fas fa-user"></i>
                            </div>
                            <div class="sms-chat-name" id="sms-chat-name"></div>
                        </div>
                        <div class="sms-chat-actions" id="sms-chat-normal-actions">
                            <button class="sms-action-btn" onclick="showSMSChatInfo()">
                                <i class="fas fa-info-circle"></i>
                            </button>
                        </div>
                        <!-- 🔥【重新设计】短信多选模式按钮 - 简洁样式 -->
                        <div class="sms-chat-multiselect-actions" id="sms-chat-multiselect-actions" style="display: none;">
                            <button class="multiselect-btn cancel-btn" onclick="exitSMSMultiSelectMode()">
                                <span>取消</span>
                            </button>
                            <button class="multiselect-btn delete-btn" onclick="deleteSelectedSMSMessages()">
                                <span>删除</span>
                            </button>
                        </div>
                    </div>
                    </div>
                    <div class="app-content sms-chat-content">
                        <div id="sms-messages-container" class="sms-messages-container">
                            <!-- 短信消息将通过JS动态生成 -->
                        </div>
                    </div>
                    <div class="sms-input-section">
                        <div class="sms-input-container">
                            <button class="sms-attachment-btn" onclick="openSMSImagePicker()">
                                <i class="fas fa-plus"></i>
                            </button>
                            <div class="sms-input-wrapper">
                                <input type="text" id="sms-message-input" class="sms-message-input" placeholder="短信" onkeydown="handleSMSInputKeydown(event)">
                                <button class="sms-wait-reply-btn" onclick="triggerSMSReply()" id="sms-wait-reply-btn" title="等待角色回复">
                                    <i class="fas fa-comment-dots"></i>
                                </button>
                            </div>
                            <button class="sms-send-btn" onclick="sendSMSMessage()" id="sms-send-button" style="display: none;">
                                <i class="fas fa-arrow-up"></i>
                            </button>
                        </div>
                    </div>
                </div>



                <!-- 🔥【新增】短信图片选择器 -->
                <input type="file" id="sms-image-input" accept="image/*" style="display: none;" onchange="handleSMSImageSelect(event)">

                <!-- 🎨【新增】自定义主题图片上传输入框 -->
                <input type="file" id="chat-top-bg-input" accept="image/*" style="display: none;" onchange="handleChatTopBgUpload(event)">
                <input type="file" id="chat-bottom-bg-input" accept="image/*" style="display: none;" onchange="handleChatBottomBgUpload(event)">
                <input type="file" id="button-icon-input" accept="image/*" style="display: none;" onchange="handleButtonIconUpload(event)">
                <input type="file" id="global-top-app-bar-input" accept="image/*" style="display: none;" onchange="handleGlobalTopAppBarUpload(event)">
                <input type="file" id="global-bottom-app-bar-input" accept="image/*" style="display: none;" onchange="handleGlobalBottomAppBarUpload(event)">
                <input type="file" id="global-back-button-input" accept="image/*" style="display: none;" onchange="handleGlobalBackButtonUpload(event)">
                <input type="file" id="global-add-button-input" accept="image/*" style="display: none;" onchange="handleGlobalAddButtonUpload(event)">
                <input type="file" id="global-bg-input" accept="image/*" style="display: none;" onchange="handleGlobalBgUpload(event)">

                <!-- 🔥【修复】短信管理选项模态框 -->
                <div id="sms-manage-modal" class="sms-manage-modal" style="display: none;" onclick="hideSMSManageOptions(event)">
                    <div class="sms-manage-modal-content" onclick="event.stopPropagation()">
                        <div class="sms-manage-option" onclick="enterSMSListMultiSelectMode()">
                            <i class="fas fa-trash"></i>
                            <span>多选删除</span>
                        </div>
                        <div class="sms-manage-option" onclick="enterSMSPinMode()">
                            <i class="fas fa-thumbtack"></i>
                            <span>置顶对话</span>
                        </div>
                    </div>
                </div>

                <!-- 短信身份选择模态框 -->
                <div id="sms-persona-selector-modal" class="modal-overlay" style="display: none;" onclick="hideSMSPersonaSelector(event)">
                    <div class="modal-content sms-selector-modal" onclick="event.stopPropagation()">
                        <div class="modal-header">
                            <h3>选择你的身份</h3>
                            <button class="modal-close-btn" onclick="hideSMSPersonaSelector()">×</button>
                        </div>
                        <div class="modal-body" id="sms-persona-selector-body">
                            <!-- 身份列表将通过JS动态生成 -->
                        </div>
                    </div>
                </div>

                <!-- 短信角色选择模态框 -->
                <div id="sms-character-selector-modal" class="modal-overlay" style="display: none;" onclick="hideSMSCharacterSelector(event)">
                    <div class="modal-content sms-selector-modal" onclick="event.stopPropagation()">
                        <div class="modal-header">
                            <h3>选择聊天角色</h3>
                            <button class="modal-close-btn" onclick="hideSMSCharacterSelector()">×</button>
                        </div>
                        <div class="modal-body" id="sms-character-selector-body">
                            <!-- 角色列表将通过JS动态生成 -->
                        </div>
                    </div>
                </div>

                <!-- 自定义商品添加模态框 -->
                <div id="custom-item-modal" class="modal-overlay" style="display: none;" onclick="hideCustomItemModal(event)">
                    <div class="modal-content custom-item-modal" onclick="event.stopPropagation()">
                        <div class="modal-header">
                            <h3>添加自定义商品</h3>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label for="custom-item-name">商品名称</label>
                                <input type="text" id="custom-item-name" class="form-input" placeholder="请输入商品名称" maxlength="50" onkeydown="handleCustomItemKeydown(event)">
                            </div>

                            <div class="form-group">
                                <label for="custom-item-description">商品介绍 <span style="color: #999; font-size: 12px;">(可选)</span></label>
                                <input type="text" id="custom-item-description" class="form-input" placeholder="请输入商品介绍" maxlength="100" onkeydown="handleCustomItemKeydown(event)">
                            </div>

                            <div class="form-group">
                                <label for="custom-item-price">商品价格</label>
                                <div class="price-input-container">
                                    <span class="price-symbol">¥</span>
                                    <input type="number" id="custom-item-price" class="form-input price-input" placeholder="0.00" min="0" step="0.01" onkeydown="handleCustomItemKeydown(event)">
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="hideCustomItemModal()">取消</button>
                            <button class="btn btn-primary" onclick="confirmAddCustomItem()">添加到购物车</button>
                        </div>
                    </div>
                </div>

                <!-- 代付选择模态框 -->
                <div id="payment-request-modal" class="modal-overlay" style="display: none;" onclick="hidePaymentRequestModal(event)">
                    <div class="modal-content payment-request-modal" onclick="event.stopPropagation()">
                        <div class="modal-header">
                            <h3>请Ta代付</h3>
                            <button class="modal-close-btn" onclick="hidePaymentRequestModal()">×</button>
                        </div>
                        <div class="modal-body">
                            <div class="payment-summary">
                                <div class="payment-total">
                                    <span class="total-label">总计：</span>
                                    <span class="total-price" id="payment-modal-total">¥0</span>
                                </div>
                                <div class="payment-items-count">
                                    共 <span id="payment-modal-items-count">0</span> 件商品
                                </div>
                            </div>

                            <div class="payment-options">
                                <h4>为谁下单？</h4>
                                <div class="payment-option-buttons">
                                    <button class="payment-option-btn" onclick="processOrder('for_self')">
                                        <i class="fas fa-user"></i>
                                        <span>为自己下单</span>
                                    </button>
                                    <button class="payment-option-btn" onclick="processOrder('for_ta')">
                                        <i class="fas fa-gift"></i>
                                        <span>为Ta下单</span>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 短信聊天设置界面 -->
                <div id="sms-chat-settings-screen" class="app-screen" style="display: none;">
                    <div class="app-top-container">
                        <div class="app-status-bar">
                            <div class="app-status-time"></div>
                            <div class="app-status-right">
                                <div class="app-signal-icon signal-icon">
                                    <div class="signal-row">
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                    </div>
                                </div>
                                <div class="app-battery-container">
                                    <div class="app-battery-icon">
                                        <div class="app-battery-level"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="app-header">
                            <button class="back-button" onclick="hideSMSChatSettings()">‹</button>
                            <div class="app-title">聊天设置</div>
                        </div>
                    </div>
                    <div class="app-content sms-settings-content">
                        <div class="setting-group">
                            <h4><i class="fas fa-history"></i> 历史消息</h4>
                            <div class="setting-item">
                                <label>附带历史消息回合数</label>
                                <div class="slider-container">
                                    <input type="range" id="sms-history-rounds-slider" min="0" max="500" value="50" onchange="updateSMSHistoryRounds()">
                                    <span id="sms-history-rounds-value">50轮</span>
                                </div>
                            </div>
                        </div>

                        <div class="setting-group">
                            <h4><i class="fas fa-palette"></i> 气泡颜色</h4>
                            <div class="setting-item">
                                <label>我的消息气泡颜色</label>
                                <div class="bubble-color-selector">
                                    <div class="color-option-text" data-color="blue" onclick="setSMSBubbleColor('blue')">
                                        蓝色
                                    </div>
                                    <div class="color-option-text" data-color="green" onclick="setSMSBubbleColor('green')">
                                        绿色
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="setting-group">
                            <h4><i class="fas fa-trash-alt"></i> 数据管理</h4>
                            <div class="setting-item" onclick="clearSMSChatHistory()">
                                <label style="white-space: nowrap;">清空记录</label>
                                <div class="setting-desc">删除所有短信记录和相关记忆，不可恢复</div>
                            </div>
                        </div>


                    </div>
                </div>

                <!-- 聊天界面 -->
                <div id="chat-screen" class="app-screen">
                    <div class="app-top-container">
                        <div class="app-status-bar">
                            <div class="app-status-time"></div>
                            <div class="app-status-right">
                                <div class="app-signal-icon signal-icon">
                                    <div class="signal-row">
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                    </div>
                                </div>
                                <div class="app-battery-container">
                                    <div class="app-battery-icon">
                                        <div class="app-battery-level"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="app-header">
                            <button class="back-button" onclick="hideApp('chat-screen')">‹</button>
                            <div class="app-title">💬</div>
                        <div class="chat-header-actions">
                            <div id="group-manage-btn" class="header-action-btn" onclick="enterGroupManageMode()" title="管理分组">
                                <i class="fas fa-cog"></i>
                            </div>
                            <div id="add-contact-btn" class="add-btn" onclick="showCharacterForm()">
                                <i class="fas fa-plus"></i>
                            </div>
                            <div id="add-chat-btn" class="add-btn" onclick="showChatOptions()">
                                <i class="fas fa-plus"></i>
                            </div>
                        </div>
                    </div>
                    </div>

                    <div class="app-content" id="chat-content">
                        <!-- 默认显示消息列表 -->
                        <div class="message-list" id="message-list">
                            <!-- 消息列表将通过JS动态生成 -->
                        </div>

                        <!-- 通讯录 -->
                        <div class="contact-list hide" id="contact-list">
                            <div class="contact-section">

                                <!-- 角色列表将通过JS动态生成 -->
                            </div>

                        </div>

                        <!-- 动态页面 -->
                        <div class="moments-page hide moments-page-no-padding" id="moments-page">
                            <div class="moments-header">
                                <div class="moments-cover" onclick="changeCoverImage()">
                                    <div class="cover-image-placeholder" id="cover-placeholder">
                                        <div class="cover-placeholder-text">点击更换封面</div>
                                        </div>
                                    <img class="cover-image hide" id="cover-image" src="">
                                    </div>

                                <!-- 用户名，独立放置在头像左上角 -->
                                <div class="moments-username" onclick="changeUsername(event)" id="moments-username">用户</div>

                                <!-- 独立的头像，跨越背景和动态列表区域，放在header外面 -->
                                <div class="moments-avatar" onclick="changeAvatarImage(event)" id="moments-avatar">
                                    <i class="fas fa-user moments-avatar-icon"></i>
                                </div>
                            </div>

                            <div class="moments-list" id="moments-list">
                                <!-- 动态列表将通过JS动态生成 -->
                            </div>


                        </div>


                        <!-- 面具区域 -->
                        <div class="profile-page hide" id="profile-page">
                            <div class="persona-section">
                                <div class="persona-header" onclick="togglePersonaSection()">
                                    <div class="persona-title">
                                        <h2>我的面具</h2>
                                        <p>管理你的多重身份设定</p>
                                    </div>
                                    <div class="persona-header-actions">
                                        <button class="add-persona-btn-header" onclick="event.stopPropagation(); showPersonaForm()" title="添加面具">
                                            <i class="fas fa-plus"></i>
                                        </button>
                                        <div class="persona-toggle" onclick="event.stopPropagation(); togglePersonaSection()">
                                            <i class="fas fa-chevron-down expanded" id="persona-chevron"></i>
                                        </div>
                                    </div>
                                </div>

                                <div class="persona-content" id="persona-content">
                                    <div class="persona-list" id="persona-list">
                                        <!-- 面具列表将通过JS动态生成 -->
                                    </div>
                                </div>
                            </div>

                            <!-- 表情包库区域 -->
                            <div class="emoji-library-section">
                                <div class="emoji-library-header" onclick="toggleEmojiLibrarySection()">
                                    <div class="emoji-library-title">
                                        <h3>角色表情包库</h3>
                                        <p>管理角色的表情包分类</p>
                                    </div>
                                    <div class="emoji-library-header-actions">
                                        <button class="create-library-btn-header" onclick="event.stopPropagation(); showCreateLibraryForm()" title="新建表情包库">
                                            <i class="fas fa-plus"></i>
                                        </button>
                                        <div class="emoji-library-toggle" onclick="event.stopPropagation(); toggleEmojiLibrarySection()">
                                            <i class="fas fa-chevron-down" id="emoji-library-chevron"></i>
                                        </div>
                                    </div>
                                </div>

                                <div class="emoji-library-content" id="emoji-library-content" style="display: none;">
                                    <div class="emoji-library-list" id="emoji-library-list">
                                        <!-- 表情包库列表将通过JS动态生成 -->
                                    </div>
                                </div>
                            </div>

                        </div>
                    </div>

                    <div class="chat-tabs">
                        <div class="chat-tab active" onclick="switchChatTab('message-list')" id="message-tab">
                            <i class="fas fa-comments"></i>
                            <span>消息</span>
                        </div>
                        <div class="chat-tab" onclick="switchChatTab('contact-list')">
                            <i class="fas fa-user-friends"></i>
                            <span>角色</span>
                        </div>
                        <div class="chat-tab" onclick="switchChatTab('moments-page')">
                            <i class="fas fa-globe-americas"></i>
                            <span>动态</span>
                        </div>
                        <div class="chat-tab" onclick="switchChatTab('profile-page')">
                            <i class="fas fa-user-circle"></i>
                            <span>我</span>
                        </div>
                    </div>
                </div>

                <!-- 发布动态界面 -->
                <div id="publish-moment-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-status-right">
                            <div class="app-signal-icon signal-icon">
                                <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hidePublishMoment()">‹</button>
                        <div class="app-title">发表动态</div>
                        <button class="publish-btn" onclick="publishMoment()">发表</button>
                    </div>
                    <div class="app-content">
                        <div class="publish-moment-form">
                            <!-- 文字输入区域 -->
                            <div class="moment-text-input">
                                <textarea
                                    id="moment-text"
                                    placeholder="此刻想法..."
                                    class="moment-textarea"
                                    maxlength="500"
                                    oninput="updateTextCount()"></textarea>
                                <div class="text-count" id="text-count">0/500</div>
                            </div>

                            <!-- 图片上传区域 -->
                            <div class="moment-images-section">
                                <div class="moment-images-grid" id="moment-images-grid">
                                    <!-- 动态添加的图片预览 -->
                                </div>
                                <div class="add-image-btn" onclick="addMomentImage()">
                                    <i class="fas fa-plus"></i>
                                    <span>添加图片</span>
                                </div>
                            </div>

                            <!-- 发布选项 -->
                            <div class="publish-options">
                                <div class="option-item" onclick="showLocationModal()">
                                    <i class="fas fa-map-marker-alt location-icon"></i>
                                    <span>所在位置</span>
                                    <span class="option-value" id="selected-location"></span>
                                    <i class="fas fa-chevron-right"></i>
                                </div>
                                <div class="option-item" onclick="showMomentMentionModal()">
                                    <i class="fas fa-at mention-icon"></i>
                                    <span>提醒谁看</span>
                                    <div class="selected-mentions" id="selected-mentions">
                                        <!-- 已选择的角色头像将显示在这里 -->
                                    </div>
                                    <i class="fas fa-chevron-right"></i>
                                </div>
                                <div class="option-item" onclick="showVisibilityModal()">
                                    <i class="fas fa-eye visibility-icon"></i>
                                    <span>谁可以看</span>
                                    <span class="option-value" id="selected-visibility">公开</span>
                                    <i class="fas fa-chevron-right"></i>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 位置选择模态框 -->
                <div id="location-modal" class="modal-overlay" style="display: none;" onclick="hideLocationModal(event)">
                    <div class="modal-content location-modal-content" onclick="event.stopPropagation()">
                        <div class="location-modal-header">
                            <button class="location-cancel-btn" onclick="hideLocationModal()">取消</button>
                            <h3 class="location-modal-title">所在位置</h3>
                            <button class="location-confirm-btn" onclick="confirmLocation()">完成</button>
                        </div>
                        <div class="location-modal-body">
                            <div class="location-search-section">
                                <div class="location-search-box">
                                    <i class="fas fa-search location-search-icon"></i>
                                    <input type="text" id="location-input" class="location-search-input" placeholder="搜索附近位置" maxlength="50">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 提醒谁看模态框 -->
                <div id="mention-modal" class="modal-overlay" style="display: none;" onclick="hideMomentMentionModal(event)">
                    <div class="modal-content mention-modal-content" onclick="event.stopPropagation()">
                        <div class="mention-modal-header">
                            <button class="mention-cancel-btn" onclick="hideMomentMentionModal()">取消</button>
                            <h3 class="mention-modal-title">提醒谁看</h3>
                            <button class="mention-confirm-btn" onclick="confirmMomentMention()">完成</button>
                        </div>
                        <div class="mention-modal-body">
                            <div class="mention-characters-list" id="mention-characters-list">
                                <!-- 角色列表将通过JS动态生成 -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 谁可以看模态框 -->
                <div id="visibility-modal" class="modal-overlay" style="display: none;" onclick="hideVisibilityModal(event)">
                    <div class="modal-content visibility-modal-content" onclick="event.stopPropagation()">
                        <div class="visibility-modal-header">
                            <button class="visibility-cancel-btn" onclick="hideVisibilityModal()">取消</button>
                            <h3 class="visibility-modal-title">谁可以看</h3>
                            <button class="visibility-confirm-btn" onclick="confirmVisibility()">完成</button>
                        </div>
                        <div class="visibility-modal-body">
                            <div class="visibility-options" id="visibility-options">
                                <div class="visibility-option" data-value="public">
                                    <div class="visibility-option-icon">
                                        <i class="fas fa-globe"></i>
                                    </div>
                                    <div class="visibility-option-content">
                                        <div class="visibility-option-title">公开</div>
                                        <div class="visibility-option-desc">所有人都可以看到</div>
                                    </div>
                                    <div class="visibility-option-radio">
                                        <i class="fas fa-check"></i>
                                    </div>
                                </div>
                                <div class="visibility-option" data-value="private">
                                    <div class="visibility-option-icon">
                                        <i class="fas fa-lock"></i>
                                    </div>
                                    <div class="visibility-option-content">
                                        <div class="visibility-option-title">私密</div>
                                        <div class="visibility-option-desc">只有自己可以看到</div>
                                    </div>
                                    <div class="visibility-option-radio">
                                        <i class="fas fa-check"></i>
                                    </div>
                                </div>
                                <div class="visibility-option" data-value="partial">
                                    <div class="visibility-option-icon">
                                        <i class="fas fa-users"></i>
                                    </div>
                                    <div class="visibility-option-content">
                                        <div class="visibility-option-title">部分可见</div>
                                        <div class="visibility-option-desc">选择特定分组可见</div>
                                    </div>
                                    <div class="visibility-option-radio">
                                        <i class="fas fa-check"></i>
                                    </div>
                                </div>
                            </div>
                            <div class="visibility-groups-section" id="visibility-groups-section" style="display: none;">
                                <div class="visibility-groups-title">选择可见分组</div>
                                <div class="visibility-groups-list" id="visibility-groups-list">
                                    <!-- 分组列表将通过JS动态生成 -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 论坛界面 -->
                <div id="forum-screen" class="app-screen">
                    <div class="app-top-container">
                        <div class="app-status-bar">
                            <div class="app-status-time"></div>
                            <div class="app-status-right">
                                <div class="app-signal-icon signal-icon">
                                    <div class="signal-row">
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                    </div>
                                </div>
                                <div class="app-battery-container">
                                    <div class="app-battery-icon"><div class="app-battery-level"></div></div>
                                </div>
                            </div>
                        </div>
                        <div class="app-header">
                            <button class="back-button" onclick="hideApp('forum-screen')">‹</button>
                            <div class="app-title">论坛</div>
                        <div class="add-forum-btn" onclick="showCreateForumScreen()">
                            <i class="fas fa-plus"></i>
                        </div>
                    </div>
                    </div>
                    <div class="app-content">
                        <div id="forum-archive-list" class="forum-archive-list">
                            <div class="forum-empty-state">
                                <i class="fas fa-comments"></i>
                                <p>还没有创建任何论坛</p>
                                <p>点击右上角 + 创建你的第一个论坛</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 创建论坛界面 -->
                <div id="create-forum-screen" class="app-screen">
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('create-forum-screen'); renderForumArchives(); showApp('forum-screen');">‹</button>
                        <div class="app-title" id="forum-form-title">创建新论坛</div>
                    </div>
                    <div class="app-content">
                        <input type="hidden" id="forum-form-id">
                        <div class="form-group">
                            <label class="form-label">论坛名称</label>
                            <input type="text" id="forum-name-input" class="form-input" placeholder="给这个世界线起个名字吧">
                        </div>
                        <div class="form-group">
                            <label class="form-label">选择角色 (可多选)</label>
                            <div id="forum-character-selection" class="selection-grid"></div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">选择你的身份</label>
                            <div id="forum-persona-selection" class="selection-grid single-selection"></div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">补充世界观 (可选)</label>
                            <textarea id="forum-worldview-input" class="form-textarea" rows="4" placeholder="补充一些背景故事或设定..."></textarea>
                        </div>
                        <div class="form-group">
                            <label class="form-label">挂载局部世界书 (可选)</label>
                            <div id="forum-worldbook-selection" class="selection-grid"></div>
                        </div>
                        <button class="form-submit" id="forum-form-submit-btn" onclick="handleForumFormSubmit()">进入论坛</button>
                    </div>
                </div>

                <!-- 帖子列表界面 -->
                <div id="forum-view-screen" class="app-screen">
                    <div class="app-top-container">
                        <div class="app-status-bar">
                            <div class="app-status-time"></div>
                            <div class="app-status-right">
                                <div class="app-signal-icon signal-icon">
                                    <div class="signal-row">
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                    </div>
                                </div>
                                <div class="app-battery-container">
                                    <div class="app-battery-icon"><div class="app-battery-level"></div></div>
                                </div>
                            </div>
                        </div>
                        <div class="app-header">
                            <button class="back-button" onclick="backToForumArchives()">‹</button>
                            <div class="app-title" id="forum-view-title">论坛</div>
                        <div class="header-actions">
                            <span class="action-btn" onclick="showMakeNewsModal()" title="搞个大新闻">
                                <i class="fas fa-pencil-alt"></i>
                            </span>
                            <span class="action-btn" onclick="showForumProfile()" title="个人主页">
                                <i class="fas fa-user"></i>
                            </span>
                        </div>
                    </div>
                    </div>
                    <div class="app-content">
                        <div id="forum-posts-list" class="post-list">
                        </div>
                    </div>

                    <!-- 悬浮按钮组 -->
                    <div class="floating-action-buttons">
                        <div class="floating-btn refresh-btn" onclick="refreshPosts()" title="刷新帖子">
                            <i class="fas fa-sync-alt"></i>
                        </div>
                        <div class="floating-btn post-btn" onclick="showCreatePostModal()" title="发帖">
                            <i class="fas fa-plus"></i>
                        </div>
                    </div>
                </div>

                <!-- 用户发帖模态框 -->
                <div id="create-post-modal" class="modal-overlay" style="display: none;" onclick="hideCreatePostModal(event)">
                    <div class="modal-content" onclick="event.stopPropagation()">
                        <div class="modal-header">
                            <h3>发布新帖</h3>
                            <button class="modal-close-btn" onclick="hideCreatePostModal()">×</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label>标题</label>
                                <input type="text" id="post-title-input" placeholder="请输入帖子标题..." maxlength="100">
                            </div>
                            <div class="form-group">
                                <label>内容</label>
                                <textarea id="post-content-input" placeholder="分享你的想法..." rows="6" maxlength="2000"></textarea>
                            </div>
                            <div class="form-group">
                                <label>图片 (可选)</label>
                                <div id="post-image-preview-container" style="display:none; margin-bottom: 10px; position: relative;">
                                    <img id="post-image-preview" src="" alt="图片预览" style="max-width: 100%; max-height: 150px; border-radius: 8px;">
                                    <button id="post-remove-image-btn" style="position: absolute; top: 5px; right: 5px; background: rgba(0,0,0,0.5); color: white; border: none; border-radius: 50%; width: 20px; height: 20px; cursor: pointer;">×</button>
                                </div>
                                <button class="form-upload-btn" id="post-upload-image-btn">
                                    <i class="fas fa-image"></i> 选择图片
                                </button>
                                <input type="file" id="post-image-upload" accept="image/*" style="display: none;">
                            </div>
                            <div class="char-count">
                                <span id="title-count">0/100</span> | <span id="content-count">0/2000</span>
                            </div>
                            <div class="form-group" style="margin-top: 15px;">
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="checkbox" id="anonymous-post-checkbox" style="margin-right: 8px;">
                                    匿名发帖（其他用户无法识别你的身份）
                                </label>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn-secondary" onclick="hideCreatePostModal()">取消</button>
                            <button class="btn-primary" onclick="submitUserPost()">发布</button>
                        </div>
                    </div>
                </div>

                <!-- 🔥【新增】视频通话形象设置模态框 -->
                <div id="video-avatar-modal" class="modal-overlay" style="display: none;" onclick="hideVideoAvatarModal(event)">
                    <div class="modal-content video-avatar-modal-content" onclick="event.stopPropagation()">
                        <div class="modal-header">
                            <h3>通话形象设置</h3>
                            <button class="modal-close-btn" onclick="hideVideoAvatarModal()">×</button>
                        </div>
                        <div class="modal-body">
                            <div class="video-avatar-preview">
                                <div class="avatar-preview-container">
                                    <div class="avatar-preview-item">
                                        <div class="avatar-preview-label">角色通话形象</div>
                                        <div class="avatar-preview-image-container">
                                            <img id="character-video-avatar-preview" src="" alt="角色通话形象" class="avatar-preview-image">
                                            <div class="avatar-preview-placeholder" id="character-avatar-placeholder">
                                                <i class="fas fa-user"></i>
                                                <span>点击设置</span>
                                            </div>
                                        </div>
                                        <button class="avatar-change-btn" onclick="changeCharacterVideoAvatar()">
                                            <i class="fas fa-camera"></i>
                                            更换形象
                                        </button>
                                    </div>

                                    <div class="avatar-preview-item">
                                        <div class="avatar-preview-label">用户通话形象</div>
                                        <div class="avatar-preview-image-container">
                                            <img id="user-video-avatar-preview" src="" alt="用户通话形象" class="avatar-preview-image">
                                            <div class="avatar-preview-placeholder" id="user-avatar-placeholder">
                                                <i class="fas fa-user"></i>
                                                <span>点击设置</span>
                                            </div>
                                        </div>
                                        <button class="avatar-change-btn" onclick="changeUserVideoAvatar()">
                                            <i class="fas fa-camera"></i>
                                            更换形象
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <div class="video-avatar-tips">
                                <div class="tips-title">
                                    <i class="fas fa-lightbulb"></i>
                                    设置说明
                                </div>
                                <div class="tips-content">
                                    • 角色通话形象：视频通话时角色显示的形象<br>
                                    • 用户通话形象：视频通话时你显示的形象<br>
                                    • 如不设置将使用默认头像
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn-secondary" onclick="hideVideoAvatarModal()">取消</button>
                            <button class="btn-primary" onclick="saveVideoAvatarSettings()">保存设置</button>
                        </div>
                    </div>
                </div>

                <!-- 🔥【新增】导出选项模态框 -->
                <div id="export-options-modal" class="modal-overlay" style="display: none;" onclick="hideExportOptions(event)">
                    <div class="modal-content export-options-modal" onclick="event.stopPropagation()">
                        <div class="modal-header">
                            <h3>导出聊天记录</h3>
                            <button class="modal-close-btn" onclick="hideExportOptions()">×</button>
                        </div>
                        <div class="modal-body">
                            <div class="export-format-section">
                                <h4>选择导出格式</h4>
                                <div class="export-format-options">
                                    <div class="export-format-option" onclick="selectExportFormat('html')">
                                        <div class="format-icon">
                                            <i class="fas fa-file-code"></i>
                                        </div>
                                        <div class="format-info">
                                            <div class="format-title">HTML格式</div>
                                            <div class="format-desc">适合阅读和分享的网页格式</div>
                                        </div>
                                        <div class="format-radio">
                                            <input type="radio" name="exportFormat" value="html" id="format-html" checked>
                                            <label for="format-html"></label>
                                        </div>
                                    </div>
                                    <div class="export-format-option" onclick="selectExportFormat('json')">
                                        <div class="format-icon">
                                            <i class="fas fa-database"></i>
                                        </div>
                                        <div class="format-info">
                                            <div class="format-title">JSON格式</div>
                                            <div class="format-desc">完整数据备份，包含聊天记录和记忆系统</div>
                                        </div>
                                        <div class="format-radio">
                                            <input type="radio" name="exportFormat" value="json" id="format-json">
                                            <label for="format-json"></label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideExportOptions()">取消</button>
                            <button class="modal-button modal-primary" onclick="executeExport()">导出</button>
                        </div>
                    </div>
                </div>

                <!-- 🔥【新增】导入选项模态框 -->
                <div id="import-options-modal" class="modal-overlay" style="display: none;" onclick="hideImportOptions(event)">
                    <div class="modal-content import-options-modal" onclick="event.stopPropagation()">
                        <div class="modal-header">
                            <h3>导入聊天记录</h3>
                            <button class="modal-close-btn" onclick="hideImportOptions()">×</button>
                        </div>
                        <div class="modal-body">
                            <div class="import-warning">
                                <div class="warning-icon">
                                    <i class="fas fa-exclamation-triangle"></i>
                                </div>
                                <div class="warning-text">
                                    <strong>注意：</strong>导入操作将完全覆盖当前角色的所有数据，包括：
                                    <ul>
                                        <li>聊天记录</li>
                                        <li>短信记录</li>
                                        <li>记忆系统</li>
                                    </ul>
                                    此操作不可撤销，请确保已备份重要数据！
                                </div>
                            </div>
                            <div class="import-file-section">
                                <input type="file" id="import-file-input" accept=".json" style="display: none;" onchange="handleImportFileSelect(event)">
                                <button class="import-file-btn" onclick="document.getElementById('import-file-input').click()">
                                    <i class="fas fa-upload"></i>
                                    选择JSON文件
                                </button>
                                <div class="import-file-info" id="import-file-info" style="display: none;">
                                    <div class="file-name" id="import-file-name"></div>
                                    <div class="file-preview" id="import-file-preview"></div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideImportOptions()">取消</button>
                            <button class="modal-button modal-primary modal-danger" onclick="executeImport()" id="import-execute-btn" disabled>导入并覆盖</button>
                        </div>
                    </div>
                </div>

                <!-- 隐藏的文件输入 -->
                <input type="file" id="character-video-avatar-input" accept="image/*" style="display: none;" onchange="handleCharacterVideoAvatarChange(event)">
                <input type="file" id="user-video-avatar-input" accept="image/*" style="display: none;" onchange="handleUserVideoAvatarChange(event)">

                <!-- 帖子详情和回复界面 -->
                <div id="post-view-screen" class="app-screen">
                    <div class="app-top-container">
                        <div class="app-status-bar">
                            <div class="app-status-time"></div>
                            <div class="app-status-right">
                                <div class="app-signal-icon signal-icon">
                                    <div class="signal-row">
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                    </div>
                                </div>
                                <div class="app-battery-container">
                                    <div class="app-battery-icon"><div class="app-battery-level"></div></div>
                                </div>
                            </div>
                        </div>
                        <div class="app-header">
                            <button class="back-button" onclick="backToForum()">‹ </button>
                            <div class="app-title">帖子详情</div>
                        <div class="header-actions">
                            <span id="favorite-btn" class="action-btn" onclick="toggleFavoritePost()" title="收藏">
                                <i class="far fa-star"></i>
                            </span>
                            <span id="share-btn" class="action-btn" onclick="showSharePostModal()" title="分享">
                                <i class="fas fa-share-square"></i>
                            </span>
                        </div>
                    </div>
                    </div>
                    <div class="app-content" id="post-view-content">
                    </div>
                    <div class="reply-input-area">
                        <button id="anonymous-toggle" class="anonymous-toggle-btn" onclick="toggleAnonymousMode()" title="匿名回复">
                            <i class="fas fa-user-secret"></i>
                        </button>
                        <input type="text" id="reply-input" placeholder="输入你的回复...">
                        <button onclick="sendReply()">发送</button>
                    </div>
                </div>

                <!-- 论坛个人主页/收藏夹 -->
                <div id="forum-profile-screen" class="app-screen">
                    <div class="app-top-container">
                        <div class="app-status-bar">
                            <div class="app-status-time"></div>
                            <div class="app-status-right">
                                <div class="app-signal-icon signal-icon">
                                    <div class="signal-row">
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                    </div>
                                </div>
                                <div class="app-battery-container">
                                    <div class="app-battery-icon"><div class="app-battery-level"></div></div>
                                </div>
                            </div>
                        </div>
                        <div class="app-header">
                            <button class="back-button" onclick="backToCurrentForum()">‹</button>
                            <div class="app-title">个人主页</div>
                        <div class="header-actions">
                            <span class="action-btn multi-select-toggle-btn" onclick="toggleMultiSelectMode()" title="多选删除" id="multi-select-btn">
                                <i class="fas fa-trash"></i>
                            </span>
                            <span class="action-btn" onclick="showVoteHistory()" title="投票历史">
                                <i class="fas fa-vote-yea"></i>
                            </span>
                        </div>
                    </div>
                    </div>
                    <div class="app-content" style="padding: 0;">
                        <div class="profile-tabs">
                            <div class="profile-tab active" onclick="switchProfileTab('my-posts')">我的帖子</div>
                            <div class="profile-tab" onclick="switchProfileTab('my-favorites')">我的收藏</div>
                        </div>

                        <div id="my-posts-list" class="post-list profile-post-list">
                        </div>
                        <div id="favorite-posts-list" class="post-list profile-post-list" style="display: none;">
                        </div>
                    </div>
                </div>

                <!-- 🎮【新增】五子棋游戏界面 -->
                <div id="gomoku-game-screen" class="app-screen" style="display: none;">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-status-right">
                            <div class="app-signal-icon signal-icon">
                                <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon"><div class="app-battery-level"></div></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="exitGomokuGame()">‹</button>
                        <div class="app-title">五子棋</div>
                        <!-- 🎮【删除】机器人标志已移除 -->
                    </div>

                    <!-- 🎮【新增】游戏内容容器 -->
                    <div class="app-content">
                        <!-- 游戏区域 (70%) -->
                        <div class="gomoku-game-area">
                        <div class="gomoku-board-container">
                            <div class="gomoku-board" id="gomoku-board">
                                <!-- 棋盘将通过JavaScript动态生成 -->
                            </div>
                        </div>

                        <!-- 🎮【修改】拆开的玩家信息 - AI在左下角 -->
                        <div class="gomoku-player-left">
                            <div class="player-avatar" id="ai-player-avatar">
                                <i class="fas fa-robot"></i>
                                <span class="piece-indicator ai-piece"></span>
                            </div>
                            <div class="player-name" id="ai-player-name" style="display: none;">AI</div>
                        </div>

                        <!-- 🎮【修改】拆开的玩家信息 - 用户在右下角 -->
                        <div class="gomoku-player-right">
                            <div class="player-avatar" id="user-player-avatar">
                                <i class="fas fa-user"></i>
                                <span class="piece-indicator user-piece"></span>
                            </div>
                            <div class="player-name" style="display: none;">你</div>
                        </div>
                    </div>

                    <!-- 聊天区域 (30%) -->
                    <div class="gomoku-chat-area">
                        <div class="gomoku-chat-header">
                            <div class="chat-header-left">
                                <button class="next-game-main-btn" onclick="startNextGomokuGame()" title="开始下一局">
                                    <i class="fas fa-play"></i>
                                    <span>下一局</span>
                                </button>
                            </div>
                            <div class="chat-header-center">
                                <!-- AI头像在计时器左侧 -->
                                <div class="player-avatar" id="ai-player-avatar-header">
                                    <i class="fas fa-robot"></i>
                                    <span class="piece-indicator ai-piece"></span>
                                </div>
                                <div class="game-status" id="gomoku-status">
                                    <div class="current-turn" id="current-turn">你的回合</div>
                                    <div class="game-timer" id="game-timer">00:00</div>
                                </div>
                                <!-- 用户头像在计时器右侧 -->
                                <div class="player-avatar" id="user-player-avatar-header">
                                    <i class="fas fa-user"></i>
                                    <span class="piece-indicator user-piece"></span>
                                </div>
                            </div>
                            <div class="chat-header-right">
                                <div class="chat-actions">
                                    <button class="chat-action-btn undo-btn" onclick="undoGomokuMove()" title="悔棋">
                                        <i class="fas fa-undo"></i>
                                    </button>
                                    <button class="chat-action-btn surrender-btn" onclick="surrenderGomokuGame()" title="认输">
                                        <i class="fas fa-flag"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="gomoku-chat-messages" id="gomoku-chat-messages">
                            <!-- 游戏聊天消息将在这里显示 -->
                        </div>
                        <div class="gomoku-chat-input">
                            <input type="text" id="gomoku-chat-input" placeholder="在游戏中聊天..." maxlength="200">
                            <button onclick="sendGameChatMessage()" id="send-game-chat-btn">
                                <i class="fas fa-paper-plane"></i>
                            </button>
                        </div>
                    </div>
                    <!-- 🎮【结束】游戏内容容器 -->
                    </div>
                </div>

                <!-- 🎮【新增】海龟汤游戏界面 -->
                <div id="turtle-soup-game-screen" class="app-screen turtle-soup-game-container" style="display: none;">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-status-right">
                            <div class="app-signal-icon signal-icon">
                                <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon"><div class="app-battery-level"></div></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="exitTurtleSoupGame()">‹</button>
                        <div class="app-title">海龟汤</div>
                        <button class="game-settings-button" onclick="showTurtleSoupSettings()">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>

                    <!-- 游戏区域 (60%) -->
                    <div class="turtle-soup-game-area">
                        <!-- DM区域 -->
                        <div class="turtle-soup-dm-section">
                            <div class="turtle-soup-dm-header">
                                <div class="turtle-soup-dm-avatar">
                                    <i class="fas fa-gamepad"></i>
                                </div>
                                <div>
                                    <div class="turtle-soup-dm-name">游戏主持人</div>
                                    <div class="turtle-soup-dm-role">(DM)</div>
                                </div>
                            </div>
                            <div class="turtle-soup-dm-message" id="turtle-soup-dm-message">
                                欢迎来到海龟汤推理游戏！我将为大家主持这场推理之旅...
                            </div>
                        </div>

                        <!-- 汤面展示区域 -->
                        <div class="turtle-soup-story-section">
                            <div class="turtle-soup-story-title">🐢 汤面</div>
                            <div class="turtle-soup-story-content" id="turtle-soup-story-content">
                                请稍等，我正在为你准备一个有趣的推理故事...
                            </div>
                            <div class="turtle-soup-game-status">
                                <div class="turtle-soup-question-count" id="turtle-soup-question-count">
                                    提问次数: 0
                                </div>
                                <div class="turtle-soup-game-timer" id="turtle-soup-game-timer">
                                    00:00
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 聊天区域 (40%) -->
                    <div class="turtle-soup-chat-area">
                        <div class="turtle-soup-chat-header">
                            <span class="turtle-soup-chat-title">推理讨论</span>
                            <!-- 🔥【新增】发言结束按钮 -->
                            <button class="finish-speaking-btn" onclick="finishSpeakingAndTriggerDM()" title="发言结束，让DM回应">
                                <i class="fas fa-check-circle"></i>
                                <span>发言结束</span>
                            </button>
                            <div class="turtle-soup-chat-actions">
                                <button class="chat-action-btn hint-btn" onclick="requestTurtleSoupHint()" title="请求提示">
                                    <i class="fas fa-lightbulb"></i>
                                </button>
                                <button class="chat-action-btn give-up-btn" onclick="giveTurtleSoupAnswer()" title="公布答案">
                                    <i class="fas fa-flag"></i>
                                </button>
                                <button class="chat-action-btn new-game-btn" onclick="startNewTurtleSoupGame()" title="新游戏">
                                    <i class="fas fa-plus"></i>
                                </button>
                            </div>
                        </div>
                        <div class="turtle-soup-chat-messages" id="turtle-soup-chat-messages">
                            <!-- 推理聊天消息将在这里显示 -->
                        </div>
                        <div class="turtle-soup-chat-input">
                            <input type="text" id="turtle-soup-chat-input" placeholder="提出你的推理问题（只能问是/否问题）..." maxlength="200">
                            <button onclick="sendTurtleSoupQuestion()" id="send-turtle-soup-btn">
                                <i class="fas fa-paper-plane"></i>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- 日记功能界面 - 仿线下模式样式 -->
                <div id="diary-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-status-right">
                            <div class="app-signal-icon signal-icon">
                                <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 日记模式覆盖层 - 仿线下模式 -->
                    <div id="diary-mode-overlay" class="diary-mode-overlay">
                        <div class="diary-mode-header">
                            <button class="back-btn" onclick="backFromDiary()">‹</button>
                            <span class="header-title" id="diary-mode-title">今日日记</span>
                            <div class="header-actions">
                                <span class="action-btn" onclick="switchDiaryTab('past')" id="past-diary-btn" title="过往日记">
                                    <i class="fas fa-history"></i>
                                </span>
                                <span class="action-btn" onclick="openDiarySettings()" id="diary-settings-btn" title="日记设置">
                                    <i class="fas fa-cog"></i>
                                </span>
                            </div>
                        </div>

                        <div class="diary-mode-content">
                            <!-- 今日日记内容 -->
                            <div id="today-diary-view" class="diary-view active">
                                <div id="today-diary-content" class="diary-paper-background">
                                    <!-- 日记内容将在这里显示 -->
                                </div>
                            </div>

                            <!-- 过往日记列表 -->
                            <div id="past-diaries-view" class="diary-view">
                                <div id="past-diaries-list" class="past-diaries-list">
                                    <!-- 过往日记列表将在这里显示 -->
                                </div>
                            </div>

                            <!-- 单个过往日记全屏查看 -->
                            <div id="single-diary-view" class="diary-view">
                                <div id="single-diary-content" class="diary-paper-background">
                                    <!-- 单个日记内容将在这里显示 -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 日记设置全屏界面 -->
                <div id="diary-settings-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-status-right">
                            <div class="app-signal-icon signal-icon">
                                <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 日记设置覆盖层 -->
                    <div id="diary-settings-overlay" class="diary-settings-overlay">
                        <div class="diary-settings-header">
                            <button class="back-btn" onclick="backFromDiarySettings()">‹</button>
                            <span class="header-title">日记设置</span>
                            <div class="header-actions">
                                <span class="action-btn" onclick="resetDiarySettings()" title="重置设置">
                                    <i class="fas fa-undo"></i>
                                </span>
                            </div>
                        </div>

                        <div class="diary-settings-content">
                            <!-- 实时预览区域 -->
                            <div class="settings-preview-section">
                                <h3>预览效果</h3>
                                <div class="diary-preview-container">
                                    <div id="diary-preview-content" class="diary-preview-paper">
                                        <div class="preview-text">
                                            2024年8月2日 星期五，天气：晴朗

                                            今天是美好的一天，阳光明媚。我在这里写下我的心情和想法。
                                            <mark>这是一段重要的内容</mark>，需要特别标记。
                                            <strike>这是一段后悔写下的话</strike>。
                                            希望每一天都能记录下美好的回忆。
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 设置选项区域 -->
                            <div class="settings-options-section">
                                <!-- 字体设置 -->
                                <div class="setting-group">
                                    <h4><i class="fas fa-font"></i> 字体设置</h4>

                                    <!-- 🔥【移除】字体族选项，使用全局字体设置 -->

                                    <div class="setting-item">
                                        <label>字体大小</label>
                                        <div class="slider-container">
                                            <input type="range" id="font-size-slider" min="12" max="24" value="16" onchange="updateDiarySettings()">
                                            <span id="font-size-value">16px</span>
                                        </div>
                                    </div>

                                    <div class="setting-item">
                                        <label>字体粗细</label>
                                        <select id="fontWeightSelect" onchange="setFontWeight(this.value)">
                                            <option value="300">细体</option>
                                            <option value="400">正常</option>
                                            <option value="500" selected>中等</option>
                                            <option value="600">半粗</option>
                                            <option value="700">粗体</option>
                                        </select>
                                    </div>
                                </div>

                                <!-- 排版设置 -->
                                <div class="setting-group">
                                    <h4><i class="fas fa-align-left"></i> 排版设置</h4>

                                    <div class="setting-item">
                                        <label>行距</label>
                                        <div class="slider-container">
                                            <input type="range" id="line-height-slider" min="1.2" max="2.5" step="0.1" value="1.6" onchange="updateDiarySettings()">
                                            <span id="line-height-value">1.6</span>
                                        </div>
                                    </div>

                                    <div class="setting-item">
                                        <label>段落间距</label>
                                        <div class="slider-container">
                                            <input type="range" id="paragraph-spacing-slider" min="0" max="30" value="15" onchange="updateDiarySettings()">
                                            <span id="paragraph-spacing-value">15px</span>
                                        </div>
                                    </div>

                                    <div class="setting-item">
                                        <label>文本对齐</label>
                                        <select id="textAlignSelect" onchange="setTextAlign(this.value)">
                                            <option value="left" selected>左对齐</option>
                                            <option value="center">居中</option>
                                            <option value="right">右对齐</option>
                                            <option value="justify">两端对齐</option>
                                        </select>
                                    </div>

                                    <div class="setting-item">
                                        <label>文本装饰</label>
                                        <select id="textDecorationSelect" onchange="setTextDecoration(this.value)">
                                            <option value="none" selected>无装饰</option>
                                            <option value="underline">下划线</option>
                                        </select>
                                    </div>
                                </div>

                                <!-- 内容宽度设置 -->
                                <div class="setting-group">
                                    <h4><i class="fas fa-arrows-alt-h"></i> 内容宽度</h4>

                                    <div class="setting-item">
                                        <label>文本宽度</label>
                                        <div class="slider-container">
                                            <input type="range" id="content-width-slider" min="60" max="100" value="100" onchange="updateDiarySettings()">
                                            <span id="content-width-value">100%</span>
                                        </div>
                                    </div>

                                    <div class="setting-item">
                                        <label>左右边距</label>
                                        <div class="slider-container">
                                            <input type="range" id="content-padding-slider" min="10" max="60" value="40" onchange="updateDiarySettings()">
                                            <span id="content-padding-value">40px</span>
                                        </div>
                                    </div>

                                    <div class="setting-item">
                                        <label>上边距</label>
                                        <div class="slider-container">
                                            <input type="range" id="content-top-margin-slider" min="0" max="120" value="20" onchange="updateDiarySettings()">
                                            <span id="content-top-margin-value">20px</span>
                                        </div>
                                    </div>
                                </div>

                                <!-- 背景纸张设置 -->
                                <div class="setting-group">
                                    <h4><i class="fas fa-image"></i> 背景纸张</h4>
                                    <div class="paper-options">
                                        <div class="paper-option active" onclick="setDiaryPaper('plain')" data-paper="plain">
                                            <div class="paper-preview plain-paper"></div>
                                            <span>白纸</span>
                                        </div>
                                        <div class="paper-option" onclick="setDiaryPaper('vintage')" data-paper="vintage">
                                            <div class="paper-preview vintage-paper"></div>
                                            <span>复古纸</span>
                                        </div>
                                        <div class="paper-option custom-paper" onclick="uploadCustomPaper()">
                                            <div class="paper-preview custom-preview">
                                                <i class="fas fa-plus"></i>
                                            </div>
                                            <span>自定义</span>
                                        </div>
                                    </div>
                                    <input type="file" id="paperImageInput" accept="image/*" style="display: none;" onchange="handlePaperUpload(event)">
                                </div>

                                <!-- 编辑功能 -->
                                <div class="setting-group">
                                    <h4><i class="fas fa-edit"></i> 编辑功能</h4>
                                    <div class="edit-actions">
                                        <button class="btn btn-primary" onclick="editTodayDiary(); backFromDiarySettings();">
                                            <i class="fas fa-pencil-alt"></i> 编辑日记
                                        </button>
                                        <button class="btn btn-secondary" onclick="generateTodayDiary(); backFromDiarySettings();">
                                            <i class="fas fa-sync-alt"></i> 重新生成
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 记忆设置模态框 -->
                <div id="memorySettingsModal" class="modal" style="display: none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>记忆系统设置</h3>
                            <button class="modal-close" onclick="closeMemorySettings()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div class="setting-group">
                                <label for="aiExtractInterval">AI记忆提取间隔（回合数）</label>
                                <input type="number" id="aiExtractInterval" min="10" max="200" step="10" value="30">
                                <small>每多少回合对话进行一次AI记忆提取（建议20-50回合）</small>
                            </div>

                            <div class="setting-group">
                                <label for="coreMemoryThreshold">核心记忆重要性阈值</label>
                                <input type="range" id="coreMemoryThreshold" min="0.7" max="1.0" step="0.05" value="0.9">
                                <span id="coreThresholdValue">90%</span>
                                <small>只有重要性超过此阈值的记忆才会成为核心记忆</small>
                            </div>

                            <div class="setting-group">
                                <label for="episodicMemoryThreshold">情景记忆重要性阈值</label>
                                <input type="range" id="episodicMemoryThreshold" min="0.4" max="0.8" step="0.05" value="0.6">
                                <span id="episodicThresholdValue">60%</span>
                                <small>重要性在此范围内的记忆会成为情景记忆</small>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="closeMemorySettings()">取消</button>
                            <button class="btn btn-primary" onclick="saveMemorySettings()">保存设置</button>
                        </div>
                    </div>
                </div>

                <!-- 线下预设设置模态框 -->
                <div id="offline-preset-modal" class="modal" style="display: none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>线下剧情预设</h3>
                            <button class="modal-close" onclick="closeOfflinePresetSettings()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <!-- 已保存的预设列表 -->
                            <div class="form-group">
                                <label>已保存的预设</label>
                                <div id="saved-presets-list" class="saved-presets-list">
                                    <!-- 预设列表将在这里动态生成 -->
                                </div>
                            </div>

                            <!-- 新建/编辑预设表单 -->
                            <div class="form-group">
                                <label for="offline-preset-name">预设名称</label>
                                <input type="text" id="offline-preset-name" placeholder="为这个预设起个名字..." maxlength="50">
                            </div>
                            <div class="form-group">
                                <label for="offline-preset-content">剧情预设内容</label>
                                <textarea id="offline-preset-content" rows="6" placeholder="请输入线下剧情模式的预设内容，这将决定AI的文风、字数、视角等...&#10;&#10;例如：&#10;- 以第三人称视角描述&#10;- 每次回复200-400字&#10;- 注重环境描写和心理活动&#10;- 营造浪漫/悬疑/冒险等氛围"></textarea>
                            </div>
                            <div class="form-group">
                                <label>预设说明</label>
                                <div class="preset-help-text">
                                    <p>• 预设内容将作为AI回复的重要指导</p>
                                    <p>• 可以指定文风、字数、视角、氛围等</p>
                                    <p>• 支持情景描写、动作描写、心理描写</p>
                                    <p>• 预设权重很高，会显著影响AI的回复风格</p>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="closeOfflinePresetSettings()">取消</button>
                            <button class="btn btn-secondary" onclick="clearPresetForm()">清空表单</button>
                            <button class="btn btn-primary" onclick="saveOfflinePreset()">保存预设</button>
                        </div>
                    </div>
                </div>

                <!-- 线下模式聊天记录模态框 -->
                <div id="offline-history-modal" class="modal" style="display: none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>线下模式聊天记录</h3>
                            <button class="modal-close" onclick="closeOfflineHistoryModal()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div id="offline-history-list" class="offline-history-list">
                                <!-- 聊天记录列表将在这里动态生成 -->
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="closeOfflineHistoryModal()">关闭</button>
                            <button class="btn btn-danger" onclick="clearAllOfflineHistory()">清空所有记录</button>
                        </div>
                    </div>
                </div>

                <!-- 纪念日表单模态框 -->
                <div id="anniversary-form-modal" class="modal" style="display: none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 id="anniversary-form-title">添加纪念日</h3>
                            <button class="modal-close" onclick="closeAnniversaryForm()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label for="anniversary-name">纪念日名称</label>
                                <input type="text" id="anniversary-name" placeholder="例如：小雪的生日" maxlength="50">
                            </div>
                            <div class="form-group">
                                <label for="anniversary-date">日期</label>
                                <input type="date" id="anniversary-date">
                            </div>
                            <div class="form-group">
                                <label for="anniversary-type">类型</label>
                                <select id="anniversary-type" onchange="toggleCustomTypeInput('anniversary')">
                                    <option value="birthday">生日</option>
                                    <option value="relationship">确定关系</option>
                                    <option value="anniversary">纪念日</option>
                                    <option value="holiday">节日</option>
                                    <option value="family">家人生日</option>
                                    <option value="other">其他</option>
                                </select>
                            </div>
                            <div class="form-group" id="anniversary-custom-type-group" style="display: none;">
                                <label for="anniversary-custom-type">自定义类型</label>
                                <input type="text" id="anniversary-custom-type" placeholder="请输入自定义类型..." maxlength="20">
                            </div>
                            <div class="form-group">
                                <label for="anniversary-character">相关角色</label>
                                <select id="anniversary-character" onchange="toggleCharacterQuoteGroup('anniversary', this.value)">
                                    <option value="">选择角色（可选）</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="anniversary-description">描述（可选）</label>
                                <textarea id="anniversary-description" rows="3" placeholder="添加一些备注..." maxlength="200"></textarea>
                            </div>
                            <div class="form-group">
                                <label for="anniversary-user-quote">我的语录</label>
                                <textarea id="anniversary-user-quote" rows="2" placeholder="你对这个纪念日的感想..." maxlength="150"></textarea>
                            </div>
                            <div class="form-group" id="anniversary-character-quote-group" style="display: none;">
                                <label for="anniversary-character-quote" id="anniversary-quote-label">角色语录</label>
                                <textarea id="anniversary-character-quote" rows="2" placeholder="角色对这个纪念日的感想..." maxlength="150"></textarea>
                            </div>
                            <div class="form-group">
                                <label for="anniversary-count-type">天数计算方式</label>
                                <select id="anniversary-count-type">
                                    <option value="countdown">倒数</option>
                                    <option value="countup">正数</option>
                                </select>
                                <small class="form-hint">选择显示"还有X天"还是"已经X天"</small>
                            </div>
                            <div class="form-group">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="anniversary-yearly" checked>
                                    每年重复
                                </label>
                            </div>
                            <div class="form-group">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="anniversary-shared">
                                    与角色共享（角色也能看到这个纪念日）
                                </label>
                            </div>
                            <div class="form-group">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="anniversary-pinned">
                                    置顶显示（在纪念日列表顶部大卡片显示）
                                </label>
                            </div>
                            <div class="form-group" id="anniversary-background-group">
                                <label for="anniversary-background-upload">背景图片（可选）</label>
                                <input type="file" id="anniversary-background-upload" accept="image/*" onchange="handleAnniversaryBackgroundUpload(this)">
                                <small class="form-hint">用于置顶显示和主屏幕小组件背景</small>
                                <div id="anniversary-background-preview" class="background-preview" style="display: none;">
                                    <img id="anniversary-background-img" src="" alt="背景预览">
                                    <button type="button" class="remove-background-btn" onclick="removeAnniversaryBackground()">
                                        <i class="fas fa-times"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="form-group" id="anniversary-user-avatar-group">
                                <label for="anniversary-user-avatar-upload">你的头像（可选）</label>
                                <input type="file" id="anniversary-user-avatar-upload" accept="image/*" onchange="handleAnniversaryUserAvatarUpload(this)">
                                <small class="form-hint">用于置顶显示时显示你的身份</small>
                                <div id="anniversary-user-avatar-preview" class="avatar-preview" style="display: none;">
                                    <img id="anniversary-user-avatar-img" src="" alt="头像预览">
                                    <button type="button" class="remove-avatar-btn" onclick="removeAnniversaryUserAvatar()">
                                        <i class="fas fa-times"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="closeAnniversaryForm()">取消</button>
                            <button class="btn btn-primary" onclick="saveAnniversary()">保存</button>
                        </div>
                    </div>
                </div>

                <!-- 约定表单模态框 -->
                <div id="appointment-form-modal" class="modal" style="display: none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 id="appointment-form-title">添加约定</h3>
                            <button class="modal-close" onclick="closeAppointmentForm()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label for="appointment-name">约定名称</label>
                                <input type="text" id="appointment-name" placeholder="例如：和小雪去看电影" maxlength="50">
                            </div>
                            <div class="form-group">
                                <label for="appointment-date">日期</label>
                                <input type="date" id="appointment-date">
                            </div>
                            <div class="form-group">
                                <label for="appointment-time">时间</label>
                                <input type="time" id="appointment-time">
                            </div>
                            <div class="form-group">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="appointment-never-expires" onchange="toggleNeverExpires('appointment')">
                                    永不过期
                                </label>
                                <small class="form-hint">勾选后，此约定将不会显示剩余天数，适合长期承诺</small>
                            </div>
                            <div class="form-group">
                                <label for="appointment-type">类型</label>
                                <select id="appointment-type" onchange="toggleCustomTypeInput('appointment')">
                                    <option value="date">约会</option>
                                    <option value="promise">承诺</option>
                                    <option value="activity">活动</option>
                                    <option value="meeting">见面</option>
                                    <option value="task">任务</option>
                                    <option value="other">其他</option>
                                </select>
                            </div>
                            <div class="form-group" id="appointment-custom-type-group" style="display: none;">
                                <label for="appointment-custom-type">自定义类型</label>
                                <input type="text" id="appointment-custom-type" placeholder="请输入自定义类型..." maxlength="20">
                            </div>
                            <div class="form-group">
                                <label for="appointment-character">相关角色</label>
                                <select id="appointment-character" onchange="toggleCharacterQuoteGroup('appointment', this.value)">
                                    <option value="">选择角色（可选）</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="appointment-priority">重要程度</label>
                                <select id="appointment-priority">
                                    <option value="low">一般</option>
                                    <option value="medium" selected>重要</option>
                                    <option value="high">很重要</option>
                                    <option value="urgent">非常重要</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="appointment-description">描述（可选）</label>
                                <textarea id="appointment-description" rows="3" placeholder="添加一些备注..." maxlength="200"></textarea>
                            </div>
                            <div class="form-group">
                                <label for="appointment-user-quote">我的语录</label>
                                <textarea id="appointment-user-quote" rows="2" placeholder="你对这个约定的感想..." maxlength="150"></textarea>
                            </div>
                            <div class="form-group" id="appointment-character-quote-group" style="display: none;">
                                <label for="appointment-character-quote" id="appointment-quote-label">角色语录</label>
                                <textarea id="appointment-character-quote" rows="2" placeholder="角色对这个约定的感想..." maxlength="150"></textarea>
                            </div>
                            <div class="form-group">
                                <label for="appointment-count-type">天数计算方式</label>
                                <select id="appointment-count-type">
                                    <option value="countdown">倒数</option>
                                    <option value="countup">正数</option>
                                </select>
                                <small class="form-hint">选择显示"还有X天"还是"已经X天"</small>
                            </div>
                            <div class="form-group">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="appointment-shared">
                                    与角色共享（角色也能看到这个约定）
                                </label>
                            </div>
                            <div class="form-group">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="appointment-pinned">
                                    置顶显示（在约定列表顶部大卡片显示）
                                </label>
                            </div>
                            <div class="form-group" id="appointment-background-group">
                                <label for="appointment-background-upload">背景图片（可选）</label>
                                <input type="file" id="appointment-background-upload" accept="image/*" onchange="handleAppointmentBackgroundUpload(this)">
                                <small class="form-hint">用于置顶显示背景</small>
                                <div id="appointment-background-preview" class="background-preview" style="display: none;">
                                    <img id="appointment-background-img" src="" alt="背景预览">
                                    <button type="button" class="remove-background-btn" onclick="removeAppointmentBackground()">
                                        <i class="fas fa-times"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="form-group" id="appointment-user-avatar-group">
                                <label for="appointment-user-avatar-upload">你的头像（可选）</label>
                                <input type="file" id="appointment-user-avatar-upload" accept="image/*" onchange="handleAppointmentUserAvatarUpload(this)">
                                <small class="form-hint">用于置顶显示时显示你的身份</small>
                                <div id="appointment-user-avatar-preview" class="avatar-preview" style="display: none;">
                                    <img id="appointment-user-avatar-img" src="" alt="头像预览">
                                    <button type="button" class="remove-avatar-btn" onclick="removeAppointmentUserAvatar()">
                                        <i class="fas fa-times"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="closeAppointmentForm()">取消</button>
                            <button class="btn btn-primary" onclick="saveAppointment()">保存</button>
                        </div>
                    </div>
                </div>

                <!-- 图片小组件设置模态框 -->
                <div id="photo-widget-modal" class="modal" style="display: none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>图片小组件</h3>
                            <button class="modal-close" onclick="closePhotoWidgetModal()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label for="widget-photo-upload">选择图片</label>
                                <input type="file" id="widget-photo-upload" accept="image/*" onchange="handlePhotoWidgetUpload(this)">
                            </div>
                            <div class="form-group">
                                <button class="btn btn-secondary" onclick="clearPhotoWidget()">清除图片</button>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="closePhotoWidgetModal()">关闭</button>
                        </div>
                    </div>
                </div>

                <!-- 纪念日小组件设置模态框 -->
                <div id="anniversary-widget-modal" class="modal" style="display: none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>纪念日小组件</h3>
                            <button class="modal-close" onclick="closeAnniversaryWidgetModal()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label for="widget-anniversary-select">选择要显示的纪念日</label>
                                <select id="widget-anniversary-select" onchange="updateAnniversaryWidget()">
                                    <option value="">请选择纪念日</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <button class="btn btn-secondary" onclick="clearAnniversaryWidget()">清除显示</button>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="closeAnniversaryWidgetModal()">关闭</button>
                        </div>
                    </div>
                </div>

                <!-- 线下模式界面设置模态框 -->
                <div id="offline-ui-settings-modal" class="modal" style="display: none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>线下模式界面设置</h3>
                            <button class="modal-close" onclick="closeOfflineUISettings()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <!-- 气泡颜色设置 -->
                            <div class="form-group">
                                <label>气泡颜色设置</label>
                                <div class="color-setting-group">
                                    <div class="color-picker-container">
                                        <div class="flex-gap-15">
                                            <div class="flex-1">
                                                <label class="label-small">我的气泡</label>
                                                <input type="color" id="offline-my-bubble-color" class="color-input" value="#007AFF">
                                            </div>
                                            <div class="flex-1">
                                                <label class="label-small">角色气泡</label>
                                                <input type="color" id="offline-ai-bubble-color" class="color-input" value="#f0f0f0">
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 透明度设置 -->
                            <div class="form-group">
                                <label>气泡透明度</label>
                                <div class="opacity-setting">
                                    <input type="range" id="offline-bubble-opacity" class="theme-range" min="0" max="1" step="0.01" value="0.9">
                                    <span id="offline-opacity-value">90%</span>
                                </div>
                            </div>



                            <!-- 🔥【新增】字体大小设置 -->
                            <div class="form-group">
                                <label>字体大小</label>
                                <div class="opacity-setting">
                                    <input type="range" id="offline-font-size" class="theme-range" min="12" max="24" step="1" value="15">
                                    <span id="offline-font-size-value">15px</span>
                                </div>
                            </div>

                            <!-- 壁纸设置 -->
                            <div class="form-group">
                                <label>背景壁纸</label>
                                <div class="wallpaper-setting">
                                    <input type="file" id="offline-wallpaper-file" accept="image/*" class="form-input" onchange="handleOfflineWallpaperUpload(this)">
                                    <button type="button" class="theme-button theme-button-secondary" onclick="clearOfflineWallpaper()">清除</button>
                                </div>
                            </div>

                            <!-- 字体设置 -->
                            <div class="form-group">
                                <label>字体设置</label>
                                <div class="font-setting">
                                    <select id="offline-font-select" class="form-input" onchange="handleOfflineFontChange()">
                                        <option value="">系统默认字体</option>
                                        <option value="custom">自定义字体URL...</option>
                                    </select>
                                    <div id="custom-font-input" style="display: none; margin-top: 10px;">
                                        <input type="url" id="offline-font-url" placeholder="例如：https://fonts.googleapis.com/css2?family=Noto+Sans+SC 或直接字体文件URL" class="form-input">
                                        <button type="button" class="theme-button theme-button-secondary" onclick="previewOfflineFont()">预览</button>
                                    </div>
                                </div>
                            </div>

                            <!-- 文字颜色设置 -->
                            <div class="form-group">
                                <label>文字颜色设置</label>
                                <div class="text-color-setting">
                                    <!-- 用户消息文字颜色 -->
                                    <div class="color-section">
                                        <label class="section-label">用户消息文字颜色</label>
                                        <div class="color-picker-container">
                                            <div class="flex-gap-15">
                                                <div class="flex-1">
                                                    <label class="label-small">普通文字</label>
                                                    <input type="color" id="offline-user-normal-text-color" class="color-input" value="#ffffff">
                                                    <div class="saved-colors" id="offline-user-normal-saved-colors"></div>
                                                </div>
                                                <div class="flex-1">
                                                    <label class="label-small">斜体文字</label>
                                                    <input type="color" id="offline-user-italic-text-color" class="color-input" value="#f0f0f0">
                                                    <div class="saved-colors" id="offline-user-italic-saved-colors"></div>
                                                </div>
                                                <div class="flex-1">
                                                    <label class="label-small">加粗文字</label>
                                                    <input type="color" id="offline-user-bold-text-color" class="color-input" value="#ffffff">
                                                    <div class="saved-colors" id="offline-user-bold-saved-colors"></div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- 角色消息文字颜色 -->
                                    <div class="color-section">
                                        <label class="section-label">角色消息文字颜色</label>
                                        <div class="color-picker-container">
                                            <div class="flex-gap-15">
                                                <div class="flex-1">
                                                    <label class="label-small">普通文字</label>
                                                    <input type="color" id="offline-ai-normal-text-color" class="color-input" value="#000000">
                                                    <div class="saved-colors" id="offline-ai-normal-saved-colors"></div>
                                                </div>
                                                <div class="flex-1">
                                                    <label class="label-small">斜体文字</label>
                                                    <input type="color" id="offline-ai-italic-text-color" class="color-input" value="#666666">
                                                    <div class="saved-colors" id="offline-ai-italic-saved-colors"></div>
                                                </div>
                                                <div class="flex-1">
                                                    <label class="label-small">加粗文字</label>
                                                    <input type="color" id="offline-ai-bold-text-color" class="color-input" value="#333333">
                                                    <div class="saved-colors" id="offline-ai-bold-saved-colors"></div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 预存颜色功能 -->
                            <div class="form-group">
                                <label>颜色管理</label>
                                <div class="color-management">
                                    <button type="button" class="theme-button theme-button-secondary" onclick="saveCurrentOfflineColors()">保存当前颜色</button>
                                    <button type="button" class="theme-button theme-button-secondary" onclick="resetOfflineColors()">重置为默认</button>
                                </div>
                            </div>

                            <!-- 头像设置 -->
                            <div class="form-group">
                                <label>头像设置</label>
                                <div class="avatar-setting">
                                    <div class="setting-row">
                                        <label class="checkbox-label">
                                            <input type="checkbox" id="offline-show-user-avatar" checked>
                                            显示用户头像
                                        </label>
                                        <label class="checkbox-label">
                                            <input type="checkbox" id="offline-show-ai-avatar" checked>
                                            显示角色头像
                                        </label>
                                    </div>
                                    <div class="setting-row">
                                        <label class="radio-label">头像位置：</label>
                                        <div class="radio-options">
                                            <div class="radio-option-button selected" onclick="selectAvatarPosition('side', this)">
                                                <div class="radio-indicator"></div>
                                                侧边显示
                                            </div>
                                            <div class="radio-option-button" onclick="selectAvatarPosition('custom', this)">
                                                <div class="radio-indicator"></div>
                                                自定义CSS控制
                                            </div>
                                            <input type="radio" name="offline-avatar-position" value="side" checked style="display: none;">
                                            <input type="radio" name="offline-avatar-position" value="custom" style="display: none;">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 气泡样式设置 -->
                            <div class="form-group">
                                <label>气泡样式设置</label>
                                <div class="bubble-style-setting">
                                    <div class="setting-row">
                                        <label class="radio-label">气泡宽度：</label>
                                        <div class="radio-options">
                                            <div class="radio-option-button selected" onclick="selectBubbleWidth('default', this)">
                                                <div class="radio-indicator"></div>
                                                智能宽度
                                            </div>
                                            <div class="radio-option-button" onclick="selectBubbleWidth('custom', this)">
                                                <div class="radio-indicator"></div>
                                                自定义CSS控制
                                            </div>
                                            <input type="radio" name="offline-bubble-width" value="default" checked style="display: none;">
                                            <input type="radio" name="offline-bubble-width" value="custom" style="display: none;">
                                        </div>
                                    </div>
                                    <div class="setting-row">
                                        <label class="radio-label">气泡样式：</label>
                                        <div class="radio-options">
                                            <div class="radio-option-button selected" onclick="selectBubbleStyle('default', this)">
                                                <div class="radio-indicator"></div>
                                                默认样式
                                            </div>
                                            <div class="radio-option-button" onclick="selectBubbleStyle('custom', this)">
                                                <div class="radio-indicator"></div>
                                                自定义CSS控制
                                            </div>
                                            <input type="radio" name="offline-bubble-style" value="default" checked style="display: none;">
                                            <input type="radio" name="offline-bubble-style" value="custom" style="display: none;">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 自定义CSS设置 -->
                            <div class="form-group">
                                <label>自定义CSS代码</label>
                                <div class="custom-css-setting">
                                    <textarea id="offline-custom-css" rows="8" class="form-input" placeholder="在这里输入自定义CSS代码来控制头像位置、气泡样式、气泡大小等...&#10;&#10;示例：&#10;/* 调整气泡宽度 */&#10;.offline-message-content {&#10;    max-width: 70% !important;&#10;}&#10;&#10;/* 调整头像位置 */&#10;.offline-avatar {&#10;    position: absolute;&#10;    top: -10px;&#10;    right: -10px;&#10;}"></textarea>
                                    <div class="css-buttons">
                                        <button type="button" class="theme-button theme-button-secondary" onclick="previewOfflineCSS()">预览CSS</button>
                                        <button type="button" class="theme-button theme-button-secondary" onclick="clearOfflineCSS()">清除CSS</button>
                                    </div>
                                </div>
                            </div>

                            <!-- 预览区域 -->
                            <div class="form-group">
                                <label>效果预览</label>
                                <div class="offline-preview-area" id="offline-preview-area">
                                    <div class="offline-preview-message user">
                                        <div class="offline-avatar user-avatar" id="preview-user-avatar">👤</div>
                                        <div class="offline-preview-content">
                                            这是用户消息的预览效果，包含<em>斜体文字</em>和<strong>加粗文字</strong>
                                        </div>
                                    </div>
                                    <div class="offline-preview-message ai">
                                        <div class="offline-avatar ai-avatar" id="preview-ai-avatar">🤖</div>
                                        <div class="offline-preview-content">
                                            这是角色回复的预览效果，包含<em>斜体文字</em>和<strong>加粗文字</strong>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="closeOfflineUISettings()">取消</button>
                            <button class="btn btn-secondary" onclick="resetOfflineUISettings()">重置</button>
                            <button class="btn btn-primary" onclick="saveOfflineUISettings()">保存设置</button>
                        </div>
                    </div>
                </div>





                <!-- 记忆查看器界面 -->
                <div id="memory-viewer-screen" class="app-screen">
                    <div class="app-top-container">
                        <div class="app-status-bar">
                            <div class="app-status-time"></div>
                            <div class="app-status-right">
                                <div class="app-signal-icon signal-icon">
                                    <div class="signal-row">
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                    </div>
                                </div>
                                <div class="app-battery-container">
                                    <div class="app-battery-icon">
                                        <div class="app-battery-level"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="app-header">
                            <button class="back-button" onclick="hideApp('memory-viewer-screen')">‹</button>

                            <div class="app-title">记忆查看器</div>
                        <div class="header-actions">
                            <!-- 右侧放3个按钮：设置、刷新、清理错误记录 -->
                            <button class="header-action-btn" onclick="showMemorySettings()" title="记忆设置">
                                <i class="fas fa-cog"></i>
                            </button>
                            <button class="header-action-btn" onclick="refreshMemoryData()" title="刷新">
                                <i class="fas fa-sync-alt"></i>
                            </button>
                            <button class="header-action-btn" onclick="cleanupIncorrectRecords()" title="清理错误记录">
                                <i class="fas fa-tools"></i>
                            </button>
                        </div>
                    </div>
                    </div>
                    <div class="app-content">
                        <!-- 角色选择器 -->
                        <div class="memory-character-selector">
                            <label for="memory-character-select">选择角色：</label>
                            <select id="memory-character-select" onchange="loadCharacterMemories()">
                                <option value="">请选择角色</option>
                            </select>
                        </div>

                        <!-- 搜索和过滤 -->
                        <div class="memory-search-section">
                            <div class="memory-search-bar">
                                <input type="text" id="memory-search-input" placeholder="搜索记忆内容..." oninput="filterMemories()">
                                <button class="search-btn" onclick="filterMemories()">
                                    <i class="fas fa-search"></i>
                                </button>
                            </div>
                            <div class="memory-filter-tabs">
                                <button class="memory-filter-tab active" data-type="all" onclick="switchMemoryFilter('all')">全部</button>
                                <button class="memory-filter-tab" data-type="core" onclick="switchMemoryFilter('core')">核心记忆</button>
                                <button class="memory-filter-tab" data-type="episodic" onclick="switchMemoryFilter('episodic')">情景记忆</button>
                                <button class="memory-filter-tab" data-type="storyline" onclick="switchMemoryFilter('storyline')">剧情总结</button>
                                <button class="memory-filter-tab" data-type="timeline" onclick="switchMemoryFilter('timeline')">时间线</button>
                            </div>
                        </div>

                        <!-- 记忆内容显示区域 -->
                        <div class="memory-content-area">
                            <div id="memory-list" class="memory-list">
                                <div class="memory-empty-state">
                                    <i class="fas fa-brain"></i>
                                    <p>请选择角色查看记忆</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 世界书编辑表单 -->
                <div id="worldbook-form-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-status-right">
                            <div class="app-signal-icon signal-icon">
                                <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideWorldbookForm()">‹</button>
                        <div class="app-title" id="worldbook-form-title">新建世界书</div>
                        <button class="save-worldbook-btn save-btn-absolute" onclick="saveWorldbook()">保存</button>
                    </div>
                    <div class="app-content">
                        <div class="worldbook-form">
                            <div class="form-group">
                                <label class="form-label">标题</label>
                                <input type="text" id="worldbook-title" class="form-input" placeholder="请输入世界书标题">
                            </div>
                            <div class="form-group">
                                <label class="form-label">内容</label>
                                <textarea id="worldbook-content" class="form-textarea textarea-large" placeholder="请输入世界书内容，这里可以描述角色背景、世界观设定等..."></textarea>
                            </div>
                        </div>
                    </div>
                </div>



                <!-- 聊天设置界面 -->
                <div id="api-chat-settings-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-status-right">
                            <div class="app-signal-icon signal-icon">
                                <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideChatSettings()">‹</button>
                        <div class="app-title">聊天设置</div>
                    </div>
                    <div class="app-content padding-none-flex overflow-auto">
                        <div class="settings-container">

                            <!-- 群聊专用设置 - 仿QQ/微信群聊界面 -->
                            <div class="settings-section" id="group-chat-settings" style="display: none;">
                                <!-- 群聊信息卡片 -->
                                <div class="group-info-card">
                                    <div class="group-avatar-section" onclick="changeGroupAvatar()">
                                        <img id="group-avatar-preview" src="" class="group-avatar-large" alt="群头像">
                                        <div class="group-avatar-edit-hint">点击修改</div>
                                    </div>
                                    <div class="group-basic-info">
                                        <div class="group-name" onclick="changeGroupName()" id="group-name-display">群聊名称</div>
                                        <div class="group-member-count" id="group-member-count-display">0名成员</div>
                                        <div class="group-description" onclick="editGroupDescription()" id="group-description-display">群公告：点击设置群公告</div>
                                    </div>
                                </div>

                                <!-- 群成员展示区域 -->
                                <div class="group-members-section">
                                    <div class="section-title">群成员</div>
                                    <div class="group-members-grid" id="group-members-grid">
                                        <!-- 群成员头像将动态生成 -->
                                        <div class="member-item add-member" onclick="addGroupMember()">
                                            <div class="member-avatar">
                                                <i class="fas fa-plus"></i>
                                            </div>
                                            <div class="member-name">邀请</div>
                                        </div>
                                        <div class="member-item remove-member" onclick="removeGroupMember()">
                                            <div class="member-avatar">
                                                <i class="fas fa-minus"></i>
                                            </div>
                                            <div class="member-name">移除</div>
                                        </div>
                                    </div>
                                </div>

                                <!-- 群功能设置 -->
                                <div class="setting-card">
                                    <div class="setting-item" onclick="changeMyGroupNickname()">
                                        <div class="setting-left">
                                            <div class="setting-label">我在本群的昵称</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="current-my-group-nickname">未选择</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showGroupNotice()">
                                        <div class="setting-left">
                                            <div class="setting-label">群公告</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value">查看详情</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>

                                </div>


                            </div>

                            <!-- 聊天窗口设置 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-user-edit section-icon"></i>
                                    <span class="section-title">聊天窗口设置</span>
                                </div>
                                <div class="setting-card">
                                    <!-- 身份选择功能已移除，身份在创建对话时选择 -->
                                    <!-- 单聊时显示双方设置，群聊时隐藏 -->
                                    <div class="setting-item single-chat-only" onclick="showAvatarSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">双方头像设置</div>
                                            <div class="setting-desc">设置在此聊天窗口中显示的头像</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item single-chat-only" onclick="showNicknameSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">双方备注设置</div>
                                            <div class="setting-desc">设置在此聊天窗口中显示的昵称</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showBackgroundSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">聊天背景设置</div>
                                            <div class="setting-desc">自定义聊天界面的背景图片</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showBubbleStyleSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">气泡样式设置</div>
                                            <div class="setting-desc">选择气泡外观样式和颜色</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="current-bubble-style">默认样式</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item single-chat-only">
                                        <div class="setting-left">
                                            <div class="setting-label">显示角色状态</div>
                                            <div class="setting-desc">在聊天界面显示角色的在线状态和活动</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="character-status-enabled">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>

                                    <!-- 🔥【新增】状态更新频率设置 -->
                                    <div class="setting-item single-chat-only" id="status-frequency-setting" style="display: none;">
                                        <div class="setting-left">
                                            <div class="setting-label">状态更新频率</div>
                                            <div class="setting-desc">控制角色状态的检查和更新频率</div>
                                        </div>
                                        <div class="setting-right">
                                            <select class="setting-select" id="status-update-frequency">
                                                <option value="high">高频 (30秒)</option>
                                                <option value="medium-high">中高频 (1分钟)</option>
                                                <option value="medium">中频 (3分钟)</option>
                                                <option value="medium-low">中低频 (5分钟)</option>
                                                <option value="low">低频 (10分钟)</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 戳一戳功能设置 - 单聊特有 -->
                            <div class="settings-section" id="poke-settings-section">
                                <div class="section-header">
                                    <i class="fas fa-hand-paper section-icon"></i>
                                    <span class="section-title">戳一戳功能</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item" id="poke-suffix-settings" onclick="showPokeSuffixSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">戳一戳后缀设置</div>
                                            <div class="setting-desc">自定义双方的戳一戳动作后缀</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 记忆设置 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-brain section-icon"></i>
                                    <span class="section-title">记忆设置</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item" onclick="showHistorySettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">附带历史消息数</div>
                                            <div class="setting-desc">自定义角色回复时参考的历史对话数量</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="current-history-count">5回合</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>

                                    <div class="setting-item" onclick="showGlobalMemorySettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">全局记忆系统</div>
                                            <div class="setting-desc">智能记忆管理，让角色记住重要的聊天内容</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="global-memory-status">7天记忆</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item single-chat-only" onclick="showMemoryShareSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">与群聊共享记忆</div>
                                            <div class="setting-desc">让角色在单聊中记住群聊的内容</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="memory-share-status">已关闭</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showWorldbookMountSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">挂载世界书</div>
                                            <div class="setting-desc">让角色参考选定的世界书内容作为背景知识</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="current-worldbook-mount">未挂载</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showEmojiLibraryMountSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">挂载表情包库</div>
                                            <div class="setting-desc">选择在此聊天中可使用的表情包库</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="current-emoji-library-mount">未挂载</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 时间感知设置 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-clock section-icon"></i>
                                    <span class="section-title">时间感知</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">时间感知开关</div>
                                            <div class="setting-desc">角色会感知当前时间并调整回复</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="time-awareness-enabled">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 通话设置 - 仅在单聊时显示 -->
                            <div class="settings-section single-chat-only">
                                <div class="section-header">
                                    <i class="fas fa-phone section-icon"></i>
                                    <span class="section-title">通话设置</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">角色主动拨打电话</div>
                                            <div class="setting-desc">允许角色根据对话内容主动发起通话</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="ai-call-enabled" class="ai-call-enabled-checkbox">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                    <!-- 🔥【新增】通话形象设置 - 仅在单聊时显示 -->
                                    <div class="setting-item single-chat-only" id="video-avatar-setting" style="display: none;" onclick="showVideoAvatarModal()">
                                        <div class="setting-left">
                                            <div class="setting-label">通话形象设置</div>
                                            <div class="setting-desc">设置双方视频通话时使用的形象</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- AI心率监测 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-heartbeat section-icon"></i>
                                    <span class="section-title">角色心率监测</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">心率监测显示</div>
                                            <div class="setting-desc">在状态栏显示角色的情感心率</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="ai-heartrate-enabled">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>





                            <!-- 后台互动设置 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-robot section-icon"></i>
                                    <span class="section-title">后台互动</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">后台互动开关</div>
                                            <div class="setting-desc">角色可在后台主动活动并发送推送</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="background-interaction-enabled">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                    <div class="background-interaction-details hide" id="background-interaction-settings">
                                        <div class="setting-item">
                                        <div class="setting-left">
                                                <div class="setting-label">主动聊天</div>
                                                <div class="setting-desc">角色在你10分钟未回复时主动发消息</div>
                                        </div>
                                        <div class="setting-right">
                                                <label class="toggle-switch">
                                                    <input type="checkbox" id="background-chat-enabled">
                                                    <span class="toggle-slider"></span>
                                                </label>
                                        </div>
                                    </div>

                                        <div class="setting-item" id="chat-frequency-setting" style="display: none;">
                                        <div class="setting-left">
                                                <div class="setting-label">主动聊天频率</div>
                                                <div class="setting-desc">角色主动发起对话的频率</div>
                                        </div>
                                        <div class="setting-right">
                                                <select id="background-chat-frequency" class="setting-select">
                                                    <option value="low">低 (1-2小时/次)</option>
                                                    <option value="medium">中 (30-60分钟/次)</option>
                                                    <option value="high">高 (10-30分钟/次)</option>
                                                </select>
                                </div>
                            </div>

                                    <div class="setting-item">
                                        <div class="setting-left">
                                                <div class="setting-label">主动发动态</div>
                                                <div class="setting-desc">角色根据人设主动发布动态</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                    <input type="checkbox" id="background-moments-enabled">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>

                                        <div class="setting-item" id="moments-frequency-setting" style="display: none; justify-content: space-between !important; align-items: center !important;">
                                            <div class="setting-left" style="flex: 1 !important;">
                                                <div class="setting-label">主动发动态频率</div>
                                                <div class="setting-desc">角色主动发布社交动态的频率</div>
                                            </div>
                                            <div class="setting-right" style="display: flex !important; align-items: center !important; flex-shrink: 0 !important;">
                                                <select id="background-moments-frequency" class="setting-select">
                                                    <option value="low">低 (4-8小时/次)</option>
                                                    <option value="medium">中 (2-4小时/次)</option>
                                                    <option value="high">高 (1-2小时/次)</option>
                                                </select>
                                            </div>
                                        </div>

                                        <div class="setting-item" id="scheduled-moments-setting" style="display: none; justify-content: space-between !important; align-items: center !important;">
                                            <div class="setting-left" style="flex: 1 !important;">
                                                <div class="setting-label">定时发布动态</div>
                                                <div class="setting-desc">设置固定时间点自动发布动态</div>
                                            </div>
                                            <div class="setting-right" style="display: flex !important; align-items: center !important; gap: 8px !important; flex-shrink: 0 !important;">
                                                <button onclick="showScheduleTimesModal()" style="background-color: #4a84c1; color: white; border: none; padding: 6px 12px; border-radius: 15px; font-size: 12px;">
                                                    <span id="schedule-times-display">未设置</span>
                                                </button>
                                                <label class="toggle-switch">
                                                    <input type="checkbox" id="scheduled-moments-enabled">
                                                    <span class="toggle-slider"></span>
                                                </label>
                                            </div>
                                        </div>

                                        <div class="setting-item" id="test-publish-setting" style="display: none; justify-content: space-between !important; align-items: center !important;">
                                            <div class="setting-left" style="flex: 1 !important;">
                                                <div class="setting-label">测试发布</div>
                                                <div class="setting-desc">让角色立即发布一条测试动态</div>
                                            </div>
                                            <div class="setting-right" style="display: flex !important; align-items: center !important; flex-shrink: 0 !important; gap: 8px;">
                                                <button onclick="testPublishMoment()" style="background-color: #4a84c1; color: white; border: none; padding: 6px 12px; border-radius: 15px; font-size: 12px;">
                                                    发布
                                                </button>
                                                <button onclick="fixAvatarData()" style="background-color: #ff6b6b; color: white; border: none; padding: 6px 12px; border-radius: 15px; font-size: 12px;">
                                                    修复头像
                                                </button>
                                            </div>
                                        </div>

                                        <!-- 🔥【新增】后台写日记设置 -->
                                        <div class="setting-item">
                                            <div class="setting-left">
                                                <div class="setting-label">后台写日记</div>
                                                <div class="setting-desc">角色可在指定时间自动写日记</div>
                                            </div>
                                            <div class="setting-right">
                                                <label class="toggle-switch">
                                                    <input type="checkbox" id="background-diary-enabled">
                                                    <span class="toggle-slider"></span>
                                                </label>
                                            </div>
                                        </div>

                                        <div class="setting-item" id="diary-time-setting" style="display: none; justify-content: space-between !important; align-items: flex-start !important;">
                                            <div class="setting-left" style="flex: 1 !important;">
                                                <div class="setting-label">写日记时间</div>
                                                <div class="setting-desc">设置角色每天写日记的时间点（支持±5分钟波动）</div>
                                            </div>
                                            <div class="setting-right" style="display: flex !important; flex-direction: column !important; align-items: flex-end !important; gap: 8px !important; flex-shrink: 0 !important;">
                                                <input type="time" id="diary-time-input" style="padding: 6px 8px; border: 1px solid #ddd; border-radius: 8px; font-size: 12px;">
                                                <button onclick="saveDiaryTime()" style="background-color: #4a84c1; color: white; border: none; padding: 6px 12px; border-radius: 15px; font-size: 12px;">
                                                    保存时间
                                                </button>
                                            </div>
                                        </div>

                                    </div>
                                </div>
                            </div>

                            <!-- 其他设置 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-cog section-icon"></i>
                                    <span class="section-title">其他设置</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">显示时间戳</div>
                                            <div class="setting-desc">在聊天消息中显示时间信息</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="timestamp-enabled" checked>
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showTimestampSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">时间戳设置</div>
                                            <div class="setting-desc">设置时间戳显示位置和格式</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="searchChatContent()">
                                        <div class="setting-left">
                                            <div class="setting-label">查找聊天内容</div>
                                            <div class="setting-desc">搜索历史消息中的关键词</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showExportOptions()">
                                        <div class="setting-left">
                                            <div class="setting-label">导出聊天记录</div>
                                            <div class="setting-desc">导出当前角色的完整数据</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showImportOptions()">
                                        <div class="setting-left">
                                            <div class="setting-label">导入聊天记录</div>
                                            <div class="setting-desc">导入角色的完整数据</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>

                                </div>
                            </div>

                            <!-- 🔥【新增】角色专属音效设置 -->
                            <div class="settings-section" id="character-sound-settings" style="display: none;">
                                <div class="section-header">
                                    <i class="fas fa-volume-up section-icon"></i>
                                    <span class="section-title">专属音效</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">启用专属音效</div>
                                            <div class="setting-desc">为该角色设置独特的音效</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="character-sound-enabled" onchange="toggleCharacterSounds()">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>

                                    <div id="character-sound-list" style="display: none;">
                                        <!-- 接收消息音效 -->
                                        <div class="character-sound-item">
                                            <div class="character-sound-header">
                                                <h4>接收消息音效</h4>
                                                <p>该角色发消息时播放的音效</p>
                                            </div>
                                            <div class="character-sound-controls">
                                                <input type="url" class="sound-url-input" id="character-messageReceived-url" placeholder="输入音效链接">
                                                <input type="file" id="character-messageReceived-file" accept="audio/*,.mp3,.m4a,.wav,.aac,.ogg,.flac" style="display: none;" onchange="handleCharacterSoundFileUpload(this, 'messageReceived')">
                                                <button onclick="document.getElementById('character-messageReceived-file').click()" class="sound-file-btn">
                                                    <i class="fas fa-upload"></i> 本地文件
                                                </button>
                                                <button onclick="testCharacterSound('messageReceived')" class="sound-test-btn">
                                                    <i class="fas fa-play"></i> 试听
                                                </button>
                                                <button onclick="clearCharacterSound('messageReceived')" class="sound-clear-btn">
                                                    <i class="fas fa-trash"></i> 清除
                                                </button>
                                            </div>
                                        </div>

                                        <!-- 来电音效 -->
                                        <div class="character-sound-item">
                                            <div class="character-sound-header">
                                                <h4>来电音效</h4>
                                                <p>该角色拨打语音/视频通话时播放的音效</p>
                                            </div>
                                            <div class="character-sound-controls">
                                                <input type="url" class="sound-url-input" id="character-incomingCall-url" placeholder="输入音效链接">
                                                <input type="file" id="character-incomingCall-file" accept="audio/*,.mp3,.m4a,.wav,.aac,.ogg,.flac" style="display: none;" onchange="handleCharacterSoundFileUpload(this, 'incomingCall')">
                                                <button onclick="document.getElementById('character-incomingCall-file').click()" class="sound-file-btn">
                                                    <i class="fas fa-upload"></i> 本地文件
                                                </button>
                                                <button onclick="testCharacterSound('incomingCall')" class="sound-test-btn">
                                                    <i class="fas fa-play"></i> 试听
                                                </button>
                                                <button onclick="clearCharacterSound('incomingCall')" class="sound-clear-btn">
                                                    <i class="fas fa-trash"></i> 清除
                                                </button>
                                            </div>
                                        </div>

                                        <!-- 推送通知音效 -->
                                        <div class="character-sound-item">
                                            <div class="character-sound-header">
                                                <h4>推送通知音效</h4>
                                                <p>收到该角色推送通知时播放的音效</p>
                                            </div>
                                            <div class="character-sound-controls">
                                                <input type="url" class="sound-url-input" id="character-notification-url" placeholder="输入音效链接">
                                                <input type="file" id="character-notification-file" accept="audio/*,.mp3,.m4a,.wav,.aac,.ogg,.flac" style="display: none;" onchange="handleCharacterSoundFileUpload(this, 'notification')">
                                                <button onclick="document.getElementById('character-notification-file').click()" class="sound-file-btn">
                                                    <i class="fas fa-upload"></i> 本地文件
                                                </button>
                                                <button onclick="testCharacterSound('notification')" class="sound-test-btn">
                                                    <i class="fas fa-play"></i> 试听
                                                </button>
                                                <button onclick="clearCharacterSound('notification')" class="sound-clear-btn">
                                                    <i class="fas fa-trash"></i> 清除
                                                </button>
                                            </div>
                                        </div>

                                        <!-- 静音选项 -->
                                        <div class="setting-item">
                                            <div class="setting-left">
                                                <div class="setting-label">静音模式</div>
                                                <div class="setting-desc">该角色的所有音效都静音</div>
                                            </div>
                                            <div class="setting-right">
                                                <label class="toggle-switch">
                                                    <input type="checkbox" id="character-silent-mode" onchange="toggleCharacterSilentMode()">
                                                    <span class="toggle-slider"></span>
                                                </label>
                                            </div>
                                        </div>

                                        <div class="character-sound-note">
                                            <p><i class="fas fa-info-circle"></i> <strong>音效优先级：</strong>静音模式 > 专属音效 > 全局音效</p>
                                            <p><i class="fas fa-info-circle"></i> 支持在线链接和本地文件（最大3MB）</p>
                                            <p><i class="fas fa-info-circle"></i> 支持常见音频格式：MP3、WAV、OGG等</p>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 危险操作 -->
                            <div class="settings-section">
                                <div class="section-header">
                                                    <i class="fas fa-exclamation-triangle section-icon danger-section-icon"></i>
                <span class="section-title danger-section-title">危险操作</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item" onclick="showBlacklistSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label" id="block-manage-label">拉黑管理</div>
                                            <div class="setting-desc" id="block-manage-desc">拉黑/解除拉黑管理</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="clearChatHistory()">
                                        <div class="setting-left">
                                            <div class="setting-label">清空聊天记录</div>
                                            <div class="setting-desc">删除所有历史消息，不可恢复</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                </div>
                            </div>

                        </div>
                    </div>
                </div>

                <!-- 人物编辑表单 -->
                <div id="character-form-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-status-right">
                            <div class="app-signal-icon signal-icon">
                                <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideCharacterForm()">‹</button>
                        <div class="app-title" id="character-form-title">新建人物</div>
                    </div>
                    <div class="app-content">
                        <div class="character-form">
                            <div class="form-group avatar-upload">
                                <label class="form-label">头像</label>
                                <div class="avatar-preview" id="avatar-preview">
                                    <div class="avatar-preview-text" id="avatar-preview-text">A</div>
                                </div>
                                <button class="upload-button" onclick="handleAvatarUploadClick()">上传头像</button>
                            </div>

                            <div class="form-group">
                                <label class="form-label">姓名</label>
                                <input type="text" class="form-input" id="character-name" placeholder="输入姓名">
                            </div>
                            <div class="form-group">
                                <label class="form-label">人设</label>
                                <textarea class="form-textarea" id="character-bio" placeholder="输入人物设定"></textarea>
                            </div>
                            <div class="form-actions form-actions-flex">
                                <button class="form-submit form-submit-flex">保存</button>
                                <button class="form-delete form-delete-red" id="character-delete-btn" onclick="deleteCurrentCharacter()">删除</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 🔥【新建人物界面文件输入框】放在界面外面，避免在某些设备上显示 -->
                <input type="file" id="avatar-upload" accept="image/*" style="display: none;">
                <input type="file" id="character-card-upload" accept=".png,.json" style="display: none;">

                <!-- 面具创建表单 -->
                <div id="persona-form-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-status-right">
                            <div class="app-signal-icon signal-icon">
                                <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hidePersonaForm()">‹</button>
                        <div class="app-title" id="persona-form-title">新建面具</div>
                    </div>
                    <div class="app-content">
                        <div class="character-form">
                            <div class="form-group avatar-upload">
                                <label class="form-label">头像</label>
                                <div class="avatar-preview" id="persona-avatar-preview">
                                    <div class="avatar-preview-text" id="persona-avatar-preview-text">我</div>
                                </div>
                                <button class="upload-button" onclick="handlePersonaAvatarUploadClick()">上传头像</button>
                            </div>

                            <div class="form-group">
                                <label class="form-label">我的名称</label>
                                <input type="text" class="form-input" id="persona-name" placeholder="例如：user小明、user学生、user工作者">
                            </div>

                            <div class="form-group">
                                <label class="form-label">我的描述</label>
                                <textarea class="form-textarea" id="persona-description" placeholder="描述这个身份的特点，包括性格、说话风格、使用场合等..."></textarea>
                            </div>

                            <button class="form-submit" onclick="savePersona()">保存面具</button>
                        </div>
                    </div>
                </div>

                <!-- 🔥【新建面具界面文件输入框】放在界面外面，避免在某些设备上显示 -->
                <input type="file" id="persona-avatar-upload" accept="image/*" style="display: none;">

                <!-- 表情包库上传文件输入框 -->
                <input type="file" id="emoji-library-upload" accept="image/*" multiple style="display: none;">

                <!-- 表情包库管理界面 -->
                <div id="emoji-library-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-status-right">
                            <div class="app-signal-icon signal-icon">
                                <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideEmojiLibraryScreen()">‹</button>
                        <div class="app-title" id="emoji-library-title">表情包库</div>
                        <div class="emoji-library-delete-btn" onclick="startEmojiSelection()" title="批量删除表情包" id="start-selection-btn">
                            <i class="fas fa-trash"></i>
                        </div>
                        <div class="emoji-selection-buttons" id="selection-buttons" style="display: none;">
                            <button onclick="selectAllEmojis()" title="全选">全选</button>
                            <button onclick="deleteSelectedEmojis()" title="删除选中">删除</button>
                            <button onclick="cancelSelection()" title="取消">取消</button>
                        </div>
                    </div>
                    <div class="app-content emoji-library-content-area">
                        <!-- 上传区域 -->
                        <div class="emoji-library-upload-area-small" id="emoji-library-upload-area" onclick="triggerEmojiUpload()">
                            <i class="fas fa-cloud-upload-alt" style="font-size: 20px; color: #6B9BD2; margin-bottom: 5px;"></i>
                            <p style="margin: 0; font-size: 14px; color: #333;">点击或拖拽上传表情包</p>
                            <p style="margin: 2px 0 0 0; font-size: 11px; color: #666;">支持 JPG、PNG、GIF 格式</p>
                        </div>

                        <!-- 表情包库统计信息 -->
                        <div class="emoji-library-stats" id="emoji-library-stats" style="display: none;">
                            <div class="stats-item">
                                <span class="stats-label">总数：</span>
                                <span class="stats-value" id="total-emojis">0</span>
                            </div>
                            <div class="stats-item">
                                <span class="stats-label">已设置描述：</span>
                                <span class="stats-value" id="described-emojis">0</span>
                            </div>
                            <div class="stats-item warning" id="undescribed-warning" style="display: none;">
                                <span class="stats-label">⚠️ 未设置描述：</span>
                                <span class="stats-value" id="undescribed-emojis">0</span>
                            </div>
                        </div>

                        <div class="emoji-library-grid" id="emoji-library-grid">
                            <!-- 表情包网格将通过JS动态生成 -->
                        </div>

                        <div class="emoji-library-empty" id="emoji-library-empty" style="display: none;">
                            <i class="fas fa-smile"></i>
                            <p>这个表情包库还是空的</p>
                            <p>点击上方区域上传表情包</p>
                        </div>
                    </div>
                </div>

                <!-- 表情包库创建/编辑表单 -->
                <div id="emoji-library-form-modal" class="modal-overlay" style="display: none;" onclick="hideEmojiLibraryForm(event)">
                    <div class="modal-content emoji-library-form-modal" onclick="event.stopPropagation()">
                        <div class="modal-header">
                            <h3 id="emoji-library-form-title">新建表情包库</h3>
                            <button class="modal-close-btn" onclick="hideEmojiLibraryForm()">×</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">库名称</label>
                                <input type="text" class="form-input" id="emoji-library-name-input" placeholder="例如：可爱动物、搞笑表情、日常聊天">
                            </div>
                            <div class="form-group">
                                <label class="form-label">描述（可选）</label>
                                <textarea class="form-textarea" id="emoji-library-description-input" placeholder="描述这个表情包库的用途和特点..." rows="3"></textarea>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-btn cancel-btn" onclick="hideEmojiLibraryForm()">取消</button>
                            <button class="modal-btn confirm-btn" onclick="saveEmojiLibrary()">保存</button>
                        </div>
                    </div>
                </div>

                <!-- API聊天界面 -->
                <div id="api-chat-screen" class="app-screen">
                    <div class="app-top-container">
                        <div class="app-status-bar">
                            <div class="app-status-time"></div>
                            <div id="ai-heartrate-display" style="display: none;">♥️ 72 bpm</div>
                            <div class="app-status-right">
                                <div class="app-signal-icon signal-icon">
                                    <div class="signal-row">
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                    </div>
                                </div>
                                <div class="app-battery-container">
                                    <div class="app-battery-icon">
                                        <div class="app-battery-level"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="header">
                        <div class="default-controls">
                            <button class="back-btn" onclick="backToChatApp().catch(e => console.error('返回聊天应用失败:', e))">‹</button>
                            <span class="header-title" id="api-chat-title">角色聊天</span>
                            <div class="header-actions">
                                <span class="action-btn" onclick="toggleOfflineMode()" id="offline-mode-btn" title="切换线下剧情模式">
                                    <i class="fas fa-door-open" id="offline-mode-icon"></i>
                                </span>
                                <span class="action-btn" onclick="showChatSettings()">
                                <i class="fas fa-ellipsis-v"></i>
                                </span>
                            </div>
                        </div>
                        <div class="selection-controls">
                            <span id="selection-cancel-btn">取消</span>
                            <span id="selection-count"></span>
                            <span id="selection-delete-btn">删除</span>
                        </div>
                        <span id="selection-forward-btn" onclick="showForwardTargetModal()" title="转发">
                            <i class="fas fa-share"></i>
                        </span>
                        </div>
                    </div>
                    <div class="app-content padding-none-flex">

                        <div class="chat-dialog">
                            <div class="chat-messages" id="api-chat-messages">
                                <!-- 聊天消息将通过JS动态生成 -->
                            </div>


                            <div class="chat-input-area">
                                <!-- 展开的工具面板 -->
                                <div class="tools-panel" id="tools-panel" style="display: none;">
                                    <div class="tools-grid">
                                        <div class="tool-item" id="regenerate-tool-item" onclick="regenerateLastResponse(); hideToolsPanel();" style="display: none;">
                                            <div class="tool-icon">
                                        <i class="fas fa-redo-alt"></i>
                                            </div>
                                            <span class="tool-label">重回</span>
                                        </div>
                                        <div class="tool-item" onclick="handleVoiceRecording(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-microphone"></i>
                                            </div>
                                            <span class="tool-label">语音</span>
                                        </div>
                                        <div class="tool-item" onclick="showCustomEmojiPanel(); hideToolsPanel();">
                                            <div class="tool-icon">
                                                <i class="fas fa-smile"></i>
                                            </div>
                                            <span class="tool-label">表情</span>
                                        </div>
                                        <div class="tool-item" onclick="openCamera(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-camera"></i>
                                            </div>
                                            <span class="tool-label">拍照</span>
                                        </div>
                                        <div class="tool-item" onclick="uploadImage(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-image"></i>
                                            </div>
                                            <span class="tool-label">图片</span>
                                        </div>
                                        <div class="tool-item" onclick="openTransfer(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-exchange-alt"></i>
                                            </div>
                                            <span class="tool-label">转账</span>
                                        </div>
                                        <div class="tool-item single-chat-only" onclick="makeCall(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-phone"></i>
                                            </div>
                                            <span class="tool-label">电话</span>
                                        </div>
                                        <div class="tool-item single-chat-only" onclick="openVideoCall(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-video"></i>
                                            </div>
                                            <span class="tool-label">视频</span>
                                        </div>
                                        <div class="tool-item" onclick="shareLocation(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-map-marker-alt"></i>
                                            </div>
                                            <span class="tool-label">位置</span>
                                        </div>
                                        <div class="tool-item diary-tool" onclick="showDiaryMenu(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-book"></i>
                                            </div>
                                            <span class="tool-label">日记</span>
                                        </div>
                                        <div class="tool-item game-tool single-chat-only" onclick="showGameMenu(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-gamepad"></i>
                                            </div>
                                            <span class="tool-label">游戏</span>
                                        </div>
                                        <div class="tool-item" onclick="openMusicPlayer(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-headphones"></i>
                                            </div>
                                            <span class="tool-label">听歌</span>
                                        </div>
                                        <div class="tool-item single-chat-only" onclick="openShoppingScreen(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-shopping-cart"></i>
                                            </div>
                                            <span class="tool-label">购物</span>
                                        </div>
                                        <div class="tool-item single-chat-only" onclick="showCharacterFootprints(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-map-marked-alt"></i>
                                            </div>
                                            <span class="tool-label">足迹</span>
                                        </div>
                                        <div class="tool-item single-chat-only" onclick="showCharacterPhone(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-mobile-alt"></i>
                                            </div>
                                            <span class="tool-label">查看</span>
                                        </div>

                                    </div>
                                </div>

                                <!-- 输入区域 -->
                                <div class="input-controls">
                                <button class="chat-action-btn toggle-tools-btn" onclick="toggleToolsPanel()" title="功能菜单" id="toggle-tools-btn">
                                    <i class="fas fa-plus"></i>
                                </button>
                                <div style="position: relative; flex: 1; min-width: 0;">
                                    <textarea class="chat-input" id="api-chat-input" rows="1" placeholder="输入消息..."></textarea>
                                    <!-- @群成员下拉选择框 -->
                                    <div class="mention-dropdown" id="mention-dropdown">
                                        <!-- 动态生成群成员列表 -->
                                    </div>
                                </div>
                                    <button class="chat-action-btn" onclick="triggerSmartReply()" title="获取AI回复">
                                        <i class="fas fa-comment-dots"></i>
                                </button>
                                <button class="send-button" onclick="sendApiMessage()">
                                    发送
                                </button>
                                </div>
                            </div>
                        </div>

                        <!-- 自定义表情包面板 -->
                        <div class="custom-emoji-panel" id="custom-emoji-panel">
                            <div class="emoji-tabs">
                                <div class="emoji-tab active" data-tab="recent">最近</div>
                                <div class="emoji-tab" data-tab="custom">全部</div>
                            </div>
                            <div class="emoji-content">
                                <div class="emoji-grid" id="emoji-grid">
                                    <!-- 表情包网格将通过JS动态生成 -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 线下剧情模式覆盖层 -->
                    <div id="offline-mode-overlay" class="offline-mode-overlay" style="display: none;">
                        <div class="offline-status-bar">
                            <div class="app-status-time"></div>
                            <div class="app-status-right">
                                <div class="app-signal-icon signal-icon">
                                    <div class="signal-row">
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                    </div>
                                </div>
                                <div class="app-battery-container">
                                    <div class="app-battery-icon">
                                        <div class="app-battery-level"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="offline-mode-header">
                            <button class="back-btn" onclick="exitOfflineMode()">‹</button>
                            <span class="header-title" id="offline-mode-title">线下剧情模式</span>
                            <div class="header-actions">
                                <span class="action-btn" onclick="showOfflineHistoryModal()" title="查看聊天记录">
                                    <i class="fas fa-history"></i>
                                </span>
                                <span class="action-btn" onclick="showOfflineUISettings()" title="界面设置">
                                    <i class="fas fa-cog"></i>
                                </span>
                                <span class="action-btn" onclick="showOfflinePresetSettings()" title="添加预设">
                                    <i class="fas fa-plus"></i>
                                </span>
                            </div>
                        </div>

                        <div class="offline-mode-content">
                            <div class="offline-chat-messages" id="offline-chat-messages">
                                <!-- 线下模式的聊天消息 -->
                            </div>

                            <div class="offline-input-area">
                                <div class="offline-input-container">
                                    <textarea id="offline-input" placeholder="在线下剧情模式中输入..." rows="3"></textarea>
                                    <div class="offline-button-group">
                                        <button class="offline-regenerate-btn" onclick="regenerateLastOfflineMessage()" title="重新生成AI回复">
                                            <i class="fas fa-redo-alt"></i>
                                        </button>
                                        <button class="offline-send-btn" onclick="sendOfflineMessage()">
                                            <i class="fas fa-paper-plane"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 🔥【聊天界面文件输入框】放在界面外面，避免在某些设备上显示 -->
                <input type="file" id="image-upload" accept="image/*" style="display: none;">
                <input type="file" id="emoji-upload" accept="image/*" style="display: none;" multiple>

                <!-- 个人表情包描述添加模态框 -->
                <div id="personal-emoji-description-modal" class="modal-overlay" style="display: none;" onclick="hidePersonalEmojiDescriptionModal(event)">
                    <div class="modal-content personal-emoji-description-modal" onclick="event.stopPropagation()">
                        <div class="modal-header">
                            <h3>添加表情包描述</h3>
                            <button class="modal-close-btn" onclick="hidePersonalEmojiDescriptionModal()">×</button>
                        </div>
                        <div class="modal-body">
                            <div class="emoji-preview-container">
                                <img id="personal-emoji-preview-image" src="" alt="表情包预览" style="max-width: 100px; max-height: 100px; border-radius: 8px; margin-bottom: 15px;">
                            </div>
                            <div class="form-group">
                                <label class="form-label">表情包描述</label>
                                <textarea class="form-textarea" id="personal-emoji-description-input" placeholder="请为这个表情包添加描述，帮助AI更好地理解表情包内容" rows="3"></textarea>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-btn cancel-btn" onclick="hidePersonalEmojiDescriptionModal()">取消</button>
                            <button class="modal-btn confirm-btn" onclick="confirmPersonalEmojiDescription()">确定</button>
                        </div>
                    </div>
                </div>

                <!-- 🔥【新增】角色足迹模态框 -->
                <div id="character-footprints-modal" class="modal-overlay" style="display: none;" onclick="hideCharacterFootprints(event)">
                    <div class="modal-content footprints-modal" onclick="event.stopPropagation()">
                        <div class="modal-header">
                            <div class="footprints-header-info">
                                <div class="footprints-character-avatar" id="footprints-character-avatar">
                                    <i class="fas fa-user"></i>
                                </div>
                                <div class="footprints-character-info">
                                    <h3 id="footprints-character-name">角色足迹</h3>
                                    <p class="footprints-subtitle">查看Ta的行为轨迹</p>
                                </div>
                            </div>
                            <div class="footprints-header-actions">
                                <button class="footprints-refresh-btn" onclick="refreshCharacterFootprints()" title="刷新足迹">
                                    <i class="fas fa-sync-alt"></i>
                                </button>
                                <button class="modal-close-btn" onclick="hideCharacterFootprints()">×</button>
                            </div>
                        </div>
                        <div class="modal-body footprints-body">
                            <div class="footprints-settings">
                                <div class="footprints-setting-item">
                                    <label>自动更新频率</label>
                                    <select id="footprints-update-frequency" onchange="updateFootprintsFrequency()">
                                        <option value="manual" selected>手动刷新</option>
                                        <option value="30">每30分钟</option>
                                        <option value="60">每小时</option>
                                        <option value="120">每2小时</option>
                                        <option value="180">每3小时</option>
                                    </select>
                                </div>
                            </div>
                            <div class="footprints-timeline" id="footprints-timeline">
                                <!-- 足迹时间线将通过JS动态生成 -->
                                <div class="footprints-empty-state">
                                    <i class="fas fa-map-marked-alt"></i>
                                    <p>暂无足迹记录</p>
                                    <p>点击刷新按钮获取最新足迹</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 浏览器界面 -->
                <div id="browser-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-status-right">
                            <div class="app-signal-icon signal-icon">
                                <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('browser-screen')">‹</button>
                        <div class="app-title">浏览器</div>
                    </div>
                    <div class="app-content padding-none-flex">
                        <div class="browser-toolbar">
                            <input type="text" class="browser-url-bar" id="browser-url" placeholder="输入网址">
                            <button onclick="loadUrl()">前往</button>
                        </div>
                        <iframe class="browser-content" id="browser-frame"></iframe>
                    </div>
                </div>



                <!-- 设置应用 -->
                <div id="settings-screen" class="app-screen">
                    <div class="app-top-container">
                        <div class="app-status-bar">
                            <div class="app-status-time"></div>
                            <div class="app-status-right">
                                <div class="app-signal-icon signal-icon">
                                    <div class="signal-row">
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                    </div>
                                </div>
                                <div class="app-battery-container">
                                    <div class="app-battery-icon">
                                        <div class="app-battery-level"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="app-header">
                            <button class="back-button" onclick="hideApp('settings-screen')">‹</button>
                            <div class="app-title">设置</div>
                        </div>
                    </div>
                    <div class="app-content">
                        <div class="settings-item" onclick="showApp('api-settings-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon wifi">
                                    <i class="fas fa-wifi"></i>
                                </div>
                                <div>API设置</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('theme-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon settings-icon-custom">
                                    <i class="fas fa-palette"></i>
                                </div>
                                <div>主题设置</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('wallpaper-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon wallpaper">
                                    <i class="fas fa-image"></i>
                                </div>
                                <div>壁纸设置</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('appearance-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon display">
                                    <i class="fas fa-mobile-alt"></i>
                                </div>
                                <div>外观设置</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('display-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon display">
                                    <i class="fas fa-font"></i>
                                </div>
                                <div>字体与字号</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('sound-settings-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon sound">
                                    <i class="fas fa-volume-up"></i>
                                </div>
                                <div>音效设置</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('data-management-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon data-management">
                                    <i class="fas fa-database"></i>
                                </div>
                                <div>数据管理</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('emergency-recovery-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon" style="background: #ff4444; color: white;">
                                    <i class="fas fa-life-ring"></i>
                                </div>
                                <div>紧急恢复</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('about-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon about">
                                    <i class="fas fa-info-circle"></i>
                                </div>
                                <div>免责声明</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                    </div>
                </div>



                <!-- 数据管理 -->
                <div id="data-management-screen" class="app-screen">
                    <div class="app-top-container">
                        <div class="app-status-bar">
                            <div class="app-status-time"></div>
                            <div class="app-status-right">
                                <div class="app-signal-icon signal-icon">
                                    <div class="signal-row">
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                    </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                        <div class="app-header">
                            <button class="back-button" onclick="backToSettings('data-management-screen')">‹</button>
                            <div class="app-title">数据管理</div>
                        </div>
                    </div>
                    <div class="app-content">
                        <!-- 存储空间使用情况 -->
                        <div class="data-section">
                            <div class="data-section-title">存储空间使用情况</div>
                            <div class="storage-usage" id="storage-usage">
                                <div class="storage-item">
                                    <div class="storage-label">聊天记录</div>
                                    <div class="storage-size" id="chat-storage-size">计算中...</div>
                                </div>
                                <div class="storage-item">
                                    <div class="storage-label">角色数据</div>
                                    <div class="storage-size" id="character-storage-size">计算中...</div>
                                </div>
                                <div class="storage-item">
                                    <div class="storage-label">聊天设置</div>
                                    <div class="storage-size" id="settings-storage-size">计算中...</div>
                                </div>
                                <div class="storage-item">
                                    <div class="storage-label">表情包</div>
                                    <div class="storage-size" id="emoji-storage-size">计算中...</div>
                                </div>
                                <div class="storage-total">
                                    <div class="storage-label">总计</div>
                                    <div class="storage-size" id="total-storage-size">计算中...</div>
                                </div>
                            </div>
                        </div>

                        <!-- 数据导入导出 -->
                        <div class="data-section">
                            <div class="data-section-title">数据备份与恢复</div>
                            <div class="settings-item" onclick="exportAllData()">
                                <div class="settings-item-left">
                                    <div class="settings-icon export">
                                        <i class="fas fa-download"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">导出所有数据</div>
                                        <div class="setting-desc">导出所有记录为JSON文件</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="settings-item" onclick="exportLightweightData()">
                                <div class="settings-item-left">
                                    <div class="settings-icon export">
                                        <i class="fas fa-file-export"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">轻量级导出</div>
                                        <div class="setting-desc">导出核心数据，适合大数据量时使用</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="settings-item" onclick="importDataFromFile()">
                                <div class="settings-item-left">
                                    <div class="settings-icon import">
                                        <i class="fas fa-upload"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">导入数据</div>
                                        <div class="setting-desc">从JSON文件恢复聊天记录和设置</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>

                        <!-- 数据检查与修复 -->
                        <div class="data-section">
                            <div class="data-section-title">数据检查与修复</div>
                            <div class="settings-item" onclick="checkAndFixChatHistory()">
                                <div class="settings-item-left">
                                    <div class="settings-icon import">
                                        <i class="fas fa-search"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">检查聊天历史</div>
                                        <div class="setting-desc">检查并修复聊天记录数据，恢复丢失的消息</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>

                            <div class="settings-item" onclick="debugChatMessagesFormat()">
                                <div class="settings-item-left">
                                    <div class="settings-icon debug">
                                        <i class="fas fa-bug"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">调试聊天记录格式</div>
                                        <div class="setting-desc">分析聊天记录的数据格式，帮助诊断导入问题</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>

                            <div class="settings-item" onclick="debugGroupChatData()">
                                <div class="settings-item-left">
                                    <div class="settings-icon debug">
                                        <i class="fas fa-users"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">调试群聊数据</div>
                                        <div class="setting-desc">检查群聊数据的存储状态，诊断群聊显示问题</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>

                            <div class="settings-item" onclick="debugImportFunction()">
                                <div class="settings-item-left">
                                    <div class="settings-icon debug">
                                        <i class="fas fa-code"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">调试导入函数</div>
                                        <div class="setting-desc">检查当前使用的导入函数版本，诊断数据丢失问题</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>

                            <div class="settings-item" onclick="runDataIntegrityDiagnosis()">
                                <div class="settings-item-left">
                                    <div class="settings-icon debug">
                                        <i class="fas fa-stethoscope"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">🔍 数据完整性诊断</div>
                                        <div class="setting-desc">检查角色记忆是否错乱，诊断数据隔离问题</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>

                            <div class="settings-item" onclick="fixDataSyncIssues()">
                                <div class="settings-item-left">
                                    <div class="settings-icon import">
                                        <i class="fas fa-sync-alt"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">🔧 修复数据同步问题</div>
                                        <div class="setting-desc">修复数据库与内存不一致，解决角色记忆错乱</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>

                        <!-- 选择性清理 -->
                        <div class="data-section">
                            <div class="data-section-title">存储清理</div>
                            <div class="settings-item" onclick="cleanupOrphanedContacts()">
                                <div class="settings-item-left">
                                    <div class="settings-icon cleanup">
                                        <i class="fas fa-user-slash"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">清理孤立数据</div>
                                        <div class="setting-desc">清理不存在的角色数据和相关记录</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>

                            <div class="settings-item" onclick="showCleanupOptions()">
                                <div class="settings-item-left">
                                    <div class="settings-icon cleanup">
                                        <i class="fas fa-broom"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">选择性清理</div>
                                        <div class="setting-desc">清理特定类型的数据以释放空间</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="settings-item" onclick="compressAllImages()">
                                <div class="settings-item-left">
                                    <div class="settings-icon compress">
                                        <i class="fas fa-compress-arrows-alt"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">压缩图片</div>
                                        <div class="setting-desc">压缩所有头像和背景图片以节省空间</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>

                        <!-- 危险操作 -->
                        <div class="data-section danger-section">
                            <div class="data-section-title">危险操作</div>
                            <div class="settings-item danger-item" onclick="clearAllData()">
                                <div class="settings-item-left">
                                    <div class="settings-icon danger">
                                        <i class="fas fa-trash-alt"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">清空所有数据</div>
                                        <div class="setting-desc">删除所有数据，不可恢复！</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 🚨 紧急恢复界面 -->
                <div class="app-screen" id="emergency-recovery-screen">
                    <div class="app-top-container">
                        <div class="app-status-bar">
                            <div class="app-status-time"></div>
                            <div class="app-status-right">
                                <div class="app-signal-icon signal-icon">
                                    <div class="signal-row">
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                        <div class="app-header">
                            <button class="back-button" onclick="backToSettings('emergency-recovery-screen')">‹</button>
                            <div class="app-title" style="color: #ff4444;">🚨 紧急恢复</div>
                        </div>
                    </div>
                    <div class="app-content">
                        <div style="padding: 20px; color: #333;">
                            <!-- 警告卡片 - 毛玻璃风格 -->
                            <div style="background: linear-gradient(135deg, rgba(255, 68, 68, 0.15) 0%, rgba(255, 68, 68, 0.08) 100%); border: 2px solid rgba(255, 68, 68, 0.3); border-radius: 16px; padding: 20px; margin-bottom: 25px; backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); box-shadow: 0 8px 32px rgba(255, 68, 68, 0.1);">
                                <h3 style="color: #ff4444; margin: 0 0 12px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>⚠️</span> 数据丢失检测
                                </h3>
                                <p style="margin: 0; font-size: 15px; color: #666; line-height: 1.5;">如果您的角色突然消失，请使用以下功能恢复数据。</p>
                            </div>

                            <!-- 第一步 -->
                            <div class="recovery-section" style="background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 25px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08); border: 1px solid rgba(255, 255, 255, 0.2);">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>🔍</span> 第一步：检查数据状态
                                </h4>
                                <button onclick="checkDataStatus()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-bg, rgba(74, 132, 193, 0.9)); color: var(--theme-button-color, white); border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: var(--theme-button-shadow, 0 4px 15px rgba(74, 132, 193, 0.3)); transition: all 0.3s ease; margin-bottom: 15px;">
                                    检查当前数据状态
                                </button>
                                <div id="data-status-result" style="background: rgba(248, 249, 250, 0.9); border-radius: 12px; padding: 15px; margin-bottom: 20px; display: none; backdrop-filter: blur(10px); border: 1px solid rgba(0,0,0,0.05);">
                                    <pre id="data-status-text" style="font-size: 12px; margin: 0; white-space: pre-wrap; color: #333; font-family: 'SF Mono', Monaco, monospace;"></pre>
                                </div>
                            </div>

                            <!-- 第二步 -->
                            <div class="recovery-section" style="background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 25px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08); border: 1px solid rgba(255, 255, 255, 0.2);">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>🔍</span> 第二步：深度数据挖掘
                                </h4>
                                <p style="font-size: 14px; color: #666; margin-bottom: 15px; line-height: 1.5;">搜索浏览器中可能残留的角色数据：</p>
                                <div style="display: flex; flex-direction: column; gap: 12px;">
                                    <button onclick="deepDataSearch()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-bg, rgba(74, 132, 193, 0.9)); color: var(--theme-button-color, white); border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: var(--theme-button-shadow, 0 4px 15px rgba(74, 132, 193, 0.3)); transition: all 0.3s ease;">
                                        🔍 深度搜索残留数据
                                    </button>
                                    <button onclick="searchChatHistory()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-secondary-bg, rgba(255, 255, 255, 0.8)); color: var(--theme-button-secondary-color, #666); border: 2px solid var(--theme-button-secondary-border, rgba(0, 0, 0, 0.1)); border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); transition: all 0.3s ease;">
                                        💬 从聊天记录推断角色
                                    </button>
                                </div>
                                <div id="deep-search-result" style="background: rgba(248, 249, 250, 0.9); border-radius: 12px; padding: 15px; margin-top: 15px; display: none; backdrop-filter: blur(10px); border: 1px solid rgba(0,0,0,0.05);">
                                    <pre id="deep-search-text" style="font-size: 12px; margin: 0; white-space: pre-wrap; color: #333; font-family: 'SF Mono', Monaco, monospace;"></pre>
                                </div>
                            </div>

                            <!-- 第三步 -->
                            <div class="recovery-section" style="background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 25px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08); border: 1px solid rgba(255, 255, 255, 0.2);">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>📥</span> 第三步：文件导入恢复
                                </h4>
                                <p style="font-size: 14px; color: #666; margin-bottom: 15px; line-height: 1.5;">如果您有备份文件：</p>
                                <input type="file" id="recovery-file-input" accept=".json" style="width: 100%; padding: 12px 15px; border: 2px solid rgba(0, 0, 0, 0.08); border-radius: 12px; font-size: 16px; background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(10px); transition: all 0.3s ease; color: #333; box-sizing: border-box; margin-bottom: 15px;">
                                <button onclick="recoverFromFile()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-bg, rgba(74, 132, 193, 0.9)); color: var(--theme-button-color, white); border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: var(--theme-button-shadow, 0 4px 15px rgba(74, 132, 193, 0.3)); transition: all 0.3s ease;">
                                    从文件恢复数据
                                </button>
                            </div>

                            <!-- 第四步 -->
                            <div class="recovery-section" style="background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 25px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08); border: 1px solid rgba(255, 255, 255, 0.2);">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>🔧</span> 第四步：重建角色卡
                                </h4>
                                <p style="font-size: 14px; color: #666; margin-bottom: 15px; line-height: 1.5;">从聊天记录重建丢失的角色：</p>
                                <div style="display: flex; flex-direction: column; gap: 12px;">
                                    <button onclick="rebuildCharactersFromChat()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-bg, rgba(74, 132, 193, 0.9)); color: var(--theme-button-color, white); border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: var(--theme-button-shadow, 0 4px 15px rgba(74, 132, 193, 0.3)); transition: all 0.3s ease;">
                                        🔧 自动重建所有角色
                                    </button>
                                    <button onclick="showManualRebuild()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-secondary-bg, rgba(255, 255, 255, 0.8)); color: var(--theme-button-secondary-color, #666); border: 2px solid var(--theme-button-secondary-border, rgba(0, 0, 0, 0.1)); border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); transition: all 0.3s ease;">
                                        ✏️ 手动重建角色
                                    </button>
                                </div>
                            </div>

                            <!-- 调试工具 -->
                            <div class="recovery-section" style="background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 25px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08); border: 1px solid rgba(255, 255, 255, 0.2);">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>🔍</span> 调试：检查当前状态
                                </h4>
                                <div style="display: flex; flex-direction: column; gap: 12px;">
                                    <button onclick="debugCurrentState()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-secondary-bg, rgba(255, 255, 255, 0.8)); color: var(--theme-button-secondary-color, #666); border: 2px solid var(--theme-button-secondary-border, rgba(0, 0, 0, 0.1)); border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); transition: all 0.3s ease;">
                                        🔍 检查当前数据状态
                                    </button>
                                    <button onclick="forceRefreshAll()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-bg, rgba(74, 132, 193, 0.9)); color: var(--theme-button-color, white); border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: var(--theme-button-shadow, 0 4px 15px rgba(74, 132, 193, 0.3)); transition: all 0.3s ease;">
                                        🔄 强制刷新所有界面
                                    </button>
                                </div>
                            </div>

                            <!-- 第五步 -->
                            <div class="recovery-section" style="background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 25px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08); border: 1px solid rgba(255, 255, 255, 0.2);">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>🧹</span> 第五步：清理异常数据
                                </h4>
                                <div style="display: flex; flex-direction: column; gap: 12px;">
                                    <button onclick="cleanupBadData()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-secondary-bg, rgba(255, 255, 255, 0.8)); color: var(--theme-button-secondary-color, #666); border: 2px solid var(--theme-button-secondary-border, rgba(0, 0, 0, 0.1)); border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); transition: all 0.3s ease;">
                                        清除张三李四等异常角色
                                    </button>
                                    <button onclick="forceReload()" style="width: 100%; padding: 14px 20px; background: #FF3B30; color: white; border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: 0 4px 15px rgba(255, 59, 48, 0.3); transition: all 0.3s ease;">
                                        强制重新加载数据
                                    </button>
                                </div>
                            </div>

                            <!-- 恢复日志 -->
                            <div id="recovery-log" style="background: rgba(248, 249, 250, 0.9); border-radius: 16px; padding: 20px; margin-top: 20px; max-height: 200px; overflow-y: auto; display: none; backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border: 1px solid rgba(0,0,0,0.05); box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);">
                                <h5 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>📋</span> 恢复日志：
                                </h5>
                                <div id="recovery-log-content" style="font-size: 13px; font-family: 'SF Mono', Monaco, monospace; color: #555; line-height: 1.4;"></div>
                            </div>
                        </div>
                    </div>
                </div>

        <!-- 关于我们 -->
                <div id="about-screen" class="app-screen">
                    <div class="app-top-container">
                        <div class="app-status-bar">
                            <div class="app-status-time"></div>
                            <div class="app-status-right">
                                <div class="app-signal-icon signal-icon">
                                    <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                        <div class="app-header">
                            <button class="back-button" onclick="backToSettings('about-screen')">‹</button>
                            <div class="app-title">免责声明</div>
                        </div>
                    </div>
                    <div class="app-content" style="padding: 20px; text-align: left; color: #333; line-height: 1.8;">
                        <h2 style="text-align: center; margin-bottom: 20px;">免责声明</h2>
                        <p style="margin-bottom: 15px;">本应用（“EVE Chat”）仅供娱乐和信息分享，不构成任何专业建议（如医疗、法律、金融等）。</p>
                        <p style="margin-bottom: 15px;">本应用中的虚拟角色和对话内容均为AI生成，不代表任何真实人物、实体或组织的观点。</p>
                        <p style="margin-bottom: 15px;">用户生成和使用的所有Al角色设定、对话、图片等内容的责任由用户自行承担。</p>
                        <p style="margin-bottom: 15px;">用户在与其他用户互动时，应自行承担风险。开发者不对用户之间的任何行为负责。</p>
                        <p style="margin-bottom: 15px;">用户使用期间产生的数据皆为本地存储。</p>
                        <p style="margin-bottom: 15px;">请勿将本网页用于任何非法或侵犯他人权益的用途。开发者不对因使用本应用而产生的任何直接或间接后果负责。</p>
                        <p style="margin-bottom: 25px; font-weight: bold;">继续使用本应用即表示您已阅读、理解并同意本免责声明。</p>
                        <div class="disclaimer-footer" style="margin-top: 30px; border-top: 1px solid #eee; padding-top: 15px; color: #888; font-size: 14px;">
                            <p><strong>作者：</strong>EVE</p>
                            <p><strong>网页名：</strong>EVE Chat</p>
                            <p>禁止任何二传二改</p>
                            <p><strong>唯一获取途径QQ群：963263414</strong></p>
                            <hr style="margin: 15px 0; border: none; border-top: 1px solid #eee;">
                            <p>版本：1.0.0</p>
                            <p>最后更新：2025年8月23日</p>
                        </div>
                    </div>
                </div>

                <!-- 电话通话界面 -->
                <div id="phone-call-screen" class="app-screen">
                    <div class="call-background"></div>
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-status-right">
                            <div class="app-signal-icon signal-icon">
                                <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="call-content">
                        <div class="call-header">
                            <div class="call-avatar">
                                <img id="call-avatar-img" src="" alt="通话头像">
                            </div>
                            <div class="call-name" id="call-name">角色名称</div>
                            <div class="call-status" id="call-status">正在通话中...</div>
                            <div class="call-time" id="call-timer">00:00</div>
                        </div>

                        <div class="call-message-container" id="call-message-container">
                            <!-- 通话中的消息将在这里显示 -->
                        </div>

                        <div class="call-input-area">
                            <input type="text" id="call-input" placeholder="输入消息..." class="call-text-input" onkeypress="if(event.key === 'Enter') { event.preventDefault(); sendCallMessage(); }">
                            <button class="call-send-btn" onclick="sendCallMessage()">
                                <i class="fas fa-paper-plane"></i>
                            </button>
                        </div>

                        <div class="call-controls">
                            <button class="call-control-btn end-call-btn" onclick="endCall()">
                                <i class="fas fa-phone" style="transform: rotate(135deg);"></i>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- 来电显示界面 -->
                <div id="incoming-call-screen" class="app-screen">
                    <div class="call-background incoming"></div>
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-status-right">
                            <div class="app-signal-icon signal-icon">
                                <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="incoming-call-content">
                        <div class="call-header">
                            <div class="call-avatar large-avatar">
                                <img id="incoming-call-avatar" src="" alt="来电头像">
                            </div>
                            <div class="call-name" id="incoming-call-name">角色名称</div>
                            <div class="call-status">来电</div>
                            <div class="call-text" id="incoming-call-text">想和你通话...</div>
                        </div>

                        <div class="incoming-call-controls">
                            <button class="incoming-call-btn reject-btn" onclick="rejectCall()">
                                <div class="call-btn-icon">
                                    <i class="fas fa-phone" style="transform: rotate(135deg);"></i>
                                </div>
                                <div class="call-btn-text">拒绝</div>
                            </button>
                            <button class="incoming-call-btn accept-btn" onclick="acceptCall()">
                                <div class="call-btn-icon">
                                    <i class="fas fa-phone"></i>
                                </div>
                                <div class="call-btn-text">接听</div>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- 🔥【新增】视频来电显示界面 -->
                <div id="incoming-video-call-screen" class="app-screen">
                    <div class="video-call-background"></div>
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-status-right">
                            <div class="app-signal-icon signal-icon">
                                <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="incoming-call-content">
                        <div class="call-header">
                            <div class="call-avatar large-avatar">
                                <img id="incoming-video-call-avatar" src="" alt="视频来电头像">
                            </div>
                            <div class="call-name" id="incoming-video-call-name">角色名称</div>
                            <div class="call-status">视频来电</div>
                            <div class="call-text" id="incoming-video-call-text">想和你视频聊聊...</div>
                        </div>

                        <div class="incoming-call-controls">
                            <button class="incoming-call-btn reject-btn" onclick="rejectVideoCall()">
                                <div class="call-btn-icon">
                                    <i class="fas fa-phone" style="transform: rotate(135deg);"></i>
                                </div>
                                <div class="call-btn-text">拒绝</div>
                            </button>
                            <button class="incoming-call-btn accept-btn" onclick="acceptVideoCall()">
                                <div class="call-btn-icon">
                                    <i class="fas fa-video"></i>
                                </div>
                                <div class="call-btn-text">接听</div>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- 🔥【新增】视频通话界面 -->
                <div id="video-call-screen" class="app-screen">
                    <div class="video-call-background"></div>
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-status-right">
                            <div class="app-signal-icon signal-icon">
                                <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 主画面：角色通话形象 -->
                    <div class="video-call-main-view">
                        <img id="video-call-character-avatar" src="" alt="角色通话形象" class="character-video-avatar">

                        <!-- 右上角小窗口：用户通话形象 -->
                        <div class="video-call-user-window">
                            <img id="video-call-user-avatar" src="" alt="用户通话形象" class="user-video-avatar">
                        </div>

                        <!-- 通话信息覆盖层 -->
                        <div class="video-call-overlay">
                            <div class="video-call-info">
                                <div class="video-call-name" id="video-call-name">角色名称</div>
                                <div class="video-call-status" id="video-call-status">视频通话中...</div>
                                <div class="video-call-time" id="video-call-timer">00:00</div>
                            </div>
                        </div>


                    </div>

                    <!-- 消息浮现区域 -->
                    <div class="video-call-floating-messages" id="video-call-floating-messages">
                        <!-- 视频通话中的消息将以浮现气泡形式在这里显示 -->
                    </div>

                    <!-- 输入和控制区域 -->
                    <div class="video-call-bottom-area">
                        <div class="video-call-input-area">
                            <input type="text" id="video-call-input" placeholder="输入消息..." class="video-call-text-input" onkeypress="if(event.key === 'Enter') { event.preventDefault(); sendVideoCallMessage(); }">
                            <button class="video-call-send-btn" onclick="sendVideoCallMessage()">
                                <i class="fas fa-paper-plane"></i>
                            </button>
                        </div>

                        <div class="video-call-controls">
                            <button class="video-call-control-btn mute-btn" onclick="toggleVideoMute()" id="video-mute-btn">
                                <i class="fas fa-microphone"></i>
                            </button>
                            <button class="video-call-control-btn end-call-btn" onclick="endVideoCall()">
                                <i class="fas fa-phone" style="transform: rotate(135deg);"></i>
                            </button>
                            <button class="video-call-control-btn camera-btn" onclick="toggleVideoCamera()" id="video-camera-btn">
                                <i class="fas fa-video"></i>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- 字体与字号设置 -->
                <div id="display-screen" class="app-screen">
                    <div class="app-top-container">
                        <div class="app-status-bar">
                            <div class="app-status-time"></div>
                            <div class="app-status-right">
                                <div class="app-signal-icon signal-icon">
                                    <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                        <div class="app-header">
                            <button class="back-button" onclick="backToSettings('display-screen')">‹</button>
                            <div class="app-title">字体与字号</div>
                        </div>
                    </div>
                    <div class="app-content">
                        <div class="font-size-preview">
                            <div class="font-size-preview-text" id="font-size-preview">
                                这是一段示例文字，用于预览字体大小效果。调节下方滑块可以改变字体大小。
                            </div>
                        </div>

                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">字体与字号</div>
                                    <div class="setting-desc">选择字体文件并调节全局字体大小</div>
                                </div>
                            </div>
                        </div>

                        <div class="font-size-slider-container">
                            <div class="font-size-labels">
                                <span>小</span>
                                <span>标准</span>
                                <span>大</span>
                            </div>
                            <input type="range" class="font-size-slider" id="font-size-slider"
                                   min="12" max="20" step="1" value="15"
                                   onchange="changeFontSize(this.value)">
                            <div class="font-size-value">
                                当前字号：<span id="font-size-value">15px</span>
                            </div>
                        </div>

                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">字距设置</div>
                                    <div class="setting-desc">调节文字之间的间距</div>
                                </div>
                            </div>
                        </div>

                        <div class="font-size-slider-container">
                            <div class="font-size-labels">
                                <span>紧凑</span>
                                <span>标准</span>
                                <span>宽松</span>
                            </div>
                            <input type="range" class="font-size-slider" id="letter-spacing-slider"
                                   min="-0.5" max="2" step="0.1" value="0"
                                   onchange="changeLetterSpacing(this.value)">
                            <div class="font-size-value">
                                当前字距：<span id="letter-spacing-value">标准</span>
                            </div>
                        </div>

                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">自动缩放</div>
                                    <div class="setting-desc">根据屏幕尺寸自动调整字体大小</div>
                                </div>
                            </div>
                            <label class="settings-toggle">
                                <input type="checkbox" id="auto-scale-toggle" onchange="toggleAutoScale()">
                                <span class="settings-slider"></span>
                            </label>
                        </div>

                        <!-- 🔥【新增】自定义字体设置 -->
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">自定义字体</div>
                                    <div class="setting-desc">使用在线字体链接自定义全局字体</div>
                                </div>
                            </div>
                        </div>

                        <div class="custom-font-container">
                            <div class="form-group">
                                <label>字体链接</label>
                                <input type="url" id="global-font-url" placeholder="支持CSS链接或TTF/OTF/WOFF字体文件链接" class="form-input">
                                <div class="font-url-hint">
                                    <div>支持格式：</div>
                                    <div>• CSS链接：https://fontsapi.zeoseven.com/5/main/result.css</div>
                                    <div>• 字体文件：https://files.catbox.moe/fp15b6.ttf</div>
                                </div>
                            </div>

                            <div class="font-action-buttons">
                                <button type="button" class="font-button font-button-preview" onclick="previewGlobalFont()">
                                    <i class="fas fa-eye"></i> 预览字体
                                </button>
                                <button type="button" class="font-button font-button-apply" onclick="applyGlobalFont()">
                                    <i class="fas fa-check"></i> 应用字体
                                </button>
                                <button type="button" class="font-button font-button-reset" onclick="resetGlobalFont()">
                                    <i class="fas fa-undo"></i> 重置字体
                                </button>
                            </div>

                            <div id="global-font-status" class="font-status" style="display: none;">
                                <div class="font-status-text"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 屏幕尺寸设置 -->
                <div id="screen-size-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-status-right">
                            <div class="app-signal-icon signal-icon">
                                <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('screen-size-screen')">‹</button>
                        <div class="app-title">屏幕尺寸</div>
                    </div>
                    <div class="app-content">
                        <div class="size-option" onclick="changeScreenSize(350, 740, '适中尺寸')" id="size-350-740">
                            <div class="size-option-left">
                                <div class="size-name">适中尺寸</div>
                                <div class="size-desc">350×740 (推荐)</div>
                            </div>
                            <div class="size-preview">
                                <div class="size-preview-rect size-preview-rect-s"></div>
                            </div>
                            <i class="fas fa-check check-icon"></i>
                        </div>

                        <div class="size-option" onclick="changeScreenSize(425, 860, 'iPhone 15')">
                            <div class="size-option-left">
                                <div class="size-name">iPhone 15</div>
                                <div class="size-desc">425×860 (适配手机)</div>
                            </div>
                            <div class="size-preview">
                                <div class="size-preview-rect size-preview-rect-l"></div>
                            </div>
                        </div>

                        <div class="size-option" onclick="changeScreenSize(450, 950, 'iPhone 15 Plus')">
                            <div class="size-option-left">
                                <div class="size-name">iPhone 15 Plus</div>
                                <div class="size-desc">450×950 (大屏)</div>
                            </div>
                            <div class="size-preview">
                                <div class="size-preview-rect size-preview-rect-xl"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 外观设置 -->
                <div id="appearance-screen" class="app-screen">
                    <div class="app-top-container">
                        <div class="app-status-bar">
                            <div class="app-status-time"></div>
                            <div class="app-status-right">
                                <div class="app-signal-icon signal-icon">
                                    <div class="signal-row">
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                    </div>
                                </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                        <div class="app-header">
                            <button class="back-button" onclick="backToSettings('appearance-screen')">‹</button>
                            <div class="app-title">外观设置</div>
                        </div>
                    </div>
                    <div class="app-content">
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">全屏显示</div>
                                    <div class="setting-desc">自动适应浏览器屏幕，无边框全屏效果</div>
                                </div>
                            </div>
                            <label class="settings-toggle">
                                <input type="checkbox" id="phone-border-toggle" onchange="togglePhoneBorder()">
                                <span class="settings-slider"></span>
                            </label>
                        </div>
                        <div class="settings-item" onclick="showScreenSizeOptions()">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">屏幕尺寸</div>
                                    <div class="setting-desc" id="current-screen-size">当前：350×740 (适中尺寸)</div>
                                </div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <!-- 🔥【修改】主屏幕字体设置 - 改为下拉菜单 -->
                        <div class="settings-item" style="position: relative;">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">主屏幕字体</div>
                                    <div class="setting-desc">设置主屏幕字体及电池的颜色</div>
                                </div>
                            </div>
                            <div class="home-font-selector" onclick="toggleHomeFontDropdown()">
                                <span id="current-home-font-text">黑色</span>
                                <i class="fas fa-chevron-down" id="home-font-arrow"></i>
                            </div>

                            <!-- 🔥【新增】主屏幕字体下拉选择菜单 -->
                            <div id="home-font-dropdown" class="home-font-dropdown" style="display: none;">
                                <div class="home-font-option selected" onclick="selectHomeFont('black')">
                                    <i class="fas fa-check"></i>
                                    <span>黑色</span>
                                    <small>适合浅色壁纸</small>
                                </div>
                                <div class="home-font-option" onclick="selectHomeFont('white')">
                                    <i class="fas fa-check"></i>
                                    <span>白色</span>
                                    <small>适合深色壁纸</small>
                                </div>
                            </div>
                        </div>
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">状态栏图标</div>
                                    <div class="setting-desc">自定义时间右侧显示的图标或文字</div>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <input type="text" id="status-icon-input" placeholder="输入" maxlength="5"
                                       style="width: 50px; padding: 6px 8px; border: 1px solid var(--theme-input-border, rgba(0, 0, 0, 0.08));
                                              border-radius: var(--theme-input-radius, 15px); background: var(--theme-form-bg, rgba(255, 255, 255, 0.8));
                                              font-size: 14px; text-align: center;"
                                       onchange="updateStatusIcon()">
                                <button onclick="resetStatusIcon()"
                                        style="padding: 6px 10px; background: var(--theme-button-secondary-bg, rgba(255, 255, 255, 0.8));
                                               border: 1px solid var(--theme-button-secondary-border, rgba(0, 0, 0, 0.1));
                                               border-radius: var(--theme-input-radius, 15px); color: var(--theme-button-secondary-color, #555);
                                               font-size: 12px; cursor: pointer; flex-shrink: 0;">
                                    重置
                                </button>
                            </div>
                        </div>

                        <!-- 🔥【新增】时间日期样式设置 -->
                        <div class="settings-item" style="position: relative;">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">时间日期样式</div>
                                    <div class="setting-desc">选择主屏幕时间日期的显示风格</div>
                                </div>
                            </div>
                            <div class="clock-style-selector" onclick="toggleClockStyleDropdown()">
                                <span id="current-clock-style-text">默认</span>
                                <i class="fas fa-chevron-down" id="clock-style-arrow"></i>
                            </div>

                            <!-- 🔥【新增】下拉选择菜单 -->
                            <div id="clock-style-dropdown" class="clock-style-dropdown" style="display: none;">
                                <div class="clock-style-option selected" onclick="selectClockStyle('default')">
                                    <i class="fas fa-check"></i>
                                    <span>默认样式</span>
                                    <small>经典简洁的时间显示</small>
                                </div>
                                <div class="clock-style-option" onclick="selectClockStyle('bold')">
                                    <i class="fas fa-check"></i>
                                    <span>粗体样式</span>
                                    <small>类似iPhone锁屏的粗体显示</small>
                                </div>
                                <div class="clock-style-option" onclick="selectClockStyle('compact')">
                                    <i class="fas fa-check"></i>
                                    <span>紧凑样式</span>
                                    <small>类似Android的简洁显示</small>
                                </div>
                                <div class="clock-style-option" onclick="selectClockStyle('modern')">
                                    <i class="fas fa-check"></i>
                                    <span>现代样式</span>
                                    <small>类似小米MIUI的现代设计</small>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 音效设置界面 -->
                <div id="sound-settings-screen" class="app-screen">
                    <div class="app-top-container">
                        <div class="app-status-bar">
                            <div class="app-status-time"></div>
                            <div class="app-status-right">
                                <div class="app-signal-icon signal-icon">
                                    <div class="signal-row">
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                    </div>
                                </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                        <div class="app-header">
                            <button class="back-button" onclick="backToSettings('sound-settings-screen')">‹</button>
                            <div class="app-title">音效设置</div>
                        </div>
                    </div>
                    <div class="app-content">
                        <div class="form-container">
                            <!-- 音效开关 -->
                            <div class="form-group">
                                <label class="switch-label">
                                    <span>启用音效</span>
                                    <input type="checkbox" id="sound-enabled" checked onchange="toggleSoundSystem()">
                                    <span class="switch-slider"></span>
                                </label>
                            </div>

                            <!-- 音效设置列表 -->
                            <div id="sound-settings-list">
                                <!-- 接收消息音效 -->
                                <div class="sound-setting-item">
                                    <div class="sound-setting-header">
                                        <h3>接收消息音效</h3>
                                        <p>角色发消息时播放</p>
                                    </div>
                                    <div class="sound-setting-controls">
                                        <input type="url" placeholder="输入音效链接" id="sound-messageReceived-url" class="sound-url-input">
                                        <input type="file" accept="audio/*,.mp3,.m4a,.wav,.aac,.ogg,.flac" id="sound-messageReceived-file" style="display: none;" onchange="handleSoundFileUpload(this, 'messageReceived')">
                                        <button onclick="document.getElementById('sound-messageReceived-file').click()" class="sound-file-btn">
                                            <i class="fas fa-upload"></i> 本地文件
                                        </button>
                                        <button onclick="testSound('messageReceived')" class="sound-test-btn">
                                            <i class="fas fa-play"></i> 试听
                                        </button>
                                        <button onclick="clearSound('messageReceived')" class="sound-clear-btn">
                                            <i class="fas fa-trash"></i> 清除
                                        </button>
                                    </div>
                                </div>

                                <!-- 发送消息音效 -->
                                <div class="sound-setting-item">
                                    <div class="sound-setting-header">
                                        <h3>发送消息音效</h3>
                                        <p>用户发消息时播放</p>
                                    </div>
                                    <div class="sound-setting-controls">
                                        <input type="url" placeholder="输入音效链接" id="sound-messageSent-url" class="sound-url-input">
                                        <input type="file" accept="audio/*,.mp3,.m4a,.wav,.aac,.ogg,.flac" id="sound-messageSent-file" style="display: none;" onchange="handleSoundFileUpload(this, 'messageSent')">
                                        <button onclick="document.getElementById('sound-messageSent-file').click()" class="sound-file-btn">
                                            <i class="fas fa-upload"></i> 本地文件
                                        </button>
                                        <button onclick="testSound('messageSent')" class="sound-test-btn">
                                            <i class="fas fa-play"></i> 试听
                                        </button>
                                        <button onclick="clearSound('messageSent')" class="sound-clear-btn">
                                            <i class="fas fa-trash"></i> 清除
                                        </button>
                                    </div>
                                </div>

                                <!-- 消息推送音效 -->
                                <div class="sound-setting-item">
                                    <div class="sound-setting-header">
                                        <h3>消息推送音效</h3>
                                        <p>收到推送通知时播放</p>
                                    </div>
                                    <div class="sound-setting-controls">
                                        <input type="url" placeholder="输入音效链接" id="sound-notification-url" class="sound-url-input">
                                        <input type="file" accept="audio/*,.mp3,.m4a,.wav,.aac,.ogg,.flac" id="sound-notification-file" style="display: none;" onchange="handleSoundFileUpload(this, 'notification')">
                                        <button onclick="document.getElementById('sound-notification-file').click()" class="sound-file-btn">
                                            <i class="fas fa-upload"></i> 本地文件
                                        </button>
                                        <button onclick="testSound('notification')" class="sound-test-btn">
                                            <i class="fas fa-play"></i> 试听
                                        </button>
                                        <button onclick="clearSound('notification')" class="sound-clear-btn">
                                            <i class="fas fa-trash"></i> 清除
                                        </button>
                                    </div>
                                </div>

                                <!-- 拨出通话音效 -->
                                <div class="sound-setting-item">
                                    <div class="sound-setting-header">
                                        <h3>拨出通话音效</h3>
                                        <p>用户拨打语音/视频通话时播放</p>
                                    </div>
                                    <div class="sound-setting-controls">
                                        <input type="url" placeholder="输入音效链接" id="sound-outgoingCall-url" class="sound-url-input">
                                        <input type="file" accept="audio/*,.mp3,.m4a,.wav,.aac,.ogg,.flac" id="sound-outgoingCall-file" style="display: none;" onchange="handleSoundFileUpload(this, 'outgoingCall')">
                                        <button onclick="document.getElementById('sound-outgoingCall-file').click()" class="sound-file-btn">
                                            <i class="fas fa-upload"></i> 本地文件
                                        </button>
                                        <button onclick="testSound('outgoingCall')" class="sound-test-btn">
                                            <i class="fas fa-play"></i> 试听
                                        </button>
                                        <button onclick="clearSound('outgoingCall')" class="sound-clear-btn">
                                            <i class="fas fa-trash"></i> 清除
                                        </button>
                                    </div>
                                </div>

                                <!-- 来电音效 -->
                                <div class="sound-setting-item">
                                    <div class="sound-setting-header">
                                        <h3>来电音效</h3>
                                        <p>角色拨打语音/视频通话时播放</p>
                                    </div>
                                    <div class="sound-setting-controls">
                                        <input type="url" placeholder="输入音效链接" id="sound-incomingCall-url" class="sound-url-input">
                                        <input type="file" accept="audio/*,.mp3,.m4a,.wav,.aac,.ogg,.flac" id="sound-incomingCall-file" style="display: none;" onchange="handleSoundFileUpload(this, 'incomingCall')">
                                        <button onclick="document.getElementById('sound-incomingCall-file').click()" class="sound-file-btn">
                                            <i class="fas fa-upload"></i> 本地文件
                                        </button>
                                        <button onclick="testSound('incomingCall')" class="sound-test-btn">
                                            <i class="fas fa-play"></i> 试听
                                        </button>
                                        <button onclick="clearSound('incomingCall')" class="sound-clear-btn">
                                            <i class="fas fa-trash"></i> 清除
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <!-- 说明文字 -->
                            <div class="sound-settings-note">
                                <p><i class="fas fa-info-circle"></i> 支持在线链接和本地文件（最大3MB）</p>
                                <p><i class="fas fa-info-circle"></i> 支持常见音频格式：MP3、WAV、OGG等</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 主题设置界面 -->
                <div id="theme-screen" class="app-screen">
                    <div class="app-top-container">
                        <div class="app-status-bar">
                            <div class="app-status-time"></div>
                            <div class="app-status-right">
                                <div class="app-signal-icon signal-icon">
                                    <div class="signal-row">
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                    </div>
                                </div>
                                <div class="app-battery-container">
                                    <div class="app-battery-icon">
                                        <div class="app-battery-level"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="app-header">
                            <button class="back-button" onclick="backToSettings('theme-screen')">‹</button>
                            <div class="app-title">主题设置</div>
                        </div>
                    </div>
                    <div class="app-content">
                        <div class="theme-option" onclick="changeTheme('default').catch(e => console.error('切换主题失败:', e))">
                            <div class="theme-preview theme-preview-simple">
                                <div class="theme-preview-header"></div>
                                <div class="theme-preview-content"></div>
                            </div>
                            <div class="theme-info">
                                <div class="theme-name">简约风格</div>
                                <div class="theme-description">清新简洁的默认主题</div>
                            </div>
                        </div>

                        <div class="theme-option" onclick="changeTheme('cute').catch(e => console.error('切换主题失败:', e))">
                            <div class="theme-preview theme-preview-cute">
                                <div class="theme-preview-header"></div>
                                <div class="theme-preview-content"></div>
                            </div>
                            <div class="theme-info">
                                <div class="theme-name">可爱风格</div>
                                <div class="theme-description">温馨可爱的粉色主题</div>
                            </div>
                        </div>

                        <div class="theme-option" onclick="changeTheme('dark').catch(e => console.error('切换主题失败:', e))">
                            <div class="theme-preview theme-preview-dark">
                                <div class="theme-preview-header"></div>
                                <div class="theme-preview-content"></div>
                            </div>
                            <div class="theme-info">
                                <div class="theme-name">夜间模式</div>
                                <div class="theme-description">护眼的深色主题</div>
                            </div>
                        </div>

                        <div class="theme-option" onclick="showApp('custom-theme-screen')">
                            <div class="theme-preview theme-preview-custom">
                                <div class="theme-preview-header"></div>
                                <div class="theme-preview-content">
                                    <i class="fas fa-paint-brush"></i>
                                </div>
                            </div>
                            <div class="theme-info">
                                <div class="theme-name">自定义主题</div>
                                <div class="theme-description">打造专属的个性化界面</div>
                            </div>
                        </div>
                        </div>
                    </div>
                </div>

                <!-- 自定义主题界面 -->
                <div id="custom-theme-screen" class="app-screen">
                    <div class="app-top-container">
                        <div class="app-status-bar">
                            <div class="app-status-time"></div>
                            <div class="app-status-right">
                                <div class="app-signal-icon signal-icon">
                                    <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                        <div class="app-header">
                            <button class="back-button" onclick="backToSettings('custom-theme-screen')">‹</button>
                            <div class="app-title">自定义主题</div>
                        </div>
                    </div>
                    <div class="app-content custom-theme-content">
                        <!-- 主题分类选项卡 -->
                        <div class="custom-theme-tabs">
                            <div class="custom-theme-tab active" onclick="switchCustomThemeTab('chat')">
                                <i class="fas fa-comment-dots"></i>
                                <span>聊天界面</span>
                            </div>
                            <div class="custom-theme-tab" onclick="switchCustomThemeTab('global')">
                                <i class="fas fa-mobile-alt"></i>
                                <span>全局界面</span>
                            </div>
                        </div>

                        <!-- 聊天界面自定义 -->
                        <div id="chat-theme-content" class="custom-theme-content-pane">
                            <!-- 聊天界面背景设置 -->
                            <div class="custom-theme-section">
                                <div class="section-title">
                                    <i class="fas fa-image"></i>
                                    <span>界面背景</span>
                                </div>

                                <div class="custom-theme-item" onclick="uploadChatTopBackground()" id="chat-top-bg-item">
                                    <div class="theme-item-left">
                                        <div class="theme-item-icon">
                                            <i class="fas fa-window-maximize"></i>
                                        </div>
                                        <div class="theme-item-info">
                                            <div class="theme-item-title">顶部应用栏背景</div>
                                            <div class="theme-item-desc">包含状态栏和标题栏</div>
                                        </div>
                                    </div>
                                    <div class="theme-item-preview" id="chat-top-bg-preview">
                                        <i class="fas fa-plus"></i>
                                    </div>
                                    <div class="theme-item-status" id="chat-top-bg-status" style="display: none;">
                                        <i class="fas fa-check-circle"></i>
                                    </div>
                                </div>

                                <div class="custom-theme-item" onclick="uploadChatBottomBackground()" id="chat-bottom-bg-item">
                                    <div class="theme-item-left">
                                        <div class="theme-item-icon">
                                            <i class="fas fa-keyboard"></i>
                                        </div>
                                        <div class="theme-item-info">
                                            <div class="theme-item-title">底部输入栏背景</div>
                                            <div class="theme-item-desc">输入框和按钮区域</div>
                                        </div>
                                    </div>
                                    <div class="theme-item-preview" id="chat-bottom-bg-preview">
                                        <i class="fas fa-plus"></i>
                                    </div>
                                    <div class="theme-item-status" id="chat-bottom-bg-status" style="display: none;">
                                        <i class="fas fa-check-circle"></i>
                                    </div>
                                </div>
                            </div>

                            <!-- 按钮自定义设置 -->
                            <div class="custom-theme-section">
                                <div class="section-title">
                                    <i class="fas fa-mouse-pointer"></i>
                                    <span>按钮样式</span>
                                </div>

                                <div class="custom-theme-item" onclick="uploadButtonIcon('back')" id="back-btn-item">
                                    <div class="theme-item-left">
                                        <div class="theme-item-icon">
                                            <i class="fas fa-arrow-left"></i>
                                        </div>
                                        <div class="theme-item-info">
                                            <div class="theme-item-title">返回按钮</div>
                                            <div class="theme-item-desc">聊天界面左上角返回按钮</div>
                                        </div>
                                    </div>
                                    <div class="theme-item-preview" id="back-btn-preview">
                                        <i class="fas fa-plus"></i>
                                    </div>
                                    <div class="theme-item-status" id="back-btn-status" style="display: none;">
                                        <i class="fas fa-check-circle"></i>
                                    </div>
                                </div>

                                <div class="custom-theme-item" onclick="uploadButtonIcon('offline')" id="offline-btn-item">
                                    <div class="theme-item-left">
                                        <div class="theme-item-icon">
                                            <i class="fas fa-door-open"></i>
                                        </div>
                                        <div class="theme-item-info">
                                            <div class="theme-item-title">线下模式按钮</div>
                                            <div class="theme-item-desc">聊天界面线下模式切换</div>
                                        </div>
                                    </div>
                                    <div class="theme-item-preview" id="offline-btn-preview">
                                        <i class="fas fa-plus"></i>
                                    </div>
                                    <div class="theme-item-status" id="offline-btn-status" style="display: none;">
                                        <i class="fas fa-check-circle"></i>
                                    </div>
                                </div>

                                <div class="custom-theme-item" onclick="uploadButtonIcon('settings')" id="settings-btn-item">
                                    <div class="theme-item-left">
                                        <div class="theme-item-icon">
                                            <i class="fas fa-cog"></i>
                                        </div>
                                        <div class="theme-item-info">
                                            <div class="theme-item-title">聊天设置按钮</div>
                                            <div class="theme-item-desc">聊天界面右上角设置按钮</div>
                                        </div>
                                    </div>
                                    <div class="theme-item-preview" id="settings-btn-preview">
                                        <i class="fas fa-plus"></i>
                                    </div>
                                    <div class="theme-item-status" id="settings-btn-status" style="display: none;">
                                        <i class="fas fa-check-circle"></i>
                                    </div>
                                </div>

                                <div class="custom-theme-item" onclick="uploadButtonIcon('expand')" id="expand-btn-item">
                                    <div class="theme-item-left">
                                        <div class="theme-item-icon">
                                            <i class="fas fa-plus"></i>
                                        </div>
                                        <div class="theme-item-info">
                                            <div class="theme-item-title">功能区展开按钮</div>
                                            <div class="theme-item-desc">底部输入栏左侧展开按钮</div>
                                        </div>
                                    </div>
                                    <div class="theme-item-preview" id="expand-btn-preview">
                                        <i class="fas fa-plus"></i>
                                    </div>
                                    <div class="theme-item-status" id="expand-btn-status" style="display: none;">
                                        <i class="fas fa-check-circle"></i>
                                    </div>
                                </div>

                                <div class="custom-theme-item" onclick="uploadButtonIcon('continue')" id="continue-btn-item">
                                    <div class="theme-item-left">
                                        <div class="theme-item-icon">
                                            <i class="fas fa-comment-dots"></i>
                                        </div>
                                        <div class="theme-item-info">
                                            <div class="theme-item-title">续写按钮</div>
                                            <div class="theme-item-desc">获取AI回复按钮</div>
                                        </div>
                                    </div>
                                    <div class="theme-item-preview" id="continue-btn-preview">
                                        <i class="fas fa-plus"></i>
                                    </div>
                                    <div class="theme-item-status" id="continue-btn-status" style="display: none;">
                                        <i class="fas fa-check-circle"></i>
                                    </div>
                                </div>

                                <div class="custom-theme-item" onclick="uploadButtonIcon('send')" id="send-btn-item">
                                    <div class="theme-item-left">
                                        <div class="theme-item-icon">
                                            <i class="fas fa-paper-plane"></i>
                                        </div>
                                        <div class="theme-item-info">
                                            <div class="theme-item-title">发送消息按钮</div>
                                            <div class="theme-item-desc">底部输入栏发送按钮</div>
                                        </div>
                                    </div>
                                    <div class="theme-item-preview" id="send-btn-preview">
                                        <i class="fas fa-plus"></i>
                                    </div>
                                    <div class="theme-item-status" id="send-btn-status" style="display: none;">
                                        <i class="fas fa-check-circle"></i>
                                    </div>
                                </div>
                            </div>

                            <!-- 应用范围设置 -->
                            <div class="custom-theme-section">
                                <div class="section-title">
                                    <i class="fas fa-layer-group"></i>
                                    <span>应用范围</span>
                                </div>

                                <div class="theme-scope-options">
                                    <div class="theme-scope-option active" data-scope="selected">
                                        <i class="fas fa-users"></i>
                                        <span>选择聊天窗口</span>
                                    </div>
                                    <div class="theme-scope-option" data-scope="all">
                                        <i class="fas fa-globe"></i>
                                        <span>所有聊天窗口</span>
                                    </div>
                                </div>

                                <!-- 选择聊天窗口列表（当选择"选择聊天窗口"时显示） -->
                                <div id="chat-selection-list" class="chat-selection-list">
                                    <!-- 聊天窗口列表将通过JS动态生成 -->
                                </div>
                            </div>
                        </div>

                        <!-- 全局界面自定义 -->
                        <div id="global-theme-content" class="custom-theme-content-pane" style="display: none;">
                            <!-- 全局应用栏设置 -->
                            <div class="custom-theme-section">
                                <div class="section-title">
                                    <i class="fas fa-window-maximize"></i>
                                    <span>应用栏样式（排除聊天界面）</span>
                                </div>

                                <div class="custom-theme-item" onclick="uploadGlobalTopAppBar()" id="global-top-app-bar-item">
                                    <div class="theme-item-left">
                                        <div class="theme-item-icon">
                                            <i class="fas fa-window-maximize"></i>
                                        </div>
                                        <div class="theme-item-info">
                                            <div class="theme-item-title">顶部应用栏</div>
                                            <div class="theme-item-desc">应用到除API聊天和短信聊天以外的所有应用页顶部</div>
                                        </div>
                                    </div>
                                    <div class="theme-item-preview" id="global-top-app-bar-preview">
                                        <i class="fas fa-plus"></i>
                                    </div>
                                    <div class="theme-item-status" id="global-top-app-bar-status" style="display: none;">
                                        <i class="fas fa-check-circle"></i>
                                    </div>
                                </div>

                                <div class="custom-theme-item" onclick="uploadGlobalBottomAppBar()" id="global-bottom-app-bar-item">
                                    <div class="theme-item-left">
                                        <div class="theme-item-icon">
                                            <i class="fas fa-window-minimize"></i>
                                        </div>
                                        <div class="theme-item-info">
                                            <div class="theme-item-title">底部应用栏</div>
                                            <div class="theme-item-desc">应用到除API聊天和短信聊天以外的所有应用页底部</div>
                                        </div>
                                    </div>
                                    <div class="theme-item-preview" id="global-bottom-app-bar-preview">
                                        <i class="fas fa-plus"></i>
                                    </div>
                                    <div class="theme-item-status" id="global-bottom-app-bar-status" style="display: none;">
                                        <i class="fas fa-check-circle"></i>
                                    </div>
                                </div>
                            </div>

                            <!-- 标题栏按钮设置 -->
                            <div class="custom-theme-section">
                                <div class="section-title">
                                    <i class="fas fa-mouse-pointer"></i>
                                    <span>标题栏按钮（排除聊天界面）</span>
                                </div>

                                <div class="custom-theme-item" onclick="uploadGlobalBackButton()" id="global-back-button-item">
                                    <div class="theme-item-left">
                                        <div class="theme-item-icon">
                                            <i class="fas fa-arrow-left"></i>
                                        </div>
                                        <div class="theme-item-info">
                                            <div class="theme-item-title">返回按钮</div>
                                            <div class="theme-item-desc">应用到除API聊天和短信聊天以外的返回按钮</div>
                                        </div>
                                    </div>
                                    <div class="theme-item-preview" id="global-back-button-preview">
                                        <i class="fas fa-plus"></i>
                                    </div>
                                    <div class="theme-item-status" id="global-back-button-status" style="display: none;">
                                        <i class="fas fa-check-circle"></i>
                                    </div>
                                </div>

                                <div class="custom-theme-item" onclick="uploadGlobalAddButton()">
                                    <div class="theme-item-left">
                                        <div class="theme-item-icon">
                                            <i class="fas fa-plus"></i>
                                        </div>
                                        <div class="theme-item-info">
                                            <div class="theme-item-title">添加按钮</div>
                                            <div class="theme-item-desc">应用到除API聊天和短信聊天以外的添加按钮</div>
                                        </div>
                                    </div>
                                    <div class="theme-item-preview" id="global-add-button-preview">
                                        <i class="fas fa-plus"></i>
                                    </div>
                                </div>
                            </div>

                            <!-- 全局背景设置 -->
                            <div class="custom-theme-section">
                                <div class="section-title">
                                    <i class="fas fa-image"></i>
                                    <span>应用背景（排除聊天界面）</span>
                                </div>

                                <div class="custom-theme-item" onclick="uploadGlobalBackground()">
                                    <div class="theme-item-left">
                                        <div class="theme-item-icon">
                                            <i class="fas fa-desktop"></i>
                                        </div>
                                        <div class="theme-item-info">
                                            <div class="theme-item-title">全局应用背景</div>
                                            <div class="theme-item-desc">应用到除API聊天和短信聊天以外的所有应用界面</div>
                                        </div>
                                    </div>
                                    <div class="theme-item-preview" id="global-bg-preview">
                                        <i class="fas fa-plus"></i>
                                    </div>
                                </div>
                            </div>


                        </div>

                        <!-- 底部操作按钮 -->
                        <div class="custom-theme-actions">
                            <button class="theme-action-btn manage-btn" onclick="showThemeManagement().catch(e => console.error('显示主题管理失败:', e))">
                                <i class="fas fa-cog"></i>
                                <span>管理</span>
                            </button>
                            <button class="theme-action-btn reset-btn" onclick="resetCustomTheme().catch(e => console.error('重置主题失败:', e))">
                                <i class="fas fa-undo"></i>
                                <span>重置</span>
                            </button>
                            <button class="theme-action-btn preview-btn" onclick="previewCustomTheme()">
                                <i class="fas fa-eye"></i>
                                <span>预览</span>
                            </button>
                            <button class="theme-action-btn apply-btn" onclick="applyCustomTheme().catch(e => console.error('应用主题失败:', e))">
                                <i class="fas fa-check"></i>
                                <span>应用</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- 壁纸设置 -->
                <div id="wallpaper-screen" class="app-screen">
                    <div class="app-top-container">
                        <div class="app-status-bar">
                            <div class="app-status-time"></div>
                            <div class="app-status-right">
                                <div class="app-signal-icon signal-icon">
                                    <div class="signal-row">
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                        <div class="app-header">
                            <button class="back-button" onclick="backToSettings('wallpaper-screen')">‹</button>
                            <div class="app-title">壁纸</div>
                        </div>
                    </div>
                    <div class="app-content">
                        <div class="settings-item" onclick="showWallpaperPicker()">
                            <div class="settings-item-left">
                                <div>选择新壁纸</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showIconPicker()">
                            <div class="settings-item-left">
                                <div>更改应用图标</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                    </div>
                </div>

                <!-- 无线局域网设置 -->
                <div id="wifi-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-status-right">
                            <div class="app-signal-icon signal-icon">
                                <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('wifi-screen')">‹</button>
                        <div class="app-title">无线局域网</div>
                    </div>
                    <div class="app-content">
                        <div class="wifi-settings">
                            <div class="settings-item">
                                <div class="settings-item-left">
                                    <div>无线局域网</div>
                                </div>
                                <label class="settings-toggle">
                                    <input type="checkbox" checked>
                                    <span class="settings-slider"></span>
                                </label>
                            </div>

                            <div class="wifi-network">
                                <div class="wifi-network-left">
                                    <div class="wifi-icon">
                                        <i class="fas fa-lock"></i>
                                    </div>
                                    <div>
                                        <div>HomeWiFi</div>
                                        <div class="wifi-strength">
                                            <div class="wifi-strength-bar active"></div>
                                            <div class="wifi-strength-bar active"></div>
                                            <div class="wifi-strength-bar active"></div>
                                            <div class="wifi-strength-bar active"></div>
                                        </div>
                                    </div>
                                </div>
                                <i class="fas fa-check check-icon"></i>
                            </div>

                            <div class="settings-item settings-item-margin" onclick="showApp('api-settings-screen')">
                                <div class="settings-item-left">
                                    <div>API设置</div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- API设置界面 -->
                <div id="api-settings-screen" class="app-screen">
                    <div class="app-top-container">
                        <div class="app-status-bar">
                            <div class="app-status-time"></div>
                            <div class="app-status-right">
                                <div class="app-signal-icon signal-icon">
                                    <div class="signal-row">
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                        <div class="signal-bar"></div>
                                    </div>
                                </div>
                                <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                        <div class="app-header">
                            <button class="back-button" onclick="backToSettings('api-settings-screen')">‹</button>
                            <div class="app-title">API设置</div>
                        </div>
                    </div>
                    <div class="app-content">
                        <div class="form-container" style="color: #000000;">



                            <!-- 快速设置卡片 -->
                            <div class="form-group" style="margin-bottom: 30px;">
                                <label style="color: #333; margin-bottom: 15px; display: block; font-size: 16px; font-weight: 600;">🚀 快速设置</label>

                                <!-- Gemini直连卡片 -->
                                <div style="margin-bottom: 12px; padding: 18px; background: linear-gradient(135deg, rgba(74, 132, 193, 0.1) 0%, rgba(74, 132, 193, 0.05) 100%); border: 2px solid rgba(74, 132, 193, 0.2); border-radius: 16px; color: #333; cursor: pointer; transition: all 0.3s ease; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);" onclick="setGeminiDirect()">
                                    <div style="display: flex; align-items: center; justify-content: space-between;">
                                        <div>
                                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 4px; color: var(--theme-button-bg, #4a84c1);">🌟 Gemini 直连</div>
                                            <div style="font-size: 13px; color: #666;">自动配置Google官方API，支持最新模型</div>
                                        </div>
                                        <div style="background: var(--theme-button-bg, rgba(74, 132, 193, 0.9)); color: white; padding: 8px 14px; border-radius: 20px; font-size: 13px; font-weight: 500; box-shadow: 0 2px 8px rgba(74, 132, 193, 0.3);">点击配置</div>
                                    </div>
                            </div>

                                <!-- HuggingFace反代卡片 -->
                                <div style="margin-bottom: 15px; padding: 18px; background: linear-gradient(135deg, rgba(255, 193, 7, 0.1) 0%, rgba(255, 193, 7, 0.05) 100%); border: 2px solid rgba(255, 193, 7, 0.2); border-radius: 16px; color: #333; cursor: pointer; transition: all 0.3s ease; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);" onclick="setHuggingFaceProxy()">
                                    <div style="display: flex; align-items: center; justify-content: space-between;">
                                        <div>
                                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 4px; color: #f39c12;">🤗 HuggingFace 反代</div>
                                            <div style="font-size: 13px; color: #666;">多种大模型，支持Claude等</div>
                                        </div>
                                        <div style="background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%); color: white; padding: 8px 14px; border-radius: 20px; font-size: 13px; font-weight: 500; box-shadow: 0 2px 8px rgba(243, 156, 18, 0.3);">点击配置</div>
                                    </div>
                            </div>

                                <div style="font-size: 12px; color: #666; text-align: center; margin-top: 10px;">
                                    ⚠️ 使用前请确保有对应的API密钥
                                </div>
                            </div>

                            <!-- API配置表单 - 美化版 -->
                            <div style="background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 25px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1); border: 1px solid rgba(255, 255, 255, 0.2);">

                                <!-- API地址 -->
                                <div style="margin-bottom: 20px;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: var(--theme-text-primary, #333); font-size: 15px;">API地址</label>
                                    <input type="text" id="api-base" placeholder="例如: https://api.openai.com 或 @https://xxx-xxx.hf.space/v1" style="width: 100%; padding: 12px 15px; border: 2px solid var(--theme-input-border, rgba(0, 0, 0, 0.08)); border-radius: 12px; font-size: 16px; background: var(--theme-form-bg, rgba(255, 255, 255, 0.9)); backdrop-filter: blur(10px); transition: all 0.3s ease; color: var(--theme-text-primary, #333); box-sizing: border-box;">
                                    <div style="font-size: 12px; color: #666; margin-top: 5px;">支持标准API和HuggingFace反代（格式：@https://xxx.hf.space/v1）</div>
                            </div>

                                <!-- API密钥 -->
                                <div style="margin-bottom: 20px;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: var(--theme-text-primary, #333); font-size: 15px;">API密钥</label>
                                    <input type="password" id="api-key" placeholder="sk-... 或 Google AI Studio API Key" style="width: 100%; padding: 12px 15px; border: 2px solid var(--theme-input-border, rgba(0, 0, 0, 0.08)); border-radius: 12px; font-size: 16px; background: var(--theme-form-bg, rgba(255, 255, 255, 0.9)); backdrop-filter: blur(10px); transition: all 0.3s ease; color: var(--theme-text-primary, #333); box-sizing: border-box;">
                                </div>

                                <!-- 模型选择 -->
                                <div style="margin-bottom: 20px;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: var(--theme-text-primary, #333); font-size: 15px;">模型</label>
                                    <div style="display: flex; gap: 10px; align-items: center; width: 100%; overflow: hidden;">
                                        <select id="model-select" style="flex: 1; min-width: 0; padding: 12px 15px; border: 2px solid var(--theme-input-border, rgba(0, 0, 0, 0.08)); border-radius: 12px; font-size: 16px; background: var(--theme-form-bg, rgba(255, 255, 255, 0.9)); backdrop-filter: blur(10px); transition: all 0.3s ease; color: var(--theme-text-primary, #333); max-height: 200px; overflow-y: auto;">
                                            <!-- 模型选项将通过JS动态填充 -->
                                    </select>
                                        <button id="fetch-models-btn" onclick="fetchModels()" style="padding: 10px 16px; background: var(--theme-button-secondary-bg, rgba(255, 255, 255, 0.8)); color: var(--theme-button-secondary-color, #666); border: 2px solid var(--theme-button-secondary-border, rgba(0, 0, 0, 0.1)); border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: 500; backdrop-filter: blur(10px); transition: all 0.3s ease; white-space: nowrap;">拉取模型</button>
                                </div>
                            </div>

                                <!-- 温度参数 -->
                                <div style="margin-bottom: 25px;">
                                    <label style="display: block; margin-bottom: 12px; font-weight: 600; color: var(--theme-text-primary, #333); font-size: 15px;">温度参数 (<span id="temperature-value" style="color: var(--theme-button-bg, #4a84c1); font-weight: 700;">0.75</span>)</label>
                                    <div style="background: rgba(255, 255, 255, 0.8); padding: 15px; border-radius: 12px; border: 2px solid var(--theme-input-border, rgba(0, 0, 0, 0.08));">
                                        <input type="range" id="temperature-slider" min="0" max="2" step="0.05" value="0.75" oninput="document.getElementById('temperature-value').textContent = parseFloat(this.value).toFixed(2);" style="width: 100%; height: 6px; border-radius: 3px; background: linear-gradient(to right, rgba(74, 132, 193, 0.2) 0%, rgba(74, 132, 193, 0.4) 100%); outline: none; -webkit-appearance: none; appearance: none;">
                                        <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 12px; color: #666;">
                                            <span>0.00 (保守)</span>
                                            <span>1.00 (平衡)</span>
                                            <span>2.00 (创新)</span>
                                        </div>
                                        <div style="font-size: 12px; color: #666; margin-top: 8px; text-align: center;">温度越低，回答越保守稳定；温度越高，回答越有创意多样</div>
                                    </div>
                            </div>

                                <!-- 表情包识别设置 -->
                                <div style="margin-bottom: 25px;">
                                    <label style="display: block; margin-bottom: 12px; font-weight: 600; color: var(--theme-text-primary, #333); font-size: 15px;">表情包识别</label>
                                    <div style="background: rgba(255, 255, 255, 0.8); padding: 15px; border-radius: 12px; border: 2px solid var(--theme-input-border, rgba(0, 0, 0, 0.08));">
                                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                                            <input type="checkbox" id="emoji-recognition-enabled" style="width: 18px; height: 18px; accent-color: var(--theme-button-bg, #4a84c1);">
                                            <span style="font-size: 14px; color: var(--theme-text-primary, #333);">启用AI识别表情包图片</span>
                                        </label>
                                        <div style="font-size: 12px; color: #666; margin-top: 8px; line-height: 1.4;">
                                            关闭后，AI将无法识别表情包图片内容，但仍可识别普通图片。这可以节省token消耗。
                                        </div>
                                    </div>
                                </div>

                                <!-- 操作按钮 -->
                                <div style="display: flex; gap: 12px; margin-top: 25px;">
                                    <button id="test-api-connection-btn" onclick="testApiConnection()" style="flex: 1; padding: 14px 20px; background: linear-gradient(135deg, #34c759 0%, #30d158 100%); color: white; border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: 0 4px 15px rgba(52, 199, 89, 0.3); transition: all 0.3s ease;">测试连接</button>
                                    <button id="save-api-settings-btn" onclick="saveApiSettings()" style="flex: 1; padding: 14px 20px; background: var(--theme-button-bg, rgba(74, 132, 193, 0.9)); color: var(--theme-button-color, white); border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: var(--theme-button-shadow, 0 4px 15px rgba(74, 132, 193, 0.3)); transition: all 0.3s ease;">保存设置</button>
                                </div>
                            </div>

                            <!-- API配置管理 -->
                            <hr style="margin: 30px 0; border: none; border-top: 1px solid #eaeaea;">
                            <div class="api-config-manager" style="background: rgba(248, 249, 250, 0.8); border-radius: 16px; padding: 20px; margin: 15px 0; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(0,0,0,0.05);">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>💾</span> API配置管理
                                </h4>
                                <p style="font-size: 13px; color: #666; margin: 0 0 15px 0; line-height: 1.5;">保存当前配置为预设，方便快速切换不同的API服务</p>

                                <div class="save-config-section" style="margin-bottom: 20px; padding: 15px; background: rgba(255,255,255,0.6); border-radius: 12px; border: 1px solid rgba(0,0,0,0.05);">
                                    <div style="display: flex; gap: 10px; margin-bottom: 12px;">
                                        <input type="text" id="config-name-input" placeholder="输入配置名称 (如: OpenAI、Gemini、Claude等)" style="flex: 1; padding: 10px 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px; background: rgba(255,255,255,0.9);">
                                        <button id="save-current-config-btn" onclick="saveCurrentConfig()" style="padding: 8px 16px; background: #e8ebf7; color: #5a6acf; border: none; border-radius: 8px; font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.3s ease; white-space: nowrap;">保存</button>
                        </div>
                                    <div style="font-size: 12px; color: #888;">当前配置将保存为: <span style="color: #333; font-weight: 500;">URL + 模型 + 温度设置</span></div>
                                </div>

                                <div class="saved-configs-section">
                                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                                        <label style="font-size: 14px; font-weight: 500; color: #333;">已保存的配置</label>
                                        <button id="clear-all-configs-btn" onclick="clearAllConfigs()" style="padding: 6px 12px; background: rgba(255, 107, 107, 0.1); color: #ff6b6b; border: 1px solid rgba(255, 107, 107, 0.3); border-radius: 6px; font-size: 12px; cursor: pointer; transition: all 0.2s ease;">🗑️ 清空全部</button>
                                    </div>
                                    <div id="saved-configs-container" style="display: grid; gap: 10px; max-height: 300px; overflow-y: auto;">
                                        <!-- 保存的配置卡片将在这里动态生成 -->
                                    </div>
                                    <div id="no-configs-message" style="text-align: center; color: #999; padding: 30px 20px; font-size: 14px; display: none;">
                                        <div style="font-size: 24px; margin-bottom: 8px;">📝</div>
                                        <div>还没有保存任何配置</div>
                                        <div style="font-size: 12px; margin-top: 4px;">在上方输入配置名称并点击"保存配置"</div>
                                    </div>
                                </div>
                            </div>



                        </div>
                    </div>
                </div>

                <!-- 角色手机界面 -->
                <div id="character-phone-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-status-right">
                            <div class="app-signal-icon signal-icon">
                                <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('character-phone-screen'); showApp('api-chat-screen');">‹</button>
                        <div class="app-title" id="character-phone-title">角色手机</div>
                    </div>

                    <div class="app-content character-phone-content">
                        <!-- 手机内容区域 -->
                        <div class="phone-content-area">
                            <!-- 消息内容 -->
                            <div class="phone-tab-content" id="phone-messages-content">
                                <div class="phone-messages-list">
                                    <div class="phone-message-item">
                                        <div class="phone-message-avatar">
                                            <i class="fas fa-user"></i>
                                        </div>
                                        <div class="phone-message-info">
                                            <div class="phone-message-name">小红</div>
                                            <div class="phone-message-preview">今天天气真好呢~</div>
                                            <div class="phone-message-time">10:30</div>
                                        </div>
                                    </div>
                                    <div class="phone-message-item">
                                        <div class="phone-message-avatar">
                                            <i class="fas fa-user"></i>
                                        </div>
                                        <div class="phone-message-info">
                                            <div class="phone-message-name">小明</div>
                                            <div class="phone-message-preview">周末一起出去玩吧</div>
                                            <div class="phone-message-time">昨天</div>
                                        </div>
                                    </div>
                                    <div class="phone-message-item">
                                        <div class="phone-message-avatar">
                                            <i class="fas fa-user"></i>
                                        </div>
                                        <div class="phone-message-info">
                                            <div class="phone-message-name">妈妈</div>
                                            <div class="phone-message-preview">记得按时吃饭哦</div>
                                            <div class="phone-message-time">昨天</div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 备忘录内容 -->
                            <div class="phone-tab-content" id="phone-notes-content" style="display: none;">
                                <div class="phone-notes-list">
                                    <div class="phone-note-item" onclick="openPhoneNote('购物清单')">
                                        <div class="phone-note-title">购物清单</div>
                                        <div class="phone-note-preview">牛奶、面包、鸡蛋...</div>
                                        <div class="phone-note-time">今天 14:20</div>
                                    </div>
                                    <div class="phone-note-item" onclick="openPhoneNote('工作计划')">
                                        <div class="phone-note-title">工作计划</div>
                                        <div class="phone-note-preview">完成项目报告，准备会议...</div>
                                        <div class="phone-note-time">昨天 16:45</div>
                                    </div>
                                    <div class="phone-note-item" onclick="openPhoneNote('读书笔记')">
                                        <div class="phone-note-title">读书笔记</div>
                                        <div class="phone-note-preview">今天读了一本很有趣的书...</div>
                                        <div class="phone-note-time">2天前</div>
                                    </div>
                                </div>
                            </div>

                            <!-- 相册内容 -->
                            <div class="phone-tab-content" id="phone-photos-content" style="display: none;">
                                <div class="phone-photos-grid">
                                    <div class="phone-photo-item" onclick="openPhonePhoto('春日樱花')">
                                        <div class="phone-photo-placeholder">
                                            <i class="fas fa-image"></i>
                                        </div>
                                    </div>
                                    <div class="phone-photo-item" onclick="openPhonePhoto('咖啡时光')">
                                        <div class="phone-photo-placeholder">
                                            <i class="fas fa-image"></i>
                                        </div>
                                    </div>
                                    <div class="phone-photo-item" onclick="openPhonePhoto('夕阳西下')">
                                        <div class="phone-photo-placeholder">
                                            <i class="fas fa-image"></i>
                                        </div>
                                    </div>
                                    <div class="phone-photo-item" onclick="openPhonePhoto('城市夜景')">
                                        <div class="phone-photo-placeholder">
                                            <i class="fas fa-image"></i>
                                        </div>
                                    </div>
                                    <div class="phone-photo-item" onclick="openPhonePhoto('美食记录')">
                                        <div class="phone-photo-placeholder">
                                            <i class="fas fa-image"></i>
                                        </div>
                                    </div>
                                    <div class="phone-photo-item" onclick="openPhonePhoto('旅行回忆')">
                                        <div class="phone-photo-placeholder">
                                            <i class="fas fa-image"></i>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- 底部标签页 -->
                        <div class="phone-tabs">
                            <div class="phone-tab active" onclick="switchPhoneTab('messages')">
                                <i class="fas fa-comment"></i>
                                <span>消息</span>
                            </div>
                            <div class="phone-tab" onclick="switchPhoneTab('notes')">
                                <i class="fas fa-sticky-note"></i>
                                <span>备忘录</span>
                            </div>
                            <div class="phone-tab" onclick="switchPhoneTab('photos')">
                                <i class="fas fa-images"></i>
                                <span>相册</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 角色手机对话详情界面 -->
                <div id="character-phone-chat-screen" class="app-screen" style="display: none;">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-status-right">
                            <div class="app-signal-icon signal-icon">
                                <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('character-phone-chat-screen'); showApp('character-phone-screen');">‹</button>
                        <div class="app-title" id="phone-chat-contact-name">联系人</div>
                    </div>

                    <div class="app-content phone-chat-content">
                        <!-- 对话消息区域 -->
                        <div class="phone-chat-messages" id="phone-chat-messages">
                            <!-- 消息将通过JavaScript动态生成 -->
                        </div>

                        <!-- 输入区域 -->
                        <div class="phone-chat-input-area">
                            <div class="phone-chat-input-container">
                                <input type="text" class="phone-chat-input" placeholder="输入消息..." readonly>
                                <button class="phone-chat-send-btn" disabled>
                                    <i class="fas fa-paper-plane"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 角色手机备忘录详情界面 -->
                <div id="character-phone-note-screen" class="app-screen" style="display: none;">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-status-right">
                            <div class="app-signal-icon signal-icon">
                                <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('character-phone-note-screen'); showApp('character-phone-screen');">‹</button>
                        <div class="app-title" id="phone-note-title">备忘录</div>
                    </div>

                    <div class="app-content phone-note-detail-content">
                        <div class="phone-note-detail">
                            <div class="phone-note-detail-header">
                                <h2 id="phone-note-detail-title">备忘录标题</h2>
                                <div class="phone-note-detail-time" id="phone-note-detail-time">时间</div>
                            </div>
                            <div class="phone-note-detail-body" id="phone-note-detail-body">
                                备忘录内容...
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 角色手机照片详情界面 -->
                <div id="character-phone-photo-screen" class="app-screen" style="display: none;">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-status-right">
                            <div class="app-signal-icon signal-icon">
                                <div class="signal-row">
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                    <div class="signal-bar"></div>
                                </div>
                            </div>
                            <div class="app-battery-container">
                                <div class="app-battery-icon">
                                    <div class="app-battery-level"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('character-phone-photo-screen'); showApp('character-phone-screen');">‹</button>
                        <div class="app-title">照片</div>
                    </div>

                    <div class="app-content phone-photo-detail-content">
                        <div class="phone-photo-detail">
                            <div class="phone-photo-detail-image" id="phone-photo-detail-image">
                                <div class="phone-photo-placeholder-large">
                                    <i class="fas fa-image"></i>
                                    <p>照片预览</p>
                                </div>
                            </div>
                            <div class="phone-photo-detail-info">
                                <div class="phone-photo-detail-title" id="phone-photo-detail-title">照片标题</div>
                                <div class="phone-photo-detail-time" id="phone-photo-detail-time">拍摄时间</div>
                                <div class="phone-photo-detail-description" id="phone-photo-detail-description">照片描述</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 颜色选择器模态框 -->
                <div class="modal" id="color-picker-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title" id="color-picker-title">选择颜色</div>
                            <button class="modal-close" onclick="hideModal('color-picker-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="color-picker" id="color-picker">
                                <div class="color-option color-red" onclick="selectColor('#FF3B30')"></div>
                                <div class="color-option color-orange" onclick="selectColor('#FF9500')"></div>
                                <div class="color-option color-yellow" onclick="selectColor('#FFCC00')"></div>
                                <div class="color-option color-green" onclick="selectColor('#34C759')"></div>
                                <div class="color-option color-light-blue" onclick="selectColor('#5AC8FA')"></div>
                                <div class="color-option color-blue" onclick="selectColor('#007AFF')"></div>
                                <div class="color-option color-purple" onclick="selectColor('#5856D6')"></div>
                                <div class="color-option color-pink" onclick="selectColor('#AF52DE')"></div>
                                <div class="color-option color-red-alt" onclick="selectColor('#FF2D55')"></div>
                            </div>
                            <div class="form-group">
                                <label class="form-label">透明度</label>
                                <input type="range" class="opacity-slider" id="opacity-slider" min="0" max="1" step="0.1" value="1">
                                <span id="opacity-value">100%</span>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('color-picker-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="applyColorSelection()">应用</button>
                        </div>
                    </div>
                </div>

                <!-- 壁纸选择器模态框 -->
                <div class="modal" id="wallpaper-picker-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">选择壁纸</div>
                            <button class="modal-close" onclick="hideModal('wallpaper-picker-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="wallpaper-preview-container" id="wallpaper-preview-container">
                                <div class="wallpaper-preview-placeholder">
                                    <i class="fas fa-image"></i>
                                    <div>选择本地图片后可在此预览</div>
                                </div>
                            </div>
                            <div class="settings-item upload-custom-item" onclick="uploadCustomWallpaper()">
                                <div class="settings-item-left">
                                    <div>从相册选择</div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <input type="file" id="custom-wallpaper-upload" accept="image/*" class="file-input-hidden">
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('wallpaper-picker-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="applyWallpaperSelection()">应用</button>
                        </div>
                    </div>
                </div>

                <!-- 图片上传选择模态框 -->
                <div class="modal" id="image-upload-choice-modal">
                    <div class="modal-content" style="max-width: 400px;">
                        <div class="modal-header">
                            <div class="modal-title" id="image-upload-choice-title">选择图片来源</div>
                            <button class="modal-close" onclick="hideModal('image-upload-choice-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="upload-choice-container">
                                <div class="upload-choice-option" onclick="chooseLocalUpload()">
                                    <div class="upload-choice-icon">
                                        <i class="fas fa-upload"></i>
                                    </div>
                                    <div class="upload-choice-text">
                                        <div class="upload-choice-title">本地上传</div>
                                        <div class="upload-choice-desc">从设备选择图片文件</div>
                                    </div>
                                </div>
                                <div class="upload-choice-option" onclick="chooseUrlUpload()">
                                    <div class="upload-choice-icon">
                                        <i class="fas fa-link"></i>
                                    </div>
                                    <div class="upload-choice-text">
                                        <div class="upload-choice-title">在线图床</div>
                                        <div class="upload-choice-desc">输入图片URL地址</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- URL输入模态框 -->
                <div class="modal" id="url-input-modal">
                    <div class="modal-content" style="max-width: 500px;">
                        <div class="modal-header">
                            <div class="modal-title" id="url-input-title">输入图片URL</div>
                            <button class="modal-close" onclick="hideModal('url-input-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="url-input-container">
                                <label for="image-url-input">图片URL地址：</label>
                                <input type="url" id="image-url-input" placeholder="https://example.com/image.jpg" style="width: 100%; padding: 10px; margin: 10px 0; border: 1px solid #ddd; border-radius: 5px;">
                                <div class="url-tips">
                                    <p><strong>支持的图床：</strong></p>
                                    <ul>
                                        <li>PostImg: https://i.postimg.cc/...</li>
                                        <li>Catbox: https://files.catbox.moe/...</li>
                                        <li>ImgBB: https://i.ibb.co/...</li>
                                        <li>Imgur: https://i.imgur.com/...</li>
                                        <li>其他支持直链的图床</li>
                                    </ul>
                                </div>
                                <div class="url-preview" id="url-preview" style="display: none;">
                                    <img id="url-preview-img" style="max-width: 100%; max-height: 200px; border-radius: 5px;">
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('url-input-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="confirmUrlUpload()">确认</button>
                        </div>
                    </div>
                </div>

                <!-- 图标选择器模态框 -->
                <div class="modal" id="icon-picker-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">更改应用图标</div>
                            <button class="modal-close" onclick="hideModal('icon-picker-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <!-- 应用列表 -->
                            <div class="app-list-section">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px;">选择要修改的应用</h4>
                                <div id="app-list-container" class="app-list-grid">
                                    <!-- 动态生成应用列表 -->
                                </div>
                            </div>

                            <!-- 图标上传区域 -->
                            <div class="icon-upload-section" id="icon-upload-section" style="display: none;">
                                <h4 style="margin: 20px 0 15px 0; color: #333; font-size: 16px;">上传新图标</h4>
                                <div class="upload-area" onclick="triggerIconUpload()">
                                    <div class="upload-placeholder" id="upload-placeholder">
                                        <i class="fas fa-cloud-upload-alt" style="font-size: 32px; color: #999; margin-bottom: 10px;"></i>
                                        <div style="color: #666;">点击选择图片</div>
                                        <div style="color: #999; font-size: 12px; margin-top: 5px;">支持 JPG、PNG 格式</div>
                                    </div>
                                    <img id="icon-preview-img" class="icon-preview-img" style="display: none;">
                                </div>
                                <input type="file" id="custom-icon-upload" accept="image/*" class="file-input-hidden">
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('icon-picker-modal')">取消</button>
                            <button class="modal-button modal-primary" id="apply-icon-btn" onclick="applyIconChange()" style="display: none;">应用</button>
                        </div>
                    </div>
                </div>

                <!-- 照片拍摄模态框 -->






                <!-- 聊天选项模态框 -->
                <div class="modal" id="chat-options-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">选择聊天类型</div>
                            <button class="modal-close" onclick="hideModal('chat-options-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="chat-option-item" onclick="showSingleChatSelector()">
                                <div class="chat-option-icon">
                                    <i class="fas fa-user icon-user-blue"></i>
                                </div>
                                <div class="chat-option-text">
                                    <div class="chat-option-title">单聊</div>
                                    <div class="chat-option-desc">与单个角色进行对话</div>
                                </div>
                            </div>
                            <div class="chat-option-item" onclick="showGroupChatSelector()">
                                <div class="chat-option-icon">
                                    <i class="fas fa-users icon-users-green"></i>
                                </div>
                                <div class="chat-option-text">
                                    <div class="chat-option-title">群聊</div>
                                    <div class="chat-option-desc">与多个角色同时聊天</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 单聊角色选择模态框 -->
                <div class="modal" id="single-chat-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">选择聊天角色</div>
                            <button class="modal-close" onclick="hideModal('single-chat-modal')">&times;</button>
                        </div>
                        <div class="modal-body" id="single-chat-body">
                            <!-- 角色列表将通过JS动态生成 -->
                        </div>
                    </div>
                </div>

                <!-- 群聊角色选择模态框 -->
                <div class="modal" id="group-chat-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">创建群聊</div>
                            <button class="modal-close" onclick="hideModal('group-chat-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">群聊名称</label>
                                <input type="text" class="form-input" id="group-chat-name" placeholder="例如：动态分享、工作群">
                            </div>
                            <div class="form-group">
                                <label class="form-label">选择成员 (至少2人，最多20人)</label>
                                <div id="group-chat-members">
                                    <!-- 群聊成员选择将通过JS动态生成 -->
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('group-chat-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="createGroupChat()">创建群聊</button>
                        </div>
                    </div>
                </div>

                <!-- 历史消息设置模态框 -->
                <div class="modal" id="history-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">历史消息设置</div>
                            <button class="modal-close" onclick="hideModal('history-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body" style="padding: 20px;">
                            <div class="setting-card" style="margin-bottom: 20px;">
                                <div class="setting-item" style="margin-bottom: 15px;">
                                    <div class="setting-left">
                                        <div class="setting-label" style="font-size: 16px; margin-bottom: 8px;">附带历史消息数 (回合数)</div>
                                        <div class="setting-desc" style="font-size: 14px; line-height: 1.4;">AI回复时参考的历史对话回合数</div>
                                    </div>
                                    <div class="setting-right">
                                        <span class="setting-value" id="history-count-display" style="font-size: 16px; font-weight: 600;">5回合</span>
                                    </div>
                                </div>
                                <div class="setting-range-container" style="margin-bottom: 15px;">
                                    <input type="range" class="theme-range" id="history-messages-count" min="0" max="100" step="1" value="5">
                                    <div class="range-labels">
                                        <span>0回合</span>
                                        <span>100回合</span>
                                    </div>
                                </div>
                                <div class="custom-input-container" style="margin-bottom: 15px;">
                                    <span class="input-label">自定义数值：</span>
                                    <input type="number" class="theme-input" id="custom-history-count" min="0" max="500" value="5" style="width: 80px; margin: 0 8px;">
                                    <span class="input-unit">回合 (最大500)</span>
                                </div>
                                <div class="setting-explanation">
                                    <div class="explanation-text">
                                        <strong>说明：</strong><br>
                                        • 一回合 = 你的一条消息 + AI的一条回复<br>
                                        • 设置为5表示AI回复时会参考最近5回合对话<br>
                                        • 注意：数值过大可能影响API响应速度
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer" style="display: flex; justify-content: space-between; padding: 20px; gap: 0;">
                            <button class="theme-button theme-button-secondary" onclick="hideModal('history-settings-modal')" style="margin: 0; padding: 12px 20px;">取消</button>
                            <button class="theme-button theme-button-primary" onclick="saveHistorySettings()" style="margin: 0; padding: 12px 20px;">保存</button>
                        </div>
                    </div>
                </div>

                <!-- 记忆挂载设置模态框 -->
                <div class="modal" id="memory-mount-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">记忆挂载设置</div>
                            <button class="modal-close" onclick="hideModal('memory-mount-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">
                                    <input type="checkbox" id="memory-mount-enabled" class="checkbox-with-margin">
                                    启用记忆挂载
                                </label>
                                <p class="small-text margin-top-5">
                                    开启后，AI会参考其他聊天窗口的对话内容作为背景记忆
                                </p>
                            </div>
                            <div class="form-group hide" id="memory-mount-details">
                                <label class="form-label">每个聊天挂载条数</label>
                                <input type="range" class="api-form-range" id="memory-mount-count" min="1" max="20" step="1" value="3">
                                <div class="flex-space-between">
                                    <span>1条</span>
                                    <span id="memory-mount-display">3条</span>
                                    <span>20条</span>
                                </div>
                            </div>
                            <div class="form-group hide" id="memory-mount-chats">
                                <label class="form-label">选择要挂载的聊天</label>
                                <div id="memory-mount-list" class="max-height-200-auto">
                                    <!-- 聊天列表将通过JS动态生成 -->
                                </div>
                                <p class="small-text margin-top-8">
                                    选择的聊天记录会作为背景信息提供给AI参考
                                </p>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('memory-mount-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveMemoryMountSettings()">保存</button>
                        </div>
                    </div>
                </div>

                <!-- 头像设置模态框 -->
                <div class="modal" id="avatar-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">双方头像设置</div>
                            <button class="modal-close" onclick="hideModal('avatar-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="avatar-setting-group">
                                <label class="form-label">我的头像 (仅在此聊天窗口生效)</label>
                                <div class="avatar-preview-container">
                                    <div class="avatar-preview" id="my-chat-avatar-preview">
                                        <i class="fas fa-user"></i>
                                    </div>
                                    <input type="file" id="my-chat-avatar-upload" accept="image/*" class="file-input-hidden">
                                    <button class="upload-button" onclick="document.getElementById('my-chat-avatar-upload').click()">上传头像</button>
                                </div>
                            </div>
                            <div class="avatar-setting-group">
                                <label class="form-label">对方头像 (仅在此聊天窗口生效)</label>
                                <div class="avatar-preview-container">
                                    <div class="avatar-preview" id="ai-chat-avatar-preview">
                                        <i class="fas fa-robot"></i>
                                    </div>
                                    <input type="file" id="ai-chat-avatar-upload" accept="image/*" class="file-input-hidden">
                                    <button class="upload-button" onclick="document.getElementById('ai-chat-avatar-upload').click()">上传头像</button>
                                    <button class="upload-button clear-avatar-btn" onclick="clearAiChatAvatar()">清除聊天头像</button>
                                </div>
                                <p class="small-text margin-top-5">
                                    注意：如果角色在聊天中更换了头像，会覆盖此设置，点击"清除聊天头像"可重置为角色卡默认头像
                                </p>
                            </div>
                            <div class="form-group margin-top-20">
                                <label class="form-label">头像形状</label>
                                <div class="avatar-shape-options">
                                    <label class="shape-radio-option">
                                        <input type="radio" name="avatar-shape" value="circle" checked>
                                        <span class="shape-radio-text">圆形</span>
                                    </label>
                                    <label class="shape-radio-option">
                                        <input type="radio" name="avatar-shape" value="rounded-square">
                                        <span class="shape-radio-text">方形</span>
                                    </label>
                                </div>
                                <p class="small-text margin-top-5">
                                    选择头像在聊天中的显示形状
                                </p>
                            </div>
                            <div class="form-group margin-top-20">
                                <label class="form-label">
                                    <input type="checkbox" id="hide-avatars" class="checkbox-with-margin">
                                    隐藏双方头像
                                </label>
                                <p class="small-text margin-top-5">
                                    开启后，聊天界面将不显示任何头像
                                </p>
                            </div>
                            <p class="small-text margin-top-15">
                                注意：此设置仅影响当前聊天窗口显示，不会同步修改角色卡或面具设置
                            </p>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('avatar-settings-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveChatAvatarSettings()">保存</button>
                        </div>
                    </div>
                </div>

                <!-- 昵称设置模态框 -->
                <div class="modal" id="nickname-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">双方备注设置</div>
                            <button class="modal-close" onclick="hideModal('nickname-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">我的昵称 (仅在此聊天中显示)</label>
                                <input type="text" class="form-input" id="my-chat-nickname" placeholder="输入你在此聊天中的昵称">
                            </div>
                            <div class="form-group">
                                <label class="form-label">对方昵称 (仅在此聊天中显示)</label>
                                <input type="text" class="form-input" id="ai-chat-nickname" placeholder="输入对方在此聊天中的昵称">
                            </div>
                            <p class="small-text margin-top-10">
                                注意：此设置仅影响当前聊天窗口显示，不会同步修改角色卡或面具设置。角色也可能根据心情和聊天内容自主修改自己的昵称。
                            </p>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('nickname-settings-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveChatNicknameSettings()">保存</button>
                        </div>
                    </div>
                </div>

                <!-- 戳一戳后缀设置模态框 -->
                <div class="modal" id="poke-suffix-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">戳一戳后缀设置</div>
                            <button class="modal-close" onclick="hideModal('poke-suffix-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">我的戳一戳后缀</label>
                                <input type="text" class="form-input" id="my-poke-suffix" placeholder="留空为无后缀（例如：的小脸蛋）">
                                <p class="tiny-text margin-top-5">显示为：[角色名]戳了戳你[后缀]，留空则显示：[角色名]戳了戳你</p>
                            </div>
                            <div class="form-group">
                                <label class="form-label">对方戳一戳后缀</label>
                                <input type="text" class="form-input" id="ai-poke-suffix" placeholder="留空为无后缀（例如：的小手）">
                                <p class="tiny-text margin-top-5">显示为：你戳了戳[角色名][后缀]，留空则显示：你戳了戳[角色名]</p>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('poke-suffix-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="savePokeSuffixSettings()">保存</button>
                        </div>
                    </div>
                </div>

                <!-- 聊天背景设置模态框 -->
                <div class="modal" id="background-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">聊天背景设置</div>
                            <button class="modal-close" onclick="hideModal('background-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="background-preview-container">
                                <div class="background-preview" id="chat-background-preview">
                                    <div class="preview-text">背景预览</div>
                                </div>
                            </div>
                            <div class="form-group">
                                <input type="file" id="background-upload" accept="image/*" class="file-input-hidden">
                                <button class="form-button" onclick="document.getElementById('background-upload').click()">选择背景图片</button>
                                <button class="form-button form-button-secondary" onclick="removeBackground()">移除背景</button>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('background-settings-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveChatBackgroundSettings()">保存</button>
                        </div>
                    </div>
                </div>

                <!-- 🔥【新增】群成员气泡颜色设置模态框 -->
                <div class="modal" id="group-member-colors-modal" style="z-index: 10001;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">群成员气泡颜色设置</div>
                            <button class="modal-close" onclick="hideModal('group-member-colors-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="setting-explanation">
                                <div class="explanation-text">为每个群成员设置独特的气泡颜色，让群聊更加生动有趣。</div>
                            </div>
                            <div id="group-member-colors-list">
                                <!-- 动态生成群成员颜色设置项 -->
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('group-member-colors-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveGroupMemberColors()">保存</button>
                        </div>
                    </div>
                </div>

                <!-- 气泡样式设置模态框 -->
                <div class="modal" id="bubble-style-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">气泡样式设置</div>
                            <button class="modal-close" onclick="hideModal('bubble-style-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="bubble-style-section">
                                <label class="form-label">选择气泡样式</label>
                                <div class="bubble-style-grid">
                                    <div class="bubble-style-option" data-style="default">
                                        <div class="style-preview">
                                            <div class="preview-bubble sent-preview">默认样式</div>
                                            <div class="preview-bubble received-preview">经典圆角</div>
                                        </div>
                                        <div class="style-name">默认样式</div>
                                    </div>

                                    <div class="bubble-style-option" data-style="shadow">
                                        <div class="style-preview bubble-style-shadow">
                                            <div class="preview-bubble sent-preview">经典阴影</div>
                                            <div class="preview-bubble received-preview">立体感</div>
                                        </div>
                                        <div class="style-name">经典阴影</div>
                                    </div>

                                    <div class="bubble-style-option" data-style="tail">
                                        <div class="style-preview bubble-style-tail">
                                            <div class="preview-bubble sent-preview">带尖角</div>
                                            <div class="preview-bubble received-preview">气泡戳</div>
                                        </div>
                                        <div class="style-name">经典气泡</div>
                                    </div>

                                    <div class="bubble-style-option" data-style="paper">
                                        <div class="style-preview bubble-style-paper">
                                            <div class="preview-bubble sent-preview">纸张卡片</div>
                                            <div class="preview-bubble received-preview">质感</div>
                                        </div>
                                        <div class="style-name">纸张样式</div>
                                    </div>
                                </div>
                            </div>

                            <div class="color-setting-group">
                                <label class="form-label">自定义颜色</label>
                                <div class="color-picker-container">
                                    <div class="flex-gap-15">
                                        <div class="flex-1">
                                            <label class="label-small">我的气泡</label>
                                            <input type="color" id="my-bubble-color" class="color-input" value="#007AFF">
                                        </div>
                                        <div class="flex-1">
                                            <label class="label-small">对方气泡</label>
                                            <input type="color" id="ai-bubble-color" class="color-input" value="#f0f0f0">
                                            <!-- 🔥【新增】群聊角色单独设置按钮 -->
                                            <div id="group-member-colors-btn" style="display: none; margin-top: 8px;">
                                                <button type="button" class="theme-button theme-button-secondary" style="font-size: 12px; padding: 6px 12px;" onclick="showGroupMemberColorSettings()">
                                                    为群成员单独设置
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="opacity-setting">
                                    <div class="flex-gap-15-mb-15">
                                        <div class="flex-1">
                                            <label class="label-small">我的气泡透明度：<span id="my-bubble-opacity-value">100%</span></label>
                                            <input type="range" id="my-bubble-opacity" min="0.1" max="1" step="0.1" value="1" class="width-100">
                                        </div>
                                        <div class="flex-1">
                                            <label class="label-small">对方气泡透明度：<span id="ai-bubble-opacity-value">100%</span></label>
                                            <input type="range" id="ai-bubble-opacity" min="0.1" max="1" step="0.1" value="1" class="width-100">
                                        </div>
                                    </div>
                                </div>

                                <div class="padding-setting">
                                    <label class="form-label">气泡大小调节</label>
                                    <div class="flex-gap-15-mb-10">
                                        <div class="flex-1">
                                            <label class="label-small">内边距：<span id="bubble-padding-value">中等</span></label>
                                            <input type="range" id="bubble-padding" min="4" max="16" step="2" value="12" class="width-100">
                                        </div>
                                    </div>
                                    <p class="tiny-text-gray margin-top-5">
                                        调整气泡内文字与边缘的距离，数值越大气泡越大
                                    </p>
                                </div>
                            </div>

                            <!-- 自定义CSS -->
                            <div class="custom-css-section">
                                <label class="form-label">自定义CSS样式</label>
                                <textarea id="custom-bubble-css" placeholder="输入自定义CSS代码...

示例（使用标准选择器）：
/* 用户消息气泡 */
.message-container.sent .message-bubble {
    background: linear-gradient(45deg, #007AFF, #5AC8FA) !important;
    border-radius: 20px !important;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2) !important;
}

/* AI消息气泡 */
.message-container.received .message-bubble {
    background: #f0f0f0 !important;
    border-radius: 20px !important;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
}

/* 消息容器 */
.message-container {
    margin-bottom: 10px !important;
}" rows="8" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-family: monospace; font-size: 12px; resize: vertical;" oninput="updatePreview()"></textarea>
                            </div>

                            <!-- 实时预览 -->
                            <div class="preview-section">
                                <label class="form-label">实时预览</label>
                                <div class="preview-container" id="bubble-preview">
                                    <div class="preview-chat">
                                        <!-- AI消息 - 使用与实际聊天界面一致的结构 -->
                                        <div class="message-container received">
                                            <div class="message-avatar">AI</div>
                                            <div class="message-bubble" id="preview-ai">
                                                这是角色发送的消息预览
                                            </div>
                                        </div>
                                        <!-- 用户消息 - 使用与实际聊天界面一致的结构 -->
                                        <div class="message-container sent">
                                            <div class="message-bubble" id="preview-user">
                                                这是用户发送的消息预览
                                            </div>
                                            <div class="message-avatar">我</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('bubble-style-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveBubbleStyleSettings()">保存</button>
                        </div>
                    </div>
                </div>

                <!-- 定时发布设置模态框 -->
                <div class="modal" id="schedule-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">定时发布设置</div>
                            <button class="modal-close" onclick="hideModal('schedule-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">
                                    <input type="checkbox" id="schedule-enabled" class="checkbox-with-margin">
                                    启用定时发布
                                </label>
                                <p class="small-text margin-top-5">
                                    开启后，角色会在指定时间点自动发布社交动态
                                </p>
                            </div>
                            <div class="form-group hide" id="schedule-times-group">
                                <label class="form-label">发布时间点</label>
                                <div id="schedule-times-container">
                                    <!-- 时间点将通过JS动态添加 -->
                                </div>
                                <button type="button" class="form-button form-button-secondary" onclick="addScheduleTime()">+ 添加时间点</button>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('schedule-settings-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveScheduleSettings()">保存</button>
                        </div>
                    </div>
                </div>

                <!-- 身份选择器模态框 -->
                <!-- 身份选择模态框已移除，身份在创建对话时选择 -->

                <!-- 世界书挂载设置模态框 -->
                <div class="modal" id="worldbook-mount-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">世界书挂载设置</div>
                            <button class="modal-close" onclick="hideModal('worldbook-mount-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">
                                    <input type="checkbox" id="worldbook-mount-enabled" class="checkbox-with-margin">
                                    启用世界书挂载
                                </label>
                                <p class="small-text margin-top-5">
                                    开启后，AI会参考选定的世界书内容作为背景知识进行对话
                                </p>
                            </div>
                            <div class="form-group hide" id="worldbook-mount-details">
                                <label class="form-label">选择要挂载的世界书</label>
                                <div id="worldbook-mount-list" class="max-height-300-auto">
                                    <!-- 世界书列表将通过JS动态生成 -->
                                </div>
                                <p class="small-text margin-top-8">
                                    选择的世界书内容会作为背景知识提供给AI参考，帮助AI更好地理解对话上下文
                                </p>
                            </div>
                            <div class="setting-explanation">
                                <div class="explanation-text">
                                    <strong>功能说明：</strong><br>
                                    • <strong>世界书挂载：</strong>将选定的世界书内容作为AI的背景知识<br>
                                    • <strong>多选支持：</strong>可以同时挂载多个世界书，内容会合并使用<br>
                                    • <strong>智能应用：</strong>AI会根据对话内容智能引用相关的世界书知识<br>
                                    • <strong>优先级：</strong>世界书知识优先级低于角色设定和历史对话
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer" style="display: flex; justify-content: space-between; padding: 20px; gap: 0;">
                            <button class="modal-button modal-secondary" onclick="hideModal('worldbook-mount-modal')" style="margin: 0; padding: 12px 20px;">取消</button>
                            <button class="modal-button modal-primary" onclick="saveWorldbookMountSettings()" style="margin: 0; padding: 12px 20px;">保存</button>
                        </div>
                    </div>
                </div>

                <!-- 表情包库挂载设置模态框 -->
                <div class="modal" id="emoji-library-mount-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">表情包库挂载设置</div>
                            <button class="modal-close" onclick="hideModal('emoji-library-mount-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">
                                    <input type="checkbox" id="emoji-library-mount-enabled" class="checkbox-with-margin" onchange="toggleEmojiLibraryMountDetails()">
                                    启用表情包库挂载
                                </label>
                                <p class="small-text margin-top-5">
                                    开启后，聊天中的表情包面板只显示选定库中的表情包
                                </p>
                            </div>
                            <div id="emoji-library-mount-details" style="display: none;">
                                <div class="form-group">
                                    <label class="form-label">选择表情包库</label>
                                    <div id="emoji-library-mount-list" class="checkbox-list">
                                        <!-- 表情包库列表将通过JS动态生成 -->
                                    </div>
                                    <p class="small-text margin-top-5">
                                        可以选择多个表情包库，它们的表情包会合并显示
                                    </p>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer" style="display: flex; justify-content: space-between; padding: 20px; gap: 0;">
                            <button class="modal-button modal-secondary" onclick="hideModal('emoji-library-mount-modal')" style="margin: 0; padding: 12px 20px;">取消</button>
                            <button class="modal-button modal-primary" onclick="saveEmojiLibraryMountSettings()" style="margin: 0; padding: 12px 20px;">保存</button>
                        </div>
                    </div>
                </div>

                <!-- 搜索聊天内容模态框 -->
                <div class="modal" id="search-chat-modal">
                    <div class="modal-content" style="max-width: 800px; max-height: 80vh;">
                        <div class="modal-header">
                            <div class="modal-title">查找聊天内容</div>
                            <button class="modal-close" onclick="hideModal('search-chat-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">搜索关键词</label>
                                <div style="display: flex; gap: 10px;">
                                    <input type="text" id="search-keyword-input" placeholder="输入要搜索的关键词..." style="flex: 1; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px;">
                                    <button onclick="performChatSearch()" style="padding: 8px 16px; background: #4a84c1; color: white; border: none; border-radius: 6px; cursor: pointer;">搜索</button>
                                </div>
                            </div>

                            <div id="search-results-summary" style="margin: 15px 0; padding: 10px; background: #f8f9fa; border-radius: 6px; display: none;">
                                <div id="search-stats"></div>
                            </div>

                            <div id="search-results-container" style="border: 1px solid #eee; border-radius: 6px; display: none;">
                                <div id="search-results-list"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 消息上下文模态框 -->
                <div class="modal" id="message-context-modal">
                    <div class="modal-content" style="max-width: 900px; max-height: 80vh;">
                        <div class="modal-header">
                            <div class="modal-title">消息上下文</div>
                            <button class="modal-close" onclick="hideModal('message-context-modal')">&times;</button>
                        </div>
                        <div class="modal-body" style="max-height: 500px; overflow-y: auto;">
                            <div id="message-context-container" style="border: 1px solid #eee; border-radius: 6px; padding: 15px;">
                                <!-- 上下文消息将在这里显示 -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 时间戳设置模态框 -->
                <div class="modal" id="timestamp-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">时间戳设置</div>
                            <button class="modal-close" onclick="hideModal('timestamp-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">
                                    <input type="checkbox" id="timestamp-modal-enabled" class="checkbox-with-margin" checked>
                                    显示时间戳
                                </label>
                                <p class="small-text margin-top-5">
                                    在聊天消息中显示时间信息
                                </p>
                            </div>

                            <div class="form-group" id="timestamp-options-group">
                                <label class="form-label">时间戳位置</label>
                                <div class="timestamp-position-options">
                                    <label class="radio-option">
                                        <input type="radio" name="timestamp-position" value="center" checked>
                                        <span class="radio-custom"></span>
                                        <div class="option-content">
                                            <div class="option-label">居中显示</div>
                                            <div class="option-desc">时间戳显示在聊天中间，每5分钟出现一次</div>
                                        </div>
                                    </label>

                                    <label class="radio-option">
                                        <input type="radio" name="timestamp-position" value="bubble">
                                        <span class="radio-custom"></span>
                                        <div class="option-content">
                                            <div class="option-label">气泡外侧</div>
                                            <div class="option-desc">时间戳显示在每条消息气泡的外侧</div>
                                        </div>
                                    </label>

                                    <label class="radio-option">
                                        <input type="radio" name="timestamp-position" value="avatar">
                                        <span class="radio-custom"></span>
                                        <div class="option-content">
                                            <div class="option-label">头像下方</div>
                                            <div class="option-desc">时间戳显示在头像正下方位置</div>
                                        </div>
                                    </label>

                                    <label class="radio-option">
                                        <input type="radio" name="timestamp-position" value="inside">
                                        <span class="radio-custom"></span>
                                        <div class="option-content">
                                            <div class="option-label">气泡内</div>
                                            <div class="option-desc">时间戳显示在气泡内右下角，与文字齐平</div>
                                        </div>
                                    </label>
                                </div>
                            </div>

                            <div class="setting-explanation">
                                <div class="explanation-text">
                                    <strong>位置说明：</strong><br>
                                    • <strong>居中显示：</strong>时间戳水平居中，仅在超过5分钟间隔时显示<br>
                                    • <strong>气泡外侧：</strong>每条消息都显示时间，用户消息在左下角，角色消息在右下角<br>
                                    • <strong>头像下方：</strong>时间戳显示在对应头像的正下方位置<br>
                                    • 所有时间戳均使用灰色小字显示，不影响聊天体验
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('timestamp-settings-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveTimestampSettings()">保存</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    <!-- 转账功能相关模态框 -->
    <div id="transfer-modal">
        <div class="transfer-content">
                            <div class="transfer-header">发起转账</div>
            <div class="transfer-input-group">
                <label for="transfer-amount">转账金额</label>
                                    <input type="number" id="transfer-amount" placeholder="0.00" min="0" max="1000000000" step="0.01">
            </div>
            <div class="transfer-input-group">
                <label for="transfer-note">备注 (可选)</label>
                                    <input type="text" id="transfer-note" placeholder="说点什么吧..." maxlength="20">
            </div>
            <div class="transfer-actions">
                <button id="transfer-cancel-btn">取消</button>
                <button id="transfer-confirm-btn">确认转账</button>
            </div>
        </div>
    </div>

    <div id="transfer-confirm-modal">
        <div class="transfer-confirm-content">
            <div class="transfer-confirm-title">收到一笔转账</div>
            <div class="transfer-confirm-info">
                <div class="transfer-confirm-amount">¥ 0.00</div>
                <div class="transfer-confirm-note">备注：</div>
            </div>
            <div class="transfer-confirm-actions">
                <button id="transfer-reject-btn">退回</button>
                <button id="transfer-accept-btn">确认收款</button>
                </div>
            </div>
        </div>



    <!-- 播放列表模态框 -->
    <div id="playlist-modal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 500px; max-height: 80vh; overflow-y: auto;">
            <div class="modal-header">
                <h3>播放列表</h3>
                <button class="close-btn" onclick="closePlaylistModal()">&times;</button>
            </div>

            <div class="playlist-content">
                <!-- 添加歌曲区域 -->
                <div class="add-song-section">
                    <h4>添加新歌曲</h4>
                    <div class="input-row">
                        <input type="text" id="song-title-input" placeholder="歌曲标题" class="song-input half-width">
                        <input type="text" id="song-artist-input" placeholder="艺术家" class="song-input half-width">
                    </div>
                    <div class="input-row">
                        <input type="text" id="song-url-input" placeholder="歌曲URL或选择本地文件" class="song-input half-width">
                        <div class="file-input-wrapper half-width">
                            <button onclick="document.getElementById('local-music-input').click()" class="upload-btn" style="width: 100%; padding: 8px;">
                                <i class="fas fa-file-audio"></i> 本地音乐
                            </button>
                        </div>
                    </div>
                    <div class="input-row">
                        <div class="file-input-wrapper half-width">
                            <input type="file" id="song-cover-input" accept="image/*,.jpg,.jpeg,.png,.gif,.webp" class="file-input" title="选择封面图片">
                            <span class="file-input-text">未选封面</span>
                        </div>
                        <div class="file-input-wrapper half-width">
                            <button onclick="document.getElementById('lyrics-file-input').click()" class="upload-btn" style="width: 100%; padding: 8px;">
                                <i class="fas fa-file-text"></i> 歌词文件
                            </button>
                        </div>
                    </div>
                    <div class="lyrics-input-section">
                        <div id="lyrics-file-status" style="display: none; padding: 12px; border: 1px solid #ddd; border-radius: 6px; background-color: #f8f9fa; color: #007AFF; font-size: 14px; text-align: center;">
                            <!-- 选择歌词文件后显示状态 -->
                        </div>
                        <div style="display: flex; gap: 8px; margin-top: 8px; font-size: 11px; color: #666;">
                            <span>支持格式：LRC、TXT、bin等歌词文件（iPhone用户可选择任意文件）</span>
                        </div>
                        <div style="margin-top: 6px; font-size: 11px; color: #666;">
                            <span>💡 推荐使用在线URL，导入本地歌曲可能会带来内存负担</span>
                        </div>
                    </div>
                    <!-- 隐藏的文件输入 -->
                    <input type="file" id="local-music-input" accept="audio/*,.mp3,.m4a,.wav,.aac,.ogg,.flac" style="display: none;">
                    <input type="file" id="lyrics-file-input" style="display: none;">
                    <button onclick="addCustomSong()" class="add-song-btn">
                        添加歌曲
                    </button>
                </div>

                <!-- 当前播放列表 -->
                <div class="current-playlist">
                    <h4>当前播放列表</h4>
                    <div id="playlist-items" class="playlist-items">
                        <!-- 播放列表项将在这里动态生成 -->
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- 音乐播放模态框 -->
    <div id="music-modal" class="music-modal" style="display: none;">
        <div class="music-modal-content">
            <div class="music-modal-header">
                <button class="music-modal-close" onclick="closeMusicModal()">
                    <i class="fas fa-times"></i>
                </button>
                <div class="music-header-title">正在播放</div>
                <button class="music-view-toggle" onclick="toggleMusicView()" id="view-toggle-btn">
                    <i class="fas fa-list"></i>
                </button>
            </div>

            <div class="music-modal-body">
                <!-- 唱片机模式 -->
                <div id="vinyl-mode" class="music-view-mode">
                    <div class="vinyl-player">
                        <div class="vinyl-container">
                            <div class="vinyl-disc" id="vinyl-disc">
                                <div class="vinyl-grooves"></div>
                                <div class="vinyl-center"></div>
                                <div class="vinyl-label">
                                    <img id="album-cover" class="album-cover-display" style="display: none;" />
                                    <!-- 只显示封面，不支持点击上传 -->
                                </div>
                            </div>
                            <div class="tonearm" id="tonearm"></div>
                        </div>

                        <div class="song-info">
                            <div class="song-title" id="vinyl-song-title">选择歌曲</div>
                            <div class="song-artist" id="vinyl-artist-name">未知艺术家</div>
                        </div>

                        <div class="vinyl-lyrics">
                            <div class="lyrics-container">
                                <div class="lyric-line active" id="lyric-current">点击播放开始听歌</div>
                            </div>
                        </div>
                    </div>
                </div>



                <!-- 完整歌词模式 -->
                <div id="lyrics-mode" class="music-view-mode" style="display: none;">
                    <div class="lyrics-mode">
                        <div class="lyrics-header">
                            <div class="song-title" id="lyrics-song-title">选择歌曲</div>
                            <div class="song-artist" id="lyrics-artist-name">未知艺术家</div>
                        </div>
                        <div class="full-lyrics-container">
                            <div class="full-lyrics" id="full-lyrics-display">
                                <div class="lyric-line active">♪ 点击播放开始听歌</div>
                                <div class="lyric-line">选择你喜欢的歌曲</div>
                                <div class="lyric-line">和角色一起享受音乐时光</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="music-modal-controls">
                <!-- 当前歌词显示 -->
                <div class="current-lyric-display">
                    <div class="current-lyric-text" id="current-lyric-text">♪ 点击播放开始听歌</div>
                </div>

                <div class="music-progress">
                    <div class="progress-bar">
                        <div class="progress-fill" id="modal-progress"></div>
                    </div>
                    <div class="time-display">
                        <span id="modal-current-time">0:00</span>
                        <span id="modal-total-time">0:00</span>
                    </div>
                </div>

                <div class="music-control-buttons">
                    <button class="control-btn shuffle" id="play-mode-btn" onclick="togglePlayMode()" title="顺序播放">
                        <i class="fas fa-list-ol"></i>
                    </button>
                    <button class="control-btn" onclick="previousTrack()" title="上一首">
                        <i class="fas fa-step-backward"></i>
                    </button>
                    <button class="control-btn play-pause-btn" id="modal-play-btn" onclick="togglePlayback()" title="播放/暂停">
                        <i class="fas fa-play"></i>
                    </button>
                    <button class="control-btn" onclick="nextTrack()" title="下一首">
                        <i class="fas fa-step-forward"></i>
                    </button>
                    <button class="control-btn playlist" id="playlist-btn" onclick="openPlaylistModal()" title="播放列表">
                        <i class="fas fa-music"></i>
                    </button>
                </div>

                <div class="listening-time">
                    <i class="fas fa-clock"></i>
                    <span id="listening-duration">已一起听 0 分钟</span>
                </div>
            </div>

            <!-- 关闭按钮 - 关机按钮样式 -->
            <button class="music-close-btn" onclick="closeMusicPlayer()" title="结束听歌">
                <i class="fas fa-power-off"></i>
            </button>


        </div>
    </div>

<script>
    // ===============================================================
    // 🔥 发布前开关：将下方 true 改为 false 即可屏蔽所有调试信息
    // ===============================================================
    const isProduction = false; 

    if (isProduction) {
        console.log = function() {};    // 屏蔽 console.log
        console.info = function() {};   // 屏蔽 console.info
        console.warn = function() {};   // 屏蔽 console.warn
        // 注意：我们通常保留 console.error 以便追踪重要错误
    }
</script>

    <script>
        // 🔥【新增修复】定义一个Promise来确保数据完全加载后再执行后续操作
        let dataLoadedPromise;
        let resolveDataLoaded;

        function initializeDataLoadPromise() {
            dataLoadedPromise = new Promise(resolve => {
                resolveDataLoaded = resolve;
            });
        }

        // 🔥【完全修复】初始化Dexie数据库 - 解决版本升级死循环问题
        window.db = new Dexie('PhoneChatDB');
        // 🔥【关键修复】创建全局别名，确保所有代码都能访问数据库
        var db = window.db;
        window.activeGlobalWorldbooks = []; // 用于存储当前激活的全局世界书ID

        // 🔥【新增】数据库重置功能
        async function resetDatabase() {
            try {
                console.log('🔄 开始重置数据库...');

                // 关闭数据库连接
                if (db.isOpen()) {
                    db.close();
                }

                // 删除数据库
                await db.delete();
                console.log('✅ 数据库已删除');

                // 重新打开数据库（会自动创建新的）
                await db.open();
                console.log('✅ 数据库已重新创建');

                return true;
            } catch (error) {
                console.error('❌ 重置数据库失败:', error);
                return false;
            }
        }

        // 🔥【新增】检查数据库健康状态
        async function checkDatabaseHealth() {
            try {
                await db.open();

                // 测试基本表访问
                const testTables = ['characters', 'chatMessages', 'apiSettings'];
                for (const tableName of testTables) {
                    await db[tableName].count();
                }

                console.log('✅ 数据库健康检查通过');
                return true;
            } catch (error) {
                console.error('❌ 数据库健康检查失败:', error);
                return false;
            }
        }

        // 全局变量
        let characters = [];
        let contacts = [];
        let currentChatCharacter = null;
        let chatMessages = {};
        let selectedMessageId = null;
        let pinnedConversations = []; // 🔥【新增】置顶对话列表
        let personas = []; // 用户面具列表
        let editingPersona = null; // 正在编辑的面具
        let isMultiSelectMode = false; // 多选模式状态
        let selectedCharacters = []; // 选中的角色ID列表
        let currentEditingCharacterId = null; // 当前正在编辑的角色ID
        let groupChats = []; // 群聊列表

        // 🔥【新增】音效管理系统
        const SoundManager = {
            sounds: {},
            characterSounds: {}, // 角色专属音效缓存
            enabled: true,
            currentlyPlaying: {}, // 🔥【新增】跟踪当前播放的音效
            isUnlocked: false, // 🔥【新增】音频上下文解锁状态

            // 音效类型定义
            TYPES: {
                MESSAGE_RECEIVED: 'messageReceived',
                MESSAGE_SENT: 'messageSent',
                NOTIFICATION: 'notification',
                OUTGOING_CALL: 'outgoingCall',
                INCOMING_CALL: 'incomingCall'
            },

            // 初始化音效管理器
            async init() {
                try {
                    // 从localStorage加载音效开关状态
                    const soundEnabled = localStorage.getItem('soundEnabled');
                    if (soundEnabled !== null) {
                        this.enabled = soundEnabled === 'true';
                    } else {
                        // 默认启用音效
                        this.enabled = true;
                        localStorage.setItem('soundEnabled', 'true');
                    }

                    await this.loadSettings();
                    console.log('🔊 音效管理器初始化完成，状态:', this.enabled);
                } catch (error) {
                    console.error('❌ 音效管理器初始化失败:', error);
                }
            },

            // 从数据库加载音效设置
            async loadSettings() {
                try {
                    // 加载全局音效设置
                    const settings = await db.soundSettings.toArray();
                    for (const setting of settings) {
                        if (setting.enabled && setting.sourceUrl) {
                            await this.loadSound(setting.soundType, setting.sourceUrl, setting.sourceType);
                        }
                    }

                    // 加载角色专属音效设置
                    const characterSettings = await db.characterSounds.toArray();
                    for (const setting of characterSettings) {
                        if (setting.enabled && setting.sourceUrl) {
                            await this.loadCharacterSound(setting.characterId, setting.soundType, setting.sourceUrl, setting.sourceType);
                        }
                    }
                } catch (error) {
                    console.error('加载音效设置失败:', error);
                }
            },

            // 加载单个音效
            async loadSound(soundType, sourceUrl, sourceType = 'url') {
                try {
                    if (!sourceUrl) return false;

                    const audio = new Audio();
                    audio.preload = 'auto';
                    audio.src = sourceUrl;

                    // 等待音频加载完成
                    await new Promise((resolve, reject) => {
                        audio.addEventListener('canplaythrough', resolve, { once: true });
                        audio.addEventListener('error', reject, { once: true });
                        audio.load();
                    });

                    this.sounds[soundType] = audio;
                    console.log(`✅ 音效加载成功: ${soundType}`);
                    return true;
                } catch (error) {
                    console.error(`❌ 音效加载失败 (${soundType}):`, error);
                    return false;
                }
            },

            // 播放音效（支持角色专属音效和静音模式）
            play(soundType, characterId = null) {
                if (!this.enabled) return;

                try {
                    // 🔥【新增】最高优先级：检查角色静音模式
                    if (characterId && this.characterSounds[characterId] && this.characterSounds[characterId]['silent']) {
                        console.log(`🔇 角色静音模式: ${characterId} - ${soundType} (已静音)`);
                        return; // 静音模式，直接返回不播放任何音效
                    }

                    let audio = null;

                    // 优先使用角色专属音效
                    if (characterId && this.characterSounds[characterId] && this.characterSounds[characterId][soundType]) {
                        audio = this.characterSounds[characterId][soundType].cloneNode();
                        console.log(`🎵 播放角色专属音效: ${characterId} - ${soundType}`);
                    }
                    // 回退到全局音效
                    else if (this.sounds[soundType]) {
                        audio = this.sounds[soundType].cloneNode();
                        console.log(`🎵 播放全局音效: ${soundType}`);
                    }

                    if (audio) {
                        audio.volume = 0.7;

                        // 🔥【新增】跟踪当前播放的音效
                        this.currentlyPlaying[soundType] = audio;

                        // 🔥【新增】音效结束时清理跟踪
                        audio.addEventListener('ended', () => {
                            delete this.currentlyPlaying[soundType];
                        });

                        // 🔥【手机修复】添加用户交互检查
                        const playPromise = audio.play();
                        if (playPromise !== undefined) {
                            playPromise.catch(error => {
                                console.warn(`音效播放失败 (${soundType}):`, error);
                                delete this.currentlyPlaying[soundType];

                                // 🔥【关键】如果是权限问题，在下次用户交互时重试
                                if (error.name === 'NotAllowedError') {
                                    this.scheduleRetryOnUserInteraction(soundType, characterId);
                                }
                            });
                        }
                    }
                } catch (error) {
                    console.error(`音效播放错误 (${soundType}):`, error);
                }
            },

            // 🔥【修复】只在首次权限问题时重试，避免每次都需要交互
            scheduleRetryOnUserInteraction(soundType, characterId) {
                // 如果已经解锁过，就不再重试
                if (this.isUnlocked) return;

                const retryPlay = () => {
                    console.log(`🔄 用户交互后重试播放音效: ${soundType}`);
                    this.isUnlocked = true; // 标记为已解锁
                    this.play(soundType, characterId);
                    // 移除监听器
                    ['touchstart', 'mousedown', 'keydown', 'click'].forEach(event => {
                        document.removeEventListener(event, retryPlay);
                    });
                };

                // 监听下次用户交互
                ['touchstart', 'mousedown', 'keydown', 'click'].forEach(event => {
                    document.addEventListener(event, retryPlay, { once: true, passive: true });
                });
            },

            // 🔥【新增】停止指定类型的音效
            stopSound(soundType) {
                try {
                    if (this.currentlyPlaying[soundType]) {
                        this.currentlyPlaying[soundType].pause();
                        this.currentlyPlaying[soundType].currentTime = 0;
                        delete this.currentlyPlaying[soundType];
                        console.log(`🔇 已停止音效: ${soundType}`);
                    }
                } catch (error) {
                    console.error(`停止音效失败 (${soundType}):`, error);
                }
            },

            // 🔥【新增】停止所有音效
            stopAllSounds() {
                try {
                    Object.keys(this.currentlyPlaying).forEach(soundType => {
                        this.stopSound(soundType);
                    });
                    console.log('🔇 已停止所有音效');
                } catch (error) {
                    console.error('停止所有音效失败:', error);
                }
            },

            // 试听音效（限制5秒）
            test(soundType) {
                if (!this.enabled || !this.sounds[soundType]) return;

                try {
                    const audio = this.sounds[soundType].cloneNode();
                    audio.volume = 0.7;

                    // 5秒后自动停止
                    const stopTimer = setTimeout(() => {
                        audio.pause();
                        audio.currentTime = 0;
                    }, 5000);

                    // 如果音频自然结束，清除定时器
                    audio.addEventListener('ended', () => {
                        clearTimeout(stopTimer);
                    });

                    audio.play().catch(error => {
                        console.warn(`音效试听失败 (${soundType}):`, error);
                        clearTimeout(stopTimer);
                    });
                } catch (error) {
                    console.error(`音效试听错误 (${soundType}):`, error);
                }
            },

            // 设置音效
            async setSound(soundType, sourceUrl, sourceType = 'url') {
                try {
                    // 清理旧音效
                    if (this.sounds[soundType]) {
                        this.sounds[soundType] = null;
                    }

                    if (!sourceUrl) {
                        // 清除音效设置
                        await db.soundSettings.delete(soundType);
                        return true;
                    }

                    // 加载新音效
                    const success = await this.loadSound(soundType, sourceUrl, sourceType);
                    if (success) {
                        // 保存到数据库
                        await db.soundSettings.put({
                            id: soundType,
                            soundType: soundType,
                            sourceType: sourceType,
                            sourceUrl: sourceUrl,
                            enabled: true,
                            timestamp: Date.now()
                        });
                    }
                    return success;
                } catch (error) {
                    console.error(`设置音效失败 (${soundType}):`, error);
                    return false;
                }
            },



            // 清除音效
            async clearSound(soundType) {
                try {
                    if (this.sounds[soundType]) {
                        this.sounds[soundType] = null;
                    }
                    await db.soundSettings.delete(soundType);
                    console.log(`✅ 音效已清除: ${soundType}`);
                    return true;
                } catch (error) {
                    console.error(`清除音效失败 (${soundType}):`, error);
                    return false;
                }
            },

            // 启用/禁用音效系统
            setEnabled(enabled) {
                this.enabled = enabled;
                localStorage.setItem('soundEnabled', enabled.toString());
            },

            // 获取音效设置
            async getSetting(soundType) {
                try {
                    return await db.soundSettings.get(soundType);
                } catch (error) {
                    console.error(`获取音效设置失败 (${soundType}):`, error);
                    return null;
                }
            },

            // 🔥【新增】角色专属音效管理方法

            // 加载角色专属音效
            async loadCharacterSound(characterId, soundType, sourceUrl, sourceType = 'url') {
                try {
                    if (!sourceUrl) return false;

                    // 🔥【新增】特殊处理静音模式
                    if (soundType === 'silent' && sourceUrl === 'silent') {
                        // 初始化角色音效缓存
                        if (!this.characterSounds[characterId]) {
                            this.characterSounds[characterId] = {};
                        }

                        this.characterSounds[characterId]['silent'] = true; // 静音标记
                        console.log(`✅ 角色静音模式设置成功: ${characterId}`);
                        return true;
                    }

                    // 🔥【新增】特殊处理开关状态标记
                    if (soundType === 'enabled' && sourceUrl === 'enabled') {
                        // 初始化角色音效缓存
                        if (!this.characterSounds[characterId]) {
                            this.characterSounds[characterId] = {};
                        }

                        this.characterSounds[characterId]['enabled'] = true; // 开关状态标记
                        console.log(`✅ 角色专属音效开关状态保存成功: ${characterId}`);
                        return true;
                    }

                    const audio = new Audio();
                    audio.preload = 'auto';
                    audio.src = sourceUrl;

                    await new Promise((resolve, reject) => {
                        audio.addEventListener('canplaythrough', resolve, { once: true });
                        audio.addEventListener('error', reject, { once: true });
                        audio.load();
                    });

                    // 初始化角色音效缓存
                    if (!this.characterSounds[characterId]) {
                        this.characterSounds[characterId] = {};
                    }

                    this.characterSounds[characterId][soundType] = audio;
                    console.log(`✅ 角色专属音效加载成功: ${characterId} - ${soundType}`);
                    return true;
                } catch (error) {
                    console.error(`❌ 角色专属音效加载失败 (${characterId} - ${soundType}):`, error);
                    return false;
                }
            },

            // 设置角色专属音效
            async setCharacterSound(characterId, soundType, sourceUrl, sourceType = 'url') {
                try {
                    // 清理旧音效
                    if (this.characterSounds[characterId] && this.characterSounds[characterId][soundType]) {
                        this.characterSounds[characterId][soundType] = null;
                    }

                    if (!sourceUrl) {
                        // 清除音效设置
                        await db.characterSounds.where({characterId: characterId, soundType: soundType}).delete();
                        return true;
                    }

                    // 加载新音效
                    const success = await this.loadCharacterSound(characterId, soundType, sourceUrl, sourceType);
                    if (success) {
                        // 保存到数据库
                        await db.characterSounds.put({
                            characterId: characterId,
                            soundType: soundType,
                            sourceType: sourceType,
                            sourceUrl: sourceUrl,
                            enabled: true,
                            timestamp: Date.now()
                        });
                    }
                    return success;
                } catch (error) {
                    console.error(`设置角色专属音效失败 (${characterId} - ${soundType}):`, error);
                    return false;
                }
            },

            // 清除角色专属音效
            async clearCharacterSound(characterId, soundType) {
                try {
                    if (this.characterSounds[characterId] && this.characterSounds[characterId][soundType]) {
                        // 🔥【新增】特殊处理静音模式和开关状态清除
                        if (soundType === 'silent' || soundType === 'enabled') {
                            delete this.characterSounds[characterId][soundType];
                        } else {
                            this.characterSounds[characterId][soundType] = null;
                        }
                    }
                    await db.characterSounds.where({characterId: characterId, soundType: soundType}).delete();
                    console.log(`✅ 角色专属音效已清除: ${characterId} - ${soundType}`);
                    return true;
                } catch (error) {
                    console.error(`清除角色专属音效失败 (${characterId} - ${soundType}):`, error);
                    return false;
                }
            },

            // 获取角色专属音效设置
            async getCharacterSetting(characterId, soundType) {
                try {
                    return await db.characterSounds.where({characterId: characterId, soundType: soundType}).first();
                } catch (error) {
                    console.error(`获取角色专属音效设置失败 (${characterId} - ${soundType}):`, error);
                    return null;
                }
            },

            // 清除角色的所有专属音效
            async clearAllCharacterSounds(characterId) {
                try {
                    if (this.characterSounds[characterId]) {
                        this.characterSounds[characterId] = {};
                    }
                    await db.characterSounds.where('characterId').equals(characterId).delete();
                    console.log(`✅ 角色所有专属音效已清除: ${characterId}`);
                    return true;
                } catch (error) {
                    console.error(`清除角色所有专属音效失败 (${characterId}):`, error);
                    return false;
                }
            }
        };

        // 🔥【新增】音效设置界面相关函数

        // 切换音效系统开关
        function toggleSoundSystem() {
            const checkbox = document.getElementById('sound-enabled');
            if (!checkbox) {
                console.error('❌ 找不到音效开关元素');
                return;
            }

            const enabled = checkbox.checked;
            console.log('🔊 音效开关状态:', enabled);

            SoundManager.setEnabled(enabled);

            // 更新界面状态
            const soundList = document.getElementById('sound-settings-list');
            if (soundList) {
                soundList.style.opacity = enabled ? '1' : '0.5';
                soundList.style.pointerEvents = enabled ? 'auto' : 'none';
            }

            showToast(enabled ? '音效已启用' : '音效已禁用', 'success');
        }

        // 处理音效文件上传
        function handleSoundFileUpload(fileInput, soundType) {
            const file = fileInput.files[0];
            if (!file) return;

            // 检查文件大小（3MB限制）
            if (file.size > 3 * 1024 * 1024) {
                showToast('音效文件不能超过3MB', 'error');
                fileInput.value = '';
                return;
            }

            // 检查文件类型
            if (!file.type.startsWith('audio/')) {
                showToast('请选择音频文件', 'error');
                fileInput.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = async (e) => {
                const success = await SoundManager.setSound(soundType, e.target.result, 'file');
                if (success) {
                    showToast('音效设置成功', 'success');
                    // 更新URL输入框显示
                    const urlInput = document.getElementById(`sound-${soundType}-url`);
                    if (urlInput) {
                        urlInput.value = file.name;
                        urlInput.disabled = true;
                    }
                } else {
                    showToast('音效设置失败', 'error');
                }
                fileInput.value = '';
            };
            reader.readAsDataURL(file);
        }

        // 测试播放音效
        function testSound(soundType) {
            SoundManager.test(soundType);
        }

        // 清除音效
        async function clearSound(soundType) {
            const success = await SoundManager.clearSound(soundType);
            if (success) {
                showToast('音效已清除', 'success');
                // 清空URL输入框
                const urlInput = document.getElementById(`sound-${soundType}-url`);
                if (urlInput) {
                    urlInput.value = '';
                    urlInput.disabled = false;
                }
            } else {
                showToast('清除音效失败', 'error');
            }
        }

        // 设置在线音效链接
        async function setSoundFromUrl(soundType) {
            const urlInput = document.getElementById(`sound-${soundType}-url`);
            if (!urlInput) return;

            const url = urlInput.value.trim();
            if (!url) {
                showToast('请输入音效链接', 'error');
                return;
            }

            const success = await SoundManager.setSound(soundType, url, 'url');
            if (success) {
                showToast('音效设置成功', 'success');
            } else {
                showToast('音效设置失败，请检查链接是否有效', 'error');
            }
        }

        // 初始化音效设置界面
        async function initSoundSettings() {
            try {
                // 设置音效开关状态
                const soundEnabled = document.getElementById('sound-enabled');
                if (soundEnabled) {
                    soundEnabled.checked = SoundManager.enabled;
                    console.log('🔊 音效开关状态:', SoundManager.enabled);
                }

                // 加载已保存的音效设置
                const soundTypes = ['messageReceived', 'messageSent', 'notification', 'outgoingCall', 'incomingCall'];

                for (const soundType of soundTypes) {
                    const setting = await SoundManager.getSetting(soundType);
                    const urlInput = document.getElementById(`sound-${soundType}-url`);

                    if (setting && urlInput) {
                        if (setting.sourceType === 'file') {
                            urlInput.value = '已设置本地文件';
                            urlInput.disabled = true;
                        } else {
                            urlInput.value = setting.sourceUrl || '';
                            urlInput.disabled = false;
                        }
                    }
                }

                // 手动更新界面状态（不调用toggleSoundSystem避免重复toast）
                const soundList = document.getElementById('sound-settings-list');
                if (soundList) {
                    soundList.style.opacity = SoundManager.enabled ? '1' : '0.5';
                    soundList.style.pointerEvents = SoundManager.enabled ? 'auto' : 'none';
                }

                console.log('✅ 音效设置界面初始化完成');
            } catch (error) {
                console.error('❌ 音效设置界面初始化失败:', error);
            }
        }

        // 🔥【修改】为URL输入框添加回车键监听 - 避免重复绑定
        let soundEventListenersInitialized = false;

        function initSoundEventListeners() {
            if (soundEventListenersInitialized) return;

            const soundTypes = ['messageReceived', 'messageSent', 'notification', 'outgoingCall', 'incomingCall'];

            soundTypes.forEach(soundType => {
                // 全局音效输入框
                const urlInput = document.getElementById(`sound-${soundType}-url`);
                if (urlInput) {
                    urlInput.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') {
                            setSoundFromUrl(soundType);
                        }
                    });

                    urlInput.addEventListener('blur', function() {
                        if (this.value.trim()) {
                            setSoundFromUrl(soundType);
                        }
                    });
                }

                // 角色专属音效输入框
                const characterUrlInput = document.getElementById(`character-${soundType}-url`);
                if (characterUrlInput) {
                    // 🔥【修复】使用箭头函数确保正确的作用域
                    characterUrlInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            setCharacterSoundFromUrl(soundType);
                        }
                    });

                    characterUrlInput.addEventListener('blur', (e) => {
                        if (e.target.value.trim()) {
                            setCharacterSoundFromUrl(soundType);
                        }
                    });
                }
            });

            soundEventListenersInitialized = true;
            console.log('🎵 音效事件监听器初始化完成');
        }

        // 为URL输入框添加回车键监听
        document.addEventListener('DOMContentLoaded', function() {
            initSoundEventListeners();
        });

        // 🔥【新增】角色专属音效管理函数

        // 切换角色专属音效开关
        async function toggleCharacterSounds() {
            const enabled = document.getElementById('character-sound-enabled').checked;
            const soundList = document.getElementById('character-sound-list');

            if (soundList) {
                soundList.style.display = enabled ? 'block' : 'none';
            }

            if (!currentChatCharacter) {
                showToast('请先选择角色', 'error');
                return;
            }

            try {
                if (enabled) {
                    // 保存开关状态到数据库
                    await SoundManager.setCharacterSound(currentChatCharacter.id, 'enabled', 'enabled', 'enabled');
                    showToast('角色专属音效已启用', 'success');
                } else {
                    // 清除该角色的所有专属音效和开关状态
                    await SoundManager.clearAllCharacterSounds(currentChatCharacter.id);
                    showToast('角色专属音效已禁用', 'success');
                }
            } catch (error) {
                console.error('保存专属音效开关状态失败:', error);
                showToast('保存设置失败', 'error');
            }
        }

        // 处理角色专属音效文件上传
        function handleCharacterSoundFileUpload(fileInput, soundType) {
            if (!currentChatCharacter) {
                showToast('请先选择角色', 'error');
                return;
            }

            const file = fileInput.files[0];
            if (!file) return;

            // 检查文件大小（3MB限制）
            if (file.size > 3 * 1024 * 1024) {
                showToast('音效文件不能超过3MB', 'error');
                fileInput.value = '';
                return;
            }

            // 检查文件类型
            if (!file.type.startsWith('audio/')) {
                showToast('请选择音频文件', 'error');
                fileInput.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = async (e) => {
                const success = await SoundManager.setCharacterSound(currentChatCharacter.id, soundType, e.target.result, 'file');
                if (success) {
                    showToast('角色专属音效设置成功', 'success');
                    // 更新URL输入框显示
                    const urlInput = document.getElementById(`character-${soundType}-url`);
                    if (urlInput) {
                        urlInput.value = file.name;
                        urlInput.disabled = true;
                    }
                } else {
                    showToast('角色专属音效设置失败', 'error');
                }
                fileInput.value = '';
            };
            reader.readAsDataURL(file);
        }

        // 测试播放角色专属音效
        function testCharacterSound(soundType) {
            if (!currentChatCharacter) {
                showToast('请先选择角色', 'error');
                return;
            }

            // 使用SoundManager的test方法，但指定角色ID
            if (SoundManager.characterSounds[currentChatCharacter.id] && SoundManager.characterSounds[currentChatCharacter.id][soundType]) {
                // 手动播放角色专属音效
                const audio = SoundManager.characterSounds[currentChatCharacter.id][soundType].cloneNode();
                audio.volume = 0.7;

                // 5秒后自动停止
                const stopTimer = setTimeout(() => {
                    audio.pause();
                    audio.currentTime = 0;
                }, 5000);

                audio.addEventListener('ended', () => {
                    clearTimeout(stopTimer);
                });

                audio.play().catch(error => {
                    console.warn(`角色专属音效试听失败:`, error);
                    clearTimeout(stopTimer);
                });
            } else {
                showToast('请先设置该音效', 'error');
            }
        }

        // 清除角色专属音效
        async function clearCharacterSound(soundType) {
            if (!currentChatCharacter) {
                showToast('请先选择角色', 'error');
                return;
            }

            const success = await SoundManager.clearCharacterSound(currentChatCharacter.id, soundType);
            if (success) {
                showToast('角色专属音效已清除', 'success');
                // 清空URL输入框
                const urlInput = document.getElementById(`character-${soundType}-url`);
                if (urlInput) {
                    urlInput.value = '';
                    urlInput.disabled = false;
                }
            } else {
                showToast('清除角色专属音效失败', 'error');
            }
        }

        // 设置角色专属在线音效链接
        async function setCharacterSoundFromUrl(soundType) {
            if (!currentChatCharacter) {
                showToast('请先选择角色', 'error');
                return;
            }

            const urlInput = document.getElementById(`character-${soundType}-url`);
            if (!urlInput) return;

            const url = urlInput.value.trim();
            if (!url) {
                showToast('请输入音效链接', 'error');
                return;
            }

            const success = await SoundManager.setCharacterSound(currentChatCharacter.id, soundType, url, 'url');
            if (success) {
                showToast('角色专属音效设置成功', 'success');
            } else {
                showToast('角色专属音效设置失败，请检查链接是否有效', 'error');
            }
        }

        // 切换角色静音模式
        async function toggleCharacterSilentMode() {
            if (!currentChatCharacter) {
                showToast('请先选择角色', 'error');
                return;
            }

            const silentCheckbox = document.getElementById('character-silent-mode');
            const isSilent = silentCheckbox.checked;

            try {
                if (isSilent) {
                    // 设置静音模式
                    const success = await SoundManager.setCharacterSound(currentChatCharacter.id, 'silent', 'silent', 'silent');
                    if (success) {
                        showToast(`${currentChatCharacter.name} 已设为静音角色`, 'success');
                    } else {
                        showToast('设置静音模式失败', 'error');
                        silentCheckbox.checked = false; // 回滚开关状态
                    }
                } else {
                    // 取消静音模式
                    const success = await SoundManager.clearCharacterSound(currentChatCharacter.id, 'silent');
                    if (success) {
                        showToast(`${currentChatCharacter.name} 已取消静音`, 'success');
                    } else {
                        showToast('取消静音模式失败', 'error');
                        silentCheckbox.checked = true; // 回滚开关状态
                    }
                }
            } catch (error) {
                console.error('切换静音模式失败:', error);
                showToast('切换静音模式失败', 'error');
                silentCheckbox.checked = !isSilent; // 回滚开关状态
            }
        }

        // 🔥【新增】清理角色专属音效设置界面
        function clearCharacterSoundSettingsUI() {
            const soundTypes = ['messageReceived', 'incomingCall', 'notification'];

            // 清空所有输入框
            soundTypes.forEach(soundType => {
                const urlInput = document.getElementById(`character-${soundType}-url`);
                if (urlInput) {
                    urlInput.value = '';
                    urlInput.disabled = false;
                }
            });

            // 重置开关状态
            const soundEnabled = document.getElementById('character-sound-enabled');
            if (soundEnabled) {
                soundEnabled.checked = false;
            }

            const soundList = document.getElementById('character-sound-list');
            if (soundList) {
                soundList.style.display = 'none';
            }

            // 重置静音开关
            const silentCheckbox = document.getElementById('character-silent-mode');
            if (silentCheckbox) {
                silentCheckbox.checked = false;
            }

            console.log('🧹 角色专属音效设置界面已清理');
        }

        // 初始化角色专属音效设置界面
        async function initCharacterSoundSettings() {
            if (!currentChatCharacter) return;

            // 🔥【新增】确保事件监听器已初始化
            initSoundEventListeners();

            // 🔥【新增】先清理界面，避免显示其他角色的设置
            clearCharacterSoundSettingsUI();

            try {
                // 检查是否有任何专属音效设置
                const soundTypes = ['messageReceived', 'incomingCall', 'notification'];
                let hasAnySetting = false;

                // 🔥【新增】检查专属音效开关状态
                const enabledSetting = await SoundManager.getCharacterSetting(currentChatCharacter.id, 'enabled');
                const isEnabled = !!enabledSetting;

                // 检查静音模式
                const silentSetting = await SoundManager.getCharacterSetting(currentChatCharacter.id, 'silent');
                const isSilent = !!silentSetting;

                // 设置静音开关状态
                const silentCheckbox = document.getElementById('character-silent-mode');
                if (silentCheckbox) {
                    silentCheckbox.checked = isSilent;
                }

                for (const soundType of soundTypes) {
                    const setting = await SoundManager.getCharacterSetting(currentChatCharacter.id, soundType);
                    const urlInput = document.getElementById(`character-${soundType}-url`);

                    if (urlInput) {
                        // 🔥【修复】先清空输入框，避免显示其他角色的设置
                        urlInput.value = '';
                        urlInput.disabled = false;

                        // 如果当前角色有设置，则显示
                        if (setting) {
                            hasAnySetting = true;
                            if (setting.sourceType === 'file') {
                                urlInput.value = '已设置本地文件';
                                urlInput.disabled = true;
                            } else {
                                urlInput.value = setting.sourceUrl || '';
                                urlInput.disabled = false;
                            }
                        }
                    }
                }

                // 🔥【修改】开关状态优先级：明确开启 > 有实际设置 > 静音模式
                let shouldShowEnabled = false;
                if (isEnabled) {
                    shouldShowEnabled = true; // 用户明确开启了开关
                } else if (hasAnySetting || isSilent) {
                    shouldShowEnabled = true; // 有实际设置或静音模式
                }

                // 设置开关状态
                const soundEnabled = document.getElementById('character-sound-enabled');
                const soundList = document.getElementById('character-sound-list');

                if (soundEnabled) {
                    soundEnabled.checked = shouldShowEnabled;
                }

                if (soundList) {
                    soundList.style.display = shouldShowEnabled ? 'block' : 'none';
                }

                console.log(`✅ 角色专属音效设置界面初始化完成: ${currentChatCharacter.name} (开关: ${shouldShowEnabled}, 静音: ${isSilent})`);
            } catch (error) {
                console.error('❌ 角色专属音效设置界面初始化失败:', error);
            }
        }

        // 🔥【版本 40】自定义主题系统迁移到Dexie
        db.version(40).stores({
            // --- 完整复制版本39的所有内容 ---
            // 基础数据表
            characters: '&id, name, groupId',
            contacts: '++id, characterId',
            chatMessages: '&id, characterId, timestamp',

            // 用户面具系统
            personas: '&id, name',

            // 表情包系统 - 添加isPersonal字段区分个人表情包和库表情包
            customEmojis: '&id, name, category, isPersonal',
            recentEmojis: '&id, lastUsed',

            // 世界书系统
            worldbooks: '&id, name, isGlobal',
            worldbookEntries: '&id, worldbookId, keyword',

            // 群聊系统
            characterGroups: '&id, name, order',
            groupChats: '&id, name',
            groupChatMessages: '&id, groupId, timestamp',
            groupChatMembers: '&id, groupId, characterId',

            // 动态系统
            moments: '&id, authorId, timestamp',
            momentLikes: '[momentId+authorId], momentId, authorId',
            momentComments: '&id, momentId, authorId, timestamp',

            // 记忆系统
            workingMemory: '&id, characterId, timestamp, content, context',
            episodicMemory: '&id, characterId, date, summary, timestamp, context',
            episodicMemories: '&id, characterId, fact, importance, timestamp, category, contextId',
            memorySummaries: '&id, characterId, date, summary, timestamp, context',
            memoryEvents: '&id, characterIds, eventType, timestamp, context, eventData, importance',
            coreMemory: '&id, characterId, category, content, timestamp',
            coreMemories: '&id, characterId, fact, importance, timestamp, type, category, contextId',
            crossAppTimeline: '&id, characterId, appType, action, timestamp, context, messageId',

            // 拉黑和好友系统
            blacklist: '&id, blockerId, blockedId, timestamp, reason',
            blockedCharacters: '&id, characterId, blockedBy, timestamp',
            friendRequests: '&id, fromId, toId, timestamp, status, type, message',
            characterStatus: '&id, characterId, status, activity, location, lastUpdate',

            // 日记系统
            characterDiaries: '&id, characterId, date, content, timestamp, weather',

            // 线下模式系统
            offlineHistoryRecords: '&id, characterId, timestamp, summary, messages',
            offlineUISettings: '&id, characterId, settings, timestamp',
            offlinePresets: '&id, name, content, timestamp',

            // 音乐播放器系统
            musicPlaylist: '&id, title, artist, album, duration, url, coverImage, lyrics, addedTime, isLocalFile',
            musicCovers: '&id, songId, imageData, timestamp',

            // 设置和配置
            apiSettings: '&id',
            globalSettings: '&id',
            wallpapers: '&id, name',
            appIcons: '&id, appId',
            chatSettings: '&id, chatId',

            // 心声系统
            innerThoughts: '&id, messageId, characterId, content, timestamp',

            // 论坛功能相关表
            forums: '++id, name',
            forumPosts: '++id, forumId, timestamp, isUserPost',
            forumReplies: '++id, postId, timestamp',
            forumFavorites: '++id, [userId+postId], userId, postId',

            // 评论点赞表
            replyLikes: '++id, [userId+replyId], userId, replyId, timestamp',

            // 论坛扩展表
            forumPostImages: '++id, postId, imageUrl',
            forumMountedWorldbooks: '++id, &[forumId+worldbookId], forumId',

            // 短信应用独立数据表
            smsContacts: '++id, characterId, personaId, createdAt',

            // 短信消息表
            smsMessages: '&id, characterId, timestamp, content, isUser, isImage, imageUrl, fileName',

            // 纪念日和约定系统 - 🔥【新增】添加userQuote字段支持用户语录
            anniversaries: '&id, name, date, type, yearly, characterId, createdBy, characterQuote, userQuote, isShared, isPinned, backgroundImage, userAvatar, countType',
            appointments: '&id, name, date, time, type, description, completed, priority, reminder, characterId, createdBy, characterQuote, userQuote, isShared, isPinned, backgroundImage, userAvatar, countType',

            // 动态可见性、位置信息和提醒功能
            momentVisibility: '++id, momentId, visibility, visibleGroups, timestamp',
            momentLocations: '++id, momentId, locationName, latitude, longitude, timestamp',
            momentMentions: '++id, momentId, mentionedCharacterId, timestamp, isRead',

            // 足迹功能
            characterFootprints: '&id, characterId, date, data, timestamp, lastUpdateTime, isComplete',
            footprintActivities: '++id, footprintId, time, activity, location, type, mood, timestamp',

            // 表情包库功能
            emojiLibraries: '&id, name, description, createdAt, updatedAt',
            emojiLibraryItems: '++id, &[libraryId+emojiId], libraryId, emojiId, addedAt',

            // 🔥【新增】日记设置表 - 将localStorage的日记设置迁移到Dexie
            diarySettings: '&id, characterId, settingName, settingValue, timestamp',

            // 🔥【新增】音效系统表
            soundSettings: '&id, soundType, sourceType, sourceUrl, enabled, timestamp',

            // 🔥【新增】角色专属音效表
            characterSounds: '++id, characterId, soundType, sourceType, sourceUrl, enabled, timestamp',

            // --- 然后，在末尾追加新表 ---
            // 🔥【新增】自定义主题系统表
            globalThemes: '&id, themeType, themeData, timestamp',
            chatThemes: '++id, chatId, themeData, timestamp',
            themeSettings: '&id, settingName, settingValue, timestamp'
        }).upgrade(async trans => {
            // 🔥【新增】迁移localStorage的自定义主题数据到Dexie
            try {
                console.log('🎨 开始迁移自定义主题数据到Dexie数据库...');

                // 1. 迁移全局自定义主题数据
                const globalCustomTheme = localStorage.getItem('globalCustomTheme');
                if (globalCustomTheme) {
                    try {
                        const globalThemeData = JSON.parse(globalCustomTheme);
                        await trans.globalThemes.add({
                            id: 'global',
                            themeType: 'global',
                            themeData: globalThemeData,
                            timestamp: Date.now()
                        });
                        console.log('✅ 全局自定义主题数据已迁移');
                        // 迁移后删除localStorage数据
                        localStorage.removeItem('globalCustomTheme');
                    } catch (parseError) {
                        console.warn('全局主题数据解析失败:', parseError);
                    }
                }

                // 2. 迁移聊天自定义主题数据
                let migratedChatThemes = 0;
                const allCharacters = await trans.characters.toArray();
                const allGroupChats = await trans.groupChats.toArray();

                // 迁移角色聊天主题
                for (const character of allCharacters) {
                    const themeKey = `customTheme_${character.id}`;
                    const themeData = localStorage.getItem(themeKey);
                    if (themeData) {
                        try {
                            const parsedThemeData = JSON.parse(themeData);
                            await trans.chatThemes.add({
                                chatId: character.id,
                                themeData: parsedThemeData,
                                timestamp: Date.now()
                            });
                            migratedChatThemes++;
                            // 迁移后删除localStorage数据
                            localStorage.removeItem(themeKey);
                        } catch (parseError) {
                            console.warn(`角色主题数据解析失败 (${character.id}):`, parseError);
                        }
                    }
                }

                // 迁移群聊主题
                for (const group of allGroupChats) {
                    const themeKey = `customTheme_${group.id}`;
                    const themeData = localStorage.getItem(themeKey);
                    if (themeData) {
                        try {
                            const parsedThemeData = JSON.parse(themeData);
                            await trans.chatThemes.add({
                                chatId: group.id,
                                themeData: parsedThemeData,
                                timestamp: Date.now()
                            });
                            migratedChatThemes++;
                            // 迁移后删除localStorage数据
                            localStorage.removeItem(themeKey);
                        } catch (parseError) {
                            console.warn(`群聊主题数据解析失败 (${group.id}):`, parseError);
                        }
                    }
                }

                if (migratedChatThemes > 0) {
                    console.log(`✅ 已迁移 ${migratedChatThemes} 个聊天自定义主题`);
                }

                // 3. 迁移主题设置
                const selectedTheme = localStorage.getItem('selectedTheme');
                if (selectedTheme) {
                    await trans.themeSettings.add({
                        id: 'selectedTheme',
                        settingName: 'selectedTheme',
                        settingValue: selectedTheme,
                        timestamp: Date.now()
                    });
                    console.log(`✅ 主题设置已迁移: ${selectedTheme}`);
                    // 迁移后删除localStorage数据
                    localStorage.removeItem('selectedTheme');
                }

                // 4. 清理旧的主题数据（如果存在）
                const oldCustomThemeData = localStorage.getItem('customThemeData');
                if (oldCustomThemeData) {
                    console.log('🧹 清理旧的主题数据');
                    localStorage.removeItem('customThemeData');
                }

                console.log('✅ 自定义主题数据迁移完成');
            } catch (error) {
                console.error('❌ 自定义主题数据迁移失败:', error);
            }
        });

        // 🔥【版本 41】窗口隔离聊天设置系统
        db.version(41).stores({
            // --- 完整复制版本40的所有内容 ---
            // 基础数据表
            characters: '&id, name, groupId',
            contacts: '++id, characterId',
            chatMessages: '&id, characterId, timestamp',

            // 用户面具系统
            personas: '&id, name',

            // 表情包系统 - 添加isPersonal字段区分个人表情包和库表情包
            customEmojis: '&id, name, category, isPersonal',
            recentEmojis: '&id, lastUsed',

            // 世界书系统
            worldbooks: '&id, name, isGlobal',
            worldbookEntries: '&id, worldbookId, keyword',

            // 群聊系统
            characterGroups: '&id, name, order',
            groupChats: '&id, name',
            groupChatMessages: '&id, groupId, timestamp',
            groupChatMembers: '&id, groupId, characterId',

            // 动态系统
            moments: '&id, authorId, timestamp',
            momentLikes: '[momentId+authorId], momentId, authorId',
            momentComments: '&id, momentId, authorId, timestamp',

            // 记忆系统
            workingMemory: '&id, characterId, timestamp, content, context',
            episodicMemory: '&id, characterId, date, summary, timestamp, context',
            episodicMemories: '&id, characterId, fact, importance, timestamp, category, contextId',
            memorySummaries: '&id, characterId, date, summary, timestamp, context',
            memoryEvents: '&id, characterIds, eventType, timestamp, context, eventData, importance',
            coreMemory: '&id, characterId, category, content, timestamp',
            coreMemories: '&id, characterId, fact, importance, timestamp, type, category, contextId',
            crossAppTimeline: '&id, characterId, appType, action, timestamp, context, messageId',

            // 拉黑和好友系统
            blacklist: '&id, blockerId, blockedId, timestamp, reason',
            blockedCharacters: '&id, characterId, blockedBy, timestamp',
            friendRequests: '&id, fromId, toId, timestamp, status, type, message',
            characterStatus: '&id, characterId, status, activity, location, lastUpdate',

            // 日记系统
            characterDiaries: '&id, characterId, date, content, timestamp, weather',

            // 线下模式系统
            offlineHistoryRecords: '&id, characterId, timestamp, summary, messages',
            offlineUISettings: '&id, characterId, settings, timestamp',
            offlinePresets: '&id, name, content, timestamp',

            // 音乐播放器系统
            musicPlaylist: '&id, title, artist, album, duration, url, coverImage, lyrics, addedTime, isLocalFile',
            musicCovers: '&id, songId, imageData, timestamp',

            // 设置和配置
            apiSettings: '&id',
            globalSettings: '&id',
            wallpapers: '&id, name',
            appIcons: '&id, appId',
            chatSettings: '&id, chatId',

            // 心声系统
            innerThoughts: '&id, messageId, characterId, content, timestamp',

            // 论坛功能相关表
            forums: '++id, name',
            forumPosts: '++id, forumId, timestamp, isUserPost',
            forumReplies: '++id, postId, timestamp',
            forumFavorites: '++id, [userId+postId], userId, postId',

            // 评论点赞表
            replyLikes: '++id, [userId+replyId], userId, replyId, timestamp',

            // 论坛扩展表
            forumPostImages: '++id, postId, imageUrl',
            forumMountedWorldbooks: '++id, &[forumId+worldbookId], forumId',

            // 短信应用独立数据表
            smsContacts: '++id, characterId, personaId, createdAt',

            // 短信消息表
            smsMessages: '&id, characterId, timestamp, content, isUser, isImage, imageUrl, fileName',

            // 纪念日和约定系统 - 🔥【新增】添加userQuote字段支持用户语录
            anniversaries: '&id, name, date, type, yearly, characterId, createdBy, characterQuote, userQuote, isShared, isPinned, backgroundImage, userAvatar, countType',
            appointments: '&id, name, date, time, type, description, completed, priority, reminder, characterId, createdBy, characterQuote, userQuote, isShared, isPinned, backgroundImage, userAvatar, countType',

            // 动态可见性、位置信息和提醒功能
            momentVisibility: '++id, momentId, visibility, visibleGroups, timestamp',
            momentLocations: '++id, momentId, locationName, latitude, longitude, timestamp',
            momentMentions: '++id, momentId, mentionedCharacterId, timestamp, isRead',

            // 足迹功能
            characterFootprints: '&id, characterId, date, data, timestamp, lastUpdateTime, isComplete',
            footprintActivities: '++id, footprintId, time, activity, location, type, mood, timestamp',

            // 表情包库功能
            emojiLibraries: '&id, name, description, createdAt, updatedAt',
            emojiLibraryItems: '++id, &[libraryId+emojiId], libraryId, emojiId, addedAt',

            // 🔥【新增】日记设置表 - 将localStorage的日记设置迁移到Dexie
            diarySettings: '&id, characterId, settingName, settingValue, timestamp',

            // 🔥【新增】音效系统表
            soundSettings: '&id, soundType, sourceType, sourceUrl, enabled, timestamp',

            // 🔥【新增】角色专属音效表
            characterSounds: '++id, characterId, soundType, sourceType, sourceUrl, enabled, timestamp',

            // 🔥【新增】自定义主题系统表
            globalThemes: '&id, themeType, themeData, timestamp',
            chatThemes: '++id, chatId, themeData, timestamp',
            themeSettings: '&id, settingName, settingValue, timestamp',

            // --- 然后，在末尾追加新表 ---
            // 🔥【新增】窗口隔离聊天设置表
            windowChatSettings: '++id, &[chatId+windowId], chatId, windowId, settings, timestamp'
        });

        let selectedGroupMembers = []; // 群聊成员选择
        let currentWorldbookTab = 'global';


        // 角色分组相关变量
        let characterGroups = []; // 角色分组列表
        let isGroupManageMode = false; // 分组管理模式
        let selectedGroupId = null; // 当前选中的分组ID

        // 自定义表情包相关变量
        let customEmojis = []; // 用户直接上传的个人表情包（显示在聊天界面）
        let recentEmojis = []; // 最近使用的表情包
        let currentEmojiTab = 'recent'; // 当前表情包标签页
        let pendingPersonalEmojiData = null; // 待处理的个人表情包数据（用于描述模态框）

        // 面具区域相关变量
        let isPersonaExpanded = true; // 面具区域是否展开，默认展开

        // 表情包库相关变量
        let emojiLibraries = []; // 表情包库列表
        let currentEmojiLibrary = null; // 当前正在管理的表情包库
        let isEmojiLibraryExpanded = false; // 表情包库区域是否展开

        // 消息多选删除相关变量
        let isMessageSelectionMode = false; // 消息选择模式
        let selectedMessages = new Set(); // 选中的消息ID集合

        // 消息列表多选相关变量
        let isMessageListMultiSelectMode = false; // 消息列表多选模式状态
        let selectedConversations = []; // 选中的对话框ID列表

        // 动态评论对话回合次追踪
        let commentConversationRounds = new Map(); // 格式: "momentId-characterId" => 回合次数

        // 🔥【新增】拉黑系统相关变量已在后面声明

        // 🔥【短信应用独立数据管理】
        let smsContacts = []; // 短信应用的独立联系人列表
        let smsMessages = {}; // 短信应用的独立消息记录 {characterId: [messages]}
        let pendingSMSMessages = []; // 待回复消息列表



        // 🔥【新增】短信多选删除相关变量
        let isSMSMultiSelectMode = false; // 短信多选模式状态
        let selectedSMSMessages = new Set(); // 选中的短信消息ID集合

        let apiSettings = {
            type: 'openai',
            base: 'https://api.openai.com/v1',
            endpoint: '/chat/completions',
            key: '',
            model: 'gpt-3.5-turbo',
            temperature: 0.70
        };

        // 注意：记忆设置现在已改为每个聊天窗口独立的设置，存储在各自的聊天设置中

        let chatSettings = {
            themeColor: '#007AFF',
            theirBubbleColor: '#f0f0f0',
            myBubbleColor: '#007AFF',
            bubbleOpacity: 1,
            timestampEnabled: true,
            timestampPosition: 'center'
        };


        let selectedAppIcon = null;
        let selectedWallpaper = null;
        let colorPickerContext = null;
        let customIconImage = null;

        // 加载全局世界书设置
        async function loadGlobalWorldbookSettings() {
            try {
                const globalSettings = await db.globalSettings.get('main');
                if (globalSettings && globalSettings.activeGlobalWorldbooks) {
                    // 确保使用window.activeGlobalWorldbooks以在全局范围内可用
                    window.activeGlobalWorldbooks = globalSettings.activeGlobalWorldbooks;
                } else {
                    window.activeGlobalWorldbooks = [];
                    // 如果没有找到设置，创建一个初始设置
                    await db.globalSettings.put({
                        id: 'main',
                        activeGlobalWorldbooks: []
                    });
                }
            } catch (error) {
                console.error('加载全局世界书设置失败:', error);
                window.activeGlobalWorldbooks = [];
            }
        }

        // 初始化应用
        document.addEventListener('DOMContentLoaded', async function() {
            // 🔥【关键修复】首先打开数据库
            try {
                await window.db.open();
                console.log('✅ 数据库已成功打开');
            } catch (error) {
                console.error('❌ 数据库打开失败:', error);
                // 如果数据库打开失败，尝试重新创建
                try {
                    await window.db.delete();
                    window.db = new Dexie('PhoneChatDB');
                    // 🔥【关键】重新创建全局别名
                    db = window.db;
                    // 重新定义数据库结构（简化版本）
                    window.db.version(41).stores({
                        characters: '&id, name, groupId',
                        contacts: '++id, characterId',
                        chatMessages: '&id, characterId, timestamp',
                        personas: '&id, name',
                        customEmojis: '&id, name, category, isPersonal',
                        recentEmojis: '&id, lastUsed'
                    });
                    await window.db.open();
                    console.log('✅ 数据库重新创建并打开成功');
                } catch (recreateError) {
                    console.error('❌ 数据库重新创建失败:', recreateError);
                }
            }

            initializeDataLoadPromise(); // 🔥【新增修复】初始化数据加载Promise
            updateTime();

            // 🔥【手机修复】音频上下文解锁
            const unlockAudio = () => {
                console.log('🔓 用户交互，解锁音频上下文');
                SoundManager.isUnlocked = true; // 标记音频已解锁
                // 移除监听器
                ['touchstart', 'mousedown', 'keydown', 'click'].forEach(event => {
                    document.removeEventListener(event, unlockAudio);
                });
            };

            // 监听用户的第一次交互
            ['touchstart', 'mousedown', 'keydown', 'click'].forEach(event => {
                document.addEventListener(event, unlockAudio, { once: true, passive: true });
            });

            // 🔥【新增】浏览器兼容性检查和诊断
            console.log('🔍 开始浏览器兼容性检查...');
            const isChrome = navigator.userAgent.includes('Chrome');
            const isSafari = navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome');
            const isFirefox = navigator.userAgent.includes('Firefox');

            console.log('浏览器类型:', { isChrome, isSafari, isFirefox });

            // 🔥【Chrome兼容性修复】为Chrome添加额外的数据加载验证
            if (isChrome) {
                console.log('🔧 检测到Chrome浏览器，启用兼容性增强模式');
                // 添加全局错误处理
                window.addEventListener('error', function(e) {
                    if (e.message.includes('contacts') || e.message.includes('characters')) {
                        console.warn('🔧 检测到数据相关错误，尝试自动修复:', e.message);
                        setTimeout(() => {
                            if (typeof forceFixDataConsistency === 'function') {
                                forceFixDataConsistency();
                            }
                        }, 1000);
                    }
                });
            }

            // 🔥【修复】改进Safari长按处理 - 只禁用系统菜单，保留自定义长按功能
            if (navigator.userAgent.includes('Safari') && navigator.userAgent.includes('Mobile')) {
                // 只禁用Safari的系统上下文菜单，但保留自定义长按功能
                document.addEventListener('contextmenu', function(e) {
                    // 🔥【修复】检查e.target是否存在且有closest方法
                    if (e.target && typeof e.target.closest === 'function') {
                        // 检查是否是我们的自定义长按触发的菜单
                        if (e.target.closest('.message-menu, .sms-message-menu, .offline-message-menu')) {
                            return; // 允许我们的自定义菜单显示
                        }
                        // 只在消息相关元素上禁用系统菜单
                        if (e.target.closest('.message-bubble, .offline-message-content, .message-item, .contact-item, .sms-message-bubble')) {
                            e.preventDefault();
                            return false;
                        }
                    }
                }, { passive: false });

                // 🔥【修复】减少对selectstart的干扰，只在真正需要时禁用
                document.addEventListener('selectstart', function(e) {
                    // 🔥【修复】检查e.target是否存在且有closest方法
                    if (e.target && typeof e.target.closest === 'function') {
                        // 只在非输入元素上禁用选择
                        if (e.target.closest('.message-bubble, .offline-message-content') &&
                            !e.target.closest('input, textarea, [contenteditable]')) {
                            e.preventDefault();
                            return false;
                        }
                    }
                }, { passive: false });

                // 🔥【修复】减少对dragstart的干扰
                document.addEventListener('dragstart', function(e) {
                    // 🔥【修复】检查e.target是否存在且有closest方法
                    if (e.target && typeof e.target.closest === 'function') {
                        if (e.target.closest('.message-bubble, .offline-message-content') &&
                            !e.target.closest('img, [draggable="true"]')) {
                            e.preventDefault();
                            return false;
                        }
                    }
                }, { passive: false });

                console.log('✅ Safari长按处理已优化');
            }

            // 🔥【新增】移动端长按调试功能
            if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                console.log('📱 检测到移动设备，启用长按调试模式');

                // 添加全局触摸事件监听器用于调试
                let debugTouchStart = null;
                document.addEventListener('touchstart', function(e) {
                    debugTouchStart = Date.now();
                    console.log('🔍 触摸开始:', e.target.className);
                }, { passive: true });

                document.addEventListener('touchend', function(e) {
                    if (debugTouchStart) {
                        const duration = Date.now() - debugTouchStart;
                        if (duration > 500) {
                            console.log('🔍 长按检测:', duration + 'ms', e.target.className);
                        }
                        debugTouchStart = null;
                    }
                }, { passive: true });
            }

            try {

            // 🔥【新增】初始化窗口ID，确保线下模式数据隔离
            initializeWindowId();

            // 🔥【新增】数据库健康检查
            console.log('🔍 开始数据库健康检查...');
            const isHealthy = await checkDatabaseHealth();
            if (!isHealthy) {
                console.warn('⚠️ 数据库健康检查失败，尝试重置...');
                const resetSuccess = await resetDatabase();
                if (!resetSuccess) {
                    throw new Error('数据库重置失败，请手动清除浏览器数据');
                }
                console.log('✅ 数据库已重置，继续初始化...');
            } else {
                console.log('✅ 数据库健康检查通过');
            }

            // 🔥【已移除】迁移旧的线下预设数据 - 现在由数据库版本15自动处理

            // 🔥【架构修复】按正确顺序加载数据
            console.log('🔄 开始按顺序加载数据...');

            // 第一步：加载基础数据
            await Promise.all([
                loadCharacterGroups(), // 先加载分组
                loadCharacters(), // 加载角色
                loadChatMessages(),
                loadMemoryConfig(), // 加载记忆配置
                loadChatSettings(),
                loadApiSettings(),
                loadCustomEmojis(),
                loadEmojiLibraries(), // 加载表情包库
                loadGlobalWorldbookSettings(), // 确保加载全局世界书设置
                initGlobalMemoryDB(), // 🔥【新增】初始化全局记忆数据库
                loadCustomAppIcons(), // 加载自定义应用图标
                migrateFootprintsFromLocalStorage(), // 🔥【新增】迁移足迹数据从localStorage到Dexie
                cleanupFootprintsCache() // 🔥【新增】清理过期的足迹缓存
            ]);

            // 🔥【新增】清理已保存的拉黑系统消息
            console.log('🧹 清理拉黑系统消息...');
            cleanupBlockedSystemMessages();

            // 🔥【新增】自动修复损坏的消息内容
            console.log('🔧 自动修复损坏的消息...');
            const fixedCount = await autoFixCorruptedMessages();
            if (fixedCount > 0) {
                console.log(`✅ 自动修复了 ${fixedCount} 条损坏的消息`);
            }

            // 第二步：加载联系人数据（必须在角色加载完成后）
            console.log('🔄 加载联系人数据...');
            await loadContacts();

            // 🔥【新增】加载短信应用的独立数据
            console.log('🔄 加载短信应用数据...');
            await loadSMSContacts();
            await loadSMSMessages();
            loadPinnedSMSConversations();

            // 联系人数据已正常加载，无需额外处理

            // 🔥【新增】加载置顶数据
            loadPinnedConversations();

            // 加载外观设置
            loadPhoneBorderSetting();
            loadScreenSize();
            loadFontSizeSettings();
            loadGlobalFontSettings(); // 🔥【新增】加载全局字体设置
            loadStatusIconSetting();
            loadHomeFontColorSetting();
            loadClockStyleSetting(); // 🔥【新增】加载时钟样式设置

            // 🔥【新增】更新全局记忆状态显示
            updateGlobalMemoryStatusDisplay();

            // 加载动态图片设置
            await loadMomentsImages();

            // 加载其他设置（包括需要数据库的壁纸设置）
            await loadWallpaper();
            await loadAppIcons();
            await loadSavedTheme();
            await loadWorldbooks();

            await loadPersonas();
            await loadGroupChats();

            // 🔥【新增】检查localStorage使用情况
            checkLocalStorageUsage();

            // 初始化记忆查看器
            await initMemoryViewer();

            // 初始化纪念日系统
            await loadAnniversaryList();
            await loadAppointmentList();

            // 初始化小组件
            initializeWidgets();

            // 🔥【新增】初始化论坛应用
            initializeForumApp();

            // 🔥【新增】预加载线下模式设置，确保刷新后不丢失
            await preloadOfflineUISettings();

            // 🔥【浏览器兼容性修复】渲染界面 - 增强数据验证和错误处理
            try {
                console.log('🔍 渲染前数据状态检查:', {
                    charactersCount: characters ? characters.length : 'undefined',
                    contactsCount: contacts ? contacts.length : 'undefined',
                    chatMessagesType: typeof chatMessages,
                    chatMessagesKeys: chatMessages ? Object.keys(chatMessages).length : 'undefined'
                });

                // 🔥【修复】确保基础数据结构存在
                if (!characters) characters = [];
                if (!contacts) contacts = [];
                if (!chatMessages) chatMessages = {};

                // 🔥【修复】智能检查是否需要恢复联系人
                if (characters.length > 0 && contacts.length === 0) {
                    // 检查是否有聊天记录，如果有则可能需要恢复联系人
                    const hasAnyMessages = Object.keys(chatMessages).length > 0;
                    if (hasAnyMessages) {
                        console.warn('⚠️ 检测到有角色和聊天记录但无联系人，可能需要恢复');
                        const chatCharacterIds = Object.keys(chatMessages).filter(id =>
                            characters.some(char => char.id === id)
                        );
                        if (chatCharacterIds.length > 0) {
                            contacts = chatCharacterIds;
                            saveContacts().catch(err => console.error('保存联系人失败:', err));
                            console.log(`🔧 从聊天记录恢复了 ${contacts.length} 个联系人`);
                        }
                    } else {
                        console.log('✅ 无聊天记录，联系人为空是正常状态');
                    }
                }

                // 渲染界面
                renderMessageList();
                renderContactList();
                renderCharacterList();
                renderPersonaList();

                // 🔥【新增】渲染后验证
                setTimeout(() => {
                    const messageItems = document.querySelectorAll('.message-item');
                    console.log(`✅ 渲染验证: 显示了 ${messageItems.length} 个对话`);

                    if (messageItems.length === 0 && characters.length > 0) {
                        console.warn('⚠️ 渲染异常检测，执行诊断...');
                        diagnoseBrowserCompatibility();

                        // 尝试修复
                        setTimeout(() => {
                            forceFixDataConsistency();
                        }, 1000);
                    }
                }, 500);

            } catch (renderError) {
                console.error('❌ 界面渲染失败:', renderError);

                // 🔥【浏览器兼容性修复】降级处理
                console.log('🔧 执行降级渲染处理...');

                // 确保基础数据结构
                if (!chatMessages) chatMessages = {};
                if (!contacts) contacts = [];
                if (!characters) characters = [];

                // 尝试重新渲染
                try {
                    renderMessageList();
                    renderContactList();
                    renderCharacterList();
                } catch (secondError) {
                    console.error('❌ 降级渲染也失败:', secondError);
                    // 最后的兜底处理
                    setTimeout(() => {
                        if (typeof forceFixDataConsistency === 'function') {
                            forceFixDataConsistency();
                        }
                    }, 2000);
                }
            }

            // 初始化时设置正确的按钮显示状态 - 延迟执行确保DOM加载完成
            setTimeout(async () => {
                switchChatTab('message-list');
                // 确保app标题有chat-mode类和正确内容
                const appTitle = document.querySelector('#chat-screen .app-title');
                if (appTitle) {
                    appTitle.classList.add('chat-mode');
                    appTitle.textContent = '💬';
                }

                // 初始化UI事件不依赖于currentChatCharacter
                initChatSettingsUIEvents();

                // 🔥【修复】强制应用气泡样式，即使没有当前聊天角色
                applyBubbleStyle();

                // 🔥【新增】应用自定义CSS
                applyCustomBubbleCSS();

                // 如果已经有聊天角色，才初始化设置和世界书
                if (currentChatCharacter) {
                initializeChatSettings(); // 初始化聊天设置界面
                updateWorldbookMountDisplay(); // 更新世界书挂载显示
                } else {
                    // 应用初始化完成，等待选择聊天角色
                }

                // 🔥【修复】在应用初始化时启动全局后台互动系统
                await initGlobalBackgroundInteractionSystem();

                // 初始化表情包库上传功能
                initEmojiLibraryUpload();

            // 🔥【新增】启动足迹缓存的午夜自动清理
            setupMidnightCacheCleanup();

                // 🔥【新增】启动纪念日和约定提醒系统
                initAnniversaryReminderSystem();

                // 🔥【新增】初始化音效管理器
                await SoundManager.init();

                // 🔥【新增】初始化足迹自动更新系统
                initializeFootprintsAutoUpdate();
            }, 100);

            // 温度滑块显示
            const temperatureSlider = document.getElementById('temperature-slider');
            if (temperatureSlider) {
                temperatureSlider.addEventListener('input', function() {
                document.getElementById('temperature-value').textContent = parseFloat(this.value).toFixed(2);
            });
            }

            // 初始化API设置界面
            initializeApiSettings();

            // 透明度滑块显示
            document.getElementById('opacity-slider').addEventListener('input', function() {
                document.getElementById('opacity-value').textContent = Math.round(this.value * 100) + '%';
            });

            // 文件选择框事件监听
            const songCoverInput = document.getElementById('song-cover-input');
            const fileInputText = document.querySelector('.file-input-text');
            if (songCoverInput && fileInputText) {
                songCoverInput.addEventListener('change', function(e) {
                    if (e.target.files && e.target.files[0]) {
                        fileInputText.textContent = e.target.files[0].name;
                    } else {
                        fileInputText.textContent = '未选封面';
                    }
                });
            }

            // 按Enter键发送消息
            document.getElementById('api-chat-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault(); // 防止换行
                    sendApiMessage();
                }
            });

            // @群成员功能相关变量
            let mentionDropdownVisible = false;
            let mentionStartPos = -1;
            let selectedMentionIndex = -1;
            let currentMentionQuery = '';

            // 监听输入框内容变化，处理@群成员功能
            document.getElementById('api-chat-input').addEventListener('input', function(e) {
                handleMentionInput(e);
            });

            // 监听键盘事件，处理@群成员选择
            document.getElementById('api-chat-input').addEventListener('keydown', function(e) {
                if (mentionDropdownVisible) {
                    handleMentionKeydown(e);
                }
            });

            // 点击其他地方时隐藏@群成员下拉框
            document.addEventListener('click', function(e) {
                const dropdown = document.getElementById('mention-dropdown');
                const input = document.getElementById('api-chat-input');
                if (mentionDropdownVisible && !dropdown.contains(e.target) && e.target !== input) {
                    hideMentionDropdown();
                }
            });



            // 初始化头像上传功能
            initializeAvatarUpload();

            // 初始化表情包上传功能
            initializeEmojiUpload();

            // 初始化应用图标上传功能
            initializeIconUpload();

            // 确保工具面板初始隐藏
            const toolsPanel = document.getElementById('tools-panel');
            if (toolsPanel) {
                toolsPanel.style.display = 'none';
            }

            // 初始化消息选择模式状态
            isMessageSelectionMode = false;
            selectedMessages.clear();

            // 图片上传
            document.getElementById('image-upload').addEventListener('change', function(e) {
                if (e.target.files && e.target.files[0]) {
                    const file = e.target.files[0];

                    // 检查文件类型，GIF格式不被Gemini API支持
                    if (file.type === 'image/gif') {
                        alert('抱歉，Gemini API 不支持 GIF 格式的图片。\n\n请选择其他格式的图片，如：\n• JPEG\n• PNG\n• WEBP');
                        // 清空文件选择器
                        e.target.value = '';
                        return;
                    }

                    const reader = new FileReader();
                    reader.onload = function(event) {
                        // 🔥【修复】直接发送图片消息，就像正常的图片发送一样
                        sendImageMessage(event.target.result);
                    };
                    reader.readAsDataURL(file);
                }

                // 清空文件选择器，允许重复选择同一文件
                e.target.value = '';
            });

            // 自定义壁纸上传
            document.getElementById('custom-wallpaper-upload').addEventListener('change', function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        selectedWallpaper = event.target.result;

                        // 更新预览容器
                        const previewContainer = document.getElementById('wallpaper-preview-container');
                        if (previewContainer) {
                            previewContainer.innerHTML = `<img src="${selectedWallpaper}" class="wallpaper-preview-image" alt="壁纸预览">`;
                        }

                        // 不在这里立即应用到主界面，等用户点击应用时再应用
                    };
                    reader.readAsDataURL(e.target.files[0]);
                }
            });

            // 自定义图标上传
            document.getElementById('custom-icon-upload').addEventListener('change', function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        customIconImage = event.target.result;
                        // 更新预览
                        const previews = document.querySelectorAll('.icon-preview');
                        previews.forEach(preview => {
                            preview.style.backgroundImage = `url(${customIconImage})`;
                            preview.innerHTML = ''; // 移除图标
                        });
                    };
                    reader.readAsDataURL(e.target.files[0]);
                }
            });

            setInterval(updateTime, 1000);
            initBatteryManager();

            // 🔥【新增修复】在所有数据加载完成后，发送"绿灯"信号
            resolveDataLoaded();
            console.log('✅ 所有初始数据加载完成，信号已发送。');

            // 🔥【新增】初始化全局动态发布系统
            setTimeout(async () => {
                try {
                    await initGlobalMomentsSystem();
                    console.log('✅ 全局动态发布系统初始化完成');
                } catch (error) {
                    console.error('❌ 全局动态发布系统初始化失败:', error);
                }
            }, 3000); // 延迟3秒确保数据完全加载

            // 🔥【新增修复】在所有数据加载后，尝试恢复上次打开的聊天
            const lastChatId = sessionStorage.getItem('currentChatCharacterId');
            if (lastChatId) {
                console.log('🔄 正在恢复上次打开的聊天:', lastChatId);
                // 等待数据加载的"绿灯"信号
                dataLoadedPromise.then(() => {
                    const character = characters.find(c => c.id === lastChatId);
                    const group = groupChats.find(g => g.id === lastChatId);
                    const chatEntity = character || group;

                    if (chatEntity) {
                        // 使用微小的延迟确保UI渲染完成
                        setTimeout(() => {
                            startChat(chatEntity);
                        }, 100);
                    } else {
                        console.warn('无法找到上次聊天的角色/群组:', lastChatId);
                        sessionStorage.removeItem('currentChatCharacterId');
                    }
                });
            }

            } catch (error) {
                console.error('应用初始化失败:', error);
                console.error('错误详情:', error.stack);

                // 显示详细错误信息
                const errorMsg = `应用初始化失败: ${error.message}\n\n可能的解决方案：\n1. 刷新页面重试\n2. 清除浏览器缓存\n3. 进入设置→紧急恢复\n\n错误类型: ${error.name}`;

                // 如果是数据库错误，尝试重置
                if (error.name === 'DataError' || error.name === 'InvalidStateError' || error.name === 'DexieError') {
                    console.log('检测到数据库错误，尝试重置数据库...');
                    if (confirm('检测到数据库错误，是否重置数据库？\n注意：这将清除所有本地数据。')) {
                        try {
                            await resetDatabase();
                            location.reload(); // 重置后刷新页面
                        } catch (resetError) {
                            console.error('重置数据库失败:', resetError);
                            alert('重置数据库失败，请手动清除浏览器数据后重试。');
                        }
                    }
                } else {
                    alert(errorMsg);

                    // 尝试显示紧急恢复界面
                    try {
                        // 确保基本的DOM结构存在
                        if (!characters) characters = [];
                        if (!contacts) contacts = [];
                        if (!chatMessages) chatMessages = {};

                        // 尝试显示设置页面
                        showApp('settings-screen');

                        // 延迟显示恢复模态框
                        setTimeout(() => {
                            try {
                                const recoveryBtn = document.querySelector('[onclick="showRecoveryModal()"]');
                                if (recoveryBtn) {
                                    recoveryBtn.click();
                                }
                            } catch (e) {
                                console.error('无法自动打开恢复界面:', e);
                            }
                        }, 1000);
                    } catch (e) {
                        console.error('无法显示紧急恢复界面:', e);
                    }
                }
            }
        });

        // 显示/隐藏应用
        function showApp(appId) {
            if (event) event.preventDefault();

            // 隐藏所有app界面
            const allApps = document.querySelectorAll('.app-screen');
            allApps.forEach(app => {
                app.style.display = 'none';
            });

            // 隐藏主屏幕组件
            const clockContainer = document.getElementById('clock-container');
            const homeGrid = document.getElementById('home-grid');
            const dockBar = document.getElementById('dock-bar');
            const mainStatusBar = document.getElementById('status-bar');
            if (clockContainer) clockContainer.style.display = 'none';
            if (homeGrid) homeGrid.style.display = 'none';
            if (dockBar) dockBar.style.display = 'none';

            // 🔥【修复】在所有应用界面中隐藏主屏幕状态栏，避免重复显示
            if (mainStatusBar) {
                mainStatusBar.style.display = 'none';
            }

            // 显示目标界面
            const targetApp = document.getElementById(appId);
            if (!targetApp) {
                console.error(`应用界面不存在: ${appId}`);
                showToast(`界面 ${appId} 不存在`, 'error');
                return;
            }
            targetApp.style.display = 'flex';

            // 如果是聊天界面，刷新消息列表
            if (appId === 'chat-screen') {
                renderMessageList();
            }

            // 如果是短信界面，刷新短信消息列表
            if (appId === 'messages-screen') {
                renderSMSMessageList();
            }

            // 如果是纪念日界面，加载纪念日列表
            if (appId === 'anniversary-screen') {
                loadAnniversaryList();
                loadAppointmentList();
            }

            // 如果是API设置界面，初始化设置
            if (appId === 'api-settings-screen') {
                // 延迟一点时间确保DOM已渲染
                setTimeout(() => {
                    initializeApiSettings();
                }, 100);
            }

            // 如果是音效设置界面，初始化设置
            if (appId === 'sound-settings-screen') {
                setTimeout(() => {
                    initSoundSettings();
                }, 100);
            }

            // 🎨【修改】如果是自定义主题界面，初始化界面 - 支持async
            if (appId === 'custom-theme-screen') {
                setTimeout(async () => {
                    await initCustomThemeScreen();
                }, 100);
            }
        }



        // 隐藏角色创建表单，返回到chat界面的通讯录
        function hideCharacterForm() {
            // 在隐藏表单时清空表单数据
            clearCharacterForm();

            hideApp('character-form-screen');
            showApp('chat-screen');
            switchChatTab('contact-list');
            // 手动触发标签切换的样式
            const chatTabs = document.querySelectorAll('.chat-tab');
            chatTabs.forEach(tab => {
                if (tab && tab.classList) {
                    tab.classList.remove('active');
                }
            });
            // 安全地添加active类到第二个标签（通讯录）
            if (chatTabs.length > 1 && chatTabs[1] && chatTabs[1].classList) {
                chatTabs[1].classList.add('active');
            }
        }

        function hideApp(appId) {
            document.getElementById(appId).style.display = 'none';

            // 检查是否所有应用都已隐藏，如果是，显示主屏幕组件
            const allApps = document.querySelectorAll('.app-screen');
            const hasVisibleApp = Array.from(allApps).some(app =>
                app.style.display === 'flex' || app.style.display === 'block'
            );

            if (!hasVisibleApp) {
                // 显示主屏幕组件
                const clockContainer = document.getElementById('clock-container');
                const homeGrid = document.getElementById('home-grid');
                const dockBar = document.getElementById('dock-bar');
                const mainStatusBar = document.getElementById('status-bar');
                if (clockContainer) clockContainer.style.display = 'block';
                if (homeGrid) homeGrid.style.display = 'grid';
                if (dockBar) dockBar.style.display = 'block';
                // 🔥【修复】恢复主屏幕状态栏显示
                if (mainStatusBar) mainStatusBar.style.display = 'flex';
            } else {
                // 🔥【修复】如果还有其他应用显示，隐藏主屏幕状态栏避免重复
                const mainStatusBar = document.getElementById('status-bar');
                if (mainStatusBar) {
                    mainStatusBar.style.display = 'none';
                }
            }
        }

        // 显示/隐藏模态框
        function showModal(modalId) {
            console.log('showModal called with:', modalId);
            const modal = document.getElementById(modalId);
            console.log('Modal element:', modal);
            if (modal) {
                modal.style.display = 'flex';
                console.log('Modal display set to flex');
            } else {
                console.log('Modal element not found!');
            }
        }

        function hideModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // 纪念日功能
        let anniversaries = [];
        let editingAnniversaryId = null;

        // 约定功能
        let appointments = [];
        let editingAppointmentId = null;

        // 纪念日分栏切换功能
        function switchAnniversaryTab(tabName) {
            // 更新标签页状态
            document.querySelectorAll('.anniversary-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`.anniversary-tab[onclick*="${tabName}"]`).classList.add('active');

            // 切换内容区域
            document.getElementById('anniversary-content').style.display = tabName === 'anniversary' ? 'block' : 'none';
            document.getElementById('appointment-content').style.display = tabName === 'appointment' ? 'block' : 'none';

            // 更新头部按钮功能
            const addBtn = document.querySelector('#anniversary-screen .add-anniversary-btn');
            if (tabName === 'anniversary') {
                addBtn.onclick = showAnniversaryForm;
                addBtn.innerHTML = '<i class="fas fa-plus"></i>';
                addBtn.title = '添加纪念日';
            } else {
                addBtn.onclick = () => showAppointmentForm();
                addBtn.innerHTML = '<i class="fas fa-plus"></i>';
                addBtn.title = '添加约定';
            }
        }

        // 🛒【新增】购物界面分栏切换功能
        function switchShoppingTab(tabName) {
            // 更新标签页状态
            document.querySelectorAll('.shopping-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`.shopping-tab[onclick*="${tabName}"]`).classList.add('active');

            // 🔥【修复】隐藏商品展示区域，显示分类选择
            const categoriesDiv = document.getElementById('shopping-categories');
            const productsDiv = document.getElementById('products-container');
            const searchContainer = document.querySelector('.shopping-search-container');
            const appTitle = document.querySelector('#shopping-screen .app-title');
            const shoppingContent = document.querySelector('.shopping-content');

            // 重置到分类选择状态
            categoriesDiv.style.display = 'block';
            searchContainer.style.display = 'block';
            productsDiv.style.display = 'none';
            shoppingContent.classList.remove('showing-products');

            // 🔥【新增】根据标签页动态设置标题
            if (tabName === 'takeout') {
                appTitle.textContent = '外卖';
            } else if (tabName === 'shopping') {
                appTitle.textContent = '购物';
            }

            // 🔥【新增】确保搜索框位置稳定
            searchContainer.style.position = 'relative';
            searchContainer.style.left = '0';
            searchContainer.style.transform = 'none';

            // 切换分类显示
            const takeoutCategories = document.getElementById('takeout-categories');
            const shoppingCategoriesList = document.getElementById('shopping-categories-list');

            if (tabName === 'takeout') {
                takeoutCategories.style.display = 'flex';
                shoppingCategoriesList.style.display = 'none';
            } else if (tabName === 'shopping') {
                takeoutCategories.style.display = 'none';
                shoppingCategoriesList.style.display = 'flex';
            }

            console.log('切换到购物标签页:', tabName);
        }

        // 🛒【新增】商品数据
        const productsData = {
            '美食': [
                {name: '麻辣香锅', brand: '海底捞', price: 45.8, options: {size: ['小份', '中份', '大份'], spicy: ['不辣', '微辣', '中辣', '特辣']}, prices: {size: {'小份': 38, '中份': 46, '大份': 58}}},
                {name: '宫保鸡丁', brand: '真功夫', price: 28.5, options: {size: ['小份', '大份'], spicy: ['不辣', '微辣', '中辣']}, prices: {size: {'小份': 24, '大份': 36}}},
                {name: '红烧肉', brand: '老乡鸡', price: 32.0, options: {size: ['小份', '大份']}, prices: {size: {'小份': 26, '大份': 42}}},
                {name: '酸菜鱼', brand: '太二', price: 68.0, options: {size: ['1-2人份', '3-4人份'], spicy: ['微辣', '中辣', '特辣']}, prices: {size: {'1-2人份': 68, '3-4人份': 93}}},
                {name: '兰州拉面', brand: '马子禄', price: 18.0, options: {noodle: ['细面', '宽面'], soup: ['清汤', '红汤']}, prices: {soup: {'清汤': 18, '红汤': 20}}},
                {name: '小笼包', brand: '鼎泰丰', price: 35.0, options: {count: ['6个', '8个', '12个']}, prices: {count: {'6个': 35, '8个': 43, '12个': 53}}},
                {name: '烤鸭', brand: '全聚德', price: 128.0, options: {size: ['半只', '整只']}, prices: {size: {'半只': 128, '整只': 188}}},
                {name: '麻婆豆腐', brand: '陈麻婆', price: 22.0, options: {spicy: ['微辣', '中辣', '特辣']}},
                {name: '糖醋里脊', brand: '外婆家', price: 38.0, options: {size: ['小份', '大份']}},
                {name: '水煮鱼', brand: '巴奴', price: 58.0, options: {size: ['1-2人份', '3-4人份'], spicy: ['中辣', '特辣', '变态辣']}},
                {name: '回锅肉', brand: '川西坝子', price: 42.0, options: {spicy: ['微辣', '中辣', '特辣']}},
                {name: '蒸蛋羹', brand: '老娘舅', price: 15.0, options: {flavor: ['原味', '肉末', '虾仁']}, prices: {flavor: {'原味': 15, '肉末': 18, '虾仁': 20}}},
                {name: '红烧排骨', brand: '味千拉面', price: 48.0, options: {size: ['小份', '大份']}, prices: {size: {'小份': 38, '大份': 63}}},
                {name: '鱼香肉丝', brand: '眉州东坡', price: 35.0, options: {spicy: ['微辣', '中辣']}},
                {name: '白切鸡', brand: '广州酒家', price: 45.0, options: {size: ['半只', '整只']}, prices: {size: {'半只': 45, '整只': 80}}},
                {name: '蛋炒饭', brand: '扬州炒饭', price: 25.0, options: {ingredients: ['普通', '虾仁', '叉烧', '海鲜']}, prices: {ingredients: {'普通': 25, '虾仁': 33, '叉烧': 31, '海鲜': 37}}},
                {name: '担担面', brand: '成都小吃', price: 20.0, options: {spicy: ['微辣', '中辣', '特辣'], noodle: ['细面', '宽面']}},
                {name: '口水鸡', brand: '廖记棒棒鸡', price: 32.0, options: {spicy: ['微辣', '中辣', '特辣']}},
                {name: '红烧茄子', brand: '农家小炒', price: 18.0, options: {size: ['小份', '大份']}, prices: {size: {'小份': 15, '大份': 23}}},
                {name: '清蒸鲈鱼', brand: '渔家傲', price: 68.0, options: {weight: ['1斤', '1.5斤', '2斤']}, prices: {weight: {'1斤': 68, '1.5斤': 88, '2斤': 108}}}
            ],
            '甜点饮品': [
                {name: '珍珠奶茶', brand: '喜茶', price: 25.0, options: {sugar: ['无糖', '三分糖', '五分糖', '七分糖', '全糖'], ice: ['多冰', '少冰', '常温', '热'], size: ['小杯', '中杯', '大杯']}, prices: {size: {'小杯': 22, '中杯': 25, '大杯': 30}}},
                {name: '芝士蛋糕', brand: '星巴克', price: 38.0, options: {flavor: ['原味', '草莓', '蓝莓', '巧克力']}},
                {name: '提拉米苏', brand: '85度C', price: 32.0, options: {size: ['小份', '大份']}, prices: {size: {'小份': 27, '大份': 40}}},
                {name: '抹茶拿铁', brand: '瑞幸咖啡', price: 28.0, options: {sugar: ['无糖', '半糖', '全糖'], ice: ['多冰', '少冰', '常温', '热'], size: ['小杯', '中杯', '大杯']}},
                {name: '红豆沙冰', brand: '满记甜品', price: 22.0, options: {ice: ['多冰', '少冰'], size: ['小杯', '大杯']}},
                {name: '芒果班戟', brand: '许留山', price: 35.0, options: {count: ['1个', '2个', '4个']}, prices: {count: {'1个': 35, '2个': 50, '4个': 70}}},
                {name: '双皮奶', brand: '南信牛奶甜品', price: 18.0, options: {flavor: ['原味', '红豆', '芒果']}},
                {name: '柠檬茶', brand: '茶颜悦色', price: 20.0, options: {sugar: ['无糖', '三分糖', '五分糖', '七分糖'], ice: ['多冰', '少冰', '常温'], size: ['中杯', '大杯']}},
                {name: '马卡龙', brand: 'Ladurée', price: 45.0, options: {flavor: ['香草', '巧克力', '草莓', '柠檬'], count: ['3个', '6个', '12个']}},
                {name: '布丁', brand: '优格', price: 15.0, options: {flavor: ['原味', '焦糖', '芒果', '草莓']}},
                {name: '烧仙草', brand: '书亦烧仙草', price: 18.0, options: {sugar: ['三分糖', '五分糖', '七分糖'], ice: ['多冰', '少冰', '常温'], size: ['中杯', '大杯']}},
                {name: '芋圆', brand: '鲜芋仙', price: 22.0, options: {ice: ['多冰', '少冰'], toppings: ['红豆', '绿豆', '花生', '椰果']}},
                {name: '冰淇淋', brand: '哈根达斯', price: 58.0, options: {flavor: ['香草', '巧克力', '草莓', '抹茶'], size: ['小杯', '大杯']}},
                {name: '司康饼', brand: '面包新语', price: 25.0, options: {flavor: ['原味', '蓝莓', '巧克力']}},
                {name: '泡芙', brand: '原麦山丘', price: 28.0, options: {flavor: ['奶油', '巧克力', '抹茶'], count: ['3个', '6个']}},
                {name: '果汁', brand: '鲜果时间', price: 20.0, options: {flavor: ['橙汁', '苹果汁', '葡萄汁', '西瓜汁'], size: ['中杯', '大杯']}},
                {name: '咖啡', brand: '瑞幸咖啡', price: 24.0, options: {type: ['美式', '拿铁', '卡布奇诺'], sugar: ['无糖', '半糖', '全糖'], size: ['小杯', '中杯', '大杯']}},
                {name: '奶昔', brand: 'DQ', price: 32.0, options: {flavor: ['香草', '巧克力', '草莓', '芒果'], size: ['小杯', '中杯', '大杯']}},
                {name: '蛋挞', brand: 'KFC', price: 8.0, options: {count: ['1个', '6个', '12个']}},
                {name: '舒芙蕾', brand: '幸福西饼', price: 42.0, options: {flavor: ['原味', '巧克力', '抹茶']}}
            ],
            '蔬菜水果': [
                {name: '有机苹果', brand: '佳沛', price: 12.8, options: {weight: ['500g', '1kg', '2kg'], type: ['红富士', '青苹果']}},
                {name: '进口香蕉', brand: '都乐', price: 8.5, options: {weight: ['500g', '1kg']}},
                {name: '新鲜草莓', brand: '丹东草莓', price: 25.0, options: {weight: ['250g', '500g', '1kg']}},
                {name: '有机西红柿', brand: '寿光蔬菜', price: 6.8, options: {weight: ['500g', '1kg'], type: ['小番茄', '大番茄']}},
                {name: '新鲜黄瓜', brand: '山东蔬菜', price: 4.5, options: {weight: ['500g', '1kg']}},
                {name: '有机胡萝卜', brand: '绿色农场', price: 5.2, options: {weight: ['500g', '1kg']}},
                {name: '新鲜菠菜', brand: '本地农场', price: 3.8, options: {weight: ['250g', '500g']}},
                {name: '进口牛油果', brand: '墨西哥', price: 18.0, options: {count: ['2个', '4个', '6个'], ripeness: ['生', '半熟', '熟']}},
                {name: '有机白菜', brand: '东北农场', price: 3.2, options: {weight: ['500g', '1kg', '2kg']}},
                {name: '新鲜芹菜', brand: '本地蔬菜', price: 4.0, options: {weight: ['250g', '500g']}},
                {name: '进口橙子', brand: '新奇士', price: 15.8, options: {weight: ['1kg', '2kg'], type: ['脐橙', '血橙']}},
                {name: '有机土豆', brand: '内蒙古', price: 4.8, options: {weight: ['1kg', '2kg', '5kg']}},
                {name: '新鲜韭菜', brand: '本地农场', price: 6.0, options: {weight: ['250g', '500g']}},
                {name: '进口猕猴桃', brand: '佳沛', price: 28.0, options: {count: ['6个', '12个'], type: ['绿心', '黄心', '红心']}},
                {name: '有机茄子', brand: '山东蔬菜', price: 7.5, options: {weight: ['500g', '1kg'], type: ['长茄子', '圆茄子']}},
                {name: '新鲜葡萄', brand: '新疆葡萄', price: 22.0, options: {weight: ['500g', '1kg'], type: ['红提', '青提', '巨峰']}},
                {name: '有机大蒜', brand: '山东大蒜', price: 12.0, options: {weight: ['250g', '500g']}},
                {name: '新鲜柠檬', brand: '四川柠檬', price: 8.8, options: {count: ['3个', '6个', '10个']}},
                {name: '进口蓝莓', brand: '智利蓝莓', price: 35.0, options: {weight: ['125g', '250g']}},
                {name: '有机生菜', brand: '本地农场', price: 5.5, options: {weight: ['250g', '500g'], type: ['球生菜', '散叶生菜']}}
            ],
            '看病买药': [
                {name: '感冒灵颗粒', brand: '999', price: 18.5, options: {package: ['6袋装', '12袋装', '24袋装']}},
                {name: '板蓝根颗粒', brand: '白云山', price: 15.0, options: {package: ['10袋装', '20袋装']}},
                {name: '维生素C', brand: '汤臣倍健', price: 68.0, options: {count: ['60片', '100片'], type: ['咀嚼片', '泡腾片']}},
                {name: '创可贴', brand: '邦迪', price: 12.0, options: {size: ['标准型', '大号', '防水型'], count: ['10片', '20片']}},
                {name: '体温计', brand: '欧姆龙', price: 85.0, options: {type: ['电子体温计', '红外体温计']}},
                {name: '碘伏', brand: '利康', price: 8.5, options: {volume: ['30ml', '60ml', '100ml']}},
                {name: '止痛片', brand: '芬必得', price: 25.0, options: {count: ['12片', '24片']}},
                {name: '胃药', brand: '达喜', price: 32.0, options: {count: ['20片', '40片']}},
                {name: '眼药水', brand: '珍视明', price: 18.0, options: {volume: ['10ml', '15ml'], type: ['缓解疲劳', '抗菌消炎']}},
                {name: '口罩', brand: '3M', price: 45.0, options: {type: ['医用外科', 'N95'], count: ['10个', '50个']}},
                {name: '血压计', brand: '欧姆龙', price: 298.0, options: {type: ['上臂式', '手腕式']}},
                {name: '钙片', brand: '钙尔奇', price: 88.0, options: {count: ['60片', '100片'], type: ['碳酸钙', '柠檬酸钙']}},
                {name: '消毒液', brand: '滴露', price: 22.0, options: {volume: ['500ml', '1L'], type: ['衣物消毒', '地面消毒']}},
                {name: '纱布', brand: '振德', price: 15.0, options: {size: ['5cm×5m', '10cm×5m'], type: ['无菌', '普通']}},
                {name: '退烧药', brand: '美林', price: 28.0, options: {type: ['儿童装', '成人装'], volume: ['100ml', '200ml']}},
                {name: '护肝片', brand: '葵花', price: 45.0, options: {count: ['36片', '72片']}},
                {name: '止咳糖浆', brand: '急支糖浆', price: 24.0, options: {volume: ['100ml', '200ml']}},
                {name: '胰岛素笔', brand: '诺和诺德', price: 180.0, options: {type: ['速效', '长效']}},
                {name: '血糖试纸', brand: '强生', price: 120.0, options: {count: ['25片', '50片']}},
                {name: '维生素D', brand: '自然之宝', price: 78.0, options: {count: ['60粒', '100粒'], strength: ['400IU', '1000IU']}}
            ],
            '数码产品': [
                {name: 'iPhone 15', brand: 'Apple', price: 5999.0, options: {storage: ['128GB', '256GB', '512GB'], color: ['黑色', '白色', '蓝色', '粉色']}},
                {name: '小米13', brand: '小米', price: 3999.0, options: {storage: ['128GB', '256GB'], color: ['黑色', '白色', '绿色']}},
                {name: 'MacBook Air', brand: 'Apple', price: 8999.0, options: {chip: ['M2', 'M3'], storage: ['256GB', '512GB', '1TB'], color: ['银色', '深空灰', '星光色']}},
                {name: '华为P60', brand: '华为', price: 4488.0, options: {storage: ['128GB', '256GB', '512GB'], color: ['黑色', '白色', '紫色']}},
                {name: 'iPad Pro', brand: 'Apple', price: 6799.0, options: {size: ['11英寸', '12.9英寸'], storage: ['128GB', '256GB', '512GB', '1TB']}},
                {name: 'AirPods Pro', brand: 'Apple', price: 1899.0, options: {generation: ['第二代', '第三代']}},
                {name: '戴尔XPS13', brand: 'Dell', price: 7999.0, options: {processor: ['i5', 'i7'], ram: ['8GB', '16GB', '32GB'], storage: ['256GB', '512GB', '1TB']}},
                {name: '索尼WH-1000XM5', brand: 'Sony', price: 2399.0, options: {color: ['黑色', '银色']}},
                {name: 'Switch游戏机', brand: '任天堂', price: 2099.0, options: {type: ['标准版', 'OLED版'], color: ['红蓝', '灰色', '白色']}},
                {name: '小米手环8', brand: '小米', price: 299.0, options: {color: ['黑色', '蓝色', '粉色'], strap: ['运动表带', '皮质表带']}},
                {name: 'Kindle', brand: 'Amazon', price: 899.0, options: {storage: ['8GB', '32GB'], type: ['标准版', 'Paperwhite', 'Oasis']}},
                {name: '罗技鼠标', brand: '罗技', price: 299.0, options: {type: ['有线', '无线'], dpi: ['1000DPI', '2000DPI', '4000DPI']}},
                {name: '机械键盘', brand: '雷蛇', price: 899.0, options: {switch: ['青轴', '红轴', '茶轴'], backlight: ['无背光', 'RGB背光']}},
                {name: '移动硬盘', brand: '西部数据', price: 599.0, options: {capacity: ['1TB', '2TB', '4TB'], type: ['USB3.0', 'Type-C']}},
                {name: '充电宝', brand: '小米', price: 149.0, options: {capacity: ['10000mAh', '20000mAh'], type: ['普通版', '快充版']}},
                {name: '蓝牙音箱', brand: 'JBL', price: 699.0, options: {size: ['便携版', '标准版'], color: ['黑色', '蓝色', '红色']}},
                {name: '智能手表', brand: 'Apple Watch', price: 2999.0, options: {size: ['41mm', '45mm'], band: ['运动表带', '皮质表带', '不锈钢表带']}},
                {name: '无线充电器', brand: '贝尔金', price: 299.0, options: {power: ['5W', '10W', '15W'], type: ['立式', '平放式']}},
                {name: '摄像头', brand: '罗技', price: 599.0, options: {resolution: ['1080P', '4K'], type: ['普通版', '广角版']}},
                {name: '路由器', brand: '华硕', price: 899.0, options: {speed: ['AC1200', 'AC1900', 'AX3000'], antenna: ['2天线', '4天线', '6天线']}}
            ],
            '家居百货': [
                {name: '乳胶枕', brand: '邓禄普', price: 299.0, options: {height: ['低枕', '中枕', '高枕'], hardness: ['软', '中等', '硬']}},
                {name: '四件套', brand: '水星家纺', price: 399.0, options: {size: ['1.5m床', '1.8m床', '2.0m床'], material: ['纯棉', '天丝', '真丝']}},
                {name: '电饭煲', brand: '美的', price: 599.0, options: {capacity: ['3L', '4L', '5L'], type: ['普通版', '智能版']}},
                {name: '吸尘器', brand: '戴森', price: 2999.0, options: {type: ['手持式', '立式', '扫地机器人'], power: ['标准版', '强力版']}},
                {name: '空气净化器', brand: '小米', price: 1299.0, options: {coverage: ['30㎡', '50㎡', '80㎡'], filter: ['标准滤网', 'HEPA滤网']}},
                {name: '台灯', brand: '飞利浦', price: 299.0, options: {type: ['护眼灯', 'LED灯'], brightness: ['三档调光', '无级调光']}},
                {name: '保温杯', brand: '膳魔师', price: 199.0, options: {capacity: ['350ml', '500ml', '750ml'], color: ['黑色', '白色', '蓝色', '粉色']}},
                {name: '毛巾', brand: '洁丽雅', price: 39.0, options: {size: ['面巾', '浴巾'], material: ['纯棉', '竹纤维'], color: ['白色', '蓝色', '粉色']}},
                {name: '垃圾桶', brand: '拓牌', price: 89.0, options: {capacity: ['8L', '12L', '20L'], type: ['脚踏式', '感应式']}},
                {name: '收纳盒', brand: '爱丽思', price: 59.0, options: {size: ['小号', '中号', '大号'], material: ['塑料', '布艺'], color: ['透明', '白色', '灰色']}},
                {name: '拖鞋', brand: '南极人', price: 29.0, options: {size: ['36-37', '38-39', '40-41', '42-43'], type: ['居家拖鞋', '浴室拖鞋']}},
                {name: '衣架', brand: '太力', price: 25.0, options: {material: ['塑料', '不锈钢'], type: ['普通衣架', '防滑衣架'], count: ['10个', '20个', '50个']}},
                {name: '洗衣液', brand: '蓝月亮', price: 45.0, options: {volume: ['1kg', '2kg', '3kg'], type: ['深层洁净', '护色', '婴儿专用']}},
                {name: '纸巾', brand: '维达', price: 35.0, options: {type: ['抽纸', '卷纸'], layers: ['3层', '4层'], count: ['12包', '24包']}},
                {name: '洗洁精', brand: '立白', price: 18.0, options: {volume: ['500ml', '1L', '2L'], type: ['普通', '柠檬香', '芦荟']}},
                {name: '床垫', brand: '慕思', price: 2999.0, options: {size: ['1.5m', '1.8m', '2.0m'], type: ['弹簧床垫', '乳胶床垫', '记忆棉床垫']}},
                {name: '窗帘', brand: '摩力克', price: 299.0, options: {size: ['1.5m宽', '2.0m宽', '2.5m宽'], material: ['棉麻', '雪尼尔', '遮光布']}},
                {name: '地毯', brand: '山花', price: 199.0, options: {size: ['60×90cm', '120×160cm', '160×230cm'], material: ['化纤', '羊毛']}},
                {name: '花洒', brand: '九牧', price: 399.0, options: {type: ['手持花洒', '顶喷花洒'], function: ['普通', '按摩', '节水']}},
                {name: '马桶刷', brand: '好人', price: 25.0, options: {type: ['普通刷', '一次性刷头'], handle: ['长柄', '短柄']}}
            ],
            '女装男装': [
                {name: '连衣裙', brand: 'ZARA', price: 299.0, options: {size: ['S', 'M', 'L', 'XL'], color: ['黑色', '白色', '蓝色', '红色'], style: ['A字裙', '直筒裙']}},
                {name: '牛仔裤', brand: 'Levi\'s', price: 599.0, options: {size: ['28', '29', '30', '31', '32', '33', '34'], color: ['深蓝', '浅蓝', '黑色'], fit: ['修身', '直筒', '宽松']}},
                {name: 'T恤', brand: 'Uniqlo', price: 99.0, options: {size: ['S', 'M', 'L', 'XL', 'XXL'], color: ['白色', '黑色', '灰色', '蓝色', '红色'], sleeve: ['短袖', '长袖']}},
                {name: '西装', brand: 'Hugo Boss', price: 2999.0, options: {size: ['46', '48', '50', '52', '54'], color: ['黑色', '深蓝', '灰色'], style: ['修身', '经典']}},
                {name: '羽绒服', brand: 'Canada Goose', price: 4999.0, options: {size: ['S', 'M', 'L', 'XL'], color: ['黑色', '军绿', '海军蓝'], length: ['短款', '中长款', '长款']}},
                {name: '毛衣', brand: 'H&M', price: 199.0, options: {size: ['S', 'M', 'L', 'XL'], color: ['米色', '灰色', '黑色', '红色'], material: ['羊毛', '棉质', '混纺']}},
                {name: '衬衫', brand: 'CK', price: 399.0, options: {size: ['S', 'M', 'L', 'XL', 'XXL'], color: ['白色', '蓝色', '粉色'], collar: ['尖领', '圆领'], sleeve: ['长袖', '短袖']}},
                {name: '短裤', brand: 'Nike', price: 299.0, options: {size: ['S', 'M', 'L', 'XL'], color: ['黑色', '灰色', '蓝色'], length: ['5分', '7分'], type: ['运动', '休闲']}},
                {name: '裙子', brand: 'Only', price: 259.0, options: {size: ['S', 'M', 'L', 'XL'], color: ['黑色', '白色', '花色'], length: ['短裙', '中裙', '长裙']}},
                {name: '外套', brand: 'Adidas', price: 699.0, options: {size: ['S', 'M', 'L', 'XL', 'XXL'], color: ['黑色', '白色', '蓝色'], type: ['夹克', '卫衣', '风衣']}},
                {name: '内衣', brand: '黛安芬', price: 199.0, options: {size: ['70A', '70B', '75A', '75B', '80A', '80B'], color: ['黑色', '白色', '肉色'], type: ['无钢圈', '有钢圈']}},
                {name: '内裤', brand: 'CK', price: 89.0, options: {size: ['S', 'M', 'L', 'XL'], color: ['黑色', '白色', '灰色'], type: ['三角', '平角'], count: ['1条', '3条装']}},
                {name: '袜子', brand: '浪莎', price: 25.0, options: {size: ['均码'], color: ['黑色', '白色', '灰色', '肉色'], type: ['短袜', '中筒袜', '长筒袜'], count: ['1双', '5双装']}},
                {name: '睡衣', brand: '安之伴', price: 159.0, options: {size: ['S', 'M', 'L', 'XL'], color: ['粉色', '蓝色', '白色'], material: ['纯棉', '丝绸', '莫代尔'], style: ['套装', '连体']}},
                {name: '运动服', brand: 'Under Armour', price: 599.0, options: {size: ['S', 'M', 'L', 'XL', 'XXL'], color: ['黑色', '灰色', '蓝色'], type: ['套装', '单件'], function: ['速干', '保暖']}},
                {name: '泳衣', brand: 'Speedo', price: 299.0, options: {size: ['S', 'M', 'L', 'XL'], color: ['黑色', '蓝色', '红色'], type: ['连体', '分体'], style: ['运动', '休闲']}},
                {name: '围巾', brand: 'Burberry', price: 1299.0, options: {material: ['羊毛', '羊绒', '丝绸'], color: ['经典格纹', '纯色'], size: ['标准', '加长']}},
                {name: '帽子', brand: 'New Era', price: 199.0, options: {type: ['棒球帽', '针织帽', '渔夫帽'], color: ['黑色', '白色', '蓝色', '红色'], size: ['均码', '可调节']}},
                {name: '手套', brand: 'The North Face', price: 199.0, options: {size: ['S', 'M', 'L'], color: ['黑色', '灰色', '蓝色'], type: ['保暖手套', '触屏手套'], material: ['羊毛', '抓绒']}},
                {name: '腰带', brand: 'Gucci', price: 2999.0, options: {size: ['90cm', '95cm', '100cm', '105cm', '110cm'], color: ['黑色', '棕色'], material: ['真皮', '帆布'], buckle: ['金扣', '银扣']}}
            ],
            '饰品箱包': [
                {name: '手提包', brand: 'LV', price: 15999.0, options: {size: ['小号', '中号', '大号'], color: ['经典棕', '黑色', '白色'], material: ['帆布', '真皮']}},
                {name: '双肩包', brand: 'Herschel', price: 699.0, options: {size: ['15L', '20L', '25L'], color: ['黑色', '灰色', '蓝色', '红色'], material: ['帆布', '尼龙']}},
                {name: '钱包', brand: 'Coach', price: 1299.0, options: {type: ['长款', '短款'], color: ['黑色', '棕色', '红色'], material: ['真皮', '帆布']}},
                {name: '手表', brand: 'Rolex', price: 89999.0, options: {type: ['机械表', '石英表'], material: ['不锈钢', '黄金', '玫瑰金'], size: ['36mm', '40mm']}},
                {name: '项链', brand: 'Tiffany', price: 3999.0, options: {material: ['银', '金', '铂金'], length: ['40cm', '45cm', '50cm'], style: ['简约', '镶钻']}},
                {name: '耳环', brand: 'Pandora', price: 599.0, options: {type: ['耳钉', '耳环', '耳夹'], material: ['银', '金'], style: ['简约', '镶钻', '珍珠']}},
                {name: '戒指', brand: 'Cartier', price: 8999.0, options: {size: ['6号', '7号', '8号', '9号', '10号'], material: ['银', '金', '铂金'], style: ['简约', '镶钻']}},
                {name: '手镯', brand: '周大福', price: 2999.0, options: {material: ['银', '金', '玉'], style: ['简约', '雕花', '镶钻'], size: ['标准', '加大']}},
                {name: '太阳镜', brand: 'Ray-Ban', price: 1299.0, options: {style: ['飞行员', '方框', '圆框'], color: ['黑色', '棕色', '蓝色'], lens: ['偏光', '普通']}},
                {name: '丝巾', brand: 'Hermès', price: 2999.0, options: {size: ['90cm×90cm', '140cm×140cm'], color: ['经典橙', '蓝色', '粉色'], material: ['真丝', '羊绒']}},
                {name: '发夹', brand: '施华洛世奇', price: 299.0, options: {type: ['发卡', '发箍', '发绳'], color: ['金色', '银色', '玫瑰金'], style: ['简约', '镶钻']}},
                {name: '胸针', brand: 'Chanel', price: 4999.0, options: {material: ['金属', '珍珠'], style: ['经典CC', '花朵', '动物'], color: ['金色', '银色']}},
                {name: '行李箱', brand: 'Samsonite', price: 1999.0, options: {size: ['20寸', '24寸', '28寸'], color: ['黑色', '银色', '蓝色'], type: ['硬壳', '软壳'], wheels: ['万向轮', '定向轮']}},
                {name: '化妆包', brand: 'Marc Jacobs', price: 899.0, options: {size: ['小号', '中号', '大号'], color: ['黑色', '粉色', '白色'], material: ['皮质', '帆布']}},
                {name: '钥匙扣', brand: 'Prada', price: 599.0, options: {material: ['金属', '皮质'], color: ['黑色', '银色', '金色'], style: ['简约', '品牌logo']}},
                {name: '手机壳', brand: 'Apple', price: 399.0, options: {model: ['iPhone 14', 'iPhone 15'], color: ['透明', '黑色', '白色', '蓝色'], material: ['硅胶', '皮质', '透明']}},
                {name: '珠宝盒', brand: '周生生', price: 299.0, options: {size: ['小号', '中号', '大号'], color: ['红色', '黑色', '白色'], material: ['绒布', '皮质']}},
                {name: '香水', brand: 'Chanel No.5', price: 899.0, options: {volume: ['30ml', '50ml', '100ml'], type: ['淡香水', '香水'], packaging: ['普通装', '礼盒装']}},
                {name: '口红', brand: 'YSL', price: 299.0, options: {color: ['正红', '玫红', '橘红', '豆沙色'], finish: ['哑光', '丝绒', '水润'], series: ['方管', '圆管']}},
                {name: '指甲油', brand: 'OPI', price: 89.0, options: {color: ['红色', '粉色', '蓝色', '黑色', '透明'], finish: ['普通', '珠光', '哑光'], volume: ['15ml', '30ml']}}
            ]
        };

        // 🛒【新增】显示分类商品
        function showCategoryProducts(categoryName) {
            const categoriesDiv = document.getElementById('shopping-categories');
            const productsDiv = document.getElementById('products-container');
            const searchContainer = document.querySelector('.shopping-search-container');
            const appTitle = document.querySelector('#shopping-screen .app-title');
            const gridElement = document.getElementById('products-grid');
            const shoppingContent = document.querySelector('.shopping-content');

            // 隐藏分类和搜索框，显示商品
            categoriesDiv.style.display = 'none';
            searchContainer.style.display = 'none';
            productsDiv.style.display = 'block';

            // 🛒【修复】添加showing-products类来移除顶部padding
            shoppingContent.classList.add('showing-products');

            // 更新顶部应用栏标题
            appTitle.textContent = categoryName;

            // 清空商品网格
            gridElement.innerHTML = '';

            // 获取该分类的商品
            const products = productsData[categoryName] || [];

            // 生成商品HTML
            products.forEach((product, index) => {
                // 检查是否有价格变化选项
                const hasVariablePrice = product.prices && Object.keys(product.prices).length > 0;
                const priceDisplay = hasVariablePrice ? `¥${product.price}起` : `¥${product.price}`;

                const productHTML = `
                    <div class="product-item">
                        <div class="product-name">${product.name}</div>
                        <div class="product-brand">${product.brand}</div>
                        <div class="product-price">${priceDisplay}</div>
                        <button class="add-to-cart-btn" onclick="addToCart('${categoryName}', ${index})">
                            加入购物车
                        </button>
                    </div>
                `;
                gridElement.innerHTML += productHTML;
            });
        }

        // 🛒【新增】返回分类页面
        function backToCategories() {
            const categoriesDiv = document.getElementById('shopping-categories');
            const productsDiv = document.getElementById('products-container');
            const searchContainer = document.querySelector('.shopping-search-container');
            const appTitle = document.querySelector('#shopping-screen .app-title');
            const shoppingContent = document.querySelector('.shopping-content');

            // 显示分类和搜索框，隐藏商品
            categoriesDiv.style.display = 'block';
            searchContainer.style.display = 'flex';
            productsDiv.style.display = 'none';

            // 🛒【修复】移除showing-products类来恢复顶部padding
            shoppingContent.classList.remove('showing-products');

            // 🔥【修复】根据当前活跃的标签页设置标题
            const activeTab = document.querySelector('.shopping-tab.active');
            if (activeTab && activeTab.textContent.trim() === '外卖') {
                appTitle.textContent = '外卖';
            } else {
                appTitle.textContent = '购物';
            }
        }

        // 🛒【新增】处理购物界面返回按钮
        function handleShoppingBack() {
            const productsDiv = document.getElementById('products-container');

            // 如果当前在商品页面，返回分类页面
            if (productsDiv.style.display === 'block') {
                backToCategories();
            } else {
                // 如果在分类页面，返回到进入购物前的界面
                hideApp('shopping-screen');
                showApp(previousScreenBeforeShopping);
            }
        }

        // 🛒【新增】购物车数据
        let shoppingCart = [];

        // 🛒【新增】添加到购物车
        function addToCart(categoryName, productIndex) {
            const product = productsData[categoryName][productIndex];
            if (!product) return;

            // 检查是否有选项需要选择
            if (product.options && Object.keys(product.options).length > 0) {
                showProductOptions(categoryName, productIndex);
            } else {
                // 直接添加到购物车
                // 检查是否已存在相同的商品
                const existingItemIndex = shoppingCart.findIndex(item =>
                    item.name === product.name &&
                    item.brand === product.brand &&
                    Object.keys(item.selectedOptions || {}).length === 0
                );

                if (existingItemIndex !== -1) {
                    // 如果已存在，增加数量
                    shoppingCart[existingItemIndex].quantity += 1;
                } else {
                    // 如果不存在，添加新商品
                    const finalPrice = getProductPrice(product, {});
                    const cartItem = {
                        name: product.name,
                        brand: product.brand,
                        price: finalPrice,
                        category: categoryName,
                        selectedOptions: {},
                        quantity: 1
                    };
                    shoppingCart.push(cartItem);
                }

                updateCartBadge(getTotalCartItems());
                showCustomToast(`${product.name} 已添加到购物车`, 'success');
            }
        }

        // 🛒【新增】显示商品选项
        function showProductOptions(categoryName, productIndex) {
            const product = productsData[categoryName][productIndex];
            let optionsHTML = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; justify-content: center; align-items: center;" onclick="closeProductOptions(event)">
                    <div style="background: white; border-radius: 15px; padding: 20px; max-width: 350px; width: 90%; max-height: 80vh; overflow-y: auto;" onclick="event.stopPropagation()">
                        <h3 style="margin: 0 0 15px 0; color: #333;">${product.name}</h3>
                        <p style="margin: 0 0 10px 0; color: #666; font-size: 14px;">${product.brand}</p>
                        <p style="margin: 0 0 15px 0; color: #ff6600; font-size: 18px; font-weight: 600;" id="current-price">¥${product.price}</p>
                        <div id="product-options-form">
            `;

            // 生成选项表单
            for (const [optionKey, optionValues] of Object.entries(product.options)) {
                const optionLabel = getOptionLabel(optionKey);
                optionsHTML += `
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">${optionLabel}:</label>
                        <select id="option-${optionKey}" onchange="updateProductPrice('${categoryName}', ${productIndex})" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px;">
                `;
                optionValues.forEach(value => {
                    optionsHTML += `<option value="${value}">${value}</option>`;
                });
                optionsHTML += `</select></div>`;
            }

            optionsHTML += `
                        </div>
                        <div style="display: flex; gap: 10px; margin-top: 20px;">
                            <button onclick="closeProductOptions()" style="flex: 1; padding: 12px; background: #f0f0f0; border: none; border-radius: 8px; color: #666; font-weight: 600;">取消</button>
                            <button onclick="confirmAddToCart('${categoryName}', ${productIndex})" style="flex: 1; padding: 12px; background: #5a92c5; border: none; border-radius: 8px; color: white; font-weight: 600;">加入购物车</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', optionsHTML);
        }

        // 🛒【新增】获取选项标签
        function getOptionLabel(optionKey) {
            const labels = {
                'size': '尺寸',
                'color': '颜色',
                'sugar': '糖度',
                'ice': '冰度',
                'spicy': '辣度',
                'flavor': '口味',
                'count': '数量',
                'weight': '重量',
                'type': '类型',
                'storage': '存储',
                'material': '材质',
                'style': '款式',
                'volume': '容量',
                'package': '包装',
                'capacity': '容量',
                'strength': '强度',
                'noodle': '面条',
                'soup': '汤底',
                'ingredients': '配料',
                'ripeness': '成熟度',
                'toppings': '配菜',
                'finish': '质地',
                'series': '系列',
                'model': '型号',
                'chip': '芯片',
                'processor': '处理器',
                'ram': '内存',
                'generation': '代数',
                'switch': '轴体',
                'backlight': '背光',
                'dpi': 'DPI',
                'power': '功率',
                'resolution': '分辨率',
                'antenna': '天线',
                'speed': '速度',
                'hardness': '软硬度',
                'layers': '层数',
                'function': '功能',
                'coverage': '覆盖面积',
                'filter': '滤网',
                'brightness': '亮度',
                'fit': '版型',
                'sleeve': '袖长',
                'collar': '领型',
                'length': '长度',
                'buckle': '扣子',
                'lens': '镜片',
                'wheels': '轮子',
                'packaging': '包装',
                'handle': '手柄'
            };
            return labels[optionKey] || optionKey;
        }

        // 🛒【新增】确认添加到购物车
        function confirmAddToCart(categoryName, productIndex) {
            const product = productsData[categoryName][productIndex];
            const selectedOptions = {};

            // 收集选择的选项
            for (const optionKey of Object.keys(product.options)) {
                const selectElement = document.getElementById(`option-${optionKey}`);
                if (selectElement) {
                    selectedOptions[optionKey] = selectElement.value;
                }
            }

            // 检查是否已存在相同的商品（包括选项）
            const existingItemIndex = shoppingCart.findIndex(item =>
                item.name === product.name &&
                item.brand === product.brand &&
                JSON.stringify(item.selectedOptions) === JSON.stringify(selectedOptions)
            );

            if (existingItemIndex !== -1) {
                // 如果已存在，增加数量
                shoppingCart[existingItemIndex].quantity += 1;
            } else {
                // 如果不存在，添加新商品
                const finalPrice = getProductPrice(product, selectedOptions);
                const cartItem = {
                    name: product.name,
                    brand: product.brand,
                    price: finalPrice,
                    category: categoryName,
                    selectedOptions: selectedOptions,
                    quantity: 1
                };
                shoppingCart.push(cartItem);
            }

            updateCartBadge(getTotalCartItems());
            closeProductOptions();

            // 显示添加成功信息
            const optionsText = Object.entries(selectedOptions).map(([key, value]) => `${getOptionLabel(key)}: ${value}`).join(', ');
            const optionsDisplay = optionsText ? ` (${optionsText})` : '';
            showCustomToast(`${product.name}${optionsDisplay} 已添加到购物车`, 'success');
        }

        // 🛒【新增】关闭商品选项
        function closeProductOptions(event) {
            if (event && event.target !== event.currentTarget) return;
            const modal = document.querySelector('[style*="position: fixed"][style*="z-index: 10000"]');
            if (modal) {
                modal.remove();
            }
        }

        // 🛒【新增】添加自定义商品功能
        function addCustomItem() {
            showCustomItemModal();
        }

        // 🛒【新增】显示自定义商品模态框
        function showCustomItemModal() {
            const modal = document.getElementById('custom-item-modal');
            const nameInput = document.getElementById('custom-item-name');
            const descriptionInput = document.getElementById('custom-item-description');
            const priceInput = document.getElementById('custom-item-price');

            // 清空输入框
            nameInput.value = '';
            descriptionInput.value = '';
            priceInput.value = '';

            modal.style.display = 'flex';

            // 聚焦到名称输入框
            setTimeout(() => {
                nameInput.focus();
            }, 100);
        }

        // 🛒【新增】隐藏自定义商品模态框
        function hideCustomItemModal(event) {
            if (event && event.target !== event.currentTarget) return;

            const modal = document.getElementById('custom-item-modal');
            modal.style.display = 'none';
        }

        // 🛒【新增】确认添加自定义商品
        function confirmAddCustomItem() {
            const nameInput = document.getElementById('custom-item-name');
            const descriptionInput = document.getElementById('custom-item-description');
            const priceInput = document.getElementById('custom-item-price');

            const itemName = nameInput.value.trim();
            const itemDescription = descriptionInput.value.trim();
            const itemPrice = priceInput.value.trim();

            // 验证输入
            if (!itemName) {
                showCustomToast('请输入商品名称', 'error');
                nameInput.focus();
                return;
            }

            if (!itemPrice || isNaN(itemPrice) || parseFloat(itemPrice) <= 0) {
                showCustomToast('请输入有效的价格', 'error');
                priceInput.focus();
                return;
            }

            // 检查是否已存在相同的自定义商品（仅根据名称判断）
            const existingItemIndex = shoppingCart.findIndex(item =>
                item.name === itemName &&
                item.brand === '自定义'
            );

            if (existingItemIndex !== -1) {
                // 如果已存在，增加数量
                shoppingCart[existingItemIndex].quantity += 1;
            } else {
                // 如果不存在，添加新商品
                const cartItem = {
                    name: itemName,
                    brand: '自定义',
                    description: itemDescription || '', // 商品介绍，可选
                    unit: '', // 不显示单位
                    price: parseFloat(itemPrice),
                    category: '自定义',
                    selectedOptions: {},
                    quantity: 1
                };
                shoppingCart.push(cartItem);
            }

            updateCartBadge(getTotalCartItems());
            showCustomToast(`${itemName} 已添加到购物车`, 'success');

            // 隐藏模态框
            hideCustomItemModal();
        }

        // 🛒【新增】处理自定义商品输入框键盘事件
        function handleCustomItemKeydown(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                confirmAddCustomItem();
            } else if (event.key === 'Escape') {
                event.preventDefault();
                hideCustomItemModal();
            }
        }

        // 🛒【新增】记录购物车前的界面
        let previousScreenBeforeCart = 'shopping-screen'; // 默认返回购物界面

        // 🛒【新增】记录购物界面前的界面
        let previousScreenBeforeShopping = 'chat-screen'; // 默认返回聊天界面

        // 🛒【新增】记录用户选择的付款方式
        let selectedPaymentMethod = 'self_pay'; // 'self_pay' 或 'request_pay'

        // 🛒【新增】打开购物界面
        function openShoppingScreen() {
            // 记录当前显示的界面
            const currentScreen = document.querySelector('.app-screen:not([style*="display: none"])');
            if (currentScreen) {
                previousScreenBeforeShopping = currentScreen.id;
            }

            showApp('shopping-screen');

            // 🔥【新增】默认切换到外卖标签页
            switchShoppingTab('takeout');
        }

        // 🛒【新增】购物车功能
        function openShoppingCart() {
            // 记录当前显示的界面
            const currentScreen = document.querySelector('.app-screen:not([style*="display: none"])');
            if (currentScreen) {
                previousScreenBeforeCart = currentScreen.id;
            }

            showApp('shopping-cart-screen');
            renderShoppingCart();
        }

        // 🛒【新增】渲染购物车内容
        function renderShoppingCart() {
            const cartContainer = document.getElementById('cart-items-container');
            const emptyState = document.getElementById('cart-empty-state');
            const cartFooter = document.getElementById('cart-footer');
            const totalPrice = document.getElementById('cart-total-price');
            const itemsCount = document.getElementById('cart-items-count');

            if (shoppingCart.length === 0) {
                cartContainer.style.display = 'none';
                emptyState.style.display = 'flex';
                cartFooter.style.display = 'none';
                return;
            }

            cartContainer.style.display = 'block';
            emptyState.style.display = 'none';
            cartFooter.style.display = 'block';

            // 清空容器
            cartContainer.innerHTML = '';

            let total = 0;
            let totalItems = 0;

            // 渲染每个购物车项目
            shoppingCart.forEach((item, index) => {
                const itemTotal = item.price * item.quantity;
                total += itemTotal;
                totalItems += item.quantity;

                const optionsText = Object.entries(item.selectedOptions || {})
                    .map(([key, value]) => `${getOptionLabel(key)}: ${value}`)
                    .join(', ');

                // 构建品牌显示文本
                let brandText = item.brand;
                // 对于自定义商品，不显示单位
                if (item.brand !== '自定义' && item.unit) {
                    brandText += ` · ${item.unit}`;
                }

                const cartItemHTML = `
                    <div class="cart-item">
                        <div class="cart-item-header">
                            <div class="cart-item-info">
                                <div class="cart-item-name">${item.name}</div>
                                <div class="cart-item-brand">${brandText}</div>
                                ${item.description ? `<div class="cart-item-description">${item.description}</div>` : ''}
                                ${optionsText ? `<div class="cart-item-options">${optionsText}</div>` : ''}
                            </div>
                            <button class="cart-item-remove" onclick="removeFromCart(${index})" title="移除商品">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="cart-item-footer">
                            <div class="cart-item-price">¥${itemTotal.toFixed(2)}</div>
                            <div class="cart-item-quantity">
                                <button class="quantity-btn" onclick="updateCartItemQuantity(${index}, ${item.quantity - 1})" ${item.quantity <= 1 ? 'disabled' : ''}>
                                    <i class="fas fa-minus"></i>
                                </button>
                                <span class="quantity-number">${item.quantity}</span>
                                <button class="quantity-btn" onclick="updateCartItemQuantity(${index}, ${item.quantity + 1})">
                                    <i class="fas fa-plus"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                cartContainer.innerHTML += cartItemHTML;
            });

            // 更新总价和数量
            totalPrice.textContent = `¥${total.toFixed(2)}`;
            itemsCount.textContent = totalItems;
        }

        // 🛒【新增】从购物车移除商品
        function removeFromCart(index) {
            const item = shoppingCart[index];
            const itemName = item ? item.name : '商品';

            showCustomConfirm(
                '移除商品',
                `确定要移除 "${itemName}" 吗？`,
                () => {
                    // 确认移除
                    shoppingCart.splice(index, 1);
                    renderShoppingCart();
                    updateCartBadge(getTotalCartItems());
                    showCustomToast('商品已移除', 'success');
                }
            );
        }

        // 🛒【新增】更新购物车商品数量
        function updateCartItemQuantity(index, newQuantity) {
            if (newQuantity <= 0) {
                removeFromCart(index);
                return;
            }

            shoppingCart[index].quantity = newQuantity;
            renderShoppingCart();
            updateCartBadge(getTotalCartItems());
        }

        // 🛒【新增】清空购物车
        function clearShoppingCart() {
            if (shoppingCart.length === 0) return;

            const itemCount = getTotalCartItems();
            showCustomConfirm(
                '清空购物车',
                `确定要清空购物车中的 ${itemCount} 件商品吗？`,
                () => {
                    // 确认清空
                    shoppingCart = [];
                    renderShoppingCart();
                    updateCartBadge(0);
                    showCustomToast('购物车已清空', 'success');
                }
            );
        }

        // 🛒【新增】获取购物车总商品数量
        function getTotalCartItems() {
            return shoppingCart.reduce((total, item) => total + item.quantity, 0);
        }

        // 🛒【修改】请Ta代付功能
        function requestPayment() {
            showRecipientModal('request_pay');
        }

        // 🛒【新增】显示收货人选择模态框
        function showRecipientModal(paymentMethod) {
            if (shoppingCart.length === 0) {
                showCustomToast('购物车是空的', 'error');
                return;
            }

            if (!currentChatCharacter) {
                showCustomToast('请先选择一个聊天对象', 'error');
                return;
            }

            // 记录用户选择的付款方式
            selectedPaymentMethod = paymentMethod;

            const total = shoppingCart.reduce((sum, item) => sum + (item.price * item.quantity), 0);
            const itemsCount = getTotalCartItems();

            // 更新模态框中的金额和商品数量
            document.getElementById('payment-modal-total').textContent = `¥${total.toFixed(2)}`;
            document.getElementById('payment-modal-items-count').textContent = itemsCount;

            // 显示收货人选择模态框
            document.getElementById('payment-request-modal').style.display = 'flex';
        }

        // 🛒【修改】结算功能
        function proceedToCheckout() {
            showRecipientModal('self_pay');
        }

        // 🛒【新增】购物车返回处理
        function handleShoppingCartBack() {
            // 隐藏购物车界面
            hideApp('shopping-cart-screen');
            // 返回到进入购物车前的界面
            showApp(previousScreenBeforeCart);
        }

        // 🛒【新增】隐藏代付选择模态框
        function hidePaymentRequestModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('payment-request-modal').style.display = 'none';
        }

        // 🛒【新增】处理订单（根据收货人和付款方式）
        function processOrder(recipient) {
            const total = shoppingCart.reduce((sum, item) => sum + (item.price * item.quantity), 0);
            const itemsCount = getTotalCartItems();

            // 生成订单详情
            const orderDetails = generateOrderDetails();

            // 隐藏模态框
            hidePaymentRequestModal();

            // 根据收货人和付款方式处理订单
            if (recipient === 'for_self') {
                // 为自己下单
                if (selectedPaymentMethod === 'self_pay') {
                    // 自己付款
                    showCustomToast('正在处理支付...', 'info', 1000);
                    setTimeout(() => {
                        sendOrderMessage(orderDetails, 'self_pay_self');
                        clearShoppingCart();
                        showCustomToast(`支付成功！总计 ¥${total.toFixed(2)}`, 'success');
                        setTimeout(() => handleShoppingCartBack(), 1000);
                    }, 1500);
                } else {
                    // 请Ta代付
                    sendPaymentRequestMessage(orderDetails, 'request_pay_self');
                    showCustomToast(`已发送代付请求给 ${currentChatCharacter.name}`, 'success');
                    clearShoppingCart();
                    setTimeout(() => handleShoppingCartBack(), 1000);
                }
            } else {
                // 为Ta下单
                if (selectedPaymentMethod === 'self_pay') {
                    // 自己付款
                    showCustomToast(`正在为 ${currentChatCharacter.name} 下单...`, 'info');
                    setTimeout(() => {
                        sendOrderMessage(orderDetails, 'self_pay_ta');
                        clearShoppingCart();
                        showCustomToast(`已成功为 ${currentChatCharacter.name} 下单！`, 'success');
                        setTimeout(() => handleShoppingCartBack(), 1000);
                    }, 1500);
                } else {
                    // 请Ta代付
                    sendPaymentRequestMessage(orderDetails, 'request_pay_ta');
                    showCustomToast(`已发送代付请求给 ${currentChatCharacter.name}`, 'success');
                    clearShoppingCart();
                    setTimeout(() => handleShoppingCartBack(), 1000);
                }
            }
        }

        // 🛒【新增】生成订单详情
        function generateOrderDetails() {
            const total = shoppingCart.reduce((sum, item) => sum + (item.price * item.quantity), 0);
            const itemsCount = getTotalCartItems();
            const orderNumber = 'SP' + Date.now().toString().slice(-8);

            return {
                orderNumber: orderNumber,
                items: [...shoppingCart],
                total: total,
                itemsCount: itemsCount,
                timestamp: Date.now()
            };
        }

        // 🛒【修改】发送代付请求消息
        function sendPaymentRequestMessage(orderDetails, orderType) {
            if (!currentChatCharacter) return;

            const itemsHtml = orderDetails.items.map(item => `
                <div class="payment-item-row">
                    <span>${item.name}</span>
                    <span>¥${(item.price * item.quantity).toFixed(2)}</span>
                </div>
            `).join('');

            const recipientName = orderType === 'request_pay_self' ? '我自己' : currentChatCharacter.name;
            const requestNote = orderType === 'request_pay_self' ? '请帮我支付这个订单，谢谢！' : '请帮忙支付这个订单，谢谢！';

            // 确定发起人和付款方
            const requesterName = orderType.endsWith('_self') ? '我' : currentChatCharacter?.name || '用户';
            const payerName = orderType.endsWith('_self') ? currentChatCharacter?.name || '亲爱的小友' : '我';
            const isUserRequested = orderType.endsWith('_self');

            let messageContent;

            if (isUserRequested) {
                // 用户发起代付 - 黄色卡片样式，支持状态显示
                messageContent = `
                    <div class="payment-request-user-card" data-order-id="${orderDetails.orderNumber}">
                        <div class="payment-request-user-title">发起订单代付请求</div>
                        <div class="payment-request-user-content">
                            <div class="payment-request-amount-label">需付款</div>
                            <div class="payment-request-amount-value">¥${orderDetails.total.toFixed(2)}</div>
                            <div class="payment-request-countdown">
                                剩余支付时间 <span class="payment-request-countdown-time" id="countdown-${orderDetails.orderNumber}">15:00</span>
                            </div>
                            <button class="payment-request-details-btn" onclick="showPaymentDetails('${orderDetails.orderNumber}')">
                                查看详情
                            </button>
                        </div>
                    </div>
                `;

                // 启动15分钟倒计时 - 延迟启动确保DOM已渲染
                setTimeout(() => {
                    startPaymentCountdown(orderDetails.orderNumber);
                }, 100);
            }

            // 发送消息到聊天
            const message = {
                id: Date.now(),
                content: messageContent,
                sender: 'sent',
                timestamp: Date.now(),
                type: 'payment_request',
                orderDetails: orderDetails,
                orderType: orderType,
                paymentStatus: null, // null=未处理, 'paid'=已支付, 'rejected'=已拒绝
                paidBy: null,        // 支付者名称
                rejectedBy: null     // 拒绝者名称
            };

            addMessageToChat(message);

            // 订单信息直接嵌入到消息中，不需要额外存储

            // 存储倒计时器
            window.paymentCountdowns = window.paymentCountdowns || {};
        }

        // 🛒【新增】启动代付倒计时 - 简化版本
        function startPaymentCountdown(orderNumber) {
            // 检查是否已有倒计时在运行
            if (window.paymentCountdowns && window.paymentCountdowns[orderNumber]) {
                clearInterval(window.paymentCountdowns[orderNumber]);
            }

            let timeLeft = 15 * 60; // 15分钟 = 900秒
            const countdownElement = document.getElementById(`countdown-${orderNumber}`);
            if (!countdownElement) return;

            const timer = setInterval(() => {
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                countdownElement.textContent = timeString;

                if (timeLeft <= 0) {
                    clearInterval(timer);
                    countdownElement.textContent = '已超时';
                    countdownElement.style.background = '#ff4444';

                    // 禁用详情按钮
                    const detailsBtn = countdownElement.closest('.payment-request-user-card').querySelector('.payment-request-details-btn');
                    if (detailsBtn) {
                        detailsBtn.disabled = true;
                        detailsBtn.textContent = '支付超时';
                        detailsBtn.style.opacity = '0.5';
                    }

                    // 清除计时器
                    delete window.paymentCountdowns[orderNumber];
                }

                timeLeft--;
            }, 1000);

            // 存储计时器以便后续清除
            window.paymentCountdowns = window.paymentCountdowns || {};
            window.paymentCountdowns[orderNumber] = timer;
        }

        // 🛒【新增】处理AI对代付请求的回复
        async function processPaymentRequestResponse(paymentMessage, aiMessages, characterId) {
            console.log('🛒 [代付响应处理] 开始处理AI对代付请求的回复:', {
                paymentMessage,
                aiMessages,
                characterId
            });

            // 合并所有AI回复文本进行分析
            let fullAiResponse = '';
            for (const msgData of aiMessages) {
                if (typeof msgData === 'string') {
                    fullAiResponse += msgData + ' ';
                } else if (typeof msgData === 'object' && msgData.content) {
                    fullAiResponse += msgData.content + ' ';
                }
            }
            fullAiResponse = fullAiResponse.trim();
            console.log('🛒 [代付响应处理] AI完整回复内容:', fullAiResponse);

            // 检测AI是否同意代付
            const acceptKeywords = [
                '我来付', '我付', '我买单', '我帮你付', '我帮你买', '我给你买',
                '我请客', '我请你', '我来买', '我来支付', '我支付', '我来结账',
                '我帮你结账', '我来结算', '我买给你', '我给你付款', '我付款',
                '我来付款', '我帮你付款', '我替你付', '我替你买', '我为你付',
                '我为你买', '我出钱', '我来出钱', '我付钱', '我给钱',
                '我来给钱', '我买下', '我来买下', '我购买', '我来购买',
                '我下单', '我来下单', '我结账', '我来结账', '我付账',
                '我来付账', '我买单了', '我付了', '我已经付', '我已付',
                '我帮你买单', '我来买单', '我替你买单', '我为你买单',
                '我给你买单', '我帮你下单', '我来下单', '我替你下单',
                '我为你下单', '我给你下单', '我帮你购买', '我来购买',
                '我替你购买', '我为你购买', '我给你购买'
            ];

            // 检测AI是否拒绝代付
            const rejectKeywords = [
                '不付', '不买', '不帮你付', '不帮你买', '不给你买', '不请客',
                '不支付', '不付款', '不出钱', '不给钱', '不买单', '不结账',
                '不下单', '不购买', '拒绝付', '拒绝买', '拒绝支付', '拒绝付款',
                '拒绝出钱', '拒绝给钱', '拒绝买单', '拒绝结账', '拒绝下单',
                '拒绝购买', '不愿意付', '不愿意买', '不愿意支付', '不愿意付款',
                '不愿意出钱', '不愿意给钱', '不愿意买单', '不愿意结账',
                '不愿意下单', '不愿意购买', '不想付', '不想买', '不想支付',
                '不想付款', '不想出钱', '不想给钱', '不想买单', '不想结账',
                '不想下单', '不想购买', '没钱', '没有钱', '钱不够', '余额不足',
                '买不起', '付不起', '太贵', '太贵了', '承担不起', '负担不起'
            ];

            const isAccepted = acceptKeywords.some(keyword => fullAiResponse.includes(keyword));
            const isRejected = rejectKeywords.some(keyword => fullAiResponse.includes(keyword));

            console.log('🛒 [代付响应处理] 关键词检测结果:', {
                isAccepted,
                isRejected,
                fullAiResponse: fullAiResponse.substring(0, 100) + '...'
            });

            // 更新代付请求状态
            if (isAccepted) {
                // AI同意代付
                paymentMessage.paymentStatus = 'paid';
                paymentMessage.paidBy = currentChatCharacter?.name || '角色';
                console.log('🛒 [代付响应处理] AI同意代付，更新状态为已支付');

                // 更新界面显示
                updatePaymentRequestDisplay(paymentMessage.orderDetails.orderNumber, 'paid');

            } else if (isRejected) {
                // AI拒绝代付
                paymentMessage.paymentStatus = 'rejected';
                paymentMessage.rejectedBy = currentChatCharacter?.name || '角色';
                console.log('🛒 [代付响应处理] AI拒绝代付，更新状态为已拒绝');

                // 更新界面显示
                updatePaymentRequestDisplay(paymentMessage.orderDetails.orderNumber, 'rejected');
            }

            // 保存更新后的消息
            if (isAccepted || isRejected) {
                try {
                    await saveChatMessagesImmediate([characterId]);
                    console.log('🛒 [代付响应处理] 代付状态已保存到数据库');
                } catch (error) {
                    console.error('🛒 [代付响应处理] 保存代付状态失败:', error);
                }
            }
        }

        // 🛒【新增】根据消息状态动态生成代付请求内容
        function generatePaymentRequestContent(message) {
            const orderDetails = message.orderDetails;
            const paymentStatus = message.paymentStatus;

            if (!orderDetails) {
                return message.content; // 回退到原始内容
            }

            // 根据状态生成不同的内容区域
            let contentArea = '';
            if (paymentStatus === 'paid') {
                // 支付成功状态 - 完全不同的布局
                contentArea = `
                    <div class="payment-request-user-content">
                        <div class="payment-request-amount-label">需付款</div>
                        <div class="payment-request-amount-value">¥${orderDetails.total.toFixed(2)}</div>
                        <div class="payment-request-success-message">
                            我已为你买单，尽情享用吧~<br>
                            <span class="payment-success-text">支付成功</span>
                        </div>
                        <button class="payment-request-details-btn" onclick="showPaymentDetails('${orderDetails.orderNumber}')">
                            查看详情
                        </button>
                    </div>
                `;
            } else if (paymentStatus === 'rejected') {
                // 拒绝状态
                contentArea = `
                    <div class="payment-request-user-content">
                        <div class="payment-request-amount-label">需付款</div>
                        <div class="payment-request-amount-value">¥${orderDetails.total.toFixed(2)}</div>
                        <div class="payment-request-rejected-message">
                            我拒绝了您的代付请求
                        </div>
                        <button class="payment-request-details-btn" onclick="showPaymentDetails('${orderDetails.orderNumber}')">
                            查看详情
                        </button>
                    </div>
                `;
            } else {
                // 待处理状态 - 原来的倒计时布局
                contentArea = `
                    <div class="payment-request-user-content">
                        <div class="payment-request-amount-label">需付款</div>
                        <div class="payment-request-amount-value">¥${orderDetails.total.toFixed(2)}</div>
                        <div class="payment-request-countdown">
                            剩余支付时间 <span class="payment-request-countdown-time" id="countdown-${orderDetails.orderNumber}">15:00</span>
                        </div>
                        <button class="payment-request-details-btn" onclick="showPaymentDetails('${orderDetails.orderNumber}')">
                            查看详情
                        </button>
                    </div>
                `;
            }

            // 生成HTML内容
            const content = `
                <div class="payment-request-user-card" data-order-id="${orderDetails.orderNumber}">
                    <div class="payment-request-user-title">发起订单代付请求</div>
                    ${contentArea}
                </div>
            `;

            // 如果是未处理状态，需要启动倒计时
            if (!paymentStatus) {
                setTimeout(() => {
                    startPaymentCountdown(orderDetails.orderNumber);
                }, 100);
            }

            return content;
        }

        // 🛒【新增】更新代付请求的界面显示
        function updatePaymentRequestDisplay(orderNumber, status) {
            console.log('🛒 [界面更新] 更新代付请求显示:', { orderNumber, status });

            // 查找对应的代付卡片
            const paymentCard = document.querySelector(`[data-order-id="${orderNumber}"]`);
            if (!paymentCard) {
                console.log('🛒 [界面更新] 未找到代付卡片:', orderNumber);
                return;
            }

            // 停止倒计时
            if (window.paymentCountdowns && window.paymentCountdowns[orderNumber]) {
                clearInterval(window.paymentCountdowns[orderNumber]);
                delete window.paymentCountdowns[orderNumber];
            }

            // 获取订单信息（从消息数据中）
            const currentMessages = chatMessages[currentChatCharacter?.id] || [];
            let orderDetails = null;
            for (const message of currentMessages) {
                if (message.type === 'payment_request' &&
                    message.orderDetails &&
                    message.orderDetails.orderNumber === orderNumber) {
                    orderDetails = message.orderDetails;
                    break;
                }
            }

            if (!orderDetails) {
                console.log('🛒 [界面更新] 未找到订单详情');
                return;
            }

            // 重新生成整个内容区域
            let newContentArea = '';
            if (status === 'paid') {
                newContentArea = `
                    <div class="payment-request-user-content">
                        <div class="payment-request-amount-label">需付款</div>
                        <div class="payment-request-amount-value">¥${orderDetails.total.toFixed(2)}</div>
                        <div class="payment-request-success-message">
                            我已为你买单，尽情享用吧~<br>
                            <span class="payment-success-text">支付成功</span>
                        </div>
                        <button class="payment-request-details-btn" onclick="showPaymentDetails('${orderNumber}')">
                            查看详情
                        </button>
                    </div>
                `;
            } else if (status === 'rejected') {
                newContentArea = `
                    <div class="payment-request-user-content">
                        <div class="payment-request-amount-label">需付款</div>
                        <div class="payment-request-amount-value">¥${orderDetails.total.toFixed(2)}</div>
                        <div class="payment-request-rejected-message">
                            我拒绝了您的代付请求
                        </div>
                        <button class="payment-request-details-btn" onclick="showPaymentDetails('${orderNumber}')">
                            查看详情
                        </button>
                    </div>
                `;
            }

            // 更新卡片内容
            paymentCard.innerHTML = `
                <div class="payment-request-user-title">发起订单代付请求</div>
                ${newContentArea}
            `;

            console.log('🛒 [界面更新] 代付请求显示已更新');
        }

        // 🛒【新增】显示代付详情模态框
        function showPaymentDetails(orderNumber) {
            // 从当前聊天记录中查找订单信息
            let orderDetails = null;
            const currentMessages = chatMessages[currentChatCharacter?.id] || [];

            for (const message of currentMessages) {
                if (message.type === 'payment_request' &&
                    message.orderDetails &&
                    message.orderDetails.orderNumber === orderNumber) {
                    orderDetails = message.orderDetails;
                    break;
                }
            }

            if (!orderDetails) {
                alert('订单信息不存在');
                return;
            }

            const itemsHtml = orderDetails.items.map(item => {
                // 🔥【修复】生成包含选项信息的商品名称
                let itemNameWithOptions = `${item.name} x${item.quantity}`;
                if (item.selectedOptions && Object.keys(item.selectedOptions).length > 0) {
                    const optionsText = Object.entries(item.selectedOptions).map(([key, value]) =>
                        `${getOptionLabel(key)}: ${value}`
                    ).join(', ');
                    itemNameWithOptions += `<br><small style="color: #666; font-size: 12px;">${optionsText}</small>`;
                }

                return `
                    <div class="payment-details-item">
                        <span class="payment-details-item-name">${itemNameWithOptions}</span>
                        <span class="payment-details-item-price">¥${(item.price * item.quantity).toFixed(2)}</span>
                    </div>
                `;
            }).join('');

            // 创建关闭函数
            window.closePaymentModal = function() {
                const modal = document.getElementById('paymentDetailsModal');
                if (modal) {
                    modal.style.display = 'none';
                }
            };

            const modalContent = `
                <div class="modal-header">
                    <h3>订单详情</h3>
                    <button class="modal-close-btn" onclick="window.closePaymentModal()">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="payment-details-item">
                        <span class="payment-details-item-name">订单号</span>
                        <span class="payment-details-item-price">${orderDetails.orderNumber}</span>
                    </div>
                    ${itemsHtml}
                    <div class="payment-details-item">
                        <span class="payment-details-item-name">总计</span>
                        <span class="payment-details-item-price">¥${orderDetails.total.toFixed(2)}</span>
                    </div>
                </div>
            `;

            // 创建或更新模态框
            let modal = document.getElementById('paymentDetailsModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'paymentDetailsModal';
                modal.className = 'modal payment-details-modal';
                document.body.appendChild(modal);
            }

            // 更新内容
            modal.innerHTML = `
                <div class="modal-content">
                    ${modalContent}
                </div>
            `;

            // 重新绑定背景点击关闭功能
            modal.onclick = function(e) {
                if (e.target === modal) {
                    window.closePaymentModal();
                }
            };

            modal.style.display = 'flex';
        }





        // 🛒【修改】发送订单确认消息
        function sendOrderMessage(orderDetails, orderType) {
            if (!currentChatCharacter) return;

            // 🔥【修复】生成包含选项信息的商品列表
            const itemsList = orderDetails.items.map(item => {
                let itemText = `${item.name} x${item.quantity}`;

                // 添加选项信息
                if (item.selectedOptions && Object.keys(item.selectedOptions).length > 0) {
                    const optionsText = Object.entries(item.selectedOptions).map(([key, value]) =>
                        `${getOptionLabel(key)}: ${value}`
                    ).join(', ');
                    itemText += ` (${optionsText})`;
                }

                return itemText;
            }).join('、');

            // 订单确认消息将由渲染函数生成HTML格式，这里只需要基本信息
            let messageContent = '订单确认';

            // 发送消息到聊天
            const message = {
                id: Date.now(),
                content: messageContent,
                sender: 'sent',
                timestamp: Date.now(),
                type: 'order_confirmation',
                orderDetails: orderDetails,
                orderType: orderType
            };

            addMessageToChat(message);
        }

        // 🛒【新增】自定义提示函数
        function showCustomToast(message, type = 'default', duration = 1500) {
            // 移除已存在的提示
            const existingToast = document.querySelector('.custom-toast');
            if (existingToast) {
                existingToast.remove();
            }

            // 创建新的提示元素
            const toast = document.createElement('div');
            toast.className = `custom-toast ${type}`;
            toast.textContent = message;

            // 添加到页面
            document.body.appendChild(toast);

            // 自动移除
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.classList.add('fade-out');
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.remove();
                        }
                    }, 300);
                }
            }, duration);
        }



        // 🛒【新增】生成AI的订单确认内容
        function generateAIOrderConfirmationContent(message) {
            const orderDetails = message.orderDetails;
            const orderType = message.orderType;

            if (!orderDetails) {
                return `<div class="message-bubble">${message.content}</div>`; // 回退到原始内容
            }

            // 生成商品列表
            const itemsList = orderDetails.items.map(item => {
                let itemText = `${item.name} x${item.quantity}`;
                if (item.selectedOptions && Object.keys(item.selectedOptions).length > 0) {
                    const optionsText = Object.entries(item.selectedOptions).map(([key, value]) =>
                        `${getOptionLabel(key)}: ${value}`
                    ).join(', ');
                    itemText += ` (${optionsText})`;
                }
                return `<div class="receipt-item">${itemText} <span class="receipt-item-price">¥${item.price}</span></div>`;
            }).join('');

            let receiptTitle = '';
            let receiptIcon = '';

            if (orderType === 'ai_order') {
                receiptTitle = '我的订单';
                receiptIcon = '🛍️';
            } else {
                receiptTitle = '订单确认';
                receiptIcon = '📋';
            }

            return `
                <div class="order-confirmation-container ai-order">
                    <div class="receipt-card">
                        <div class="receipt-header">
                            <div class="receipt-title">${receiptIcon} ${receiptTitle}</div>
                            <div class="receipt-subtitle">订单支付成功</div>
                        </div>
                        <div class="receipt-content">
                            <div class="receipt-order-number">订单号：${orderDetails.orderNumber}</div>
                            <div class="receipt-items">${itemsList}</div>
                            <div class="receipt-divider"></div>
                            <div class="receipt-total">总计：¥${orderDetails.total.toFixed(2)}</div>
                            <div class="receipt-time">下单时间：${new Date(orderDetails.timestamp).toLocaleString()}</div>
                        </div>
                        <div class="receipt-footer">
                            <div class="thank-you">感谢购买！</div>
                        </div>
                    </div>
                </div>
            `;
        }









        // 🛒【新增】根据选项计算商品价格
        function getProductPrice(product, selectedOptions = {}) {
            if (!product.prices) {
                return product.price;
            }

            // 查找有价格定义的选项
            for (const [optionKey, optionValue] of Object.entries(selectedOptions)) {
                if (product.prices[optionKey] && product.prices[optionKey][optionValue] !== undefined) {
                    return product.prices[optionKey][optionValue];
                }
            }

            return product.price;
        }

        // 🛒【新增】实时更新商品价格显示
        function updateProductPrice(categoryName, productIndex) {
            const product = productsData[categoryName][productIndex];
            const selectedOptions = {};

            // 获取当前选择的所有选项
            for (const optionKey of Object.keys(product.options)) {
                const selectElement = document.getElementById(`option-${optionKey}`);
                if (selectElement) {
                    selectedOptions[optionKey] = selectElement.value;
                }
            }

            // 计算新价格
            const newPrice = getProductPrice(product, selectedOptions);

            // 更新价格显示
            const priceElement = document.getElementById('current-price');
            if (priceElement) {
                priceElement.textContent = `¥${newPrice}`;
            }
        }

        // 🛒【新增】自定义确认对话框
        function showCustomConfirm(title, message, onConfirm, onCancel) {
            // 移除已存在的确认框
            const existingConfirm = document.querySelector('.custom-confirm');
            if (existingConfirm) {
                existingConfirm.remove();
            }

            // 创建确认框元素
            const confirmDialog = document.createElement('div');
            confirmDialog.className = 'custom-confirm';
            confirmDialog.innerHTML = `
                <div class="custom-confirm-dialog">
                    <div class="custom-confirm-title">${title}</div>
                    <div class="custom-confirm-message">${message}</div>
                    <div class="custom-confirm-buttons">
                        <button class="custom-confirm-btn cancel" onclick="closeCustomConfirm()">取消</button>
                        <button class="custom-confirm-btn confirm" onclick="confirmCustomAction()">确定</button>
                    </div>
                </div>
            `;

            // 添加到页面
            document.body.appendChild(confirmDialog);

            // 存储回调函数
            window.customConfirmCallbacks = {
                onConfirm: onConfirm || (() => {}),
                onCancel: onCancel || (() => {})
            };

            // 点击背景关闭
            confirmDialog.addEventListener('click', (e) => {
                if (e.target === confirmDialog) {
                    closeCustomConfirm();
                }
            });
        }

        // 🛒【新增】关闭自定义确认框
        function closeCustomConfirm() {
            const confirmDialog = document.querySelector('.custom-confirm');
            if (confirmDialog) {
                confirmDialog.remove();
            }
            if (window.customConfirmCallbacks && window.customConfirmCallbacks.onCancel) {
                window.customConfirmCallbacks.onCancel();
            }
        }

        // 🛒【新增】确认自定义操作
        function confirmCustomAction() {
            const confirmDialog = document.querySelector('.custom-confirm');
            if (confirmDialog) {
                confirmDialog.remove();
            }
            if (window.customConfirmCallbacks && window.customConfirmCallbacks.onConfirm) {
                window.customConfirmCallbacks.onConfirm();
            }
        }

        // 更新购物车徽章数量
        function updateCartBadge(count) {
            const badge = document.getElementById('cart-badge');
            if (badge) {
                if (count > 0) {
                    badge.textContent = count > 99 ? '99+' : count.toString();
                    badge.style.display = 'flex';
                } else {
                    badge.style.display = 'none';
                }
            }
        }

        // 约定表单功能
        function showAppointmentForm(appointmentId = null) {
            editingAppointmentId = appointmentId;
            const modal = document.getElementById('appointment-form-modal');
            const title = document.getElementById('appointment-form-title');

            // 填充角色选择列表
            populateCharacterSelect('appointment-character');

            if (appointmentId) {
                // 编辑模式
                title.textContent = '编辑约定';
                const appointment = appointments.find(a => a.id === appointmentId);
                if (appointment) {
                    document.getElementById('appointment-name').value = appointment.name;
                    document.getElementById('appointment-date').value = appointment.date;
                    document.getElementById('appointment-time').value = appointment.time || '';

                    // 处理类型和自定义类型
                    if (appointment.customType) {
                        document.getElementById('appointment-type').value = 'other';
                        document.getElementById('appointment-custom-type').value = appointment.customType;
                        toggleCustomTypeInput('appointment');
                    } else {
                        document.getElementById('appointment-type').value = appointment.type;
                    }

                    document.getElementById('appointment-character').value = appointment.characterId || '';
                    document.getElementById('appointment-priority').value = appointment.priority || 'medium';
                    document.getElementById('appointment-description').value = appointment.description || '';
                    document.getElementById('appointment-user-quote').value = appointment.userQuote || '';
                    document.getElementById('appointment-character-quote').value = appointment.characterQuote || '';
                    document.getElementById('appointment-shared').checked = appointment.isShared === true;
                    document.getElementById('appointment-pinned').checked = appointment.isPinned === true;
                    document.getElementById('appointment-count-type').value = appointment.countType || 'countdown';
                    document.getElementById('appointment-never-expires').checked = appointment.neverExpires === true;

                    // 🔥【新增】如果是永不过期，触发相应的UI更新
                    if (appointment.neverExpires) {
                        toggleNeverExpires('appointment');
                    }

                    // 🔥【修复】显示背景图预览
                    if (appointment.backgroundImage) {
                        document.getElementById('appointment-background-img').src = appointment.backgroundImage;
                        document.getElementById('appointment-background-preview').style.display = 'block';
                    }

                    // 🔥【修复】显示用户头像预览
                    if (appointment.userAvatar) {
                        document.getElementById('appointment-user-avatar-img').src = appointment.userAvatar;
                        document.getElementById('appointment-user-avatar-preview').style.display = 'block';
                    }

                    // 显示或隐藏角色语录区域
                    toggleCharacterQuoteGroup('appointment', appointment.characterId);
                }
            } else {
                // 新增模式
                title.textContent = '添加约定';
                clearAppointmentForm();
            }

            modal.style.display = 'flex';
        }

        function closeAppointmentForm() {
            document.getElementById('appointment-form-modal').style.display = 'none';
            clearAppointmentForm();
            editingAppointmentId = null;
        }

        function clearAppointmentForm() {
            document.getElementById('appointment-name').value = '';
            document.getElementById('appointment-date').value = '';
            document.getElementById('appointment-time').value = '';
            document.getElementById('appointment-type').value = 'date';
            document.getElementById('appointment-custom-type').value = '';
            document.getElementById('appointment-character').value = '';
            document.getElementById('appointment-priority').value = 'medium';
            document.getElementById('appointment-description').value = '';
            document.getElementById('appointment-user-quote').value = '';
            document.getElementById('appointment-character-quote').value = '';
            document.getElementById('appointment-shared').checked = false;
            document.getElementById('appointment-pinned').checked = false;
            document.getElementById('appointment-count-type').value = 'countdown';
            document.getElementById('appointment-never-expires').checked = false;

            // 🔥【新增】重置永不过期相关的UI状态
            const dateInput = document.getElementById('appointment-date');
            const timeInput = document.getElementById('appointment-time');
            dateInput.disabled = false;
            timeInput.disabled = false;
            dateInput.style.opacity = '1';
            timeInput.style.opacity = '1';

            // 🔥【修复】清空文件输入和预览
            document.getElementById('appointment-background-upload').value = '';
            document.getElementById('appointment-user-avatar-upload').value = '';
            document.getElementById('appointment-background-preview').style.display = 'none';
            document.getElementById('appointment-user-avatar-preview').style.display = 'none';
            document.getElementById('appointment-background-img').src = '';
            document.getElementById('appointment-user-avatar-img').src = '';

            // 隐藏角色语录区域和自定义类型区域
            toggleCharacterQuoteGroup('appointment', '');
            toggleCustomTypeInput('appointment');
        }

        async function saveAppointment(event) {
            // 防止事件冒泡和默认行为
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            // 🔥【修复】安全获取所有表单值，确保不会获取到事件对象
            const nameEl = document.getElementById('appointment-name');
            const dateEl = document.getElementById('appointment-date');
            const timeEl = document.getElementById('appointment-time');
            const typeEl = document.getElementById('appointment-type');
            const customTypeEl = document.getElementById('appointment-custom-type');
            const characterIdEl = document.getElementById('appointment-character');
            const priorityEl = document.getElementById('appointment-priority');
            const descriptionEl = document.getElementById('appointment-description');
            const userQuoteEl = document.getElementById('appointment-user-quote');
            const characterQuoteEl = document.getElementById('appointment-character-quote');
            const isSharedEl = document.getElementById('appointment-shared');
            const isPinnedEl = document.getElementById('appointment-pinned');
            const countTypeEl = document.getElementById('appointment-count-type');
            const neverExpiresEl = document.getElementById('appointment-never-expires');

            const name = nameEl ? String(nameEl.value || '').trim() : '';
            const date = dateEl ? String(dateEl.value || '') : '';
            const time = timeEl ? String(timeEl.value || '') : '';
            const type = typeEl ? String(typeEl.value || '') : '';
            const customType = customTypeEl ? String(customTypeEl.value || '').trim() : '';
            const characterId = characterIdEl ? String(characterIdEl.value || '') : '';
            const priority = priorityEl ? String(priorityEl.value || 'medium') : 'medium';
            const description = descriptionEl ? String(descriptionEl.value || '').trim() : '';
            const userQuote = userQuoteEl ? String(userQuoteEl.value || '').trim() : '';
            const characterQuote = characterQuoteEl ? String(characterQuoteEl.value || '').trim() : '';
            const isShared = isSharedEl ? Boolean(isSharedEl.checked) : false;
            const isPinned = isPinnedEl ? Boolean(isPinnedEl.checked) : false;
            const countType = countTypeEl ? String(countTypeEl.value || 'countdown') : 'countdown';
            const neverExpires = neverExpiresEl ? Boolean(neverExpiresEl.checked) : false;

            // 🔥【调试】输出所有获取的值
            console.log('获取的表单值:', {
                name, date, time, type, customType, characterId,
                priority, description, userQuote, characterQuote, isShared, isPinned, countType, neverExpires
            });

            // 🔥【修改】验证逻辑 - 永不过期的约定不需要日期
            if (!name || (!neverExpires && !date)) {
                showToast(neverExpires ? '请填写约定名称' : '请填写约定名称和日期', 'error');
                return;
            }

            if (type === 'other' && !customType) {
                showToast('请填写自定义类型', 'error');
                return;
            }

            // 🔥【修复】获取背景图和用户头像
            const backgroundImg = document.getElementById('appointment-background-img');
            const userAvatarImg = document.getElementById('appointment-user-avatar-img');
            const backgroundImage = backgroundImg && backgroundImg.src && backgroundImg.src !== window.location.href ? backgroundImg.src : null;
            const userAvatar = userAvatarImg && userAvatarImg.src && userAvatarImg.src !== window.location.href ? userAvatarImg.src : null;

            try {
                // 🔥【修复】严格清理所有数据，确保没有事件对象或其他不可序列化的内容
                const appointmentData = {
                    name: String(name || ''),
                    date: neverExpires ? null : String(date || ''),
                    time: neverExpires ? null : String(time || ''),
                    type: String(type === 'other' ? 'other' : type || ''),
                    customType: type === 'other' ? String(customType || '') : null,
                    characterId: characterId ? String(characterId) : null,
                    priority: String(priority || 'medium'),
                    description: String(description || ''),
                    userQuote: userQuote ? String(userQuote) : null,
                    characterQuote: characterQuote ? String(characterQuote) : null,
                    isShared: Boolean(isShared),
                    isPinned: Boolean(isPinned),
                    backgroundImage: backgroundImage ? String(backgroundImage) : null,
                    userAvatar: userAvatar ? String(userAvatar) : null,
                    countType: String(countType || 'countdown'),
                    neverExpires: Boolean(neverExpires),
                    completed: false,
                    createdBy: 'user',
                    timestamp: Date.now()
                };

                // 🔥【修复】如果当前约定被设置为置顶，需要先取消其他约定的置顶状态
                if (isPinned) {
                    // 找到所有其他置顶的约定并取消置顶
                    const otherPinnedAppointments = appointments.filter(a =>
                        a.isPinned && a.id !== appointmentData.id
                    );

                    for (const otherAppointment of otherPinnedAppointments) {
                        otherAppointment.isPinned = false;
                        await db.appointments.put(otherAppointment);
                    }

                    if (otherPinnedAppointments.length > 0) {
                        console.log(`取消了 ${otherPinnedAppointments.length} 个约定的置顶状态`);
                    }
                }

                if (editingAppointmentId) {
                    // 编辑模式
                    appointmentData.id = String(editingAppointmentId);

                    // 🔥【调试】检查数据是否包含不可序列化的对象
                    console.log('准备更新约定数据:', JSON.stringify(appointmentData, null, 2));

                    await db.appointments.put(appointmentData);
                    const index = appointments.findIndex(a => a.id === editingAppointmentId);
                    if (index !== -1) {
                        appointments[index] = appointmentData;
                    }
                    showToast('约定已更新', 'success');

                    // 🔥【修复】更新后重新加载列表
                    closeAppointmentForm();
                    loadAppointmentList();

                    // 🔥【新增】记录约定更新到跨应用时间线
                    if (appointmentData.isShared && appointmentData.characterId) {
                        try {
                            await recordCrossAppEvent(
                                appointmentData.characterId,
                                'appointment',
                                'update',
                                {
                                    id: appointmentData.id,
                                    type: 'appointment_update',
                                    content: `用户更新了约定"${appointmentData.name}"（${appointmentData.date}${appointmentData.time ? ' ' + appointmentData.time : ''}）${appointmentData.description ? '：' + appointmentData.description : ''}`,
                                    appointmentName: appointmentData.name,
                                    appointmentDate: appointmentData.date,
                                    appointmentTime: appointmentData.time,
                                    appointmentType: appointmentData.type,
                                    description: appointmentData.description,
                                    priority: appointmentData.priority
                                }
                            );
                            console.log('📝 [约定时间线] 已记录约定更新事件到跨应用时间线');
                        } catch (error) {
                            console.error('❌ [约定时间线] 记录约定更新事件失败:', error);
                        }
                    }
                } else {
                    // 新增模式
                    appointmentData.id = Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9);

                    // 🔥【调试】检查数据是否包含不可序列化的对象
                    console.log('准备添加约定数据:', JSON.stringify(appointmentData, null, 2));

                    await db.appointments.add(appointmentData);
                    appointments.push(appointmentData);
                    showToast('约定已添加', 'success');

                    // 🔥【调试】验证数据库中的数据
                    const dbAppointments = await db.appointments.toArray();
                    console.log('🔍 数据库中的所有约定:', dbAppointments.length, dbAppointments);

                    // 🔥【新增】记录约定创建到跨应用时间线
                    if (appointmentData.isShared && appointmentData.characterId) {
                        try {
                            await recordCrossAppEvent(
                                appointmentData.characterId,
                                'appointment',
                                'create',
                                {
                                    id: appointmentData.id,
                                    type: 'appointment_create',
                                    content: `用户创建了约定"${appointmentData.name}"（${appointmentData.date}${appointmentData.time ? ' ' + appointmentData.time : ''}）${appointmentData.description ? '：' + appointmentData.description : ''}`,
                                    appointmentName: appointmentData.name,
                                    appointmentDate: appointmentData.date,
                                    appointmentTime: appointmentData.time,
                                    appointmentType: appointmentData.type,
                                    description: appointmentData.description,
                                    priority: appointmentData.priority
                                },
                                appointmentData.id
                            );
                            console.log('📝 [约定时间线] 已记录约定创建事件到跨应用时间线');
                        } catch (error) {
                            console.error('❌ [约定时间线] 记录约定创建事件失败:', error);
                        }
                    }
                }

                // 🔥【修复】新增约定后关闭表单并重新加载列表
                if (!editingAppointmentId) {
                    closeAppointmentForm();
                    loadAppointmentList();
                }
            } catch (error) {
                console.error('保存约定失败:', error);
                showToast('保存失败，请重试', 'error');
            }
        }



        // 显示纪念日表单
        function showAnniversaryForm(anniversaryId = null) {
            editingAnniversaryId = anniversaryId;
            const modal = document.getElementById('anniversary-form-modal');
            const title = document.getElementById('anniversary-form-title');

            // 填充角色选择列表
            populateCharacterSelect('anniversary-character');

            if (anniversaryId) {
                // 编辑模式
                title.textContent = '编辑纪念日';
                const anniversary = anniversaries.find(a => a.id === anniversaryId);
                if (anniversary) {
                    document.getElementById('anniversary-name').value = anniversary.name;
                    document.getElementById('anniversary-date').value = anniversary.date;

                    // 处理类型和自定义类型
                    if (anniversary.customType) {
                        document.getElementById('anniversary-type').value = 'other';
                        document.getElementById('anniversary-custom-type').value = anniversary.customType;
                        toggleCustomTypeInput('anniversary');
                    } else {
                        document.getElementById('anniversary-type').value = anniversary.type;
                    }

                    document.getElementById('anniversary-character').value = anniversary.characterId || '';
                    document.getElementById('anniversary-description').value = anniversary.description || '';
                    document.getElementById('anniversary-user-quote').value = anniversary.userQuote || '';
                    document.getElementById('anniversary-character-quote').value = anniversary.characterQuote || '';
                    document.getElementById('anniversary-yearly').checked = anniversary.yearly !== false;
                    document.getElementById('anniversary-shared').checked = anniversary.isShared === true;
                    document.getElementById('anniversary-pinned').checked = anniversary.isPinned === true;
                    document.getElementById('anniversary-count-type').value = anniversary.countType || 'countdown';

                    // 显示背景图预览
                    if (anniversary.backgroundImage) {
                        document.getElementById('anniversary-background-img').src = anniversary.backgroundImage;
                        document.getElementById('anniversary-background-preview').style.display = 'block';
                    }

                    // 显示用户头像预览
                    if (anniversary.userAvatar) {
                        document.getElementById('anniversary-user-avatar-img').src = anniversary.userAvatar;
                        document.getElementById('anniversary-user-avatar-preview').style.display = 'block';
                    }

                    // 显示或隐藏角色语录区域
                    toggleCharacterQuoteGroup('anniversary', anniversary.characterId);
                }
            } else {
                // 新建模式
                title.textContent = '添加纪念日';
                clearAnniversaryForm();
            }

            modal.style.display = 'flex';
        }

        // 关闭纪念日表单
        function closeAnniversaryForm() {
            document.getElementById('anniversary-form-modal').style.display = 'none';
            clearAnniversaryForm();
            editingAnniversaryId = null;
        }

        // 清空纪念日表单
        function clearAnniversaryForm() {
            document.getElementById('anniversary-name').value = '';
            document.getElementById('anniversary-date').value = '';
            document.getElementById('anniversary-type').value = 'birthday';
            document.getElementById('anniversary-custom-type').value = '';
            document.getElementById('anniversary-character').value = '';
            document.getElementById('anniversary-description').value = '';
            document.getElementById('anniversary-user-quote').value = '';
            document.getElementById('anniversary-character-quote').value = '';
            document.getElementById('anniversary-yearly').checked = true;
            document.getElementById('anniversary-shared').checked = false;
            document.getElementById('anniversary-pinned').checked = false;
            document.getElementById('anniversary-count-type').value = 'countdown';

            // 清空文件输入和预览
            document.getElementById('anniversary-background-upload').value = '';
            document.getElementById('anniversary-user-avatar-upload').value = '';
            document.getElementById('anniversary-background-preview').style.display = 'none';
            document.getElementById('anniversary-user-avatar-preview').style.display = 'none';

            // 隐藏角色语录区域和自定义类型区域
            toggleCharacterQuoteGroup('anniversary', '');
            toggleCustomTypeInput('anniversary');
        }

        // 填充角色选择列表
        function populateCharacterSelect(selectId) {
            const select = document.getElementById(selectId);
            const currentValue = select.value;

            // 清空现有选项，保留第一个默认选项
            select.innerHTML = '<option value="">选择角色（可选）</option>';

            // 添加所有角色
            characters.forEach(character => {
                const option = document.createElement('option');
                option.value = character.id;
                option.textContent = character.name;
                select.appendChild(option);
            });

            // 恢复之前的选择
            if (currentValue) {
                select.value = currentValue;
            }
        }

        // 🔥【修复】切换角色语录区域显示 - 支持用户和角色双语录
        function toggleCharacterQuoteGroup(type, characterId) {
            const quoteGroup = document.getElementById(`${type}-character-quote-group`);
            const quoteTextarea = document.getElementById(`${type}-character-quote`);
            const quoteLabel = document.getElementById(`${type}-quote-label`);

            if (characterId) {
                // 选择了角色，显示角色语录区域
                const character = characters.find(c => c.id === characterId);
                if (character) {
                    quoteGroup.style.display = 'block';
                    quoteLabel.textContent = '角色语录';
                    quoteTextarea.placeholder = `${character.name}对这个${type === 'anniversary' ? '纪念日' : '约定'}的感想...`;
                }
            } else {
                // 没有选择角色，隐藏角色语录区域
                quoteGroup.style.display = 'none';
                quoteTextarea.value = ''; // 清空角色语录内容
            }
        }

        // 切换自定义类型输入框显示
        function toggleCustomTypeInput(type) {
            const typeSelect = document.getElementById(`${type}-type`);
            const customTypeGroup = document.getElementById(`${type}-custom-type-group`);
            const customTypeInput = document.getElementById(`${type}-custom-type`);

            if (typeSelect.value === 'other') {
                customTypeGroup.style.display = 'block';
                customTypeInput.focus();
            } else {
                customTypeGroup.style.display = 'none';
                customTypeInput.value = '';
            }
        }

        // 🔥【新增】切换永不过期选项
        function toggleNeverExpires(type) {
            const neverExpiresCheckbox = document.getElementById(`${type}-never-expires`);
            const dateInput = document.getElementById(`${type}-date`);
            const timeInput = document.getElementById(`${type}-time`);

            if (neverExpiresCheckbox.checked) {
                // 勾选永不过期时，禁用日期和时间输入
                dateInput.disabled = true;
                timeInput.disabled = true;
                dateInput.style.opacity = '0.5';
                timeInput.style.opacity = '0.5';
                // 清空日期和时间值
                dateInput.value = '';
                timeInput.value = '';
            } else {
                // 取消勾选时，恢复日期和时间输入
                dateInput.disabled = false;
                timeInput.disabled = false;
                dateInput.style.opacity = '1';
                timeInput.style.opacity = '1';
            }
        }

        // 保存纪念日
        async function saveAnniversary(event) {
            // 防止事件冒泡和默认行为
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            const name = document.getElementById('anniversary-name').value.trim();
            const date = document.getElementById('anniversary-date').value;
            const type = document.getElementById('anniversary-type').value;
            const customType = document.getElementById('anniversary-custom-type').value.trim();
            const characterId = document.getElementById('anniversary-character').value;
            const description = document.getElementById('anniversary-description').value.trim();
            const userQuote = document.getElementById('anniversary-user-quote').value.trim();
            const characterQuote = document.getElementById('anniversary-character-quote').value.trim();
            const yearly = document.getElementById('anniversary-yearly').checked;
            const isShared = document.getElementById('anniversary-shared').checked;
            const isPinned = document.getElementById('anniversary-pinned').checked;
            const countType = document.getElementById('anniversary-count-type').value;

            if (!name || !date) {
                showToast('请填写纪念日名称和日期', 'error');
                return;
            }

            if (type === 'other' && !customType) {
                showToast('请填写自定义类型', 'error');
                return;
            }

            // 获取背景图和用户头像
            const backgroundImg = document.getElementById('anniversary-background-img');
            const userAvatarImg = document.getElementById('anniversary-user-avatar-img');
            const backgroundImage = backgroundImg && backgroundImg.src && backgroundImg.src !== window.location.href ? backgroundImg.src : null;
            const userAvatar = userAvatarImg && userAvatarImg.src && userAvatarImg.src !== window.location.href ? userAvatarImg.src : null;

            // 🔥【修复】严格清理所有数据，确保没有事件对象或其他不可序列化的内容
            const anniversaryData = {
                id: String(editingAnniversaryId || Date.now().toString()),
                name: String(name || ''),
                date: String(date || ''),
                type: String(type === 'other' ? 'other' : type || ''),
                customType: type === 'other' ? String(customType || '') : null,
                characterId: characterId ? String(characterId) : null,
                description: String(description || ''),
                userQuote: userQuote ? String(userQuote) : null,
                characterQuote: characterQuote ? String(characterQuote) : null,
                yearly: Boolean(yearly),
                isShared: Boolean(isShared),
                isPinned: Boolean(isPinned),
                backgroundImage: backgroundImage ? String(backgroundImage) : null,
                userAvatar: userAvatar ? String(userAvatar) : null,
                countType: String(countType || 'countdown'),
                createdBy: 'user',
                createdAt: editingAnniversaryId ?
                    (anniversaries.find(a => a.id === editingAnniversaryId)?.createdAt || new Date().toISOString()) :
                    new Date().toISOString()
            };

            try {
                // 🔥【修复】如果当前纪念日被设置为置顶，需要先取消其他纪念日的置顶状态
                if (isPinned) {
                    // 找到所有其他置顶的纪念日并取消置顶
                    const otherPinnedAnniversaries = anniversaries.filter(a =>
                        a.isPinned && a.id !== anniversaryData.id
                    );

                    for (const otherAnniversary of otherPinnedAnniversaries) {
                        otherAnniversary.isPinned = false;
                        await db.anniversaries.put(otherAnniversary);
                    }

                    if (otherPinnedAnniversaries.length > 0) {
                        console.log(`取消了 ${otherPinnedAnniversaries.length} 个纪念日的置顶状态`);
                    }
                }

                if (editingAnniversaryId) {
                    // 更新现有纪念日
                    await db.anniversaries.put(anniversaryData);
                    const index = anniversaries.findIndex(a => a.id === editingAnniversaryId);
                    if (index !== -1) {
                        anniversaries[index] = anniversaryData;
                    }
                    showToast('纪念日已更新', 'success');

                    // 🔥【新增】记录纪念日更新到跨应用时间线
                    if (anniversaryData.isShared && anniversaryData.characterId) {
                        try {
                            await recordCrossAppEvent(
                                anniversaryData.characterId,
                                'anniversary',
                                'update',
                                {
                                    id: anniversaryData.id,
                                    type: 'anniversary_update',
                                    content: `用户更新了纪念日"${anniversaryData.name}"（${anniversaryData.date}）${anniversaryData.description ? '：' + anniversaryData.description : ''}`,
                                    anniversaryName: anniversaryData.name,
                                    anniversaryDate: anniversaryData.date,
                                    anniversaryType: anniversaryData.type,
                                    description: anniversaryData.description,
                                    countType: anniversaryData.countType
                                }
                            );
                            console.log('📝 [纪念日时间线] 已记录纪念日更新事件到跨应用时间线');
                        } catch (error) {
                            console.error('❌ [纪念日时间线] 记录纪念日更新事件失败:', error);
                        }
                    }
                } else {
                    // 添加新纪念日
                    await db.anniversaries.add(anniversaryData);
                    anniversaries.push(anniversaryData);
                    showToast('纪念日已添加', 'success');

                    // 🔥【新增】记录纪念日创建到跨应用时间线
                    if (anniversaryData.isShared && anniversaryData.characterId) {
                        try {
                            await recordCrossAppEvent(
                                anniversaryData.characterId,
                                'anniversary',
                                'create',
                                {
                                    id: anniversaryData.id,
                                    type: 'anniversary_create',
                                    content: `用户创建了纪念日"${anniversaryData.name}"（${anniversaryData.date}）${anniversaryData.description ? '：' + anniversaryData.description : ''}`,
                                    anniversaryName: anniversaryData.name,
                                    anniversaryDate: anniversaryData.date,
                                    anniversaryType: anniversaryData.type,
                                    description: anniversaryData.description,
                                    countType: anniversaryData.countType
                                },
                                anniversaryData.id
                            );
                            console.log('📝 [纪念日时间线] 已记录纪念日创建事件到跨应用时间线');
                        } catch (error) {
                            console.error('❌ [纪念日时间线] 记录纪念日创建事件失败:', error);
                        }
                    }
                }

                closeAnniversaryForm();
                loadAnniversaryList();

                // 🔥【新增】如果是置顶纪念日，立即更新小组件
                if (anniversaryData.isPinned) {
                    setTimeout(() => {
                        localStorage.setItem('anniversaryWidgetSelection', anniversaryData.id);
                        displayAnniversaryWidget(anniversaryData);
                    }, 100);
                }
            } catch (error) {
                console.error('保存纪念日失败:', error);
                showToast('保存失败，请重试', 'error');
            }
        }

        // 加载纪念日列表
        async function loadAnniversaryList() {
            try {
                // 确保数据库已初始化
                if (!db || !db.anniversaries) {
                    console.warn('数据库未初始化，跳过纪念日加载');
                    anniversaries = [];
                    renderAnniversaryList();
                    return;
                }

                anniversaries = await db.anniversaries.orderBy('date').toArray();
                renderAnniversaryList();
            } catch (error) {
                console.error('加载纪念日列表失败:', error);
                // 不显示错误提示，避免初始化时的干扰
                anniversaries = [];
                renderAnniversaryList();
            }
        }

        // 渲染纪念日列表
        function renderAnniversaryList() {
            const container = document.getElementById('anniversary-list');
            const pinnedSection = document.getElementById('pinned-anniversary-section');
            const pinnedCard = document.getElementById('pinned-anniversary-card');

            // 分离置顶和普通纪念日
            const pinnedAnniversaries = anniversaries.filter(a => a.isPinned);
            const regularAnniversaries = anniversaries.filter(a => !a.isPinned);

            // 处理置顶纪念日显示
            if (pinnedAnniversaries.length > 0) {
                const pinnedAnniversary = pinnedAnniversaries[0]; // 只显示第一个置顶的
                renderPinnedAnniversary(pinnedAnniversary);
                pinnedSection.style.display = 'block';
            } else {
                pinnedSection.style.display = 'none';
            }

            // 处理普通纪念日列表
            if (regularAnniversaries.length === 0 && pinnedAnniversaries.length === 0) {
                container.innerHTML = `
                    <div class="anniversary-empty-state">
                        <i class="fas fa-heart"></i>
                        <p>还没有纪念日</p>
                        <p>点击右上角 + 添加重要的日子</p>
                    </div>
                `;
                return;
            }

            const now = new Date();
            const currentYear = now.getFullYear();

            container.innerHTML = regularAnniversaries.map(anniversary => {
                const anniversaryDate = new Date(anniversary.date);
                const countType = anniversary.countType || 'countdown'; // 默认为倒数

                let countText = '';

                if (countType === 'countup') {
                    // 正数：基于日历日期计算（当天显示"今天"，第二天显示"已经1天"）
                    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    const anniversaryDateOnly = new Date(anniversaryDate.getFullYear(), anniversaryDate.getMonth(), anniversaryDate.getDate());
                    const daysPassed = Math.floor((today - anniversaryDateOnly) / (1000 * 60 * 60 * 24));
                    countText = daysPassed === 0 ? '今天' :
                               `已经 ${daysPassed} 天`;
                } else {
                    // 倒数：基于日历日期计算（当天显示"今天"）
                    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    let nextDate = new Date(currentYear, anniversaryDate.getMonth(), anniversaryDate.getDate());

                    // 如果今年的日期已过，计算明年的日期
                    if (nextDate < today) {
                        nextDate.setFullYear(currentYear + 1);
                    }

                    const daysUntil = Math.floor((nextDate - today) / (1000 * 60 * 60 * 24));
                    countText = daysUntil === 0 ? '今天' :
                               daysUntil === 1 ? '明天' :
                               `还有 ${daysUntil} 天`;
                }

                // 获取相关角色信息
                const character = anniversary.characterId ? characters.find(c => c.id === anniversary.characterId) : null;
                const characterInfo = character ? `
                    <div class="anniversary-character-info">
                        <div class="character-avatar">
                            <img src="${character.avatar || character.avatarUrl || createDefaultAvatar(character.name)}" alt="${character.name}" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                            <div class="character-avatar-fallback" style="display: none;">${character.name.charAt(0)}</div>
                        </div>
                        <span class="character-name">与 ${character.name}</span>
                    </div>
                ` : '';

                const userQuote = anniversary.userQuote ? `
                    <div class="anniversary-user-quote">
                        <i class="fas fa-quote-left"></i>
                        <span>${escapeHtml(anniversary.userQuote)}</span>
                    </div>
                ` : '';

                const characterQuote = anniversary.characterQuote ? `
                    <div class="anniversary-character-quote">
                        <i class="fas fa-quote-left"></i>
                        <span>${escapeHtml(anniversary.characterQuote)}</span>
                    </div>
                ` : '';

                return `
                    <div class="anniversary-item ${anniversary.isShared ? 'shared' : ''}" onclick="toggleAnniversaryItem(event, '${anniversary.id}')" data-anniversary-id="${anniversary.id}">
                        <!-- 简洁条状显示 -->
                        <div class="anniversary-item-compact">
                            <div class="anniversary-item-compact-left">
                                <div class="anniversary-item-compact-name">${escapeHtml(anniversary.name)}</div>
                            </div>
                            <div class="anniversary-item-compact-countdown">${countText}</div>
                        </div>

                        <!-- 详细信息（默认隐藏） -->
                        <div class="anniversary-item-details">
                            <div class="anniversary-item-header">
                                <div>
                                    <div class="anniversary-item-name">${escapeHtml(anniversary.name)}</div>
                                    <div class="anniversary-item-date">${formatDate(anniversary.date)}</div>
                                    ${characterInfo}
                                </div>
                                <div class="anniversary-item-type ${anniversary.type}">${getTypeText(anniversary)}</div>
                            </div>
                            ${anniversary.description ? `<div class="anniversary-item-description">${escapeHtml(anniversary.description)}</div>` : ''}
                            ${userQuote}
                            ${characterQuote}
                            <div class="anniversary-item-actions" onclick="event.stopPropagation()">
                                <button class="anniversary-action-btn anniversary-edit-btn" onclick="showAnniversaryForm('${anniversary.id}')" title="编辑">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button class="anniversary-action-btn anniversary-delete-btn" onclick="deleteAnniversary('${anniversary.id}')" title="删除">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            // 🔥【优化】更新纪念日小组件 - 智能选择显示内容
            const savedAnniversary = localStorage.getItem('anniversaryWidgetSelection');
            let anniversaryToShow = null;

            if (savedAnniversary) {
                anniversaryToShow = anniversaries.find(a => a.id === savedAnniversary);
            }

            // 如果保存的纪念日不存在，自动选择置顶的纪念日
            if (!anniversaryToShow && anniversaries.length > 0) {
                const pinnedAnniversary = anniversaries.find(a => a.isPinned);
                if (pinnedAnniversary) {
                    anniversaryToShow = pinnedAnniversary;
                    localStorage.setItem('anniversaryWidgetSelection', pinnedAnniversary.id);
                }
            }

            if (anniversaryToShow) {
                displayAnniversaryWidget(anniversaryToShow);
            } else if (anniversaries.length === 0) {
                // 如果没有任何纪念日，清除小组件
                clearAnniversaryWidget();
            }


        }



        // 删除纪念日
        async function deleteAnniversary(anniversaryId) {
            if (confirm('确定要删除这个纪念日吗？')) {
                try {
                    await db.anniversaries.delete(anniversaryId);
                    anniversaries = anniversaries.filter(a => a.id !== anniversaryId);
                    renderAnniversaryList();

                    // 🔥【新增】删除后刷新小组件
                    setTimeout(() => {
                        refreshAnniversaryWidget();
                    }, 100);

                    showToast('纪念日已删除', 'success');
                } catch (error) {
                    console.error('删除纪念日失败:', error);
                    showToast('删除失败，请重试', 'error');
                }
            }
        }

        // 🔥【新增】取消纪念日置顶
        async function unpinAnniversary(anniversaryId) {
            try {
                const anniversary = anniversaries.find(a => a.id === anniversaryId);
                if (anniversary) {
                    anniversary.isPinned = false;
                    await db.anniversaries.put(anniversary);
                    renderAnniversaryList();
                    showToast('已取消置顶，现在可以删除了', 'success');
                }
            } catch (error) {
                console.error('取消置顶失败:', error);
                showToast('操作失败，请重试', 'error');
            }
        }

        // 切换纪念日条目的展开/收缩状态
        function toggleAnniversaryItem(event, anniversaryId) {
            event.stopPropagation();
            const item = event.currentTarget;
            const isExpanded = item.classList.contains('expanded');

            // 收缩所有其他条目
            document.querySelectorAll('.anniversary-item.expanded').forEach(otherItem => {
                if (otherItem !== item) {
                    otherItem.classList.remove('expanded');
                }
            });

            // 切换当前条目状态
            if (isExpanded) {
                item.classList.remove('expanded');
            } else {
                item.classList.add('expanded');
            }
        }

        // 加载约定列表
        async function loadAppointmentList() {
            try {
                // 确保数据库已初始化
                if (!db || !db.appointments) {
                    console.warn('数据库未初始化，跳过约定加载');
                    appointments = [];
                    renderAppointmentList();
                    return;
                }

                // 🔥【修复】不使用orderBy('date')，因为永不过期的约定date为null
                appointments = await db.appointments.toArray();
                console.log('✅ 约定列表已从数据库重新加载，数量:', appointments.length);
                console.log('📋 约定详情:', appointments);
                renderAppointmentList();
            } catch (error) {
                console.error('加载约定列表失败:', error);
                appointments = [];
                renderAppointmentList();
            }
        }

        // 渲染约定列表
        function renderAppointmentList() {
            const container = document.getElementById('appointment-list');

            if (appointments.length === 0) {
                container.innerHTML = `
                    <div class="appointment-empty-state">
                        <i class="fas fa-calendar-check"></i>
                        <p>还没有约定</p>
                        <p>点击右上角 + 添加新约定</p>
                    </div>
                `;
                return;
            }

            // 🔥【修复】处理置顶约定
            const pinnedAppointments = appointments.filter(a => a.isPinned);
            const regularAppointments = appointments.filter(a => !a.isPinned);

            // 渲染置顶约定
            if (pinnedAppointments.length > 0) {
                const pinnedAppointment = pinnedAppointments[0]; // 只显示第一个置顶约定
                renderPinnedAppointment(pinnedAppointment);
                document.getElementById('pinned-appointment-section').style.display = 'block';
            } else {
                document.getElementById('pinned-appointment-section').style.display = 'none';
            }

            // 🔥【修改】按日期和完成状态排序，处理永不过期的约定
            const sortedAppointments = [...regularAppointments].sort((a, b) => {
                // 未完成的排在前面
                if (a.completed !== b.completed) {
                    return a.completed ? 1 : -1;
                }

                // 🔥【新增】永不过期的约定排在最后
                if (a.neverExpires !== b.neverExpires) {
                    return a.neverExpires ? 1 : -1;
                }

                // 如果都不是永不过期，按日期排序
                if (!a.neverExpires && !b.neverExpires) {
                    return new Date(a.date + ' ' + (a.time || '00:00')) - new Date(b.date + ' ' + (b.time || '00:00'));
                }

                // 如果都是永不过期，按创建时间排序
                return (a.timestamp || 0) - (b.timestamp || 0);
            });

            container.innerHTML = sortedAppointments.map(appointment => {
                // 🔥【新增】处理永不过期的约定
                let status = 'pending';
                let countdownText = '';
                let isOverdue = false;

                if (appointment.neverExpires) {
                    // 永不过期的约定
                    status = appointment.completed ? 'completed' : 'never-expires';
                    countdownText = appointment.completed ? '已完成' : '永不过期';
                } else {
                    // 有日期的约定
                    const appointmentDate = new Date(appointment.date + ' ' + (appointment.time || '00:00'));
                    const now = new Date();
                    isOverdue = appointmentDate < now && !appointment.completed;

                    if (appointment.completed) {
                        status = 'completed';
                        countdownText = '已完成';
                    } else if (isOverdue) {
                        status = 'overdue';
                        const daysPassed = Math.floor((now - appointmentDate) / (1000 * 60 * 60 * 24));
                        countdownText = `已过期 ${daysPassed} 天`;
                    } else {
                        const timeDiff = appointmentDate - now;
                        const daysLeft = Math.ceil(timeDiff / (1000 * 60 * 60 * 24));
                        if (daysLeft === 0) {
                            countdownText = '今天';
                        } else if (daysLeft === 1) {
                            countdownText = '明天';
                        } else {
                            countdownText = `还有 ${daysLeft} 天`;
                        }
                    }
                }

                // 获取相关角色信息
                const character = appointment.characterId ? characters.find(c => c.id === appointment.characterId) : null;

                // 构建用户语录
                const userQuote = appointment.userQuote ? `
                    <div class="appointment-user-quote">
                        <i class="fas fa-quote-left"></i>
                        <span>${escapeHtml(appointment.userQuote)}</span>
                    </div>
                ` : '';

                return `
                    <div class="appointment-item ${appointment.completed ? 'completed' : ''} ${isOverdue ? 'overdue' : ''} ${appointment.isShared ? 'shared' : ''}" onclick="toggleAppointmentExpansion('${appointment.id}')">
                        <div class="appointment-item-compact">
                            <div class="appointment-item-left">
                                <div class="appointment-item-name">${escapeHtml(appointment.name)}</div>
                            </div>
                            <div class="appointment-item-right">
                                <div class="appointment-countdown ${status}">${countdownText}</div>
                            </div>
                        </div>
                        <div class="appointment-item-details">
                            <div class="appointment-detail-header">
                                <div class="appointment-detail-left">
                                    <div class="appointment-detail-name">${escapeHtml(appointment.name)}</div>
                                    <div class="appointment-detail-time">${appointment.neverExpires ? '长期约定' : formatAppointmentDate(appointment.date, appointment.time)}</div>
                                </div>
                                <div class="appointment-detail-right">
                                    <span class="appointment-type-tag">${getAppointmentTypeText(appointment)}</span>
                                    <button class="appointment-edit-btn" onclick="event.stopPropagation(); showAppointmentForm('${appointment.id}')" title="编辑约定">
                                        <i class="fas fa-edit"></i>
                                    </button>
                                </div>
                            </div>
                            ${appointment.description ? `<p><strong>描述：</strong>${escapeHtml(appointment.description)}</p>` : ''}
                            ${character ? `<p><strong>相关角色：</strong>${character.name}</p>` : ''}
                            ${appointment.characterQuote ? `
                                <div class="appointment-character-quote">
                                    <i class="fas fa-quote-left"></i>
                                    <span>${escapeHtml(appointment.characterQuote)}</span>
                                </div>
                            ` : ''}
                            <div class="appointment-item-actions">
                                ${!appointment.completed ?
                                    `<button class="appointment-action-btn appointment-complete-btn" onclick="toggleAppointmentComplete('${appointment.id}')">完成</button>` :
                                    `<button class="appointment-action-btn appointment-complete-btn completed" disabled>已完成</button>`
                                }
                                <button class="appointment-action-btn appointment-delete-btn" onclick="deleteAppointment('${appointment.id}')">删除</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // 🔥【新增】获取状态文本
        function getStatusText(status) {
            switch (status) {
                case 'completed': return '已完成';
                case 'overdue': return '已过期';
                case 'pending': return '待完成';
                default: return '待完成';
            }
        }

        // 🔥【新增】切换约定展开状态
        function toggleAppointmentExpansion(appointmentId) {
            const item = document.querySelector(`.appointment-item[onclick*="${appointmentId}"]`);
            if (item) {
                item.classList.toggle('expanded');
            }
        }

        // 🔥【修复】渲染置顶约定 - 完全照搬纪念日的结构
        function renderPinnedAppointment(appointment) {
            const pinnedCard = document.getElementById('pinned-appointment-card');
            const now = new Date();
            const currentYear = now.getFullYear();
            const countType = appointment.countType || 'countdown'; // 默认为倒数

            let countdownText = '';
            let countdownLabel = '';

            // 🔥【新增】处理永不过期的约定
            if (appointment.neverExpires) {
                countdownText = '∞';
                countdownLabel = '';
            } else {
                const appointmentDate = new Date(appointment.date + ' ' + (appointment.time || '00:00'));

                if (countType === 'countup') {
                    // 正数：基于日历日期计算（当天显示"今天"，第二天显示1天）
                    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    const appointmentDateOnly = new Date(appointmentDate.getFullYear(), appointmentDate.getMonth(), appointmentDate.getDate());
                    const daysPassed = Math.floor((today - appointmentDateOnly) / (1000 * 60 * 60 * 24));
                    countdownText = daysPassed === 0 ? '今天' :
                                   `${daysPassed}`;
                    countdownLabel = daysPassed === 0 ? '' : '天';
                } else {
                    // 倒数：基于日历日期计算（当天显示"今天"）
                    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    const appointmentDateOnly = new Date(appointmentDate.getFullYear(), appointmentDate.getMonth(), appointmentDate.getDate());
                    const daysUntil = Math.floor((appointmentDateOnly - today) / (1000 * 60 * 60 * 24));
                    countdownText = daysUntil === 0 ? '今天' :
                                   daysUntil === 1 ? '明天' :
                                   daysUntil < 0 ? `${Math.abs(daysUntil)}` :
                                   `${daysUntil}`;
                    countdownLabel = daysUntil === 0 ? '' :
                                    daysUntil === 1 ? '' :
                                    daysUntil < 0 ? '天前' :
                                    '天';
                }
            }

            // 获取相关角色信息
            const character = appointment.characterId ? characters.find(c => c.id === appointment.characterId) : null;

            // 构建背景图样式
            const backgroundStyle = appointment.backgroundImage ?
                `<div class="pinned-card-background" style="background-image: url('${appointment.backgroundImage}')"></div>` : '';

            // 构建头像区域
            let avatarsHtml = '';
            if (appointment.userAvatar || character) {
                avatarsHtml = '<div class="pinned-card-avatars">';

                // 角色头像（现在在左边）
                if (character) {
                    avatarsHtml += `
                        <div class="pinned-card-avatar">
                            <img src="${character.avatar || character.avatarUrl || createDefaultAvatar(character.name)}" alt="${character.name}" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                            <div class="pinned-card-avatar-fallback" style="display: none;">${character.name.charAt(0)}</div>
                        </div>
                    `;
                }

                // 用户头像（现在在右边）
                if (appointment.userAvatar) {
                    avatarsHtml += `
                        <div class="pinned-card-avatar">
                            <img src="${appointment.userAvatar}" alt="你" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                            <div class="pinned-card-avatar-fallback" style="display: none;">你</div>
                        </div>
                    `;
                }

                avatarsHtml += '</div>';
            }

            // 构建类型标签
            const typeClass = appointment.type || 'other';
            const typeText = getAppointmentTypeText(appointment);

            // 构建优先级标签
            const priorityText = getPriorityText(appointment.priority);
            const priorityClass = appointment.priority || 'medium';

            // 构建用户语录
            const userQuoteHtml = appointment.userQuote ? `
                <div class="pinned-card-user-quote">
                    <i class="fas fa-quote-left"></i>
                    <span class="quote-author">你：</span>${escapeHtml(appointment.userQuote)}
                </div>
            ` : '';

            // 构建角色语录
            const characterQuoteHtml = appointment.characterQuote ? `
                <div class="pinned-card-quote">
                    <i class="fas fa-quote-left"></i>
                    <span class="quote-author">${character ? character.name : '角色'}：</span>${escapeHtml(appointment.characterQuote)}
                </div>
            ` : '';

            pinnedCard.innerHTML = `
                ${backgroundStyle}
                <div class="pinned-card-content">
                    <div class="pinned-card-header">
                        ${avatarsHtml}
                        <div class="pinned-card-type ${typeClass}">${typeText}</div>
                    </div>
                    <div class="pinned-card-main">
                        <div class="pinned-card-title">${escapeHtml(appointment.name)}</div>
                        <div class="pinned-card-countdown">${countdownText}</div>
                        <div class="pinned-card-countdown-label">${countdownLabel}</div>
                        <div class="pinned-card-date">${appointment.neverExpires ? '长期约定' : (countType === 'countup' ? '起始日' : '目标日') + ' ' + formatAppointmentDate(appointment.date, appointment.time)}</div>
                    </div>
                    <div class="pinned-card-footer">
                        ${userQuoteHtml}
                        ${characterQuoteHtml}
                        <div class="pinned-card-actions">
                            <button class="pinned-card-unpin-btn" onclick="event.stopPropagation(); unpinAppointment('${appointment.id}')" title="取消置顶">
                                <i class="fas fa-thumbtack"></i>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="pinned-card-priority-badge ${priorityClass}">${priorityText}</div>
            `;

            // 添加data属性用于长按删除
            pinnedCard.dataset.appointmentId = appointment.id;

            // 添加点击事件
            pinnedCard.onclick = function(e) {
                if (!e.target.closest('.pinned-card-actions')) {
                    showAppointmentForm(appointment.id);
                }
            };
        }

        // 切换约定完成状态
        async function toggleAppointmentComplete(appointmentId) {
            try {
                const appointment = appointments.find(a => a.id === appointmentId);
                if (appointment) {
                    appointment.completed = !appointment.completed;
                    await db.appointments.put(appointment);
                    renderAppointmentList();
                    showToast(appointment.completed ? '约定已完成' : '约定已标记为未完成', 'success');
                }
            } catch (error) {
                console.error('更新约定状态失败:', error);
                showToast('操作失败，请重试', 'error');
            }
        }

        // 删除约定
        async function deleteAppointment(appointmentId) {
            if (confirm('确定要删除这个约定吗？')) {
                try {
                    await db.appointments.delete(appointmentId);
                    appointments = appointments.filter(a => a.id !== appointmentId);
                    renderAppointmentList();
                    showToast('约定已删除', 'success');
                } catch (error) {
                    console.error('删除约定失败:', error);
                    showToast('删除失败，请重试', 'error');
                }
            }
        }

        // 🔥【新增】取消约定置顶
        async function unpinAppointment(appointmentId) {
            try {
                const appointment = appointments.find(a => a.id === appointmentId);
                if (appointment) {
                    appointment.isPinned = false;
                    await db.appointments.put(appointment);
                    renderAppointmentList();
                    showToast('已取消置顶，现在可以删除了', 'success');
                }
            } catch (error) {
                console.error('取消置顶失败:', error);
                showToast('操作失败，请重试', 'error');
            }
        }

        // 格式化约定日期时间
        function formatAppointmentDate(dateString, timeString) {
            const date = new Date(dateString);
            let result = `${date.getMonth() + 1}月${date.getDate()}日`;

            if (timeString) {
                const [hours, minutes] = timeString.split(':');
                result += ` ${hours}:${minutes}`;
            }

            return result;
        }

        // 获取优先级文本
        function getPriorityText(priority) {
            const priorityMap = {
                low: '低',
                medium: '中',
                high: '高',
                urgent: '紧急'
            };
            return priorityMap[priority] || '中';
        }

        // 获取约定类型文本
        function getAppointmentTypeText(appointment) {
            if (appointment.customType) {
                return appointment.customType;
            }

            const typeMap = {
                date: '约会',
                promise: '承诺',
                activity: '活动',
                meeting: '见面',
                task: '任务',
                other: '其他'
            };
            return typeMap[appointment.type] || '其他';
        }

        // 角色主动创建纪念日
        async function createAnniversaryByCharacter(characterId, anniversaryData) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) {
                    console.error('角色不存在:', characterId);
                    return false;
                }

                // 🔥【增强】根据角色人设生成更个性化的语录
                let characterQuote = anniversaryData.characterQuote;
                if (!characterQuote) {
                    characterQuote = generatePersonalizedQuote(character, 'anniversary', anniversaryData);
                }

                const newAnniversary = {
                    id: `anniversary_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    name: anniversaryData.name,
                    date: anniversaryData.date,
                    type: anniversaryData.type || 'other',
                    characterId: characterId,
                    description: anniversaryData.description || '',
                    characterQuote: characterQuote,
                    yearly: anniversaryData.yearly !== false,
                    isShared: true, // 角色创建的默认共享
                    createdBy: 'character',
                    timestamp: Date.now()
                };

                await db.anniversaries.add(newAnniversary);
                anniversaries.push(newAnniversary);

                // 如果当前在纪念日界面，刷新列表
                if (document.getElementById('anniversary-screen').style.display !== 'none') {
                    renderAnniversaryList();
                }

                // 🔥【修复】使用系统推送通知而不是toast
                createAnniversaryNotification(character, newAnniversary, 'created');

                console.log(`✅ ${character.name} 创建了一个纪念日：${anniversaryData.name}`);
                return true;
            } catch (error) {
                console.error('角色创建纪念日失败:', error);
                return false;
            }
        }

        // 角色主动创建约定
        async function createAppointmentByCharacter(characterId, appointmentData) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) {
                    console.error('角色不存在:', characterId);
                    return false;
                }

                // 🔥【增强】根据角色人设生成更个性化的语录
                let characterQuote = appointmentData.characterQuote;
                if (!characterQuote) {
                    characterQuote = generatePersonalizedQuote(character, 'appointment', appointmentData);
                }

                // 🔥【新增】处理永不过期选项
                const neverExpires = appointmentData.neverExpires === true;

                const newAppointment = {
                    id: `appointment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    name: appointmentData.name,
                    date: neverExpires ? null : appointmentData.date,
                    time: neverExpires ? null : (appointmentData.time || ''),
                    type: appointmentData.type || 'other',
                    characterId: characterId,
                    description: appointmentData.description || '',
                    characterQuote: characterQuote,
                    priority: appointmentData.priority || 'medium',
                    completed: false,
                    isShared: true, // 角色创建的默认共享
                    createdBy: 'character',
                    neverExpires: neverExpires,
                    timestamp: Date.now()
                };

                await db.appointments.add(newAppointment);
                appointments.push(newAppointment);

                // 如果当前在纪念日界面，刷新列表
                if (document.getElementById('anniversary-screen').style.display !== 'none') {
                    renderAppointmentList();
                }

                // 🔥【修复】使用系统推送通知而不是toast
                createAppointmentNotification(character, newAppointment, 'created');

                console.log(`✅ ${character.name} 创建了一个约定：${appointmentData.name}`);
                return true;
            } catch (error) {
                console.error('角色创建约定失败:', error);
                return false;
            }
        }

        // 🔥【增强】根据角色人设生成个性化语录
        function generatePersonalizedQuote(character, type, data) {
            const characterName = character.name;

            // 🔥【新增】根据角色性格特征调整语录风格
            const personality = character.personality || '';
            const isGentle = personality.includes('温柔') || personality.includes('温和') || personality.includes('善良');
            const isPlayful = personality.includes('活泼') || personality.includes('开朗') || personality.includes('调皮');
            const isCool = personality.includes('冷酷') || personality.includes('高冷') || personality.includes('傲娇');
            const isSerious = personality.includes('严肃') || personality.includes('认真') || personality.includes('正经');

            // 基础模板
            const templates = {
                anniversary: {
                    birthday: [
                        // 温柔型
                        ...(isGentle ? [
                            `${characterName}："生日快乐～这一天对我们来说很特别呢。"`,
                            `${characterName}："又是一年生日，希望你每天都开心。"`,
                            `${characterName}："生日是值得庆祝的日子，我会好好记住的。"`
                        ] : []),
                        // 活泼型
                        ...(isPlayful ? [
                            `${characterName}："生日快乐！！！要开心地庆祝哦～"`,
                            `${characterName}："哇！又是生日了，时间过得好快呀！"`,
                            `${characterName}："生日耶！我们一定要好好庆祝！"`
                        ] : []),
                        // 冷酷型
                        ...(isCool ? [
                            `${characterName}："生日...算是个值得记住的日子吧。"`,
                            `${characterName}："又长大一岁了呢。"`,
                            `${characterName}："生日快乐。这个日子我会记住的。"`
                        ] : []),
                        // 严肃型
                        ...(isSerious ? [
                            `${characterName}："生日快乐。这是一个重要的纪念日。"`,
                            `${characterName}："又是一年生日，时间的流逝让人深思。"`,
                            `${characterName}："生日是人生的重要节点，值得铭记。"`
                        ] : []),
                        // 通用
                        `${characterName}："生日快乐！这一天对我们来说很特别呢。"`,
                        `${characterName}："又是一年生日，时间过得真快啊。"`,
                        `${characterName}："生日是值得庆祝的日子，我会记住的。"`
                    ],
                    relationship: [
                        ...(isGentle ? [
                            `${characterName}："从那天开始，我们的关系就变得更加珍贵了。"`,
                            `${characterName}："那是我们之间温暖的转折点。"`
                        ] : []),
                        ...(isPlayful ? [
                            `${characterName}："从那天开始，我们就是特别的关系啦！"`,
                            `${characterName}："那一刻超级重要的！我永远不会忘记！"`
                        ] : []),
                        ...(isCool ? [
                            `${characterName}："从那天开始...算是不一样了吧。"`,
                            `${characterName}："那个转折点，我记得。"`
                        ] : []),
                        `${characterName}："从那天开始，我们的关系就不一样了。"`,
                        `${characterName}："这是我们之间重要的转折点。"`
                    ],
                    anniversary: [
                        `${characterName}："这个日子对我们来说意义非凡。"`,
                        `${characterName}："每年的这一天，我都会想起当时的情景。"`,
                        `${characterName}："这是值得纪念的美好时光。"`
                    ],
                    other: [
                        `${characterName}："这是一个特别的日子。"`,
                        `${characterName}："我想把这个日子记录下来。"`,
                        `${characterName}："这一天值得我们铭记。"`
                    ]
                },
                appointment: {
                    date: [
                        ...(isGentle ? [
                            `${characterName}："我们约好了，我会准时的。"`,
                            `${characterName}："期待和你一起度过这个美好时光。"`
                        ] : []),
                        ...(isPlayful ? [
                            `${characterName}："约会约会！不见不散哦～"`,
                            `${characterName}："我已经超级期待了！"`
                        ] : []),
                        ...(isCool ? [
                            `${characterName}："约定就是约定，我会去的。"`,
                            `${characterName}："这个时间，我记住了。"`
                        ] : []),
                        `${characterName}："我们约好了，不见不散。"`,
                        `${characterName}："期待和你一起度过这个时光。"`
                    ],
                    promise: [
                        ...(isSerious ? [
                            `${characterName}："我会严格遵守这个承诺。"`,
                            `${characterName}："承诺的分量，我深知其重。"`
                        ] : []),
                        `${characterName}："我会遵守这个承诺的。"`,
                        `${characterName}："说到做到，这是我的原则。"`
                    ],
                    activity: [
                        `${characterName}："一起做这件事一定很有趣。"`,
                        `${characterName}："我已经开始期待了。"`
                    ],
                    other: [
                        `${characterName}："我们约定好了。"`,
                        `${characterName}："这个约定我会记在心里。"`
                    ]
                }
            };

            // 根据类型和子类型选择模板
            const typeTemplates = templates[type] || {};
            const subTypeTemplates = typeTemplates[data.type] || typeTemplates.other || [];

            if (subTypeTemplates.length === 0) {
                return type === 'anniversary' ?
                    `${characterName}："这是一个特别的日子。"` :
                    `${characterName}："我们约定好了。"`;
            }

            // 随机选择一个模板
            return subTypeTemplates[Math.floor(Math.random() * subTypeTemplates.length)];
        }

        // 🔥【新增】纪念日系统通知
        function createAnniversaryNotification(character, anniversary, action) {
            let notificationText = '';
            let notificationIcon = '';

            if (action === 'created') {
                notificationIcon = '🎉';
                switch (anniversary.type) {
                    case 'birthday':
                        notificationText = `${notificationIcon} ${character.name} 记录了生日：${anniversary.name}`;
                        break;
                    case 'relationship':
                        notificationText = `${notificationIcon} ${character.name} 创建了关系纪念日：${anniversary.name}`;
                        break;
                    case 'anniversary':
                        notificationText = `${notificationIcon} ${character.name} 创建了纪念日：${anniversary.name}`;
                        break;
                    default:
                        notificationText = `${notificationIcon} ${character.name} 创建了特别的日子：${anniversary.name}`;
                }
            } else if (action === 'reminder') {
                notificationIcon = '📅';
                const today = new Date();
                const anniversaryDate = new Date(anniversary.date);
                const isToday = anniversaryDate.toDateString() === today.toDateString();

                if (isToday) {
                    notificationText = `${notificationIcon} 今天是${anniversary.name}！${character.name}想和你一起纪念`;
                } else {
                    notificationText = `${notificationIcon} ${character.name}提醒：明天是${anniversary.name}`;
                }
            }

            // 使用现有的推送通知系统，增加优先级
            createPushNotification(character, notificationText, 150);
        }

        // 🔥【新增】约定系统通知
        function createAppointmentNotification(character, appointment, action) {
            let notificationText = '';
            let notificationIcon = '';

            if (action === 'created') {
                notificationIcon = '📝';
                switch (appointment.type) {
                    case 'date':
                        notificationText = `${notificationIcon} ${character.name} 和你约定了约会：${appointment.name}`;
                        break;
                    case 'promise':
                        notificationText = `${notificationIcon} ${character.name} 和你许下承诺：${appointment.name}`;
                        break;
                    case 'meeting':
                        notificationText = `${notificationIcon} ${character.name} 约定和你见面：${appointment.name}`;
                        break;
                    case 'activity':
                        notificationText = `${notificationIcon} ${character.name} 约定了活动：${appointment.name}`;
                        break;
                    default:
                        notificationText = `${notificationIcon} ${character.name} 创建了约定：${appointment.name}`;
                }
            } else if (action === 'reminder') {
                notificationIcon = '⏰';
                const today = new Date();
                const appointmentDate = new Date(appointment.date);
                const isToday = appointmentDate.toDateString() === today.toDateString();

                if (isToday) {
                    const timeText = appointment.time ? ` ${appointment.time}` : '';
                    notificationText = `${notificationIcon} 今天${timeText}是${appointment.name}！${character.name}在等你`;
                } else {
                    notificationText = `${notificationIcon} ${character.name}提醒：明天是${appointment.name}`;
                }
            }

            // 使用现有的推送通知系统，增加优先级
            createPushNotification(character, notificationText, 150);
        }

        // 🔥【新增】检测AI回复中的纪念日创建意图
        async function detectAnniversaryCreationInAIReply(characterId, aiReplyText, userMessageText) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;

            console.log('🔍 检测AI回复中的纪念日创建意图...');
            console.log('AI回复:', aiReplyText);
            console.log('用户消息:', userMessageText);

            // 检测AI是否明确表示要创建纪念日
            const creationPhrases = [
                '创建纪念日', '建立纪念日', '记录这个日子', '设立纪念日',
                '创建约定', '建立约定', '记录约定', '设立约定',
                '我想记录', '让我记录', '我来记录', '我要记录'
            ];

            const hasCreationIntent = creationPhrases.some(phrase =>
                aiReplyText.includes(phrase)
            );

            if (hasCreationIntent) {
                console.log('✅ 检测到创建意图，尝试解析内容...');

                // 尝试从AI回复中提取纪念日信息
                let anniversaryName = '特别的日子';
                let anniversaryType = 'other';
                let anniversaryDate = new Date().toISOString().split('T')[0];

                // 提取日期
                const dateMatch = aiReplyText.match(/(\d{4})年(\d{1,2})月(\d{1,2})日|(\d{1,2})月(\d{1,2})日/);
                if (dateMatch) {
                    if (dateMatch[1] && dateMatch[2] && dateMatch[3]) {
                        // 完整日期
                        anniversaryDate = `${dateMatch[1]}-${dateMatch[2].padStart(2, '0')}-${dateMatch[3].padStart(2, '0')}`;
                    } else if (dateMatch[4] && dateMatch[5]) {
                        // 月日格式，使用当前年份
                        const currentYear = new Date().getFullYear();
                        anniversaryDate = `${currentYear}-${dateMatch[4].padStart(2, '0')}-${dateMatch[5].padStart(2, '0')}`;
                    }
                }

                // 提取名称
                const nameMatch = aiReplyText.match(/纪念日.*?[：:]\s*([^。！？\n]+)|名称.*?[：:]\s*([^。！？\n]+)|叫做\s*([^。！？\n]+)/);
                if (nameMatch) {
                    anniversaryName = (nameMatch[1] || nameMatch[2] || nameMatch[3]).trim();
                }

                // 判断类型
                if (aiReplyText.includes('生日') || userMessageText.includes('生日')) {
                    anniversaryType = 'birthday';
                    if (!nameMatch) anniversaryName = '生日';
                } else if (aiReplyText.includes('第一次') || userMessageText.includes('第一次')) {
                    anniversaryType = 'first_time';
                    if (!nameMatch) anniversaryName = '我们的第一次';
                } else if (aiReplyText.includes('相遇') || aiReplyText.includes('认识')) {
                    anniversaryType = 'meeting';
                    if (!nameMatch) anniversaryName = '我们相遇的日子';
                }

                console.log('📝 解析出的纪念日信息:', {
                    name: anniversaryName,
                    date: anniversaryDate,
                    type: anniversaryType
                });

                // 创建纪念日
                const anniversaryData = {
                    name: anniversaryName,
                    date: anniversaryDate,
                    type: anniversaryType,
                    description: `由${character.name}创建的纪念日`
                };

                const success = await createAnniversaryByCharacter(characterId, anniversaryData);
                if (success) {
                    console.log('✅ 纪念日创建成功！');
                } else {
                    console.error('❌ 纪念日创建失败');
                }
            }
        }

        // 🔥【优化】更合理的纪念日和约定提醒系统
        async function checkAnniversaryReminders() {
            const today = new Date();
            const todayStr = today.toISOString().split('T')[0];
            const tomorrow = new Date(today);
            tomorrow.setDate(tomorrow.getDate() + 1);
            const tomorrowStr = tomorrow.toISOString().split('T')[0];

            console.log('🔍 检查纪念日和约定提醒...');

            // 检查今天的纪念日 - 只在特定时间提醒
            const currentHour = today.getHours();
            const shouldRemindToday = currentHour === 8 || currentHour === 20; // 早上8点或晚上8点

            for (const anniversary of anniversaries) {
                if (anniversary.characterId && anniversary.isShared) {
                    const character = characters.find(c => c.id === anniversary.characterId);
                    if (!character) continue;

                    const anniversaryDate = new Date(anniversary.date);
                    const thisYearDate = new Date(today.getFullYear(), anniversaryDate.getMonth(), anniversaryDate.getDate());
                    const thisYearDateStr = thisYearDate.toISOString().split('T')[0];

                    // 今天是纪念日且在合适的时间
                    if (thisYearDateStr === todayStr && shouldRemindToday) {
                        // 检查是否已经提醒过（避免重复）
                        const hasRemindedToday = await checkIfAlreadyReminded(character.id, anniversary.id, 'today');
                        if (!hasRemindedToday) {
                            await triggerAnniversaryReminder(character, anniversary, 'today');
                            await markAsReminded(character.id, anniversary.id, 'today');
                        }
                    }
                    // 明天是纪念日且是晚上8点（提前一天提醒）
                    else if (thisYearDateStr === tomorrowStr && currentHour === 20) {
                        const hasRemindedTomorrow = await checkIfAlreadyReminded(character.id, anniversary.id, 'tomorrow');
                        if (!hasRemindedTomorrow) {
                            await triggerAnniversaryReminder(character, anniversary, 'tomorrow');
                            await markAsReminded(character.id, anniversary.id, 'tomorrow');
                        }
                    }
                }
            }

            // 检查今天的约定
            for (const appointment of appointments) {
                if (appointment.characterId && appointment.isShared && !appointment.completed && !appointment.neverExpires) {
                    const character = characters.find(c => c.id === appointment.characterId);
                    if (!character) continue;

                    // 今天是约定日期
                    if (appointment.date === todayStr && shouldRemindToday) {
                        const hasRemindedToday = await checkIfAlreadyReminded(character.id, appointment.id, 'today');
                        if (!hasRemindedToday) {
                            await triggerAppointmentReminder(character, appointment, 'today');
                            await markAsReminded(character.id, appointment.id, 'today');
                        }
                    }
                    // 明天是约定日期
                    else if (appointment.date === tomorrowStr && currentHour === 20) {
                        const hasRemindedTomorrow = await checkIfAlreadyReminded(character.id, appointment.id, 'tomorrow');
                        if (!hasRemindedTomorrow) {
                            await triggerAppointmentReminder(character, appointment, 'tomorrow');
                            await markAsReminded(character.id, appointment.id, 'tomorrow');
                        }
                    }
                }
            }
        }

        // 🔥【新增】检查是否已经提醒过（避免重复提醒）
        async function checkIfAlreadyReminded(characterId, itemId, timing) {
            const today = new Date().toISOString().split('T')[0];
            const key = `reminder_${characterId}_${itemId}_${timing}_${today}`;
            return localStorage.getItem(key) !== null;
        }

        // 🔥【新增】标记为已提醒
        async function markAsReminded(characterId, itemId, timing) {
            const today = new Date().toISOString().split('T')[0];
            const key = `reminder_${characterId}_${itemId}_${timing}_${today}`;
            localStorage.setItem(key, 'true');
        }

        // 🔥【新增】触发纪念日提醒
        async function triggerAnniversaryReminder(character, anniversary, timing) {
            const timingText = timing === 'today' ? '今天' : '明天';

            // 🔥【增强】根据角色性格生成更自然的提醒消息
            const personality = character.personality || '';
            const isGentle = personality.includes('温柔') || personality.includes('温和');
            const isPlayful = personality.includes('活泼') || personality.includes('开朗');
            const isCool = personality.includes('冷酷') || personality.includes('高冷');

            let messages = [];

            if (isGentle) {
                messages = [
                    `${timingText}是${anniversary.name}呢，你还记得吗？`,
                    `${timingText}是个特别的日子——${anniversary.name}。`,
                    `想起来${timingText}是${anniversary.name}，心情有点特别呢。`
                ];
            } else if (isPlayful) {
                messages = [
                    `哎呀！${timingText}是${anniversary.name}！你记得吗？`,
                    `${timingText}是${anniversary.name}呢～时间过得好快！`,
                    `${anniversary.name}就在${timingText}！要庆祝一下吗？`
                ];
            } else if (isCool) {
                messages = [
                    `${timingText}是${anniversary.name}...你应该记得吧。`,
                    `${anniversary.name}，${timingText}。`,
                    `${timingText}...${anniversary.name}呢。`
                ];
            } else {
                messages = [
                    `${timingText}是${anniversary.name}呢，你还记得吗？`,
                    `${timingText}是个特别的日子——${anniversary.name}。`,
                    `提醒一下，${timingText}是${anniversary.name}哦。`,
                    `${anniversary.name}就在${timingText}，时间过得真快。`
                ];
            }

            const message = messages[Math.floor(Math.random() * messages.length)];

            // 发送提醒消息到聊天
            await sendCharacterReminderMessage(character.id, message);

            // 创建通知
            createAnniversaryNotification(character, anniversary, 'reminder');
        }

        // 🔥【新增】触发约定提醒
        async function triggerAppointmentReminder(character, appointment, timing) {
            const timingText = timing === 'today' ? '今天' : '明天';
            const timeText = appointment.time ? ` ${appointment.time}` : '';

            // 🔥【增强】根据角色性格生成更自然的提醒消息
            const personality = character.personality || '';
            const isGentle = personality.includes('温柔') || personality.includes('温和');
            const isPlayful = personality.includes('活泼') || personality.includes('开朗');
            const isCool = personality.includes('冷酷') || personality.includes('高冷');

            let messages = [];

            if (isGentle) {
                messages = [
                    `${timingText}${timeText}我们有约定——${appointment.name}，记得哦。`,
                    `温馨提醒，${timingText}${timeText}是${appointment.name}的时间。`,
                    `${appointment.name}就在${timingText}${timeText}，我很期待呢。`
                ];
            } else if (isPlayful) {
                messages = [
                    `${timingText}${timeText}我们有约定——${appointment.name}，别忘了哦！`,
                    `哇！${appointment.name}就在${timingText}${timeText}，准备好了吗？`,
                    `我们约好的${appointment.name}是${timingText}${timeText}呢～超期待的！`
                ];
            } else if (isCool) {
                messages = [
                    `${timingText}${timeText}...${appointment.name}。`,
                    `${appointment.name}，${timingText}${timeText}。别忘了。`,
                    `约定的时间到了，${timingText}${timeText}。`
                ];
            } else {
                messages = [
                    `${timingText}${timeText}我们有约定——${appointment.name}，别忘了哦。`,
                    `提醒你一下，${timingText}${timeText}是${appointment.name}的时间。`,
                    `${appointment.name}就在${timingText}${timeText}，准备好了吗？`,
                    `我们约好的${appointment.name}是${timingText}${timeText}呢。`
                ];
            }

            const message = messages[Math.floor(Math.random() * messages.length)];

            // 发送提醒消息到聊天
            await sendCharacterReminderMessage(character.id, message);

            // 创建通知
            createAppointmentNotification(character, appointment, 'reminder');
        }

        // 🔥【新增】角色发送提醒消息
        async function sendCharacterReminderMessage(characterId, message) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;

            // 创建AI消息对象
            const aiMessage = {
                id: `reminder-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                content: [{ type: 'text', text: message }],
                text: message,
                timestamp: Date.now(),
                isUser: false,
                isReminder: true, // 标记为提醒消息
                sender: 'received' // 🔥【新增】确保消息格式正确
            };

            // 添加到聊天记录
            if (!chatMessages[characterId]) {
                chatMessages[characterId] = [];
            }
            chatMessages[characterId].push(aiMessage);

            // 保存到数据库
            try {
                // 🔥【修复】使用时间戳和随机数确保ID唯一性，避免重复键错误
                const stableId = `${characterId}_reminder_${aiMessage.timestamp}_${Math.random().toString(36).substr(2, 9)}_${chatMessages[characterId].length - 1}`;
                await db.chatMessages.add({
                    id: stableId,
                    characterId: characterId,
                    timestamp: aiMessage.timestamp,
                    messageOrder: chatMessages[characterId].length - 1,
                    originalMessageId: aiMessage.id,
                    messageData: aiMessage
                });
            } catch (error) {
                console.error('保存提醒消息失败:', error);
            }

            // 如果用户当前在和该角色聊天，使用动画添加消息
            if (currentChatCharacter && currentChatCharacter.id === characterId) {
                addMessageWithAnimation(aiMessage, characterId);

                // 🔥【新增】为提醒消息添加特殊样式
                setTimeout(() => {
                    const messageContainers = document.querySelectorAll('.message-container.received');
                    const lastContainer = messageContainers[messageContainers.length - 1];
                    if (lastContainer) {
                        const bubble = lastContainer.querySelector('.message-bubble');
                        if (bubble) {
                            bubble.classList.add('reminder-message');
                        }
                    }
                }, 100);
            }

            // 刷新消息列表
            renderMessageList();

            // 🔥【增强】创建更个性化的推送通知
            const notificationText = `💭 ${character.name}: ${message}`;
            createPushNotification(character, notificationText, 180);
        }

        // 🔥【优化】更合理的纪念日提醒系统初始化
        function initAnniversaryReminderSystem() {
            console.log('🎉 启动纪念日和约定提醒系统...');

            // 🔥【优化】只在早上8点和晚上8点检查，避免过度打扰
            const scheduleReminders = () => {
                const now = new Date();
                const hour = now.getHours();
                const minute = now.getMinutes();

                // 只在早上8:00-8:05和晚上20:00-20:05之间检查
                if ((hour === 8 || hour === 20) && minute < 5) {
                    console.log(`🔔 定时检查纪念日提醒 - ${hour}:${minute.toString().padStart(2, '0')}`);
                    checkAnniversaryReminders();
                }
            };

            // 立即检查一次（如果当前是合适的时间）
            setTimeout(() => {
                scheduleReminders();
            }, 5000); // 延迟5秒，确保数据加载完成

            // 每5分钟检查一次是否到了提醒时间
            setInterval(scheduleReminders, 5 * 60 * 1000); // 5分钟

            console.log('✅ 纪念日提醒系统已启动 - 只在早8点和晚8点提醒');
        }

        // 🔥【重新设计】提供手动创建纪念日和约定的接口
        window.createAnniversaryByCharacterManual = createAnniversaryByCharacter;
        window.createAppointmentByCharacterManual = createAppointmentByCharacter;

        // 🔥【新增】为开发者提供测试接口
        window.testAnniversaryReminder = async function(characterId) {
            const character = characters.find(c => c.id === characterId);
            if (!character) {
                console.error('角色不存在');
                return;
            }

            // 创建一个测试纪念日
            const testAnniversary = {
                name: '测试纪念日',
                date: new Date().toISOString().split('T')[0],
                type: 'other',
                description: '这是一个测试纪念日'
            };

            await createAnniversaryByCharacter(characterId, testAnniversary);
            console.log('✅ 测试纪念日创建成功');
        };

        // 🔥【新增】为开发者提供测试约定接口
        window.testAppointmentReminder = async function(characterId) {
            const character = characters.find(c => c.id === characterId);
            if (!character) {
                console.error('角色不存在');
                return;
            }

            // 创建一个测试约定
            const testAppointment = {
                name: '测试约定',
                date: new Date().toISOString().split('T')[0],
                type: 'other',
                description: '这是一个测试约定'
            };

            await createAppointmentByCharacter(characterId, testAppointment);
            console.log('✅ 测试约定创建成功');
        };

        // 🔥【保留但优化】自然提及现有纪念日或约定 - 只在用户明确询问时间时触发
        async function checkForNaturalAnniversaryMention(characterId, messageContent) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;

            // 🔥【更严格】只在用户明确询问时间相关问题时才触发
            const directTimeQuestions = [
                '今天是几号', '今天几号', '现在几号', '什么时候', '哪天',
                '今天是什么日子', '有什么安排', '最近有什么事'
            ];

            const isDirectTimeQuestion = directTimeQuestions.some(question =>
                messageContent.includes(question)
            );

            // 只有在直接询问时间时才有可能提及（并且概率很低）
            if (isDirectTimeQuestion && Math.random() < 0.1) { // 只有10%概率
                const today = new Date();

                // 检查是否有相关的纪念日或约定
                const relevantAnniversaries = anniversaries.filter(a =>
                    a.characterId === characterId && a.isShared
                );
                const relevantAppointments = appointments.filter(a =>
                    a.characterId === characterId && a.isShared && !a.completed
                );

                // 优先提及即将到来的纪念日或约定
                const upcomingItems = [...relevantAnniversaries, ...relevantAppointments]
                    .map(item => {
                        const itemDate = new Date(item.date);
                        const daysDiff = Math.ceil((itemDate - today) / (1000 * 60 * 60 * 24));
                        return { ...item, daysDiff, isAnniversary: !!item.yearly };
                    })
                    .filter(item => item.daysDiff >= 0 && item.daysDiff <= 3) // 只提及3天内的
                    .sort((a, b) => a.daysDiff - b.daysDiff);

                if (upcomingItems.length > 0) {
                    const item = upcomingItems[0];
                    let reminderMessage = '';

                    if (item.daysDiff === 0) {
                        reminderMessage = `对了，今天是${item.name}呢。`;
                    } else if (item.daysDiff === 1) {
                        reminderMessage = `说起来，明天是${item.name}。`;
                    } else {
                        reminderMessage = `想起来，${item.daysDiff}天后是${item.name}。`;
                    }

                    // 发送自然的提醒消息
                    await sendCharacterReminderMessage(characterId, reminderMessage);
                }
            }
        }

        // 🔥【简化】提供简单的手动创建接口供开发者使用
        window.manualCreateAnniversary = async function(characterId, name, date, type = 'other') {
            const anniversaryData = {
                name: name,
                date: date,
                type: type,
                description: `手动创建的${type === 'birthday' ? '生日' : '纪念日'}`
            };
            return await createAnniversaryByCharacter(characterId, anniversaryData);
        };

        window.manualCreateAppointment = async function(characterId, name, date, type = 'other', neverExpires = false) {
            const appointmentData = {
                name: name,
                date: date,
                type: type,
                description: `手动创建的约定`,
                neverExpires: neverExpires
            };
            return await createAppointmentByCharacter(characterId, appointmentData);
        };

        // 🔥【新增】开发者调试接口
        window.anniversaryDebug = {
            // 手动触发提醒检查
            checkReminders: () => checkAnniversaryReminders(),

            // 为指定角色创建测试纪念日
            createTestAnniversary: async (characterId, name = '测试纪念日') => {
                const today = new Date().toISOString().split('T')[0];
                return await window.manualCreateAnniversary(characterId, name, today, 'other');
            },

            // 为指定角色创建测试约定
            createTestAppointment: async (characterId, name = '测试约定', neverExpires = false) => {
                const today = new Date().toISOString().split('T')[0];
                return await window.manualCreateAppointment(characterId, name, today, 'other', neverExpires);
            },

            // 查看所有纪念日
            listAnniversaries: () => {
                console.table(anniversaries.map(a => ({
                    id: a.id,
                    name: a.name,
                    date: a.date,
                    character: characters.find(c => c.id === a.characterId)?.name || '未知',
                    quote: a.characterQuote
                })));
            },

            // 查看所有约定
            listAppointments: () => {
                console.table(appointments.map(a => ({
                    id: a.id,
                    name: a.name,
                    date: a.date,
                    character: characters.find(c => c.id === a.characterId)?.name || '未知',
                    quote: a.characterQuote,
                    completed: a.completed
                })));
            }
        };

        console.log('🔧 纪念日调试接口已加载，使用 anniversaryDebug 对象进行调试');

        // 🔥【新增】简单的测试函数，用于验证角色创建功能
        window.testCreateAnniversary = async function() {
            // 获取第一个角色
            if (characters.length === 0) {
                console.error('❌ 没有角色可用于测试');
                return;
            }

            const testCharacter = characters[0];
            console.log('🧪 使用角色进行测试:', testCharacter.name);

            const testData = {
                name: '测试纪念日',
                date: new Date().toISOString().split('T')[0],
                type: 'other',
                description: '这是一个测试纪念日'
            };

            console.log('📝 创建纪念日数据:', testData);

            try {
                const result = await createAnniversaryByCharacter(testCharacter.id, testData);
                console.log('✅ 创建结果:', result);

                // 检查是否真的添加到了数组中
                console.log('📊 当前纪念日数量:', anniversaries.length);
                console.log('📋 最新的纪念日:', anniversaries[anniversaries.length - 1]);

                return result;
            } catch (error) {
                console.error('❌ 测试失败:', error);
                return false;
            }
        };

        // 🔥【新增】测试约定创建功能
        window.testCreateAppointment = async function() {
            // 获取第一个角色
            if (characters.length === 0) {
                console.error('❌ 没有角色可用于测试');
                return;
            }

            const testCharacter = characters[0];
            console.log('🧪 使用角色进行测试:', testCharacter.name);

            const testData = {
                name: '测试约定',
                date: new Date().toISOString().split('T')[0],
                type: 'other',
                description: '这是一个测试约定'
            };

            console.log('📝 创建约定数据:', testData);

            try {
                const result = await createAppointmentByCharacter(testCharacter.id, testData);
                console.log('✅ 创建结果:', result);

                // 检查是否真的添加到了数组中
                console.log('📊 当前约定数量:', appointments.length);
                console.log('📋 最新的约定:', appointments[appointments.length - 1]);

                return result;
            } catch (error) {
                console.error('❌ 测试失败:', error);
                return false;
            }
        };



        // 格式化日期
        function formatDate(dateString) {
            const date = new Date(dateString);
            const weekdays = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
            const year = date.getFullYear();
            const month = date.getMonth() + 1;
            const day = date.getDate();
            const weekday = weekdays[date.getDay()];
            return `${year}-${month}-${day} ${weekday}`;
        }

        // 获取类型文本
        function getTypeText(anniversary) {
            if (anniversary.customType) {
                return anniversary.customType;
            }

            const typeMap = {
                birthday: '生日',
                relationship: '确定关系',
                anniversary: '纪念日',
                holiday: '节日',
                family: '家人生日',
                other: '其他'
            };
            return typeMap[anniversary.type] || '其他';
        }

        // 🔥【新增】获取约定类型文本
        function getAppointmentTypeText(appointment) {
            if (appointment.customType) {
                return appointment.customType;
            }

            const typeMap = {
                date: '约会',
                meeting: '会面',
                travel: '旅行',
                event: '活动',
                work: '工作',
                study: '学习',
                health: '健康',
                other: '其他'
            };
            return typeMap[appointment.type] || '其他';
        }

        // 🔥【新增】处理纪念日背景图上传
        function handleAnniversaryBackgroundUpload(input) {
            if (input.files && input.files[0]) {
                const file = input.files[0];
                const reader = new FileReader();

                reader.onload = function(e) {
                    document.getElementById('anniversary-background-img').src = e.target.result;
                    document.getElementById('anniversary-background-preview').style.display = 'block';
                };

                reader.readAsDataURL(file);
            }
        }

        // 🔥【新增】处理纪念日用户头像上传
        function handleAnniversaryUserAvatarUpload(input) {
            if (input.files && input.files[0]) {
                const file = input.files[0];
                const reader = new FileReader();

                reader.onload = function(e) {
                    document.getElementById('anniversary-user-avatar-img').src = e.target.result;
                    document.getElementById('anniversary-user-avatar-preview').style.display = 'block';
                };

                reader.readAsDataURL(file);
            }
        }

        // 🔥【新增】移除纪念日背景图
        function removeAnniversaryBackground() {
            document.getElementById('anniversary-background-upload').value = '';
            document.getElementById('anniversary-background-preview').style.display = 'none';
            document.getElementById('anniversary-background-img').src = '';
        }

        // 🔥【新增】移除纪念日用户头像
        function removeAnniversaryUserAvatar() {
            document.getElementById('anniversary-user-avatar-upload').value = '';
            document.getElementById('anniversary-user-avatar-preview').style.display = 'none';
            document.getElementById('anniversary-user-avatar-img').src = '';
        }

        // 🔥【新增】处理约定背景图上传
        function handleAppointmentBackgroundUpload(input) {
            if (input.files && input.files[0]) {
                const file = input.files[0];
                const reader = new FileReader();

                reader.onload = function(e) {
                    document.getElementById('appointment-background-img').src = e.target.result;
                    document.getElementById('appointment-background-preview').style.display = 'block';
                };

                reader.readAsDataURL(file);
            }
        }

        // 🔥【新增】处理约定用户头像上传
        function handleAppointmentUserAvatarUpload(input) {
            if (input.files && input.files[0]) {
                const file = input.files[0];
                const reader = new FileReader();

                reader.onload = function(e) {
                    document.getElementById('appointment-user-avatar-img').src = e.target.result;
                    document.getElementById('appointment-user-avatar-preview').style.display = 'block';
                };

                reader.readAsDataURL(file);
            }
        }

        // 🔥【新增】移除约定背景图
        function removeAppointmentBackground() {
            document.getElementById('appointment-background-upload').value = '';
            document.getElementById('appointment-background-preview').style.display = 'none';
            document.getElementById('appointment-background-img').src = '';
        }

        // 🔥【新增】移除约定用户头像
        function removeAppointmentUserAvatar() {
            document.getElementById('appointment-user-avatar-upload').value = '';
            document.getElementById('appointment-user-avatar-preview').style.display = 'none';
            document.getElementById('appointment-user-avatar-img').src = '';
        }

        // 🔥【新增】渲染置顶纪念日
        function renderPinnedAnniversary(anniversary) {
            const pinnedCard = document.getElementById('pinned-anniversary-card');
            const now = new Date();
            const currentYear = now.getFullYear();

            const anniversaryDate = new Date(anniversary.date);
            const countType = anniversary.countType || 'countdown'; // 默认为倒数

            let countdownText = '';
            let countdownLabel = '';

            if (countType === 'countup') {
                // 正数：基于日历日期计算（当天显示"今天"，第二天显示1天）
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const anniversaryDateOnly = new Date(anniversaryDate.getFullYear(), anniversaryDate.getMonth(), anniversaryDate.getDate());
                const daysPassed = Math.floor((today - anniversaryDateOnly) / (1000 * 60 * 60 * 24));
                countdownText = daysPassed === 0 ? '今天' :
                               `${daysPassed}`;
                countdownLabel = daysPassed === 0 ? '' : '天';
            } else {
                // 倒数：基于日历日期计算（当天显示"今天"）
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                let nextDate = new Date(currentYear, anniversaryDate.getMonth(), anniversaryDate.getDate());

                // 如果今年的日期已过，计算明年的日期
                if (nextDate < today) {
                    nextDate.setFullYear(currentYear + 1);
                }

                const daysUntil = Math.floor((nextDate - today) / (1000 * 60 * 60 * 24));
                countdownText = daysUntil === 0 ? '今天' :
                               daysUntil === 1 ? '明天' :
                               `${daysUntil}`;
                countdownLabel = daysUntil === 0 ? '' :
                                daysUntil === 1 ? '' :
                                '天';
            }

            // 获取相关角色信息
            const character = anniversary.characterId ? characters.find(c => c.id === anniversary.characterId) : null;

            // 构建背景图样式
            const backgroundStyle = anniversary.backgroundImage ?
                `<div class="pinned-card-background" style="background-image: url('${anniversary.backgroundImage}')"></div>` : '';

            // 构建头像区域
            let avatarsHtml = '';
            if (anniversary.userAvatar || character) {
                avatarsHtml = '<div class="pinned-card-avatars">';

                // 角色头像（现在在左边）
                if (character) {
                    avatarsHtml += `
                        <div class="pinned-card-avatar">
                            <img src="${character.avatar || character.avatarUrl || createDefaultAvatar(character.name)}" alt="${character.name}" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                            <div class="pinned-card-avatar-fallback" style="display: none;">${character.name.charAt(0)}</div>
                        </div>
                    `;
                }

                // 用户头像（现在在右边）
                if (anniversary.userAvatar) {
                    avatarsHtml += `
                        <div class="pinned-card-avatar">
                            <img src="${anniversary.userAvatar}" alt="你" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                            <div class="pinned-card-avatar-fallback" style="display: none;">你</div>
                        </div>
                    `;
                }

                avatarsHtml += '</div>';
            }

            // 构建类型标签
            const typeClass = anniversary.type || 'other';
            const typeText = getTypeText(anniversary);

            // 构建用户语录
            const userQuoteHtml = anniversary.userQuote ? `
                <div class="pinned-card-user-quote">
                    <i class="fas fa-quote-left"></i>
                    <span class="quote-author">你：</span>${escapeHtml(anniversary.userQuote)}
                </div>
            ` : '';

            // 构建角色语录
            const characterQuoteHtml = anniversary.characterQuote ? `
                <div class="pinned-card-quote">
                    <i class="fas fa-quote-left"></i>
                    <span class="quote-author">${character ? character.name : '角色'}：</span>${escapeHtml(anniversary.characterQuote)}
                </div>
            ` : '';

            pinnedCard.innerHTML = `
                ${backgroundStyle}
                <div class="pinned-card-content">
                    <div class="pinned-card-header">
                        ${avatarsHtml}
                        <div class="pinned-card-type ${typeClass}">${typeText}</div>
                    </div>
                    <div class="pinned-card-main">
                        <div class="pinned-card-title">${escapeHtml(anniversary.name)}</div>
                        <div class="pinned-card-countdown">${countdownText}</div>
                        <div class="pinned-card-countdown-label">${countdownLabel}</div>
                        <div class="pinned-card-date">${countType === 'countup' ? '起始日' : '目标日'} ${formatDate(anniversary.date)}</div>
                    </div>
                    <div class="pinned-card-footer">
                        ${userQuoteHtml}
                        ${characterQuoteHtml}
                        <div class="pinned-card-actions">
                            <button class="pinned-card-unpin-btn" onclick="event.stopPropagation(); unpinAnniversary('${anniversary.id}')" title="取消置顶">
                                <i class="fas fa-thumbtack"></i>
                            </button>
                        </div>
                    </div>
                </div>
            `;

            // 添加data属性用于长按删除
            pinnedCard.dataset.anniversaryId = anniversary.id;

            // 添加点击事件
            pinnedCard.onclick = function(e) {
                if (!e.target.closest('.pinned-card-actions')) {
                    showAnniversaryForm(anniversary.id);
                }
            };
        }



        // 显示新短信表单 - 改为和chatapp一样的流程
        function showNewMessageForm() {
            // 重置选择状态
            window.selectedPersonaForSMS = null;
            window.selectedCharacterForSMS = null;

            // 显示身份选择模态框
            showSMSPersonaSelector();
        }

        // 显示短信身份选择模态框
        function showSMSPersonaSelector() {
            renderSMSPersonaSelector();
            document.getElementById('sms-persona-selector-modal').style.display = 'flex';
        }

        // 隐藏短信身份选择模态框
        function hideSMSPersonaSelector(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('sms-persona-selector-modal').style.display = 'none';
        }

        // 显示短信角色选择模态框
        function showSMSCharacterSelector() {
            renderSMSCharacterSelector();
            document.getElementById('sms-character-selector-modal').style.display = 'flex';
        }

        // 隐藏短信角色选择模态框
        function hideSMSCharacterSelector(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('sms-character-selector-modal').style.display = 'none';
        }

        // 渲染短信身份选择器
        function renderSMSPersonaSelector() {
            const container = document.getElementById('sms-persona-selector-body');
            if (!container) return;

            // 只显示身份面具，不包含默认身份
            if (!personas || personas.length === 0) {
                container.innerHTML = '<div class="sms-empty-state">暂无身份面具</div>';
                return;
            }

            const personaHTML = personas.map(persona => `
                <div class="sms-persona-item" onclick="selectSMSPersona('${persona.id}')">
                    <div class="sms-item-avatar">
                        ${persona.avatarUrl ?
                            `<img src="${persona.avatarUrl}" alt="${persona.name}">` :
                            `<i class="fas fa-user"></i>`
                        }
                    </div>
                    <div class="sms-item-info">
                        <div class="sms-item-name">${persona.name}</div>
                        <div class="sms-item-desc">${persona.description ? persona.description.substring(0, 50) + '...' : '身份面具'}</div>
                    </div>
                </div>
            `).join('');

            container.innerHTML = personaHTML;
        }

        // 渲染短信角色选择器
        function renderSMSCharacterSelector() {
            const container = document.getElementById('sms-character-selector-body');
            if (!container) return;

            if (!characters || characters.length === 0) {
                container.innerHTML = '<div class="sms-empty-state">暂无角色</div>';
                return;
            }

            container.innerHTML = characters.map(character => `
                <div class="sms-character-item" onclick="selectSMSCharacter('${character.id}')">
                    <div class="sms-item-avatar">
                        ${character.avatarUrl ?
                            `<img src="${character.avatarUrl}" alt="${character.name}">` :
                            `<i class="fas fa-user"></i>`
                        }
                    </div>
                    <div class="sms-item-info">
                        <div class="sms-item-name">${character.name}</div>
                        <div class="sms-item-desc">${character.bio ? character.bio.substring(0, 50) + '...' : '暂无人设描述'}</div>
                    </div>
                </div>
            `).join('');
        }

        // 选择短信身份
        function selectSMSPersona(personaId) {
            const persona = personas.find(p => p.id === personaId);
            if (!persona) {
                showToast('身份面具不存在', 'error');
                return;
            }

            window.selectedPersonaForSMS = persona;

            // 隐藏身份选择器，显示角色选择器
            hideSMSPersonaSelector();
            showSMSCharacterSelector();
        }

        // 选择短信角色
        function selectSMSCharacter(characterId) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;

            window.selectedCharacterForSMS = character;

            // 隐藏角色选择器
            hideSMSCharacterSelector();

            // 创建短信聊天
            createSMSChatWithPersona(character, window.selectedPersonaForSMS);
        }

        // 创建短信聊天（带身份）
        async function createSMSChatWithPersona(character, persona) {
            try {
                // 检查是否选择了身份面具
                if (!persona) {
                    showToast('请先选择身份面具', 'error');
                    return;
                }

                // 🔥【修复】检查该角色是否已存在短信对话（使用独立的smsContacts）
                if (smsContacts.includes(character.id)) {
                    // 角色已存在短信对话，直接进入短信聊天
                    startSMSChat(character);
                    showToast(`已进入与 ${character.name} 的短信聊天`, 'success');
                    return;
                }

                // 保存身份设置到聊天设置中（短信应用也使用相同的设置系统）
                const chatSettingsKey = character.id;
                if (!chatSettings[chatSettingsKey]) {
                    chatSettings[chatSettingsKey] = {};
                }
                chatSettings[chatSettingsKey].selectedIdentityId = persona.id;

                // 保存到数据库
                await saveChatSettings(character.id, chatSettings[chatSettingsKey]);

                console.log('短信聊天使用身份面具:', persona.name);

                // 🔥【修复】添加到短信应用的独立联系人列表
                if (!smsContacts.includes(character.id)) {
                    smsContacts.push(character.id);
                    await saveSMSContacts();
                }

                // 🔥【修复】初始化该角色的短信消息记录
                if (!smsMessages[character.id]) {
                    smsMessages[character.id] = [];
                }

                // 刷新短信消息列表
                renderSMSMessageList();

                // 进入短信聊天界面
                startSMSChat(character);

                showToast(`已创建与 ${character.name} 的短信聊天（身份：${persona.name}）`, 'success');

            } catch (error) {
                console.error('创建短信聊天失败:', error);
                showToast('创建短信聊天失败', 'error');
            }
        }

        // 开始短信聊天
        function startSMSChat(character) {
            // 设置当前短信聊天角色
            window.currentSMSCharacter = character;

            // 更新短信聊天界面信息
            updateSMSChatHeader(character);

            // 渲染短信消息
            renderSMSMessages(character.id);

            // 显示短信聊天界面
            document.getElementById('messages-screen').style.display = 'none';
            document.getElementById('sms-chat-screen').style.display = 'block';

            // 初始化输入框
            initSMSInput();
        }

        // 更新短信聊天头部信息
        function updateSMSChatHeader(character) {
            const nameEl = document.getElementById('sms-chat-name');
            const avatarEl = document.getElementById('sms-chat-avatar');

            // 设置角色名称
            nameEl.textContent = character.name;

            // 设置角色头像
            if (character.avatarUrl) {
                avatarEl.style.backgroundImage = `url(${character.avatarUrl})`;
                avatarEl.innerHTML = ''; // 清空图标
            } else {
                avatarEl.style.backgroundImage = '';
                avatarEl.innerHTML = '<i class="fas fa-user"></i>'; // 显示默认图标
            }
        }



        // 显示短信正在输入指示器
        function showSMSTypingIndicator() {
            const container = document.getElementById('sms-messages-container');
            if (!container) return;

            // 移除已存在的指示器
            hideSMSTypingIndicator();

            // 创建正在输入指示器
            const typingIndicator = document.createElement('div');
            typingIndicator.className = 'sms-typing-indicator';
            typingIndicator.id = 'sms-typing-indicator';
            typingIndicator.innerHTML = `
                <div class="sms-typing-bubble">
                    <div class="sms-typing-dots">
                        <div class="sms-typing-dot"></div>
                        <div class="sms-typing-dot"></div>
                        <div class="sms-typing-dot"></div>
                    </div>
                </div>
            `;

            // 添加到消息容器
            container.appendChild(typingIndicator);

            // 滚动到底部
            setTimeout(() => {
                container.scrollTop = container.scrollHeight;
            }, 100);
        }

        // 隐藏短信正在输入指示器
        function hideSMSTypingIndicator() {
            const indicator = document.getElementById('sms-typing-indicator');
            if (indicator) {
                indicator.remove();
            }
        }

        // 🔥【已移除】旧的长按处理函数，现在使用新的事件监听器系统

        // 🔥【新增】进入短信多选模式
        function enterSMSMultiSelectMode(messageId) {
            console.log('触发短信长按多选模式，消息ID:', messageId);
            isSMSMultiSelectMode = true;
            selectedSMSMessages = new Set([messageId]); // 将触发长按的消息添加到选中列表

            // 切换头部按钮显示
            const normalActions = document.getElementById('sms-chat-normal-actions');
            const multiselectActions = document.getElementById('sms-chat-multiselect-actions');
            if (normalActions) normalActions.style.display = 'none';
            if (multiselectActions) multiselectActions.style.display = 'flex';

            // 重新渲染消息列表以显示选中状态
            const characterId = window.currentSMSCharacter?.id;
            if (characterId) {
                renderSMSMessages(characterId);
            }


        }

        // 🔥【新增】退出短信多选模式
        function exitSMSMultiSelectMode() {
            isSMSMultiSelectMode = false;
            selectedSMSMessages.clear();

            // 切换头部按钮显示
            const normalActions = document.getElementById('sms-chat-normal-actions');
            const multiselectActions = document.getElementById('sms-chat-multiselect-actions');
            if (normalActions) normalActions.style.display = 'flex';
            if (multiselectActions) multiselectActions.style.display = 'none';

            // 重新渲染消息列表恢复正常状态
            const characterId = window.currentSMSCharacter?.id;
            if (characterId) {
                renderSMSMessages(characterId);
            }
        }



        // 🔥【新增】切换短信消息选择状态
        function toggleSMSMessageSelection(messageId) {
            if (selectedSMSMessages.has(messageId)) {
                selectedSMSMessages.delete(messageId);
            } else {
                selectedSMSMessages.add(messageId);
            }

            // 重新渲染消息列表以更新选择状态
            const characterId = window.currentSMSCharacter?.id;
            if (characterId) {
                renderSMSMessages(characterId);
            }

            // 如果没有选中的消息，退出多选模式
            if (selectedSMSMessages.size === 0) {
                exitSMSMultiSelectMode();
            }
        }

        // 🔥【新增】删除选中的短信消息
        async function deleteSelectedSMSMessages() {
            if (selectedSMSMessages.size === 0) {
                showToast('请先选择要删除的消息', 'error');
                return;
            }

            const count = selectedSMSMessages.size;
            const confirmText = `确定要删除选中的 ${count} 条短信吗？这将同时删除相关的时间线记忆。`;

            if (confirm(confirmText)) {
                try {
                    const characterId = window.currentSMSCharacter?.id;
                    if (!characterId) return;

                    // 批量删除选中的消息
                    for (const messageId of selectedSMSMessages) {
                        // 🔥【修复】先获取要删除的消息信息，用于删除相关时间线记录
                        let messageToDelete = null;
                        if (smsMessages[characterId]) {
                            const messageIndex = smsMessages[characterId].findIndex(msg => msg.id === messageId);
                            if (messageIndex > -1) {
                                messageToDelete = smsMessages[characterId][messageIndex];
                            }
                        }

                        // 🔥【新增】删除相关的时间线记录
                        if (messageToDelete) {
                            try {
                                await deleteSMSRelatedTimelineEvents(messageToDelete, characterId);
                                console.log('✅ 已清理短信相关的时间线记录');
                            } catch (error) {
                                console.error('删除短信时间线记录失败:', error);
                            }
                        }

                        // 从内存中删除消息
                        if (smsMessages[characterId]) {
                            const messageIndex = smsMessages[characterId].findIndex(msg => msg.id === messageId);
                            if (messageIndex > -1) {
                                smsMessages[characterId].splice(messageIndex, 1);
                            }
                        }

                        // 🔥【重要】从数据库中删除消息，不触发强制同步
                        await db.smsMessages.where('id').equals(messageId).delete();
                    }

                    // 退出多选模式
                    exitSMSMultiSelectMode();

                    // 重新渲染消息列表
                    renderSMSMessages(characterId);

                    // 刷新短信消息列表（更新最后一条消息预览）
                    renderSMSMessageList();

                    showToast(`✅ 已删除 ${count} 条短信消息`, 'success');

                } catch (error) {
                    console.error('批量删除短信消息失败:', error);
                    showToast('删除消息失败', 'error');
                }
            }
        }

        // 删除短信消息（保留原有的单条删除功能，但不再使用）
        async function deleteSMSMessage(messageId, characterId) {
            try {

                // 确认删除
                if (!confirm('确定要删除这条短信吗？这将同时删除相关的时间线记忆。')) {
                    return;
                }

                // 🔥【修复】先获取要删除的消息信息，用于删除相关时间线记录
                let messageToDelete = null;
                if (smsMessages[characterId]) {
                    const messageIndex = smsMessages[characterId].findIndex(msg => msg.id === messageId);
                    if (messageIndex > -1) {
                        messageToDelete = smsMessages[characterId][messageIndex];
                    }
                }

                // 🔥【新增】删除相关的时间线记录
                if (messageToDelete) {
                    try {
                        await deleteSMSRelatedTimelineEvents(messageToDelete, characterId);
                        console.log('✅ 已清理短信相关的时间线记录');
                    } catch (error) {
                        console.error('删除短信时间线记录失败:', error);
                    }
                }

                // 从内存中删除消息
                if (smsMessages[characterId]) {
                    const messageIndex = smsMessages[characterId].findIndex(msg => msg.id === messageId);
                    if (messageIndex > -1) {
                        smsMessages[characterId].splice(messageIndex, 1);
                    }
                }

                // 🔥【重要】从数据库中删除消息，不触发强制同步
                await db.smsMessages.where('id').equals(messageId).delete();

                // 重新渲染消息列表
                renderSMSMessages(characterId);

                // 刷新短信消息列表（更新最后一条消息预览）
                renderSMSMessageList();

                console.log(`✅ 已删除短信消息: ${messageId}`);

            } catch (error) {
                console.error('删除短信消息失败:', error);
                showToast('删除消息失败', 'error');
            }
        }

        // 渲染短信消息
        function renderSMSMessages(characterId) {
            const container = document.getElementById('sms-messages-container');
            if (!container) return;

            // 获取气泡颜色设置
            const bubbleColor = getSMSChatSetting('bubbleColor', 'blue');

            // 移除现有的颜色类
            container.classList.remove('green-bubble');

            // 添加新的颜色类
            if (bubbleColor === 'green') {
                container.classList.add('green-bubble');
            }

            // 🔥【修复】获取该角色的短信消息记录
            const messages = smsMessages[characterId] || [];

            if (messages.length === 0) {
                // 如果没有消息，显示空状态
                container.innerHTML = `
                    <div class="sms-empty-chat">
                        <p style="text-align: center; color: #999; font-size: 14px; margin-top: 50px;">
                            还没有消息，开始聊天吧！
                        </p>
                    </div>
                `;
                return;
            }

            // 渲染消息列表 - iPhone风格的时间显示
            let messagesHTML = '';
            let lastTimestamp = null;

            messages.forEach((message, index) => {
                const messageClass = message.isUser ? 'user-message' : 'character-message';
                const currentTime = new Date(message.timestamp);

                // 🔥【修复】改进时间戳显示逻辑，支持跨天显示 - 苹果短信风格
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const yesterday = new Date(today.getTime() - 24 * 60 * 60 * 1000);
                const dayBeforeYesterday = new Date(today.getTime() - 2 * 24 * 60 * 60 * 1000);
                const messageDate = new Date(currentTime.getFullYear(), currentTime.getMonth(), currentTime.getDate());

                // 计算时间差（天数）
                const diffTime = today.getTime() - messageDate.getTime();
                const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

                let timestamp = '';
                const timeString = currentTime.toLocaleTimeString('zh-CN', {
                    hour: '2-digit',
                    minute: '2-digit'
                });

                if (messageDate.getTime() === today.getTime()) {
                    // 今天的消息只显示时间
                    timestamp = timeString;
                } else if (messageDate.getTime() === yesterday.getTime()) {
                    // 昨天的消息显示"昨天 xx:xx"
                    timestamp = `昨天 ${timeString}`;
                } else if (messageDate.getTime() === dayBeforeYesterday.getTime()) {
                    // 前天的消息显示"前天 xx:xx"
                    timestamp = `前天 ${timeString}`;
                } else if (diffDays < 7) {
                    // 本周内的消息显示"星期x xx:xx"
                    const weekdays = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
                    const weekday = weekdays[currentTime.getDay()];
                    timestamp = `${weekday} ${timeString}`;
                } else {
                    // 更早的消息显示"月/日 xx:xx"
                    const dateString = currentTime.toLocaleDateString('zh-CN', {
                        month: 'numeric',
                        day: 'numeric'
                    });
                    timestamp = `${dateString} ${timeString}`;
                }

                // 检查是否需要显示时间戳（每5分钟或第一条消息）
                const shouldShowTime = !lastTimestamp ||
                    (currentTime - lastTimestamp) > 5 * 60 * 1000 ||
                    index === 0;

                if (shouldShowTime) {
                    messagesHTML += `<div class="sms-timestamp">${timestamp}</div>`;
                    lastTimestamp = currentTime;
                }

                // 🔥【修复】处理图片消息和文本消息，支持多模态格式
                let messageContent = '';

                // 🔥【关键修复】从多模态格式中提取文本内容
                let textContent = '';
                if (Array.isArray(message.content)) {
                    // 新的多模态格式
                    const textPart = message.content.find(part => part.type === 'text');
                    textContent = textPart ? textPart.text : '';
                } else if (message.text) {
                    // 兼容旧格式
                    textContent = message.text;
                }

                if (message.isImage && message.imageUrl) {
                    // 图片消息 - 不使用气泡包裹，直接显示图片
                    const imageClickHandler = isSMSMultiSelectMode ? '' : `onclick="showImagePreview('${message.imageUrl}', '${message.fileName || '图片'}')"`;
                    messageContent = `
                        <div class="sms-image-container">
                            <img src="${message.imageUrl}" alt="${message.fileName || '图片'}" class="sms-image" ${imageClickHandler}>
                        </div>
                    `;
                } else {
                    // 文本消息 - 使用气泡包裹
                    const escapedText = textContent
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;');

                    messageContent = `
                        <div class="sms-message-bubble">
                            ${escapedText}
                        </div>
                    `;
                }

                // 🔥【新设计】简化消息结构 - 选中状态通过CSS伪元素显示勾选标记
                messagesHTML += `
                    <div class="sms-message ${messageClass} ${selectedSMSMessages.has(message.id) ? 'selected' : ''}" data-message-id="${message.id}" data-character-id="${characterId}">
                        ${messageContent}
                    </div>
                `;
            });

            container.innerHTML = messagesHTML;

            // 🔥【新增】为消息添加事件监听器
            addSMSMessageEventListeners(characterId);

            // 滚动到底部
            setTimeout(() => {
                container.scrollTop = container.scrollHeight;
            }, 100);
        }

        // 🔥【修复】为单个短信消息添加事件监听器
        function addSingleSMSMessageEventListener(messageElement, characterId) {
            const messageId = messageElement.dataset.messageId;
            if (!messageId) return;

            if (isSMSMultiSelectMode) {
                // 多选模式：点击切换选择状态
                messageElement.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleSMSMessageSelection(messageId);
                });
            } else {
                // 普通模式：长按进入多选模式
                let pressTimer = null;
                let startPos = { x: 0, y: 0 };

                // 触摸开始
                messageElement.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    startPos.x = touch.clientX;
                    startPos.y = touch.clientY;

                    pressTimer = setTimeout(() => {
                        if (navigator.vibrate) {
                            navigator.vibrate(50);
                        }
                        enterSMSMultiSelectMode(messageId);
                    }, 800);
                });

                // 触摸结束
                messageElement.addEventListener('touchend', (e) => {
                    if (pressTimer) {
                        clearTimeout(pressTimer);
                        pressTimer = null;
                    }
                });

                // 触摸移动
                messageElement.addEventListener('touchmove', (e) => {
                    if (pressTimer) {
                        const touch = e.touches[0];
                        const moveX = Math.abs(touch.clientX - startPos.x);
                        const moveY = Math.abs(touch.clientY - startPos.y);

                        if (moveX > 10 || moveY > 10) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                        }
                    }
                });

                // 桌面端鼠标事件
                messageElement.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // 左键
                        pressTimer = setTimeout(() => {
                            enterSMSMultiSelectMode(messageId);
                        }, 800);
                    }
                });

                messageElement.addEventListener('mouseup', (e) => {
                    if (pressTimer) {
                        clearTimeout(pressTimer);
                        pressTimer = null;
                    }
                });

                messageElement.addEventListener('mouseleave', (e) => {
                    if (pressTimer) {
                        clearTimeout(pressTimer);
                        pressTimer = null;
                    }
                });
            }
        }

        // 🔥【保留】为所有短信消息添加事件监听器（用于完整重新渲染时）
        function addSMSMessageEventListeners(characterId) {
            const messages = document.querySelectorAll('.sms-message');
            messages.forEach(messageElement => {
                const messageId = messageElement.dataset.messageId;
                if (!messageId) return;

                // 🔥【修复】不再使用replaceWith，直接为现有元素添加监听器
                addSingleSMSMessageEventListener(messageElement, characterId);
            });
        }

        // 🔥【修复】添加单个短信消息并应用动画效果
        function addSMSMessageWithAnimation(message, characterId) {
            const container = document.getElementById('sms-messages-container');
            if (!container || !window.currentSMSCharacter || characterId !== window.currentSMSCharacter.id) return;

            // 🔥【新增】播放接收消息音效（仅对AI消息）
            if (!message.isUser) {
                SoundManager.play(SoundManager.TYPES.MESSAGE_RECEIVED, characterId);
            }

            // 获取气泡颜色设置
            const bubbleColor = getSMSChatSetting('bubbleColor', 'blue');

            // 移除现有的颜色类
            container.classList.remove('green-bubble');

            // 添加新的颜色类
            if (bubbleColor === 'green') {
                container.classList.add('green-bubble');
            }

            const messageClass = message.isUser ? 'user-message' : 'character-message';
            const currentTime = new Date(message.timestamp);
            const timestamp = currentTime.toLocaleTimeString('zh-CN', {
                hour: '2-digit',
                minute: '2-digit'
            });

            // 检查是否需要显示时间戳
            const existingMessages = container.querySelectorAll('.sms-message');
            let shouldShowTime = false;

            if (existingMessages.length === 0) {
                shouldShowTime = true;
            } else {
                const lastMessage = existingMessages[existingMessages.length - 1];
                const lastTimestamp = lastMessage.dataset.timestamp;
                if (!lastTimestamp || (currentTime - new Date(parseInt(lastTimestamp))) > 5 * 60 * 1000) {
                    shouldShowTime = true;
                }
            }

            // 创建时间戳元素（如果需要）
            if (shouldShowTime) {
                const timestampElement = document.createElement('div');
                timestampElement.className = 'sms-timestamp';
                timestampElement.textContent = timestamp;
                container.appendChild(timestampElement);
            }

            // 创建消息元素
            const messageElement = document.createElement('div');
            messageElement.className = `sms-message ${messageClass}`;
            messageElement.dataset.messageId = message.id;
            messageElement.dataset.characterId = characterId;
            messageElement.dataset.timestamp = message.timestamp;

            // 🔥【修复】处理图片消息和文本消息，支持多模态格式
            let messageContent = '';

            // 🔥【关键修复】从多模态格式中提取文本内容
            let textContent = '';
            if (Array.isArray(message.content)) {
                // 新的多模态格式
                const textPart = message.content.find(part => part.type === 'text');
                textContent = textPart ? textPart.text : '';
            } else if (message.text) {
                // 兼容旧格式
                textContent = message.text;
            }

            if (message.isImage && message.imageUrl) {
                // 图片消息 - 不使用气泡包裹，直接显示图片
                const imageClickHandler = isSMSMultiSelectMode ? '' : `onclick="showImagePreview('${message.imageUrl}', '${message.fileName || '图片'}')"`;
                messageContent = `
                    <div class="sms-image-container">
                        <img src="${message.imageUrl}" alt="${message.fileName || '图片'}" class="sms-image" ${imageClickHandler}>
                    </div>
                `;
            } else {
                // 文本消息 - 使用气泡包裹
                const escapedText = textContent
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');

                messageContent = `
                    <div class="sms-message-bubble">
                        ${escapedText}
                    </div>
                `;
            }

            // 🔥【新设计】简化消息内容，选中状态通过CSS伪元素显示
            messageElement.innerHTML = messageContent;

            // 🔥【新增】添加选中样式类
            if (selectedSMSMessages.has(message.id)) {
                messageElement.classList.add('selected');
            } else {
                messageElement.classList.remove('selected');
            }

            // 设置初始动画状态
            messageElement.style.opacity = '0';
            messageElement.style.transform = 'translateY(20px)';

            // 添加到容器
            container.appendChild(messageElement);

            // 🔥【修复】只为新添加的消息添加事件监听器，而不是重新绑定所有消息
            addSingleSMSMessageEventListener(messageElement, characterId);

            // 触发滑入动画
            requestAnimationFrame(() => {
                messageElement.style.opacity = '1';
                messageElement.style.transform = 'translateY(0)';
                messageElement.style.transition = 'all 0.3s ease-out';
            });

            // 滚动到底部
            setTimeout(() => {
                container.scrollTop = container.scrollHeight;
            }, 100);
        }

        // 隐藏短信聊天界面
        function hideSMSChat() {
            // 🔥【新增】退出多选模式
            if (isSMSMultiSelectMode) {
                exitSMSMultiSelectMode();
            }

            document.getElementById('sms-chat-screen').style.display = 'none';
            document.getElementById('messages-screen').style.display = 'block';
            window.currentSMSCharacter = null;
        }

        // 初始化短信输入框
        function initSMSInput() {
            const input = document.getElementById('sms-message-input');
            if (!input) return;

            input.addEventListener('input', function() {
                const sendBtn = document.getElementById('sms-send-button');

                if (this.value.trim()) {
                    sendBtn.style.display = 'flex';
                } else {
                    sendBtn.style.display = 'none';
                }
            });
        }

        // 🔥【新增】打开短信图片选择器
        function openSMSImagePicker() {
            const imageInput = document.getElementById('sms-image-input');
            if (imageInput) {
                imageInput.click();
            }
        }

        // 🔥【新增】处理短信图片选择
        function handleSMSImageSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            // 检查文件类型
            if (!file.type.startsWith('image/')) {
                showToast('请选择图片文件', 'warning');
                return;
            }

            // 检查文件大小（限制为5MB）
            const maxSize = 5 * 1024 * 1024; // 5MB
            if (file.size > maxSize) {
                showToast('图片文件过大，请选择小于5MB的图片', 'warning');
                return;
            }

            // 检查是否有当前聊天角色
            if (!window.currentSMSCharacter) {
                showToast('请先选择一个角色', 'error');
                return;
            }

            // 读取图片并发送
            const reader = new FileReader();
            reader.onload = function(e) {
                sendSMSImage(e.target.result, file.name);
            };
            reader.readAsDataURL(file);

            // 清空文件输入，允许重复选择同一文件
            event.target.value = '';
        }

        // 🔥【新增】发送短信图片
        async function sendSMSImage(imageDataUrl, fileName) {
            if (!window.currentSMSCharacter) {
                showToast('聊天角色不存在', 'error');
                return;
            }

            const characterId = window.currentSMSCharacter.id;

            try {
                // 🔥【关键修复】像chatapp一样读取输入框内容
                const smsInput = document.getElementById('sms-message-input');
                const textContent = smsInput ? smsInput.value.trim() : '';

                console.log('🔍 [sendSMSImage] 文本内容:', textContent);
                console.log('🔍 [sendSMSImage] 图片URL长度:', imageDataUrl ? imageDataUrl.length : 0);

                // 🔥【关键修复】创建与chatapp完全一致的多模态消息对象
                const messageContent = [
                    { type: 'text', text: textContent }
                ];

                if (imageDataUrl) {
                    messageContent.push({
                        type: 'image_url',
                        image_url: { url: imageDataUrl }
                    });
                }

                console.log('🔍 [sendSMSImage] 创建的消息内容:', messageContent);
                console.log('🔍 [sendSMSImage] 消息内容数组长度:', messageContent.length);

                const imageMessage = {
                    id: `sms-img-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    content: messageContent, // 🔥【关键修复】使用与chatapp相同的多模态数组格式
                    text: textContent, // 保留以便短信界面显示
                    timestamp: Date.now(),
                    isUser: true,
                    isImage: true, // 保留标记以便短信界面识别
                    imageUrl: imageDataUrl, // 保留以便短信界面显示
                    fileName: fileName
                };

                // 🔥【关键修复】清空输入框，像chatapp一样
                if (smsInput) {
                    smsInput.value = '';
                    // 触发输入事件，更新发送按钮状态
                    smsInput.dispatchEvent(new Event('input'));
                }

                // 🔥【添加到短信消息记录】
                if (!smsMessages[characterId]) {
                    smsMessages[characterId] = [];
                }
                smsMessages[characterId].push(imageMessage);

                // 🔥【保存消息到数据库】
                await saveSingleSMSMessage(characterId, imageMessage);

                // 🔥【记录用户发送图片到跨应用时间线】
                try {
                    await recordCrossAppEvent(
                        characterId,
                        'sms',
                        'user_image',
                        {
                            id: characterId,
                            type: 'sms_image',
                            fileName: fileName,
                            fileSize: imageDataUrl.length,
                            chatId: characterId,
                            sender: 'user'
                        },
                        imageMessage.id
                    );
                    console.log('📝 [短信时间线] 已记录用户发送图片事件到跨应用时间线');
                } catch (error) {
                    console.error('❌ [短信时间线] 记录用户发送图片事件失败:', error);
                }

                // 🔥【使用动画效果添加图片消息到界面】
                addSMSMessageWithAnimation(imageMessage, characterId);

                // 刷新短信消息列表（更新最后一条消息预览）
                renderSMSMessageList();

                console.log('🔥 [短信图片] 用户图片消息发送成功');

            } catch (error) {
                console.error('发送短信图片失败:', error);
                showToast('发送图片失败', 'error');
            }
        }

        // 🔥【新增】显示短信图片预览
        function showImagePreview(imageUrl, fileName) {
            // 复用现有的图片预览功能
            showImage(imageUrl);
        }

        // 处理短信输入框按键事件
        function handleSMSInputKeydown(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                sendSMSMessage();
            }
        }

        // 发送短信消息
        async function sendSMSMessage() {
            const input = document.getElementById('sms-message-input');
            const messageText = input.value.trim();

            if (!messageText) {
                showToast('请输入消息内容', 'warning');
                return;
            }

            if (!window.currentSMSCharacter) {
                showToast('聊天角色不存在', 'error');
                return;
            }

            // 🔥【新增】播放发送消息音效
            SoundManager.play(SoundManager.TYPES.MESSAGE_SENT, window.currentSMSCharacter?.id);

            const characterId = window.currentSMSCharacter.id;

            // 🔥【修复】创建与chatapp一致的多模态用户消息对象
            const userMessage = {
                id: `sms-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                content: [
                    { type: 'text', text: messageText }
                ], // 🔥【关键修复】使用与chatapp相同的多模态数组格式
                text: messageText, // 保留以便短信界面显示
                timestamp: Date.now(),
                isUser: true
            };

            // 🔥【修复】添加到短信消息记录
            if (!smsMessages[characterId]) {
                smsMessages[characterId] = [];
            }
            smsMessages[characterId].push(userMessage);

            // 🔥【高效保存】只保存新增的单条消息
            await saveSingleSMSMessage(characterId, userMessage);

            // 🔥【新增】记录用户发送短信到跨应用时间线
            try {
                await recordCrossAppEvent(
                    characterId,
                    'sms',
                    'user_message',
                    {
                        id: characterId, // 🔥【修复】添加上下文ID，确保记忆共享正常工作
                        type: 'sms_message',
                        content: messageText.substring(0, 100), // 记录前100字符
                        messageLength: messageText.length,
                        chatId: characterId, // 短信的聊天ID就是角色ID
                        sender: 'user'
                    },
                    userMessage.id
                );
                console.log('📝 [短信时间线] 已记录用户发送短信事件到跨应用时间线');
            } catch (error) {
                console.error('❌ [短信时间线] 记录用户发送短信事件失败:', error);
            }

            // 清空输入框
            input.value = '';
            document.getElementById('sms-send-button').style.display = 'none';

            // 🔥【新增】使用动画效果添加用户消息到界面
            addSMSMessageWithAnimation(userMessage, characterId);

            // 刷新短信消息列表（更新最后一条消息预览）
            renderSMSMessageList();
        }

        // 触发短信回复
        async function triggerSMSReply() {
            if (!window.currentSMSCharacter) {
                showToast('请先选择一个角色', 'error');
                return;
            }

            const characterId = window.currentSMSCharacter.id;
            const smsMessagesList = smsMessages[characterId] || [];

            if (smsMessagesList.length === 0) {
                showToast('请先发送消息', 'info');
                return;
            }

            // 检查最后一条消息是否是用户发送的
            const lastMessage = smsMessagesList[smsMessagesList.length - 1];
            if (!lastMessage || !lastMessage.isUser) {
                showToast('请先发送消息', 'info');
                return;
            }

            // 🔥【关键修复】收集用户在这一轮发送的所有消息，保持多模态格式
            const userMessages = [];
            for (let i = smsMessagesList.length - 1; i >= 0; i--) {
                const msg = smsMessagesList[i];
                if (msg.isUser) {
                    // 🔥【关键修复】传递完整的多模态消息对象，而不是只传递文本
                    userMessages.unshift(msg); // 添加到开头，保持时间顺序
                } else {
                    break; // 遇到AI消息就停止，说明这轮用户消息结束了
                }
            }

            try {
                // 🔥【修改】不显示toast，改用正在输入指示器
                // showToast('角色正在回复中...', 'info');

                // 🔥【修复】传递用户这一轮的所有消息
                await generateSMSReply(window.currentSMSCharacter, userMessages);

            } catch (error) {
                console.error('短信AI回复失败:', error);
                showToast('AI回复失败: ' + error.message, 'error');
            }
        }



        // 🔥【新增】短信专用AI提示词构建函数，集成全局记忆系统
        async function buildSMSPrompt(character, userMessages) {
            console.log('🔥 [短信提示词] 开始构建，角色:', character.name);

            // 🔥【核心】获取短信聊天设置，包括历史消息回合数
            const historyRounds = getSMSChatSetting('historyRounds', 50);
            console.log('🔥 [短信提示词] 历史消息回合数:', historyRounds);

            // 🔥【核心】获取短信历史消息
            const characterId = character.id;
            const smsMessagesList = smsMessages[characterId] || [];
            const recentSMSMessages = smsMessagesList.slice(-historyRounds);
            console.log('🔥 [短信提示词] 短信历史消息数量:', recentSMSMessages.length);

            // 🔥【核心】获取用户在短信聊天中设置的身份面具
            const chatSettingsKey = character.id;
            const smsChatSettings = chatSettings[chatSettingsKey] || {};
            const selectedPersona = smsChatSettings.selectedIdentityId ?
                personas.find(p => p.id === smsChatSettings.selectedIdentityId) : null;

            console.log('🔥 [短信提示词] 用户身份面具:', selectedPersona?.name || '默认身份');

            // 🔥【核心】检查角色是否被拉黑，短信app作为聊天辅助工具的特殊逻辑
            const isUserBlocked = isBlocked('user', character.id);
            const isCharacterBlocked = isBlocked(character.id, 'user');

            // 🔥【核心】获取时间信息（与ChatApp保持一致）
            const now = new Date();
            const currentTime = now.toLocaleString('zh-CN', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                weekday: 'long'
            });

            // 获取季节和时间段信息
            const month = now.getMonth() + 1;
            let season = '';
            if (month >= 3 && month <= 5) season = '春季';
            else if (month >= 6 && month <= 8) season = '夏季';
            else if (month >= 9 && month <= 11) season = '秋季';
            else season = '冬季';

            const hour = now.getHours();
            let timeOfDay = '';
            if (hour >= 5 && hour < 8) timeOfDay = '清晨';
            else if (hour >= 8 && hour < 11) timeOfDay = '上午';
            else if (hour >= 11 && hour < 14) timeOfDay = '中午';
            else if (hour >= 14 && hour < 17) timeOfDay = '下午';
            else if (hour >= 17 && hour < 19) timeOfDay = '傍晚';
            else if (hour >= 19 && hour < 22) timeOfDay = '晚上';
            else if (hour >= 22 || hour < 2) timeOfDay = '深夜';
            else timeOfDay = '凌晨';

            const timeInfo = `- **当前时间:** ${currentTime}\n- **季节:** ${season}，${timeOfDay}时分`;

            // 🔥【核心】构建短信专用的角色提示词
            let smsPrompt = `# **短信聊天模式 - ${character.name}**

## **输出格式要求**
你的回复必须是JSON数组格式，但短信通常比较简洁：
- **单条短信:** \`["你好！今天过得怎么样？"]\`
- **多条短信:** \`["你好！", "今天过得怎么样？", "有什么有趣的事吗？"]\`
- **只能包含纯文本字符串:** 数组中只能有字符串，不能有任何对象
- **绝对禁止:** 不要输出代码块、不要有\`\`\`json标记
- **绝对禁止:** 不要使用 {"type": "reply_to"} 等对象格式

## **你的角色与任务**
你现在扮演名为"${character.name}"的角色，通过短信与用户进行对话。

## **角色设定:**
${character.bio || character.prompt || '暂无详细人设'}

## **当前情景:**
${timeInfo}

## **短信聊天特点:**
- **消息简洁**: 每条短信1-2句话，可以发送1-3条
- **语气自然**: 符合短信聊天的轻松节奏
- **纯文本交流**: 只能发送普通文字消息
- **支持功能**: 可以发送文字形式的照片描述，如"[照片：我刚拍的窗外风景]"
- **不支持功能**:
  * 不支持引用回复 (reply_to)
  * 不支持表情包、语音、视频
  * 不支持转账、定位等复杂功能
  * 不支持任何对象格式的消息
- **记忆连贯**: 与ChatApp共享记忆，保持角色一致性`;

            // 🔥【核心】添加拉黑状态的特殊提示
            if (isUserBlocked) {
                smsPrompt += `\n\n## 特殊情况说明
用户在聊天应用中拉黑了你，但你现在通过短信联系用户。你可能会：
- 表达想要和解的意愿
- 解释之前的误会
- 请求用户给你一个机会
- 表现出真诚的态度
请根据你的性格和之前的互动历史来回应。`;
            } else if (isCharacterBlocked) {
                smsPrompt += `\n\n## 特殊情况说明
你在聊天应用中拉黑了用户，但用户现在通过短信联系你。你可能会：
- 保持之前的态度或有所软化
- 根据用户的消息内容决定是否回应
- 表现出符合你性格的反应
请根据你的性格和拉黑的原因来回应。`;
            }

            // 🔥【核心】添加用户身份信息
            if (selectedPersona) {
                smsPrompt += `\n\n## 对话者身份
用户在这个短信聊天中的身份是：${selectedPersona.name}
身份描述：${selectedPersona.description || '无详细描述'}
请根据用户的这个身份来进行短信对话。`;
            }

            // 🔥【核心】集成世界书系统（与ChatApp保持一致）
            const localBookIds = smsChatSettings.selectedWorldbooks || [];
            const globalBooks = window.activeGlobalWorldbooks || [];
            const allBookIds = [...new Set([...globalBooks, ...localBookIds])];

            if (allBookIds.length > 0) {
                smsPrompt += `\n\n## 背景知识/世界观
以下是相关的设定信息，请在短信对话中自然地运用：\n`;
                allBookIds.forEach(bookId => {
                    const worldbook = worldbooks.find(w => w.id === bookId);
                    if (worldbook) {
                        smsPrompt += `\n--- ${worldbook.title} ---\n${worldbook.content}\n`;
                    }
                });
            }

            // 🔥【核心】集成动态记忆系统占位符
            if (smsChatSettings.enableDynamicMemory !== false) {
                smsPrompt += `\n\n<!-- DYNAMIC_MEMORY_PLACEHOLDER -->`;
            }

            return smsPrompt;
        }

        // 🔥【新增】短信专用API调用函数
        async function callSMSAPI(userMessage, character) {
            try {
                console.log('🔥 [短信API] 开始调用，角色:', character.name);

                // 获取短信历史消息作为上下文
                const characterId = character.id;
                const smsMessagesList = smsMessages[characterId] || [];
                const historyRounds = getSMSChatSetting('historyRounds', 50);
                const recentSMSMessages = smsMessagesList.slice(-historyRounds);

                // 构建消息历史
                let conversationHistory = '';
                if (recentSMSMessages.length > 0) {
                    conversationHistory = '\n\n## 短信对话历史\n';
                    recentSMSMessages.forEach(msg => {
                        const sender = msg.isUser ? '用户' : character.name;
                        conversationHistory += `${sender}: ${msg.text}\n`;
                    });
                }

                let fullPrompt = '';

                // 🔥【修复】判断是回复用户消息还是主动发起对话
                if (userMessage.includes('你被用户在聊天应用中拉黑了') ||
                    userMessage.includes('用户拒绝了你的好友申请') ||
                    userMessage.includes('你想主动通过短信联系用户')) {
                    // 这是主动联系的场景
                    const smsPrompt = await buildSMSPrompt(character, '');
                    fullPrompt = smsPrompt + conversationHistory + `\n\n## 主动联系场景\n${userMessage}\n\n## 回复要求\n请以${character.name}的身份发送短信消息。要求：\n- 体现短信聊天的简洁特点，通常1-3条消息\n- 保持与ChatApp中相同的角色性格和记忆连贯性\n- 可以延续之前在ChatApp中的话题或情感状态\n- 【重要】必须使用JSON数组格式回复\n- 体现"真人对话"的自然感\n- 如果需要发送多条消息，请分别放在数组中\n\n请回复JSON格式的短信内容：`;
                } else {
                    // 这是回复用户消息的场景
                    const smsPrompt = await buildSMSPrompt(character, userMessage);
                    fullPrompt = smsPrompt + conversationHistory + `\n\n## 当前用户消息\n用户: ${userMessage}\n\n## 回复要求\n请以${character.name}的身份回复这条短信。要求：\n- 体现短信聊天的简洁特点，通常1-3条消息\n- 保持与ChatApp中相同的角色性格和记忆连贯性\n- 可以延续之前在ChatApp中的话题或情感状态\n- 【重要】必须使用JSON数组格式回复\n- 体现"真人对话"的自然感\n- 如果需要发送多条消息，请分别放在数组中\n\n请回复JSON格式的短信内容：`;
                }

                // 🔥【核心】集成动态记忆系统到短信提示词
                if (fullPrompt.includes('<!-- DYNAMIC_MEMORY_PLACEHOLDER -->')) {
                    try {
                        let memoryReplacement = '';

                        // 获取核心记忆
                        const coreMemories = await db.coreMemories
                            .where('characterId')
                            .equals(character.id)
                            .toArray();

                        if (coreMemories.length > 0) {
                            const sortedCoreMemories = coreMemories.sort((a, b) => b.importance - a.importance);
                            memoryReplacement += '\n\n【核心记忆】以下是重要的记忆：\n';
                            sortedCoreMemories.forEach((memory, index) => {
                                memoryReplacement += `${index + 1}. ${memory.fact}\n`;
                            });
                        }

                        // 获取情景记忆
                        const episodicMemories = await db.episodicMemories
                            .where('characterId')
                            .equals(character.id)
                            .toArray();

                        const recentEpisodicMemories = episodicMemories
                            .sort((a, b) => b.timestamp - a.timestamp)
                            .slice(0, 5); // 短信中显示较少的记忆

                        if (recentEpisodicMemories.length > 0) {
                            memoryReplacement += '\n\n【情景记忆】以下是最近的重要经历：\n';
                            recentEpisodicMemories.forEach((memory, index) => {
                                memoryReplacement += `${index + 1}. ${memory.fact}\n`;
                            });
                        }

                        // 🔥【新增】获取动态记忆（包含评论区）
                        const recentMoments = await getVisibleMomentsForCharacter(character.id, 3); // 短信中显示较少的动态
                        if (recentMoments.length > 0) {
                            memoryReplacement += '\n\n【动态记忆】以下是最近的动态和讨论：\n';
                            recentMoments.forEach((moment, index) => {
                                const authorName = moment.authorId === 'user' ? '用户' : moment.nickname;

                                // 添加时间信息
                                let timeInfo = '';
                                if (moment.timestamp) {
                                    const now = Date.now();
                                    const timeDiff = now - moment.timestamp;
                                    const hours = Math.floor(timeDiff / (1000 * 60 * 60));
                                    const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));

                                    if (days > 0) {
                                        timeInfo = ` (${days}天前)`;
                                    } else if (hours > 0) {
                                        timeInfo = ` (${hours}小时前)`;
                                    } else {
                                        timeInfo = ' (最近)';
                                    }
                                }

                                // 包含评论区内容
                                const momentContent = `${index + 1}. ${authorName}: ${moment.text}${timeInfo}${moment.commentsText || ''}`;
                                memoryReplacement += momentContent;
                            });
                        }

                        // 获取跨应用时间线
                        const timeline = await getCrossAppTimeline(character.id, 5); // 短信中显示较少的时间线
                        if (timeline.length > 0) {
                            memoryReplacement += '\n\n【最近活动】以下是最近的跨应用活动：\n';
                            timeline.forEach((event, index) => {
                                const timeStr = new Date(event.timestamp).toLocaleTimeString('zh-CN', {hour: '2-digit', minute: '2-digit'});
                                let description = '';

                                switch (event.appType) {
                                    case 'music':
                                        description = `在音乐应用中${event.context.action === 'listen_together' ? '一起听歌' : '发表评论'}`;
                                        break;
                                    case 'game':
                                        description = `在游戏应用中${event.context.action === 'play_together' ? '一起游戏' : '互动'}`;
                                        break;
                                    case 'chat':
                                        description = event.action === 'message' ? '用户发送消息' : 'AI回复消息';
                                        break;
                                    case 'sms':
                                        if (event.action === 'user_message') {
                                            description = '用户发送短信';
                                        } else if (event.action === 'ai_reply') {
                                            description = 'AI回复短信';
                                        } else if (event.action === 'character_initiate') {
                                            description = 'AI主动发送短信';
                                        } else {
                                            description = '短信互动';
                                        }
                                        break;
                                    default:
                                        description = `在${event.appType}中进行${event.action}`;
                                }

                                memoryReplacement += `${timeStr} - ${description}\n`;
                            });
                        }

                        // 替换占位符
                        if (memoryReplacement) {
                            fullPrompt = fullPrompt.replace('<!-- DYNAMIC_MEMORY_PLACEHOLDER -->', memoryReplacement);
                        } else {
                            fullPrompt = fullPrompt.replace('<!-- DYNAMIC_MEMORY_PLACEHOLDER -->', '');
                        }

                    } catch (error) {
                        console.error('🔥 [短信API] 获取记忆数据失败:', error);
                        fullPrompt = fullPrompt.replace('<!-- DYNAMIC_MEMORY_PLACEHOLDER -->', '');
                    }
                }

                console.log('🔥 [短信API] 构建的完整提示词:', fullPrompt);

                // 🔥【修复】检测是否是Gemini API并使用相应格式
                const isGemini = apiSettings.base.includes('generativelanguage.googleapis.com');
                let response, data, aiReply;

                if (isGemini) {
                    // Gemini API 格式
                    const apiUrl = `${apiSettings.base}/models/${apiSettings.model}:generateContent?key=${apiSettings.key}`;

                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: fullPrompt }]
                            }],
                            generationConfig: {
                                temperature: 0.8
                                // 不添加maxOutputTokens，Gemini不支持这个参数
                            }
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`Gemini API请求失败: ${response.status} ${response.statusText}`);
                    }

                    data = await response.json();
                    aiReply = data.candidates?.[0]?.content?.parts?.[0]?.text;

                    if (!aiReply) {
                        console.log('🔥 [短信API] Gemini响应数据:', data);
                        throw new Error('Gemini API返回了空内容');
                    }
                } else {
                    // OpenAI 格式 - 🔥【修复】智能处理URL拼接，支持抱脸轮询
                    let apiUrl;
                    if (apiSettings.base.endsWith('/v1')) {
                        apiUrl = `${apiSettings.base}/chat/completions`;
                    } else if (apiSettings.base.includes('/v1/')) {
                        // 如果URL中已经包含/v1/路径，直接添加chat/completions
                        apiUrl = `${apiSettings.base}/chat/completions`;
                    } else {
                        apiUrl = `${apiSettings.base}/v1/chat/completions`;
                    }

                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiSettings.key}`
                        },
                        body: JSON.stringify({
                            model: apiSettings.model,
                            messages: [
                                {
                                    role: 'user',
                                    content: fullPrompt
                                }
                            ],
                            temperature: 0.8,
                            max_tokens: 200, // 短信回复不需要太长
                            stream: false
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`API请求失败: ${response.status} ${response.statusText}`);
                    }

                    data = await response.json();
                    aiReply = data.choices?.[0]?.message?.content;

                    if (!aiReply) {
                        console.log('🔥 [短信API] OpenAI响应数据:', data);
                        throw new Error('API返回了空内容');
                    }
                }

                aiReply = aiReply.trim();
                console.log('🔥 [短信API] AI原始回复:', aiReply);

                return aiReply;

            } catch (error) {
                console.error('短信API调用失败:', error);
                throw error;
            }
        }

        // 🔥【新增】短信专用AI回复生成函数
        async function generateSMSReply(character, userMessages) {
            try {
                console.log('🔥 [短信AI回复] 开始生成回复，角色:', character.name, '用户消息:', userMessages);

                // 🔥【新增】显示正在输入指示器
                showSMSTypingIndicator();

                // 🔥【关键修复】检查是否有图片消息，决定使用哪种AI调用方式
                console.log('🔍 [generateSMSReply] 收到的用户消息:', userMessages);

                let hasImageMessage = false;
                let combinedContent = [];

                // 🔥【关键修复】检查用户消息中是否包含图片
                if (Array.isArray(userMessages)) {
                    userMessages.forEach(msg => {
                        if (Array.isArray(msg.content)) {
                            // 多模态消息
                            combinedContent.push(...msg.content);
                            const hasImage = msg.content.some(item => item.type === 'image_url');
                            if (hasImage) {
                                hasImageMessage = true;
                                console.log('🔍 [generateSMSReply] 检测到图片消息');
                            }
                        } else {
                            // 兼容旧格式文本消息
                            combinedContent.push({ type: 'text', text: msg.text || msg });
                        }
                    });
                } else {
                    // 单个消息
                    if (Array.isArray(userMessages.content)) {
                        combinedContent = userMessages.content;
                        hasImageMessage = userMessages.content.some(item => item.type === 'image_url');
                    } else {
                        combinedContent = [{ type: 'text', text: userMessages.text || userMessages }];
                    }
                }

                console.log('🔍 [generateSMSReply] 合并后的内容:', combinedContent);
                console.log('🔍 [generateSMSReply] 是否包含图片:', hasImageMessage);

                let response;

                if (hasImageMessage) {
                    // 🔥【关键修复】如果有图片，需要构建包含JSON格式要求的提示词
                    console.log('🔍 [generateSMSReply] 使用多模态API调用');

                    // 🔥【关键修复】为多模态消息构建短信格式的提示词
                    const smsPrompt = await buildSMSPrompt(character, userMessages);

                    // 构建包含图片的多模态消息，但添加短信格式要求
                    const textContent = combinedContent.find(item => item.type === 'text')?.text || '';
                    const imageContent = combinedContent.find(item => item.type === 'image_url');

                    // 构建多模态消息数组，包含短信特殊格式要求
                    const multimodalMessage = [
                        {
                            type: 'text',
                            text: `${smsPrompt}\n\n## 当前用户消息\n用户发送了图片${textContent ? `并说: ${textContent}` : ''}\n\n## 回复要求\n请以${character.name}的身份回复这条短信：\n- 发送1-3条简洁的短信\n- 保持角色性格和记忆连贯性\n- 仔细观察图片内容并给出相应回复\n- 【重要】必须输出纯字符串JSON数组，不要代码块标记\n- 【重要】只能包含纯文本字符串，不能有任何对象\n- 【禁止】不要使用 {"type": "reply_to"} 等对象格式\n- 正确格式：["回复内容1", "回复内容2"]\n- 错误格式：[{"type": "reply_to", "content": "..."}]\n\n请回复：`
                        }
                    ];

                    if (imageContent) {
                        multimodalMessage.push(imageContent);
                    }

                    response = await callChatAPI(multimodalMessage, character);
                } else {
                    // 🔥【保持原有逻辑】如果没有图片，使用原有的短信专用逻辑（保持记忆功能）
                    console.log('🔍 [generateSMSReply] 使用短信专用API调用');
                    const smsPrompt = await buildSMSPrompt(character, userMessages);

                    // 构建完整的提示词，包括历史消息
                    const characterId = character.id;
                    const smsMessagesList = smsMessages[characterId] || [];
                    const historyRounds = getSMSChatSetting('historyRounds', 50);
                    const recentSMSMessages = smsMessagesList.slice(-historyRounds);

                    let conversationHistory = '';
                    if (recentSMSMessages.length > 0) {
                        conversationHistory = '\n\n## 短信对话历史\n';
                        recentSMSMessages.forEach(msg => {
                            const sender = msg.isUser ? '用户' : character.name;
                            const msgText = Array.isArray(msg.content) ?
                                (msg.content.find(p => p.type === 'text')?.text || '[多媒体消息]') :
                                (msg.text || '[消息]');
                            conversationHistory += `${sender}: ${msgText}\n`;
                        });
                    }

                    // 构建当前用户消息部分
                    let currentUserMessages = '\n\n## 当前用户消息\n';
                    if (Array.isArray(userMessages)) {
                        userMessages.forEach((msg) => {
                            const msgText = Array.isArray(msg.content) ?
                                (msg.content.find(p => p.type === 'text')?.text || '[多媒体消息]') :
                                (msg.text || msg);
                            currentUserMessages += `用户: ${msgText}\n`;
                        });
                    } else {
                        currentUserMessages += `用户: ${userMessages}\n`;
                    }

                    const fullPrompt = smsPrompt + conversationHistory + currentUserMessages + `\n## 回复要求\n请以${character.name}的身份回复这些短信：\n- 发送1-3条简洁的短信\n- 保持角色性格和记忆连贯性\n- 直接输出JSON数组，不要代码块标记\n\n请回复：`;

                    response = await generateAIResponse(fullPrompt, character);
                }

                // 🔥【移除错误的转换逻辑】
                // AI应该直接返回JSON格式，不需要额外转换
                console.log('🔥 [短信AI回复] AI原始回复:', response);

                // 🔥【增强】短信回复处理，支持JSON格式和多条消息
                if (response && response.trim()) {
                    let messages = [];

                    try {
                        // 🔥【修复】清理可能的代码块标记
                        let cleanResponse = response.trim();

                        // 移除可能的代码块标记
                        cleanResponse = cleanResponse.replace(/^```json\s*/, '').replace(/\s*```$/, '');
                        cleanResponse = cleanResponse.replace(/^```\s*/, '').replace(/\s*```$/, '');

                        // 尝试解析JSON格式
                        const parsedResponse = JSON.parse(cleanResponse);
                        if (Array.isArray(parsedResponse)) {
                            // 🔥【修复】只保留纯文本字符串，过滤掉复杂对象（引用、表情包等）
                            messages = parsedResponse.filter(msg => {
                                return msg && typeof msg === 'string' && msg.trim();
                            });
                        } else if (typeof parsedResponse === 'string') {
                            messages = [parsedResponse];
                        } else {
                            // 如果不是数组也不是字符串，当作单条消息处理
                            messages = [response.trim()];
                        }
                    } catch (error) {
                        // 如果JSON解析失败，尝试提取引号内的内容
                        console.log('🔥 [短信AI回复] JSON解析失败，尝试提取文本:', error);
                        const quotedMatches = response.match(/"([^"]+)"/g);
                        if (quotedMatches) {
                            messages = quotedMatches.map(match => match.slice(1, -1)).filter(msg => msg.trim());
                        } else {
                            // 最后回退到按换行分隔
                            messages = response.trim().split('\n').filter(msg => msg.trim());
                        }
                    }

                    // 确保短信消息记录存在
                    if (!smsMessages[character.id]) {
                        smsMessages[character.id] = [];
                    }

                    // 🔥【核心】逐条发送消息，模拟真人发消息的效果
                    for (let i = 0; i < messages.length; i++) {
                        const messageText = messages[i].trim();
                        if (messageText) {
                            // 如果不是第一条消息，添加延迟和正在输入指示器
                            if (i > 0) {
                                // 显示正在输入指示器
                                showSMSTypingIndicator();

                                // 随机延迟500-1500ms，模拟真人思考和打字时间
                                const delay = Math.random() * 1000 + 500;
                                await new Promise(resolve => setTimeout(resolve, delay));

                                // 隐藏正在输入指示器
                                hideSMSTypingIndicator();
                            }

                            const aiReplyMessage = {
                                id: `sms-ai-${Date.now()}-${i}-${Math.random().toString(36).substr(2, 9)}`,
                                content: [
                                    { type: 'text', text: messageText }
                                ], // 🔥【关键修复】使用与chatapp相同的多模态数组格式
                                text: messageText, // 保留以便短信界面显示
                                timestamp: Date.now() + i * 100, // 确保时间戳不同，每条消息间隔100ms
                                isUser: false
                            };

                            // 添加到短信消息记录
                            smsMessages[character.id].push(aiReplyMessage);

                            // 🔥【高效保存】保存每条AI回复消息
                            await saveSingleSMSMessage(character.id, aiReplyMessage);

                            // 🔥【新增】使用动画效果添加消息到界面
                            addSMSMessageWithAnimation(aiReplyMessage, character.id);

                            // 🔥【新增】为短信AI回复创建推送通知
                            createSMSPushNotification(character, aiReplyMessage.text, i * 500);

                            // 短暂延迟，让用户看到消息弹出效果
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    }

                    console.log(`🔥 [短信AI回复] 已逐条添加并保存${messages.length}条AI回复消息到短信记录`);

                    // 🔥【新增】记录短信AI回复到跨应用时间线
                    try {
                        await recordCrossAppEvent(
                            character.id,
                            'sms',
                            'ai_reply',
                            {
                                id: character.id, // 🔥【修复】添加上下文ID，确保记忆共享正常工作
                                type: 'sms_reply',
                                content: response.trim().substring(0, 100), // 记录前100字符
                                messageCount: messages.length,
                                userMessage: Array.isArray(userMessages) ? userMessages.join(' ').substring(0, 50) : userMessages.substring(0, 50), // 记录用户消息的前50字符
                                chatId: character.id, // 短信的聊天ID就是角色ID
                                sender: 'ai'
                            },
                            smsMessages[character.id][smsMessages[character.id].length - 1].id // 最后一条消息的ID
                        );
                        console.log('📝 [短信时间线] 已记录AI回复事件到跨应用时间线');
                    } catch (error) {
                        console.error('❌ [短信时间线] 记录AI回复事件失败:', error);
                    }
                }

                // 🔥【修改】确保正在输入指示器已隐藏
                hideSMSTypingIndicator();

                // 🔥【修改】不需要重新渲染整个消息列表，因为消息已经逐条添加了
                // renderSMSMessages(character.id);

                // 刷新短信消息列表（更新最后一条消息预览）
                renderSMSMessageList();

                // 🔥【移除】不显示toast提示，用正在输入指示器就够了
                // showToast(`${character.name} 已回复`, 'success');

            } catch (error) {
                console.error('生成短信AI回复失败:', error);
                // 🔥【新增】出错时也要隐藏指示器
                hideSMSTypingIndicator();
                throw error;
            }
        }

        // 🔥【新增】角色主动发送短信功能（用于被拉黑后的求和场景）
        async function characterInitiateSMS(characterId, reason = 'blocked') {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) {
                    console.error('角色不存在:', characterId);
                    return;
                }

                console.log('🔥 [角色主动短信] 角色主动发送短信，原因:', reason);

                // 确保短信联系人列表中有这个角色
                if (!smsContacts.includes(characterId)) {
                    smsContacts.push(characterId);
                    await saveSMSContacts();
                }

                // 初始化短信消息记录
                if (!smsMessages[characterId]) {
                    smsMessages[characterId] = [];
                }

                // 构建角色主动联系的提示词
                let initiatePrompt = '';
                if (reason === 'blocked') {
                    initiatePrompt = `你被用户在聊天应用中拉黑了，但你想通过短信主动联系用户，希望能够和解或解释。请发送一条真诚的短信给用户，表达你的想法。消息要简短、真诚，符合短信的特点。`;
                } else if (reason === 'friend_request_rejected') {
                    initiatePrompt = `用户拒绝了你的好友申请，但你想通过短信继续尝试联系，希望用户能给你一个机会。请发送一条短信给用户。消息要礼貌、不强求，符合短信的特点。`;
                } else {
                    initiatePrompt = `你想主动通过短信联系用户。请发送一条自然的短信给用户。`;
                }

                // 🔥【修复】使用ChatApp的generateAIResponse函数生成主动联系的消息
                const smsPrompt = await buildSMSPrompt(character, '');
                const fullPrompt = smsPrompt + `\n\n## 主动联系场景\n${initiatePrompt}\n\n## 回复要求\n请以${character.name}的身份发送短信：\n- 发送1-3条简洁的短信\n- 保持角色性格\n- 直接输出JSON数组，不要代码块标记\n\n请回复：`;
                const response = await generateAIResponse(fullPrompt, character);

                // 🔥【修复】处理JSON格式的短信回复
                if (response && response.trim()) {
                    let messageText = response.trim();

                    try {
                        // 🔥【修复】清理可能的代码块标记
                        let cleanResponse = response.trim();

                        // 移除可能的代码块标记
                        cleanResponse = cleanResponse.replace(/^```json\s*/, '').replace(/\s*```$/, '');
                        cleanResponse = cleanResponse.replace(/^```\s*/, '').replace(/\s*```$/, '');

                        // 尝试解析JSON格式
                        const parsedResponse = JSON.parse(cleanResponse);
                        if (Array.isArray(parsedResponse) && parsedResponse.length > 0) {
                            // 🔥【修复】只取第一条纯文本消息，跳过复杂对象
                            const firstTextMessage = parsedResponse.find(msg => typeof msg === 'string' && msg.trim());
                            if (firstTextMessage) {
                                messageText = firstTextMessage;
                            }
                        } else if (typeof parsedResponse === 'string') {
                            messageText = parsedResponse;
                        }
                    } catch (error) {
                        // 如果JSON解析失败，尝试提取引号内的内容
                        console.log('🔥 [短信主动联系] JSON解析失败，尝试提取文本:', error);
                        const quotedMatch = response.match(/"([^"]+)"/);
                        if (quotedMatch) {
                            messageText = quotedMatch[1];
                        }
                        // 否则直接使用原文本
                    }

                    const initiateMessage = {
                        id: `sms-initiate-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                        content: [
                            { type: 'text', text: messageText }
                        ], // 🔥【关键修复】使用与chatapp相同的多模态数组格式
                        text: messageText, // 保留以便短信界面显示
                        timestamp: Date.now(),
                        isUser: false
                    };

                    smsMessages[characterId].push(initiateMessage);

                    // 🔥【高效保存】只保存新增的单条主动联系消息
                    await saveSingleSMSMessage(characterId, initiateMessage);

                    // 🔥【新增】如果用户当前在该角色的短信聊天界面，使用动画效果添加消息
                    if (window.currentSMSCharacter && window.currentSMSCharacter.id === characterId) {
                        addSMSMessageWithAnimation(initiateMessage, characterId);
                    }

                    // 🔥【新增】为角色主动发送短信创建推送通知
                    createSMSPushNotification(character, initiateMessage.text, 100);

                    // 🔥【新增】记录角色主动发送短信到跨应用时间线
                    try {
                        await recordCrossAppEvent(
                            characterId,
                            'sms',
                            'character_initiate',
                            {
                                id: characterId, // 🔥【修复】添加上下文ID，确保记忆共享正常工作
                                type: 'sms_initiate',
                                content: response.trim().substring(0, 100), // 记录前100字符
                                reason: reason,
                                initiateType: 'character_proactive',
                                chatId: characterId, // 短信的聊天ID就是角色ID
                                sender: 'ai'
                            },
                            initiateMessage.id
                        );
                        console.log('📝 [短信时间线] 已记录角色主动发送短信事件到跨应用时间线');
                    } catch (error) {
                        console.error('❌ [短信时间线] 记录角色主动发送短信事件失败:', error);
                    }
                }

                // 🔥【修复】只保存联系人，不重复保存消息（消息已在上面单独保存）
                await saveSMSContacts();

                // 刷新界面
                renderSMSMessageList();

                console.log(`🔥 [角色主动短信] ${character.name} 已主动发送短信`);

                // 🔥【新增】显示通知给用户
                showToast(`${character.name} 通过短信联系了你`, 'info');

            } catch (error) {
                console.error('角色主动发送短信失败:', error);
            }
        }

        // 🔥【新增】全局函数：当角色被拉黑时，有概率通过短信联系用户
        window.onCharacterBlocked = async function(characterId) {
            // 30%的概率角色会通过短信联系用户
            if (Math.random() < 0.3) {
                // 延迟1-5分钟后发送短信，模拟真实情况
                const delay = Math.random() * 4 * 60 * 1000 + 60 * 1000; // 1-5分钟
                setTimeout(() => {
                    characterInitiateSMS(characterId, 'blocked');
                }, delay);

                console.log(`🔥 [拉黑触发] ${characterId} 将在 ${Math.round(delay/1000/60)} 分钟后通过短信联系用户`);
            }
        };

        // 🔥【增强】全局函数：当好友申请被拒绝时的多重后续行动
        window.onFriendRequestRejected = async function(characterId) {
            console.log(`💔 [好友申请被拒] ${characterId} 的好友申请被拒绝，启动后续行动...`);

            // 🔥【新增】记录被拒绝的次数，用于调整后续策略
            const rejectionKey = `friendRequestRejections_${characterId}`;
            let rejectionCount = parseInt(localStorage.getItem(rejectionKey) || '0') + 1;
            localStorage.setItem(rejectionKey, rejectionCount.toString());

            // 🔥【增强】根据被拒绝次数调整策略
            let smsChance = 0.6; // 基础60%概率发短信
            let retryChance = 0.3; // 30%概率再次尝试好友申请

            if (rejectionCount >= 2) {
                smsChance = 0.8; // 被拒绝2次后，80%概率发短信
                retryChance = 0.5; // 50%概率再次尝试
            }

            if (rejectionCount >= 3) {
                smsChance = 0.9; // 被拒绝3次后，90%概率发短信
                retryChance = 0.2; // 但重试概率降低到20%
            }

            // 1. 通过短信联系
            if (Math.random() < smsChance) {
                const smsDelay = Math.random() * 30 * 60 * 1000 + 10 * 60 * 1000; // 10-40分钟
                setTimeout(() => {
                    characterInitiateSMS(characterId, 'friend_request_rejected');
                }, smsDelay);
                console.log(`📱 [短信策略] ${characterId} 将在 ${Math.round(smsDelay/1000/60)} 分钟后通过短信联系用户`);
            }

            // 2. 🔥【新增】再次尝试好友申请（如果角色性格坚持）
            if (Math.random() < retryChance && rejectionCount < 4) {
                const retryDelay = Math.random() * 120 * 60 * 1000 + 60 * 60 * 1000; // 1-3小时后重试
                setTimeout(async () => {
                    await characterRetryFriendRequest(characterId, rejectionCount);
                }, retryDelay);
                console.log(`🔄 [重试策略] ${characterId} 将在 ${Math.round(retryDelay/1000/60)} 分钟后再次尝试好友申请`);
            }

            // 3. 🔥【新增】在聊天中表达被拒绝的感受
            setTimeout(async () => {
                await expressRejectionFeelings(characterId, rejectionCount);
            }, Math.random() * 10 * 60 * 1000 + 5 * 60 * 1000); // 5-15分钟后表达感受
        };

        // 🔥【新增】角色重试好友申请
        async function characterRetryFriendRequest(characterId, rejectionCount) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;

                // 构建重试好友申请的提示词
                const retryPrompt = `你是${character.name}，你的好友申请已经被用户拒绝了${rejectionCount}次。

你的性格：${character.bio}

现在你想再次尝试发送好友申请。请根据你的性格决定：
1. 是否要再次尝试
2. 如果尝试，应该说什么

考虑因素：
- 你已经被拒绝了${rejectionCount}次
- 你的性格是否会坚持不懈
- 你是否真的想修复这段关系
- 你应该如何调整你的道歉策略

请回复JSON格式：
- 如果要重试：[{"type": "friend_request", "message": "你的新道歉信息"}]
- 如果不重试：["我想我应该放弃了..."]

请根据你的性格做出真实的选择：`;

                const response = await generateAIResponse(retryPrompt, character);
                const reactions = await parseAiResponse(response);

                // 处理角色的决定
                for (const reaction of reactions) {
                    if (typeof reaction === 'object' && reaction.type === 'friend_request') {
                        // 角色决定重试
                        const retryMessage = {
                            id: Date.now().toString(),
                            sender: 'received',
                            type: 'friend_request',
                            message: reaction.message || '请再给我一次机会',
                            timestamp: Date.now(),
                            isRetryRequest: true,
                            retryCount: rejectionCount
                        };

                        if (!chatMessages[characterId]) {
                            chatMessages[characterId] = [];
                        }
                        chatMessages[characterId].push(retryMessage);

                        // 如果当前正在和这个角色聊天，立即显示
                        if (currentChatCharacter && currentChatCharacter.id === characterId) {
                            addMessageWithAnimation(retryMessage, characterId);
                        }

                        await saveChatMessagesImmediate([characterId]);
                        console.log(`🔄 ${character.name} 重试了第${rejectionCount + 1}次好友申请`);
                        break;
                    } else if (typeof reaction === 'string') {
                        // 角色决定放弃
                        const giveUpMessage = {
                            id: Date.now().toString(),
                            sender: 'received',
                            content: reaction,
                            timestamp: Date.now(),
                            isGiveUpMessage: true
                        };

                        if (!chatMessages[characterId]) {
                            chatMessages[characterId] = [];
                        }
                        chatMessages[characterId].push(giveUpMessage);

                        if (currentChatCharacter && currentChatCharacter.id === characterId) {
                            addMessageWithAnimation(giveUpMessage, characterId);
                        }

                        await saveChatMessagesImmediate([characterId]);
                        console.log(`💔 ${character.name} 决定放弃重试好友申请`);
                        break;
                    }
                }

            } catch (error) {
                console.error('角色重试好友申请失败:', error);
            }
        }

        // 🔥【新增】表达被拒绝的感受
        async function expressRejectionFeelings(characterId, rejectionCount) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;

                // 构建表达感受的提示词
                const feelingsPrompt = `你是${character.name}，你的好友申请刚刚被用户拒绝了（这是第${rejectionCount}次被拒绝）。

你的性格：${character.bio}

现在你想在聊天中表达你对被拒绝的感受。请根据你的性格表达：
- 你的失望、伤心、困惑或其他情绪
- 你对这种情况的看法
- 你是否还抱有希望

要求：
1. 用1-2句话表达你的真实感受
2. 符合你的性格设定
3. 不要过于戏剧化，要自然真实

请用JSON数组格式回复：`;

                const response = await generateAIResponse(feelingsPrompt, character);
                const reactions = await parseAiResponse(response);

                // 添加感受表达消息
                for (const reaction of reactions) {
                    if (typeof reaction === 'string') {
                        const feelingMessage = {
                            id: Date.now().toString(),
                            sender: 'received',
                            content: reaction,
                            timestamp: Date.now(),
                            isRejectionFeeling: true
                        };

                        if (!chatMessages[characterId]) {
                            chatMessages[characterId] = [];
                        }
                        chatMessages[characterId].push(feelingMessage);

                        if (currentChatCharacter && currentChatCharacter.id === characterId) {
                            addMessageWithAnimation(feelingMessage, characterId);
                        }

                        await saveChatMessagesImmediate([characterId]);
                        console.log(`💭 ${character.name} 表达了被拒绝的感受`);
                    }
                }

            } catch (error) {
                console.error('表达被拒绝感受失败:', error);
            }
        }

        // 显示短信聊天信息
        function showSMSChatInfo() {
            if (!window.currentSMSCharacter) return;

            // 隐藏短信聊天界面
            document.getElementById('sms-chat-screen').style.display = 'none';

            // 显示设置界面
            document.getElementById('sms-chat-settings-screen').style.display = 'block';

            // 初始化设置界面
            initSMSChatSettings();
        }

        // 隐藏短信聊天设置界面
        function hideSMSChatSettings() {
            document.getElementById('sms-chat-settings-screen').style.display = 'none';
            document.getElementById('sms-chat-screen').style.display = 'block';
        }

        // 初始化短信聊天设置界面
        function initSMSChatSettings() {
            if (!window.currentSMSCharacter) return;

            // 加载历史消息回合数设置
            const historyRounds = getSMSChatSetting('historyRounds', 50);
            document.getElementById('sms-history-rounds-slider').value = historyRounds;
            document.getElementById('sms-history-rounds-value').textContent = historyRounds + '轮';

            // 加载气泡颜色设置
            const bubbleColor = getSMSChatSetting('bubbleColor', 'blue');
            updateBubbleColorSelection(bubbleColor);
        }

        // 获取短信聊天设置
        function getSMSChatSetting(settingName, defaultValue) {
            if (!window.currentSMSCharacter) return defaultValue;
            const key = `sms-chat-${window.currentSMSCharacter.id}-${settingName}`;
            const saved = localStorage.getItem(key);
            return saved !== null ? saved : defaultValue;
        }

        // 保存短信聊天设置
        function setSMSChatSetting(settingName, value) {
            if (!window.currentSMSCharacter) return;
            const key = `sms-chat-${window.currentSMSCharacter.id}-${settingName}`;
            localStorage.setItem(key, value);
        }

        // 更新历史消息回合数
        function updateSMSHistoryRounds() {
            const slider = document.getElementById('sms-history-rounds-slider');
            const value = slider.value;
            document.getElementById('sms-history-rounds-value').textContent = value + '轮';
            setSMSChatSetting('historyRounds', value);
        }

        // 设置短信气泡颜色
        function setSMSBubbleColor(color) {
            setSMSChatSetting('bubbleColor', color);
            updateBubbleColorSelection(color);

            // 更新当前聊天界面的气泡颜色
            updateSMSChatBubbleColors(color);
        }

        // 更新气泡颜色选择状态
        function updateBubbleColorSelection(color) {
            document.querySelectorAll('.color-option-text').forEach(option => {
                option.classList.remove('active');
            });
            document.querySelector(`.color-option-text[data-color="${color}"]`).classList.add('active');
        }

        // 更新短信聊天界面的气泡颜色
        function updateSMSChatBubbleColors(color) {
            const chatContainer = document.getElementById('sms-messages-container');
            if (chatContainer) {
                // 移除现有的颜色类
                chatContainer.classList.remove('green-bubble');

                // 添加新的颜色类
                if (color === 'green') {
                    chatContainer.classList.add('green-bubble');
                }
            }
        }

        // 🔥【新增】清空短信聊天记录功能
        async function clearSMSChatHistory() {
            if (!window.currentSMSCharacter) {
                showToast('请先选择一个短信对话', 'error');
                return;
            }

            const character = window.currentSMSCharacter;
            const confirmText = `确定要清空与 ${character.name} 的所有短信记录吗？\n\n此操作将同时删除：\n• 相关的所有记忆\n\n此操作不可恢复！`;

            if (confirm(confirmText)) {
                try {
                    const characterId = character.id;
                    console.log(`🗑️ 开始清空角色 ${character.name} 的短信记录和记忆...`);

                    // 1. 清空短信消息记录
                    if (smsMessages[characterId]) {
                        delete smsMessages[characterId];
                    }

                    // 2. 从数据库中删除短信消息
                    await db.smsMessages.where('characterId').equals(characterId).delete();

                    // 3. 删除相关的时间线记忆
                    const timelineEvents = await db.crossAppTimeline
                        .where('characterId')
                        .equals(characterId)
                        .and(event => event.appType === 'sms')
                        .toArray();

                    if (timelineEvents.length > 0) {
                        const timelineIds = timelineEvents.map(event => event.id);
                        await db.crossAppTimeline.bulkDelete(timelineIds);
                        console.log(`✅ 删除了 ${timelineEvents.length} 条短信相关时间线记忆`);
                    }

                    // 4. 删除相关的情景记忆
                    const episodicMemories = await db.episodicMemories
                        .where('characterId')
                        .equals(characterId)
                        .toArray();

                    if (episodicMemories.length > 0) {
                        const episodicIds = episodicMemories.map(memory => memory.id);
                        await db.episodicMemories.bulkDelete(episodicIds);
                        console.log(`✅ 删除了 ${episodicMemories.length} 条情景记忆`);
                    }

                    // 5. 删除相关的核心记忆
                    const coreMemories = await db.coreMemories
                        .where('characterId')
                        .equals(characterId)
                        .toArray();

                    if (coreMemories.length > 0) {
                        const coreIds = coreMemories.map(memory => memory.id);
                        await db.coreMemories.bulkDelete(coreIds);
                        console.log(`✅ 删除了 ${coreMemories.length} 条核心记忆`);
                    }

                    // 6. 刷新短信界面
                    renderSMSMessages(characterId);
                    renderSMSMessageList();

                    showToast(`✅ 已清空与 ${character.name} 的所有短信记录和记忆`, 'success');
                    console.log(`✅ 清空完成: 短信记录、${timelineEvents.length}条时间线记忆、${episodicMemories.length}条情景记忆、${coreMemories.length}条核心记忆`);

                } catch (error) {
                    console.error('清空短信聊天记录失败:', error);
                    showToast('清空聊天记录失败', 'error');
                }
            }
        }

        // 渲染短信消息列表
        function renderSMSMessageList() {
            const messagesList = document.getElementById('messages-list');
            if (!messagesList) return;

            // 清空现有内容
            messagesList.innerHTML = '';

            // 🔥【修复】如果没有短信联系人，显示空状态
            if (!smsContacts || smsContacts.length === 0) {
                messagesList.innerHTML = `
                    <div class="messages-empty-state">
                        <i class="fas fa-comment-dots"></i>
                        <p>暂无短信</p>
                        <p>点击右上角编辑按钮创建新信息</p>
                    </div>
                `;
                return;
            }

            // 🔥【修复】按置顶状态排序短信联系人
            const sortedContacts = [...smsContacts].sort((a, b) => {
                const aIsPinned = pinnedSMSConversations.has(a);
                const bIsPinned = pinnedSMSConversations.has(b);
                if (aIsPinned && !bIsPinned) return -1;
                if (!aIsPinned && bIsPinned) return 1;
                return 0;
            });

            // 渲染每个短信联系人的消息项
            sortedContacts.forEach(contactId => {
                const character = characters.find(c => c.id === contactId);
                if (!character) return;

                const messages = smsMessages[contactId] || [];
                const lastMessage = messages[messages.length - 1];

                // 格式化时间 - iPhone风格
                let timeText = '';
                if (lastMessage) {
                    const date = new Date(lastMessage.timestamp);
                    const now = new Date();
                    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    const yesterday = new Date(today.getTime() - 24 * 60 * 60 * 1000);
                    const messageDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());

                    // 计算时间差
                    const diffTime = now.getTime() - date.getTime();
                    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

                    if (messageDate.getTime() === today.getTime()) {
                        // 当天聊的显示几点几分
                        timeText = date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                    } else if (messageDate.getTime() === yesterday.getTime()) {
                        // 前一天发生的显示昨天
                        timeText = '昨天';
                    } else if (diffDays < 7) {
                        // 再前面的显示星期x
                        const weekdays = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
                        timeText = weekdays[date.getDay()];
                    } else {
                        // 超过这个星期的显示为yyyy/M/d
                        timeText = date.toLocaleDateString('zh-CN', {
                            year: 'numeric',
                            month: 'numeric',
                            day: 'numeric'
                        });
                    }
                } else {
                    timeText = new Date().toLocaleDateString('zh-CN', {
                        year: 'numeric',
                        month: 'numeric',
                        day: 'numeric'
                    });
                }

                // 🔥【修复】获取最后一条短信消息的预览文本，支持多模态格式
                let previewText = '';
                if (lastMessage) {
                    if (lastMessage.isImage) {
                        // 图片消息显示[图片]
                        previewText = '[图片]';
                    } else {
                        // 🔥【关键修复】从多模态格式中提取文本内容
                        let textContent = '';
                        if (Array.isArray(lastMessage.content)) {
                            // 新的多模态格式
                            const textPart = lastMessage.content.find(part => part.type === 'text');
                            textContent = textPart ? textPart.text : '';
                        } else if (lastMessage.text) {
                            // 兼容旧格式
                            textContent = lastMessage.text;
                        }

                        if (textContent) {
                            // 文本消息显示前20个字符
                            previewText = textContent.length > 20
                                ? textContent.substring(0, 20) + '...'
                                : textContent;
                        } else {
                            // 空消息
                            previewText = '[图片]';
                        }
                    }
                } else {
                    previewText = '点击开始聊天';
                }

                const messageItem = document.createElement('div');
                const isPinned = pinnedSMSConversations.has(contactId);
                const isSelected = selectedSMSConversations.has(contactId);
                messageItem.className = `sms-message-item ${isPinned ? 'pinned' : ''} ${isSelected ? 'selected' : ''}`;

                // 🔥【修复】根据模式设置点击事件
                if (isSMSListMultiSelectMode) {
                    messageItem.onclick = () => toggleSMSConversationSelection(contactId);
                } else {
                    messageItem.onclick = () => startSMSChat(character);
                }

                messageItem.innerHTML = `
                    <div class="sms-message-avatar">
                        ${character.avatarUrl
                            ? `<img src="${character.avatarUrl}" alt="${character.name}">`
                            : `<div class="sms-avatar-placeholder">${character.name.charAt(0)}</div>`
                        }
                    </div>
                    <div class="sms-message-content">
                        <div class="sms-message-header">
                            <div class="sms-message-name">${character.name}</div>
                            <div class="sms-message-time">${timeText}</div>
                        </div>
                        <div class="sms-message-preview">${previewText}</div>
                    </div>
                    ${!isSMSListMultiSelectMode ? `
                        <div class="sms-message-arrow">
                            <i class="fas fa-chevron-right"></i>
                        </div>
                    ` : ''}
                `;

                messagesList.appendChild(messageItem);
            });
        }
        // 🔥【新增】删除短信对话功能
        async function deleteSMSConversation(characterId) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;

            const confirmText = `确定要删除与 ${character.name} 的短信对话吗？\n\n此操作将同时删除：\n• 所有短信记录\n• 相关的时间线记忆\n• 相关的情景记忆\n• 相关的核心记忆\n\n此操作不可恢复！`;

            if (confirm(confirmText)) {
                try {
                    console.log(`🗑️ 开始删除角色 ${character.name} 的短信对话和记忆...`);

                    // 1. 从短信联系人列表中移除
                    const contactIndex = smsContacts.indexOf(characterId);
                    if (contactIndex > -1) {
                        smsContacts.splice(contactIndex, 1);
                    }

                    // 2. 删除短信消息记录
                    if (smsMessages[characterId]) {
                        delete smsMessages[characterId];
                    }

                    // 3. 从数据库中删除短信数据
                    await db.transaction('rw', [db.smsContacts, db.smsMessages], async () => {
                        // 删除短信联系人记录
                        await db.smsContacts.where('characterId').equals(characterId).delete();
                        // 删除短信消息记录
                        await db.smsMessages.where('characterId').equals(characterId).delete();
                    });

                    // 4. 删除相关的时间线记忆
                    const timelineEvents = await db.crossAppTimeline
                        .where('characterId')
                        .equals(characterId)
                        .and(event => event.appType === 'sms')
                        .toArray();

                    if (timelineEvents.length > 0) {
                        const timelineIds = timelineEvents.map(event => event.id);
                        await db.crossAppTimeline.bulkDelete(timelineIds);
                        console.log(`✅ 删除了 ${timelineEvents.length} 条短信相关时间线记忆`);
                    }

                    // 5. 删除相关的情景记忆
                    const episodicMemories = await db.episodicMemories
                        .where('characterId')
                        .equals(characterId)
                        .toArray();

                    if (episodicMemories.length > 0) {
                        const episodicIds = episodicMemories.map(memory => memory.id);
                        await db.episodicMemories.bulkDelete(episodicIds);
                        console.log(`✅ 删除了 ${episodicMemories.length} 条情景记忆`);
                    }

                    // 6. 删除相关的核心记忆
                    const coreMemories = await db.coreMemories
                        .where('characterId')
                        .equals(characterId)
                        .toArray();

                    if (coreMemories.length > 0) {
                        const coreIds = coreMemories.map(memory => memory.id);
                        await db.coreMemories.bulkDelete(coreIds);
                        console.log(`✅ 删除了 ${coreMemories.length} 条核心记忆`);
                    }

                    // 7. 刷新短信消息列表
                    renderSMSMessageList();

                    // 8. 如果当前正在该对话中，返回到短信列表
                    if (window.currentSMSCharacter && window.currentSMSCharacter.id === characterId) {
                        hideSMSChat();
                    }

                    showToast(`✅ 已删除与 ${character.name} 的短信对话和所有相关记忆`, 'success');
                    console.log(`✅ 删除完成: 短信对话、${timelineEvents.length}条时间线记忆、${episodicMemories.length}条情景记忆、${coreMemories.length}条核心记忆`);

                } catch (error) {
                    console.error('删除短信对话失败:', error);
                    showToast('删除短信对话失败', 'error');
                }
            }
        }

        // 🔥【新增】短信管理功能相关变量
        let isSMSListMultiSelectMode = false; // 短信列表多选模式状态
        let selectedSMSConversations = new Set(); // 选中的短信对话ID集合
        let pinnedSMSConversations = new Set(); // 置顶的短信对话ID集合

        // 🔥【新增】显示短信管理选项
        function showSMSManageOptions() {
            const modal = document.getElementById('sms-manage-modal');
            if (modal) {
                modal.style.display = 'flex';
            }
        }

        // 🔥【新增】隐藏短信管理选项
        function hideSMSManageOptions(event) {
            if (event && event.target !== event.currentTarget) return;
            const modal = document.getElementById('sms-manage-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // 🔥【新增】进入短信列表多选模式
        function enterSMSListMultiSelectMode() {
            hideSMSManageOptions();
            isSMSListMultiSelectMode = true;
            selectedSMSConversations.clear();

            // 切换头部按钮显示
            const normalActions = document.getElementById('sms-normal-actions');
            const multiselectActions = document.getElementById('sms-list-multiselect-actions');
            if (normalActions) normalActions.style.display = 'none';
            if (multiselectActions) multiselectActions.style.display = 'flex';

            // 重新渲染消息列表以显示选择模式
            renderSMSMessageList();
        }

        // 🔥【新增】进入短信置顶模式
        function enterSMSPinMode() {
            hideSMSManageOptions();
            isSMSListMultiSelectMode = true;
            selectedSMSConversations.clear();

            // 切换头部按钮显示
            const normalActions = document.getElementById('sms-normal-actions');
            const multiselectActions = document.getElementById('sms-list-multiselect-actions');
            if (normalActions) normalActions.style.display = 'none';
            if (multiselectActions) {
                multiselectActions.style.display = 'flex';
                // 修改删除按钮为置顶按钮
                const deleteBtn = multiselectActions.querySelector('.delete-btn');
                if (deleteBtn) {
                    deleteBtn.innerHTML = '<span>置顶</span>';
                    deleteBtn.onclick = pinSelectedSMSConversations;
                    deleteBtn.style.background = 'rgba(255, 193, 7, 0.12)';
                    deleteBtn.style.color = '#FFC107';
                }
            }

            // 重新渲染消息列表以显示选择模式
            renderSMSMessageList();
        }

        // 🔥【新增】退出短信列表多选模式
        function exitSMSListMultiSelectMode() {
            isSMSListMultiSelectMode = false;
            selectedSMSConversations.clear();

            // 切换头部按钮显示
            const normalActions = document.getElementById('sms-normal-actions');
            const multiselectActions = document.getElementById('sms-list-multiselect-actions');
            if (normalActions) normalActions.style.display = 'flex';
            if (multiselectActions) {
                multiselectActions.style.display = 'none';
                // 恢复删除按钮的原始状态
                const deleteBtn = multiselectActions.querySelector('.delete-btn');
                if (deleteBtn) {
                    deleteBtn.innerHTML = '<span>删除</span>';
                    deleteBtn.onclick = deleteSelectedSMSConversations;
                    deleteBtn.style.background = 'rgba(255, 59, 48, 0.12)';
                    deleteBtn.style.color = '#FF3B30';
                }
            }

            // 重新渲染消息列表恢复正常状态
            renderSMSMessageList();
        }

        // 🔥【新增】切换短信对话选择状态
        function toggleSMSConversationSelection(characterId) {
            if (selectedSMSConversations.has(characterId)) {
                selectedSMSConversations.delete(characterId);
            } else {
                selectedSMSConversations.add(characterId);
            }

            // 重新渲染消息列表以更新选择状态
            renderSMSMessageList();

            // 如果没有选中的对话，退出多选模式
            if (selectedSMSConversations.size === 0) {
                exitSMSListMultiSelectMode();
            }
        }

        // 🔥【新增】删除选中的短信对话
        async function deleteSelectedSMSConversations() {
            if (selectedSMSConversations.size === 0) {
                showToast('请先选择要删除的对话', 'error');
                return;
            }

            const count = selectedSMSConversations.size;
            const confirmText = `确定要删除选中的 ${count} 个短信对话吗？\n\n此操作将同时删除：\n• 所有短信记录\n• 相关的时间线记忆\n• 相关的情景记忆\n• 相关的核心记忆\n\n此操作不可恢复！`;

            if (confirm(confirmText)) {
                try {
                    console.log(`🗑️ 开始批量删除 ${count} 个短信对话和相关记忆...`);
                    let totalTimelineDeleted = 0;
                    let totalEpisodicDeleted = 0;
                    let totalCoreDeleted = 0;

                    // 批量删除选中的对话
                    for (const characterId of selectedSMSConversations) {
                        // 1. 从短信联系人列表中移除
                        const contactIndex = smsContacts.indexOf(characterId);
                        if (contactIndex > -1) {
                            smsContacts.splice(contactIndex, 1);
                        }

                        // 2. 删除短信消息记录
                        if (smsMessages[characterId]) {
                            delete smsMessages[characterId];
                        }

                        // 3. 从数据库中删除短信数据
                        await db.transaction('rw', [db.smsContacts, db.smsMessages], async () => {
                            // 删除短信联系人记录
                            await db.smsContacts.where('characterId').equals(characterId).delete();
                            // 删除短信消息记录
                            await db.smsMessages.where('characterId').equals(characterId).delete();
                        });

                        // 4. 删除相关的时间线记忆
                        const timelineEvents = await db.crossAppTimeline
                            .where('characterId')
                            .equals(characterId)
                            .and(event => event.appType === 'sms')
                            .toArray();

                        if (timelineEvents.length > 0) {
                            const timelineIds = timelineEvents.map(event => event.id);
                            await db.crossAppTimeline.bulkDelete(timelineIds);
                            totalTimelineDeleted += timelineEvents.length;
                        }

                        // 5. 删除相关的情景记忆
                        const episodicMemories = await db.episodicMemories
                            .where('characterId')
                            .equals(characterId)
                            .toArray();

                        if (episodicMemories.length > 0) {
                            const episodicIds = episodicMemories.map(memory => memory.id);
                            await db.episodicMemories.bulkDelete(episodicIds);
                            totalEpisodicDeleted += episodicMemories.length;
                        }

                        // 6. 删除相关的核心记忆
                        const coreMemories = await db.coreMemories
                            .where('characterId')
                            .equals(characterId)
                            .toArray();

                        if (coreMemories.length > 0) {
                            const coreIds = coreMemories.map(memory => memory.id);
                            await db.coreMemories.bulkDelete(coreIds);
                            totalCoreDeleted += coreMemories.length;
                        }
                    }

                    // 退出多选模式
                    exitSMSListMultiSelectMode();

                    showToast(`✅ 已删除 ${count} 个短信对话和所有相关记忆`, 'success');
                    console.log(`✅ 批量删除完成: ${count}个对话、${totalTimelineDeleted}条时间线记忆、${totalEpisodicDeleted}条情景记忆、${totalCoreDeleted}条核心记忆`);

                } catch (error) {
                    console.error('批量删除短信对话失败:', error);
                    showToast('删除对话失败', 'error');
                }
            }
        }

        // 🔥【新增】置顶选中的短信对话
        async function pinSelectedSMSConversations() {
            if (selectedSMSConversations.size === 0) {
                showToast('请先选择要置顶的对话', 'error');
                return;
            }

            try {
                // 将选中的对话添加到置顶列表
                for (const characterId of selectedSMSConversations) {
                    if (pinnedSMSConversations.has(characterId)) {
                        // 如果已经置顶，则取消置顶
                        pinnedSMSConversations.delete(characterId);
                    } else {
                        // 如果未置顶，则添加置顶
                        pinnedSMSConversations.add(characterId);
                    }
                }

                // 保存置顶状态到本地存储
                localStorage.setItem('pinnedSMSConversations', JSON.stringify([...pinnedSMSConversations]));

                // 退出多选模式
                exitSMSListMultiSelectMode();

                const count = selectedSMSConversations.size;
                showToast(`✅ 已更新 ${count} 个对话的置顶状态`, 'success');

            } catch (error) {
                console.error('置顶短信对话失败:', error);
                showToast('置顶对话失败', 'error');
            }
        }

        // 🔥【新增】加载置顶状态
        function loadPinnedSMSConversations() {
            try {
                const saved = localStorage.getItem('pinnedSMSConversations');
                if (saved) {
                    pinnedSMSConversations = new Set(JSON.parse(saved));
                }
            } catch (error) {
                console.error('加载置顶状态失败:', error);
                pinnedSMSConversations = new Set();
            }
        }













        // 图片小组件功能
        function showPhotoWidgetOptions() {
            document.getElementById('photo-widget-modal').style.display = 'flex';
        }

        function closePhotoWidgetModal() {
            document.getElementById('photo-widget-modal').style.display = 'none';
        }

        function handlePhotoWidgetUpload(input) {
            if (input.files && input.files[0]) {
                const file = input.files[0];
                const reader = new FileReader();

                reader.onload = function(e) {
                    const imageData = e.target.result;

                    // 保存到localStorage
                    localStorage.setItem('photoWidgetImage', imageData);

                    // 更新显示
                    updatePhotoWidget(imageData);

                    showToast('图片已设置', 'success');
                    closePhotoWidgetModal();
                };

                reader.readAsDataURL(file);
            }
        }

        function updatePhotoWidget(imageData) {
            const placeholder = document.getElementById('photo-placeholder');
            const image = document.getElementById('photo-widget-image');

            if (imageData) {
                placeholder.style.display = 'none';
                image.src = imageData;
                image.style.display = 'block';

                // 确保图片正确缩放
                image.onload = function() {
                    // 图片已加载，CSS会自动处理缩放
                };
            } else {
                placeholder.style.display = 'block';
                image.style.display = 'none';
            }
        }

        function clearPhotoWidget() {
            localStorage.removeItem('photoWidgetImage');
            updatePhotoWidget(null);
            showToast('图片已清除', 'success');
            closePhotoWidgetModal();
        }

        // 纪念日小组件功能
        function showAnniversaryWidgetOptions() {
            // 更新选择列表
            updateAnniversaryWidgetSelect();
            document.getElementById('anniversary-widget-modal').style.display = 'flex';
        }

        function closeAnniversaryWidgetModal() {
            document.getElementById('anniversary-widget-modal').style.display = 'none';
        }

        function updateAnniversaryWidgetSelect() {
            const select = document.getElementById('widget-anniversary-select');
            const currentSelection = localStorage.getItem('anniversaryWidgetSelection');

            // 清空选项
            select.innerHTML = '<option value="">请选择纪念日</option>';

            // 🔥【优化】优先显示置顶的纪念日
            const pinnedAnniversaries = anniversaries.filter(a => a.isPinned);
            const regularAnniversaries = anniversaries.filter(a => !a.isPinned);

            // 先添加置顶纪念日
            if (pinnedAnniversaries.length > 0) {
                const pinnedGroup = document.createElement('optgroup');
                pinnedGroup.label = '⭐ 置顶纪念日';
                pinnedAnniversaries.forEach(anniversary => {
                    const option = document.createElement('option');
                    option.value = anniversary.id;
                    option.textContent = anniversary.name;
                    if (anniversary.id === currentSelection) {
                        option.selected = true;
                    }
                    pinnedGroup.appendChild(option);
                });
                select.appendChild(pinnedGroup);
            }

            // 再添加普通纪念日
            if (regularAnniversaries.length > 0) {
                const regularGroup = document.createElement('optgroup');
                regularGroup.label = '📅 其他纪念日';
                regularAnniversaries.forEach(anniversary => {
                    const option = document.createElement('option');
                    option.value = anniversary.id;
                    option.textContent = anniversary.name;
                    if (anniversary.id === currentSelection) {
                        option.selected = true;
                    }
                    regularGroup.appendChild(option);
                });
                select.appendChild(regularGroup);
            }
        }

        function updateAnniversaryWidget() {
            const select = document.getElementById('widget-anniversary-select');
            const selectedId = select.value;

            if (selectedId) {
                const anniversary = anniversaries.find(a => a.id === selectedId);
                if (anniversary) {
                    localStorage.setItem('anniversaryWidgetSelection', selectedId);
                    displayAnniversaryWidget(anniversary);
                    showToast('纪念日小组件已更新', 'success');
                }
            } else {
                clearAnniversaryWidget();
            }
        }

        function displayAnniversaryWidget(anniversary) {
            const placeholder = document.getElementById('anniversary-placeholder');
            const display = document.getElementById('anniversary-display');
            const nameEl = document.getElementById('widget-anniversary-name');
            const countdownEl = document.getElementById('widget-anniversary-countdown');
            const dateEl = document.getElementById('widget-anniversary-date');
            const widget = document.querySelector('.anniversary-widget-content').parentElement;

            // 计算天数
            const now = new Date();
            const currentYear = now.getFullYear();
            const anniversaryDate = new Date(anniversary.date);
            const countType = anniversary.countType || 'countdown'; // 默认为倒数

            let countdownText = '';

            if (countType === 'countup') {
                // 正数：基于日历日期计算（当天显示"今天"，第二天显示1天）
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const anniversaryDateOnly = new Date(anniversaryDate.getFullYear(), anniversaryDate.getMonth(), anniversaryDate.getDate());
                const daysPassed = Math.floor((today - anniversaryDateOnly) / (1000 * 60 * 60 * 24));
                countdownText = daysPassed === 0 ? '今天' :
                               `${daysPassed}`;
            } else {
                // 倒数：基于日历日期计算（当天显示"今天"）
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                let nextDate = new Date(currentYear, anniversaryDate.getMonth(), anniversaryDate.getDate());

                if (nextDate < today) {
                    nextDate.setFullYear(currentYear + 1);
                }

                const daysUntil = Math.floor((nextDate - today) / (1000 * 60 * 60 * 24));
                countdownText = daysUntil === 0 ? '今天' :
                               daysUntil === 1 ? '明天' :
                               `${daysUntil}`;
            }

            // 更新显示
            nameEl.textContent = anniversary.name;
            countdownEl.textContent = countdownText;
            dateEl.textContent = formatDate(anniversary.date);

            // 设置背景图
            if (anniversary.backgroundImage) {
                widget.style.backgroundImage = `url('${anniversary.backgroundImage}')`;
                widget.style.backgroundSize = 'cover';
                widget.style.backgroundPosition = 'center';
                widget.style.backgroundRepeat = 'no-repeat';
                // 添加半透明遮罩以确保文字可读性
                widget.style.position = 'relative';
                if (!widget.querySelector('.widget-overlay')) {
                    const overlay = document.createElement('div');
                    overlay.className = 'widget-overlay';
                    overlay.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.1);
                        border-radius: inherit;
                        z-index: 1;
                    `;
                    widget.appendChild(overlay);
                }
                // 确保内容在遮罩之上，设置白色文字
                const content = widget.querySelector('.anniversary-widget-content');
                if (content) {
                    content.style.position = 'relative';
                    content.style.zIndex = '2';

                    // 确保文字样式正确应用
                    const nameEl = content.querySelector('#widget-anniversary-name');
                    const countdownEl = content.querySelector('#widget-anniversary-countdown');
                    const dateEl = content.querySelector('#widget-anniversary-date');

                    // 只设置必要的白色文字和阴影，让CSS控制大小和布局
                    if (nameEl) {
                        nameEl.style.cssText += `
                            color: rgba(255, 255, 255, 0.9) !important;
                            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8) !important;
                        `;
                    }

                    if (countdownEl) {
                        countdownEl.style.cssText += `
                            color: white !important;
                            text-shadow: 0 2px 6px rgba(0, 0, 0, 0.8) !important;
                        `;
                    }

                    if (dateEl) {
                        dateEl.style.cssText += `
                            color: rgba(255, 255, 255, 0.8) !important;
                            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8) !important;
                        `;
                    }
                }
            } else {
                // 清除背景图
                widget.style.backgroundImage = '';
                const overlay = widget.querySelector('.widget-overlay');
                if (overlay) {
                    overlay.remove();
                }
            }

            placeholder.style.display = 'none';
            display.style.display = 'block';
        }

        function clearAnniversaryWidget() {
            localStorage.removeItem('anniversaryWidgetSelection');
            const placeholder = document.getElementById('anniversary-placeholder');
            const display = document.getElementById('anniversary-display');
            const widget = document.querySelector('.anniversary-widget-content').parentElement;

            // 清除背景图和遮罩
            if (widget) {
                widget.style.backgroundImage = '';
                const overlay = widget.querySelector('.widget-overlay');
                if (overlay) {
                    overlay.remove();
                }
            }

            placeholder.style.display = 'block';
            display.style.display = 'none';

            showToast('纪念日小组件已清除', 'success');
        }

        // 🔥【新增】强制刷新纪念日小组件
        function refreshAnniversaryWidget() {
            if (anniversaries && anniversaries.length > 0) {
                // 优先显示置顶的纪念日
                const pinnedAnniversary = anniversaries.find(a => a.isPinned);
                if (pinnedAnniversary) {
                    localStorage.setItem('anniversaryWidgetSelection', pinnedAnniversary.id);
                    displayAnniversaryWidget(pinnedAnniversary);
                    return;
                }

                // 如果没有置顶的，显示第一个纪念日
                const firstAnniversary = anniversaries[0];
                if (firstAnniversary) {
                    localStorage.setItem('anniversaryWidgetSelection', firstAnniversary.id);
                    displayAnniversaryWidget(firstAnniversary);
                }
            } else {
                clearAnniversaryWidget();
            }
        }

        // 🔥【开发者调试】手动刷新小组件的全局函数
        window.refreshWidget = refreshAnniversaryWidget;

        // 🔥【开发者调试】纪念日小组件调试工具
        window.anniversaryWidgetDebug = {
            // 查看当前纪念日列表
            listAnniversaries: () => {
                console.table(anniversaries.map(a => ({
                    id: a.id,
                    name: a.name,
                    isPinned: a.isPinned,
                    hasBackground: !!a.backgroundImage,
                    hasUserAvatar: !!a.userAvatar
                })));
            },

            // 查看当前小组件状态
            checkWidget: () => {
                const saved = localStorage.getItem('anniversaryWidgetSelection');
                const current = anniversaries.find(a => a.id === saved);
                console.log('小组件状态:', {
                    savedId: saved,
                    currentAnniversary: current ? current.name : '未找到',
                    isPinned: current ? current.isPinned : false,
                    hasBackground: current ? !!current.backgroundImage : false
                });
            },

            // 强制刷新小组件
            refresh: refreshAnniversaryWidget,

            // 清除小组件
            clear: clearAnniversaryWidget
        };

        // 初始化小组件
        function initializeWidgets() {
            try {
                // 初始化图片小组件
                const savedImage = localStorage.getItem('photoWidgetImage');
                if (savedImage) {
                    updatePhotoWidget(savedImage);
                }

                // 🔥【优化】初始化纪念日小组件 - 优先显示置顶纪念日
                const savedAnniversary = localStorage.getItem('anniversaryWidgetSelection');
                if (anniversaries && anniversaries.length > 0) {
                    let anniversaryToShow = null;

                    // 如果有保存的选择，优先使用
                    if (savedAnniversary) {
                        anniversaryToShow = anniversaries.find(a => a.id === savedAnniversary);
                    }

                    // 如果没有保存的选择或者保存的纪念日不存在，自动选择置顶的纪念日
                    if (!anniversaryToShow) {
                        const pinnedAnniversary = anniversaries.find(a => a.isPinned);
                        if (pinnedAnniversary) {
                            anniversaryToShow = pinnedAnniversary;
                            // 保存这个选择
                            localStorage.setItem('anniversaryWidgetSelection', pinnedAnniversary.id);
                        }
                    }

                    if (anniversaryToShow) {
                        displayAnniversaryWidget(anniversaryToShow);
                    }
                }
            } catch (error) {
                console.error('初始化小组件失败:', error);
            }
        }

        // 切换照片文字显示
        function togglePhotoText(container, description) {
            const overlay = container.querySelector('.photo-text-overlay');
            const sparkles = container.querySelector('.sparkle-container');
            const badge = container.querySelector('.photo-badge');

            if (overlay.style.display === 'none') {
                // 显示文字，隐藏星星和标志
                overlay.style.display = 'flex';
                sparkles.style.opacity = '0';
                badge.style.opacity = '0.3';
            } else {
                // 隐藏文字，显示星星和标志
                overlay.style.display = 'none';
                sparkles.style.opacity = '1';
                badge.style.opacity = '1';
            }
        }

        // 显示用户照片描述
        function showUserPhotoDescription(description) {
            const modalHtml = `
                <div id="photo-description-modal" class="modal" style="display: flex; z-index: 10000; background: rgba(0, 0, 0, 0.8);">
                    <div class="magical-photo-modal">
                        <div class="photo-modal-bg"></div>
                        <div class="photo-modal-content">
                            <div class="photo-modal-header">
                                <i class="fas fa-camera photo-modal-icon"></i>
                                <div class="photo-modal-title">照片内容</div>
                            </div>
                            <div class="photo-modal-body">
                                <div class="photo-description-text">${description}</div>
                            </div>
                            <div class="photo-modal-footer">
                                <button class="photo-modal-btn" id="photo-description-close">确定</button>
                            </div>
                        </div>
                        <div class="modal-sparkles">
                            <div class="modal-sparkle modal-sparkle-1">✨</div>
                            <div class="modal-sparkle modal-sparkle-2">⭐</div>
                            <div class="modal-sparkle modal-sparkle-3">✨</div>
                            <div class="modal-sparkle modal-sparkle-4">⭐</div>
                            <div class="modal-sparkle modal-sparkle-5">💫</div>
                            <div class="modal-sparkle modal-sparkle-6">✨</div>
                            <div class="modal-sparkle modal-sparkle-7">⭐</div>
                            <div class="modal-sparkle modal-sparkle-8">💫</div>
                        </div>
                    </div>
                </div>
            `;

            // 添加到页面
            document.body.insertAdjacentHTML('beforeend', modalHtml);

            const modal = document.getElementById('photo-description-modal');
            const closeBtn = document.getElementById('photo-description-close');

            // 关闭按钮事件
            closeBtn.onclick = () => {
                modal.remove();
            };

            // 点击背景关闭
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            };
        }

        // 自定义输入提示框
        function showCustomPrompt(title, placeholder, initialValue = '', type = 'text') {
            return new Promise(resolve => {
                // 创建模态框HTML
                const modalHtml = `
                    <div id="custom-prompt-modal" class="modal" style="display: flex; z-index: 10000;">
                        <div class="modal-content" style="max-width: 400px;">
                            <div class="modal-header">
                                <div class="modal-title">${title}</div>
                            </div>
                            <div class="modal-body">
                                <input type="${type}" id="custom-prompt-input" class="form-input"
                                       placeholder="${placeholder}" value="${initialValue}"
                                       style="width: 100%; margin-top: 10px;">
                            </div>
                            <div class="modal-footer">
                                <button class="modal-button modal-secondary" id="custom-prompt-cancel">取消</button>
                                <button class="modal-button modal-primary" id="custom-prompt-confirm">确定</button>
                            </div>
                        </div>
                    </div>
                `;

                // 添加到页面
                document.body.insertAdjacentHTML('beforeend', modalHtml);

                const modal = document.getElementById('custom-prompt-modal');
                const input = document.getElementById('custom-prompt-input');
                const confirmBtn = document.getElementById('custom-prompt-confirm');
                const cancelBtn = document.getElementById('custom-prompt-cancel');

                // 确定按钮事件
                confirmBtn.onclick = () => {
                    const value = input.value;
                    modal.remove();
                    resolve(value);
                };

                // 取消按钮事件
                cancelBtn.onclick = () => {
                    modal.remove();
                    resolve(null);
                };

                // 回车键确认
                input.onkeydown = (e) => {
                    if (e.key === 'Enter') {
                        confirmBtn.click();
                    }
                };

                // 聚焦输入框
                setTimeout(() => input.focus(), 100);
            });
        }

        // 切换聊天标签
        function switchChatTab(tabId) {
            // 移除所有标签的active类
            document.querySelectorAll('.chat-tab').forEach(tab => {
                if (tab && tab.classList) {
                    tab.classList.remove('active');
                }
            });

            // 添加当前标签的active类
            if (event && event.currentTarget && event.currentTarget.classList) {
                event.currentTarget.classList.add('active');
            } else {
                // 如果没有event对象，根据tabId设置active
                if (tabId === 'message-list') {
                    const messageTab = document.getElementById('message-tab');
                    if (messageTab && messageTab.classList) {
                        messageTab.classList.add('active');
                    }
                } else if (tabId === 'contact-list') {
                    const tabs = document.querySelectorAll('.chat-tab');
                    if (tabs.length > 1 && tabs[1] && tabs[1].classList) {
                        tabs[1].classList.add('active');
                    }
                } else if (tabId === 'moments-page') {
                    const tabs = document.querySelectorAll('.chat-tab');
                    if (tabs.length > 2 && tabs[2] && tabs[2].classList) {
                        tabs[2].classList.add('active');
                    }
                } else if (tabId === 'profile-page') {
                    const tabs = document.querySelectorAll('.chat-tab');
                    if (tabs.length > 3 && tabs[3] && tabs[3].classList) {
                        tabs[3].classList.add('active');
                    }
                }
            }

            // 隐藏所有内容
            const messageListEl = document.getElementById('message-list');
            const contactListEl = document.getElementById('contact-list');
            const profilePageEl = document.getElementById('profile-page');
            const momentsPageEl = document.getElementById('moments-page');
            const targetEl = document.getElementById(tabId);

            if (messageListEl) messageListEl.style.display = 'none';
            if (contactListEl) contactListEl.style.display = 'none';
            if (profilePageEl) profilePageEl.style.display = 'none';
            if (momentsPageEl) momentsPageEl.style.display = 'none';

            // 显示选中的内容
            if (targetEl) targetEl.style.display = 'block';

            // 控制app标题的渐变效果和内容
            const appTitle = document.querySelector('#chat-screen .app-title');
            if (appTitle) {
                if (tabId === 'message-list') {
                    appTitle.classList.add('chat-mode');
                    appTitle.textContent = '💬';
                } else if (tabId === 'contact-list') {
                    appTitle.classList.remove('chat-mode');
                    appTitle.textContent = '角色';
                } else if (tabId === 'moments-page') {
                    appTitle.classList.remove('chat-mode');
                                            appTitle.textContent = '动态';
                    // 🔥【新增】切换到动态页面时加载用户设置
                    loadMomentsImages();
                } else if (tabId === 'profile-page') {
                    appTitle.classList.remove('chat-mode');
                    appTitle.textContent = '我';
                }
            }

            // 控制按钮显示
            const addContactBtn = document.getElementById('add-contact-btn');
            const addChatBtn = document.getElementById('add-chat-btn');
            const groupManageBtn = document.getElementById('group-manage-btn');

            if (addContactBtn && addChatBtn && groupManageBtn) {
                if (tabId === 'contact-list') {
                    addContactBtn.style.display = 'flex';
                    addChatBtn.style.display = 'none';
                    groupManageBtn.style.display = isGroupManageMode ? 'none' : 'flex';
                    // 修改加号按钮的点击事件为创建角色
                    addContactBtn.onclick = () => showCharacterForm();
                } else if (tabId === 'message-list') {
                    addContactBtn.style.display = 'none';
                    addChatBtn.style.display = 'flex';
                    groupManageBtn.style.display = 'none';
                } else if (tabId === 'moments-page') {
                                            // 动态页面显示发布按钮
                    addContactBtn.style.display = 'flex';
                    addChatBtn.style.display = 'none';
                    groupManageBtn.style.display = 'none';
                    // 修改加号按钮的点击事件为发布动态
                    addContactBtn.onclick = () => showPublishMoment();
                } else {
                    addContactBtn.style.display = 'none';
                    addChatBtn.style.display = 'none';
                    groupManageBtn.style.display = 'none';
                }
            }

            // 如果是动态页面，检查是否需要加载动态内容
            if (tabId === 'moments-page') {
                // 只在动态列表为空时加载，避免重复显示
                const momentsList = document.getElementById('moments-list');
                if (momentsList && momentsList.children.length === 0) {
                loadMoments();
                }
                                        // 移除动态页面的padding，实现全屏效果
                const chatContent = document.getElementById('chat-content');
                if (chatContent) {
                    chatContent.style.padding = '0';
                }
            } else {
                // 其他页面恢复正常padding
                const chatContent = document.getElementById('chat-content');
                if (chatContent) {
                    chatContent.style.padding = '15px';
                }

                // 停止时间更新器（节省资源）
                stopTimeUpdater();
            }
        }

        // 更新时间
        function updateTime() {
            const now = new Date();
            const hours = now.getHours().toString().padStart(2, '0');
            const minutes = now.getMinutes().toString().padStart(2, '0');
            const timeString = `${hours}:${minutes}`;

            // 更新状态栏时间
            const statusTime = document.getElementById('status-bar-time');
            if (statusTime) {
                statusTime.textContent = timeString;
            }

            // 更新应用内状态栏时间
            const appStatusTimes = document.querySelectorAll('.app-status-time');
            appStatusTimes.forEach(element => {
                element.textContent = timeString;
            });

            // 更新主时钟
            const mainTime = document.getElementById('main-time');
            if (mainTime) {
                mainTime.textContent = timeString;
            }

            // 更新日期
            const mainDate = document.getElementById('main-date');
            if (mainDate) {
                // 🔥【新增】根据时钟样式显示不同的日期格式
                const clockStyle = document.body.getAttribute('data-clock-style') || 'default';
                let dateText = '';

                switch (clockStyle) {
                    case 'modern':
                        // 现代样式：英文格式 "MON, DEC 18"
                        dateText = now.toLocaleDateString('en-US', {
                            weekday: 'short',
                            month: 'short',
                            day: 'numeric'
                        }).toUpperCase();
                        break;
                    case 'compact':
                        // 紧凑样式：简短格式 "12/18 周一"
                        const compactDate = now.toLocaleDateString('zh-CN', {
                            month: 'numeric',
                            day: 'numeric'
                        });
                        const compactWeekday = now.toLocaleDateString('zh-CN', {
                            weekday: 'short'
                        });
                        dateText = `${compactDate} ${compactWeekday}`;
                        break;
                    case 'bold':
                        // 粗体样式：完整格式 "12月18日 星期一"
                        dateText = now.toLocaleDateString('zh-CN', {
                            month: 'long',
                            day: 'numeric',
                            weekday: 'long'
                        });
                        break;
                    default:
                        // 默认样式：标准格式
                        dateText = now.toLocaleDateString('zh-CN', {
                            month: 'long',
                            day: 'numeric',
                            weekday: 'long'
                        });
                        break;
                }

                mainDate.textContent = dateText;
            }
        }

        // 加载角色分组数据
        async function loadCharacterGroups() {
            try {
                const savedGroups = await db.characterGroups.orderBy('order').toArray();

                if (savedGroups.length === 0) {
                    // 如果没有分组，创建默认分组
                    const defaultGroups = [
                        { id: 'my_friends', name: '我的好友', order: 999, isDefault: true, canInteract: false },
                        { id: 'special_care', name: '特别关心', order: 1, isDefault: false, canInteract: true },
                        { id: 'close_friends', name: '亲密朋友', order: 2, isDefault: false, canInteract: true },
                        { id: 'family', name: '家人', order: 3, isDefault: false, canInteract: true },
                        { id: 'classmates', name: '同学', order: 4, isDefault: false, canInteract: true },
                        { id: 'colleagues', name: '同事', order: 5, isDefault: false, canInteract: true }
                    ];

                    await db.characterGroups.bulkAdd(defaultGroups);
                    characterGroups = defaultGroups;
                } else {
                    characterGroups = savedGroups;
                }
            } catch (error) {
                console.error('加载角色分组失败:', error);
                // 创建基本的默认分组
                characterGroups = [
                    { id: 'my_friends', name: '我的好友', order: 999, isDefault: true, canInteract: false }
                ];
            }
        }

        // 保存角色分组数据
        async function saveCharacterGroups() {
            try {
                await db.characterGroups.clear();
                await db.characterGroups.bulkAdd(characterGroups);
            } catch (error) {
                console.error('保存角色分组失败:', error);
            }
        }

        // 加载角色数据 - 使用IndexedDB（包含数据迁移）
        async function loadCharacters() {
            try {
                // 先检查IndexedDB中是否有数据
                const savedCharacters = await db.characters.toArray();

                if (savedCharacters.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('characters');
                    if (localStorageData) {
                        const localCharacters = JSON.parse(localStorageData);

                        if (localCharacters.length > 0) {
                            // 为旧角色数据添加默认分组
                            localCharacters.forEach(character => {
                                if (!character.groupId) {
                                    character.groupId = 'my_friends'; // 默认分组
                                }
                            });

                            // 迁移数据到IndexedDB
                            await db.characters.bulkAdd(localCharacters);
                            characters = localCharacters;
                            // 可选：清除localStorage中的旧数据
                            // localStorage.removeItem('characters');
                        } else {
                            characters = [];
                        }
                    } else {
                        characters = [];
                    }
                } else {
                    // 确保所有角色都有分组ID
                    savedCharacters.forEach(character => {
                        if (!character.groupId) {
                            character.groupId = 'my_friends';
                        }
                    });
                    characters = savedCharacters;
                }
            } catch (error) {
                console.error('加载角色数据失败:', error);
                // 如果IndexedDB失败，尝试从localStorage加载
                const localStorageData = localStorage.getItem('characters');
                if (localStorageData) {
                    characters = JSON.parse(localStorageData);
                    // 为角色添加默认分组
                    characters.forEach(character => {
                        if (!character.groupId) {
                            character.groupId = 'my_friends';
                        }
                    });

                } else {
                    characters = [];
                }
            }
        }

        // 保存角色数据 - 使用IndexedDB
        async function saveCharacters() {
            try {


                // 检查重复ID
                const uniqueIds = new Set();
                const uniqueCharacters = [];

                for (const character of characters) {
                    if (!character.id) {
                        console.warn('发现没有ID的角色，跳过保存:', character);
                        continue;
                    }

                    if (!uniqueIds.has(character.id)) {
                        uniqueIds.add(character.id);
                        uniqueCharacters.push(character);
                    } else {
                        console.warn(`发现重复ID的角色 (${character.id})，跳过重复项:`, character);
                    }
                }

                // 🔥【安全修复】使用事务确保原子操作，防止数据丢失
                if (uniqueCharacters.length === 0) {
                    console.warn('⚠️ 拒绝保存空角色数据，可能存在数据丢失风险');
                    return;
                }

                // 使用事务进行原子操作
                await db.transaction('rw', db.characters, async () => {
                    await db.characters.clear();
                    await db.characters.bulkPut(uniqueCharacters);
                });

                console.log(`✅ 安全保存了 ${uniqueCharacters.length} 个角色到数据库`);


            } catch (error) {
                console.error('保存角色时发生错误:', error);
                alert('保存角色时发生错误: ' + error.message);
                throw error;
            }
        }

        // 显示存储使用情况
        function showStorageUsage() {
            const usage = [];

            // 计算各种数据的大小
            const characters = localStorage.getItem('characters') || '[]';
            const chatMessages = localStorage.getItem('chatMessages') || '{}';
            const customEmojis = localStorage.getItem('customEmojis') || '[]';

            usage.push(`角色数据: ${(characters.length / 1024).toFixed(1)} KB`);
            usage.push(`聊天记录: ${(chatMessages.length / 1024).toFixed(1)} KB`);
            usage.push(`表情包: ${(customEmojis.length / 1024).toFixed(1)} KB`);

            const total = characters.length + chatMessages.length + customEmojis.length;
            usage.push(`总计: ${(total / 1024).toFixed(1)} KB`);


            alert('存储使用情况:\n' + usage.join('\n'));
        }

        // 🔥【修复】加载联系人数据 - 只加载用户主动添加的联系人，增强浏览器兼容性
        async function loadContacts() {
            try {
                console.log('🔄 加载联系人列表...');

                // 从数据库加载联系人列表
                const savedContacts = await db.contacts.toArray();

                if (savedContacts.length === 0) {
                    // 如果数据库中没有联系人，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('contacts');
                    if (localStorageData) {
                        const localContacts = JSON.parse(localStorageData);
                        contacts = Array.isArray(localContacts) ? localContacts : [];
                        console.log(`✅ 从localStorage迁移了 ${contacts.length} 个联系人`);
                        // 保存到数据库
                        await saveContacts();
                    } else {
                        // 🔥【修复】不自动生成联系人列表，保持用户的删除操作
                        contacts = [];
                        console.log('✅ 初始化空联系人列表（用户可能删除了所有对话）');
                    }
                } else {
                    // 从数据库对象数组转换为ID数组
                    contacts = savedContacts.map(contact => contact.characterId).filter(id => id);
                    console.log(`✅ 从数据库加载了 ${contacts.length} 个联系人`);

                    // 🔥【修复】只清理无效的联系人，不自动添加新的
                    if (characters && characters.length > 0) {
                        const characterIds = characters.map(char => char.id);
                        const validContacts = contacts.filter(id => characterIds.includes(id));

                        // 只有当发现无效联系人时才更新
                        if (validContacts.length !== contacts.length) {
                            const removedCount = contacts.length - validContacts.length;
                            console.log(`🔧 清理了 ${removedCount} 个无效的联系人记录`);
                            contacts = validContacts;
                            await saveContacts();
                        }
                    }
                }

            } catch (error) {
                console.error('❌ 加载联系人列表失败:', error);
                // 🔥【浏览器兼容性修复】出错时尝试从角色列表重建
                if (characters && characters.length > 0) {
                    console.log('🔧 出错时从角色列表重建联系人');
                    contacts = characters.map(char => char.id);
                } else {
                    contacts = []; // 如果出错，确保联系人列表为空，防止程序崩溃
                }
            }
        }



        // 保存联系人数据 - 使用IndexedDB
        async function saveContacts() {
            try {
        // 过滤掉任何可能存在的无效ID
        const validContacts = contacts.filter(id => id);
        // 将联系人ID列表转换为数据库需要的对象数组格式
        const contactArray = validContacts.map(id => ({ characterId: id }));

        await db.transaction('rw', db.contacts, async () => {
            // 先清空旧表，再批量写入新数据
                await db.contacts.clear();
                if (contactArray.length > 0) {
                    await db.contacts.bulkAdd(contactArray);
                }
        });
            } catch (error) {
                console.error('保存联系人失败:', error);
            }
        }

        // 🔥【短信应用独立数据管理】加载短信联系人
        async function loadSMSContacts() {
            try {
                console.log('🔄 加载短信联系人列表...');
                const savedSMSContacts = await db.smsContacts.toArray();

                // 转换为简单的ID数组格式，保持与原有逻辑兼容
                smsContacts = savedSMSContacts.map(contact => contact.characterId).filter(id => id);
                console.log(`✅ 从数据库加载了 ${smsContacts.length} 个短信联系人`);

                // 清理无效的联系人（角色已被删除）
                if (characters && characters.length > 0) {
                    const characterIds = characters.map(char => char.id);
                    const validSMSContacts = smsContacts.filter(id => characterIds.includes(id));

                    if (validSMSContacts.length !== smsContacts.length) {
                        const removedCount = smsContacts.length - validSMSContacts.length;
                        console.log(`🔧 清理了 ${removedCount} 个无效的短信联系人记录`);
                        smsContacts = validSMSContacts;
                        await saveSMSContacts();
                    }
                }
            } catch (error) {
                console.error('加载短信联系人失败:', error);
                smsContacts = [];
            }
        }

        // 🔥【短信应用独立数据管理】保存短信联系人
        async function saveSMSContacts() {
            try {
                const validSMSContacts = smsContacts.filter(id => id);
                const smsContactArray = validSMSContacts.map(id => ({
                    characterId: id,
                    createdAt: Date.now()
                }));

                await db.transaction('rw', db.smsContacts, async () => {
                    await db.smsContacts.clear();
                    if (smsContactArray.length > 0) {
                        await db.smsContacts.bulkAdd(smsContactArray);
                    }
                });
                console.log(`✅ 保存了 ${validSMSContacts.length} 个短信联系人`);
            } catch (error) {
                console.error('保存短信联系人失败:', error);
            }
        }

        // 🔥【短信应用独立数据管理】加载短信消息
        async function loadSMSMessages() {
            try {
                console.log('🔄 加载短信消息...');
                const savedSMSMessages = await db.smsMessages.toArray();
                smsMessages = {};

                // 🔥【修复】将数据库格式转换为新的多模态内存格式，支持图片消息
                savedSMSMessages.forEach(msg => {
                    if (!smsMessages[msg.characterId]) {
                        smsMessages[msg.characterId] = [];
                    }

                    // 🔥【关键修复】根据消息类型构建正确的多模态格式
                    let messageContent = [];

                    if (msg.isImage && msg.imageUrl) {
                        // 图片消息：包含文本和图片两部分
                        messageContent = [
                            { type: 'text', text: msg.content || '' },
                            { type: 'image_url', image_url: { url: msg.imageUrl } }
                        ];
                    } else {
                        // 文本消息：只包含文本
                        messageContent = [
                            { type: 'text', text: msg.content || '' }
                        ];
                    }

                    const messageObj = {
                        id: msg.id,
                        content: messageContent, // 🔥【关键修复】转换为多模态数组格式
                        text: msg.content, // 保留以便短信界面显示
                        timestamp: msg.timestamp,
                        isUser: msg.isUser,
                        // 🔥【新增】恢复图片相关数据
                        isImage: msg.isImage || false,
                        imageUrl: msg.imageUrl || null,
                        fileName: msg.fileName || null
                    };

                    smsMessages[msg.characterId].push(messageObj);
                });

                // 按时间戳排序每个角色的消息
                Object.keys(smsMessages).forEach(characterId => {
                    smsMessages[characterId].sort((a, b) => a.timestamp - b.timestamp);
                });

                const imageCount = savedSMSMessages.filter(msg => msg.isImage).length;
                console.log(`✅ 从数据库加载了 ${savedSMSMessages.length} 条短信消息${imageCount > 0 ? `（包含 ${imageCount} 张图片）` : ''}`);
            } catch (error) {
                console.error('加载短信消息失败:', error);
                smsMessages = {};
            }
        }

        // 🔥【短信应用独立数据管理】保存短信消息
        // 🔥【高效保存】保存单条短信消息
        async function saveSingleSMSMessage(characterId, message) {
            try {
                // 🔥【修复】正确处理多模态消息格式
                let contentToSave = '';
                if (Array.isArray(message.content)) {
                    // 新的多模态格式，提取文本内容
                    const textPart = message.content.find(part => part.type === 'text');
                    contentToSave = textPart ? textPart.text : '';
                } else if (message.text) {
                    // 兼容旧格式
                    contentToSave = message.text;
                } else {
                    contentToSave = '';
                }

                // 🔥【新增】构建完整的消息对象，包含图片相关字段
                const messageToSave = {
                    id: message.id,
                    characterId: characterId,
                    timestamp: message.timestamp,
                    content: contentToSave,
                    isUser: message.isUser,
                    // 🔥【关键修复】保存图片相关数据
                    isImage: message.isImage || false,
                    imageUrl: message.imageUrl || null,
                    fileName: message.fileName || null
                };

                await db.smsMessages.add(messageToSave);
                console.log(`✅ 保存了角色 ${characterId} 的单条短信消息${message.isImage ? '（包含图片）' : ''}`);
            } catch (error) {
                console.error('保存单条短信消息失败:', error);
                throw error;
            }
        }

        // 🔥【批量保存】保存所有短信消息（仅用于初始化或修复）
        async function saveSMSMessages(characterId) {
            try {
                if (!smsMessages[characterId]) return;

                const messagesToSave = smsMessages[characterId].map(msg => {
                    // 🔥【修复】正确处理多模态消息格式
                    let contentToSave = '';
                    if (Array.isArray(msg.content)) {
                        // 新的多模态格式，提取文本内容
                        const textPart = msg.content.find(part => part.type === 'text');
                        contentToSave = textPart ? textPart.text : '';
                    } else if (msg.text) {
                        // 兼容旧格式
                        contentToSave = msg.text;
                    } else {
                        contentToSave = '';
                    }

                    // 🔥【新增】构建完整的消息对象，包含图片相关字段
                    return {
                        id: msg.id,
                        characterId: characterId,
                        timestamp: msg.timestamp,
                        content: contentToSave,
                        isUser: msg.isUser,
                        // 🔥【关键修复】保存图片相关数据
                        isImage: msg.isImage || false,
                        imageUrl: msg.imageUrl || null,
                        fileName: msg.fileName || null
                    };
                });

                await db.transaction('rw', db.smsMessages, async () => {
                    // 删除该角色的旧消息
                    await db.smsMessages.where('characterId').equals(characterId).delete();
                    // 添加新消息
                    if (messagesToSave.length > 0) {
                        await db.smsMessages.bulkAdd(messagesToSave);
                    }
                });

                const imageCount = messagesToSave.filter(msg => msg.isImage).length;
                console.log(`✅ 批量保存了角色 ${characterId} 的 ${messagesToSave.length} 条短信消息${imageCount > 0 ? `（包含 ${imageCount} 张图片）` : ''}`);
            } catch (error) {
                console.error('批量保存短信消息失败:', error);
            }
        }

        // 加载聊天消息 - 使用IndexedDB（包含数据迁移）
        async function loadChatMessages() {
            try {
                const savedMessages = await db.chatMessages.toArray();
                chatMessages = {};

                if (savedMessages.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('chatMessages');
                    if (localStorageData) {

                        const localMessages = JSON.parse(localStorageData);

                        // 将对象格式转换为数组格式存储到IndexedDB
                        const messageArray = [];
                        for (const [characterId, messages] of Object.entries(localMessages)) {
                            for (const message of messages) {
                                messageArray.push({
                                    id: `${characterId}_${message.id || message.timestamp}`,
                                    characterId: characterId,
                                    timestamp: message.timestamp,
                                    messageData: message
                                });
                            }
                        }

                        if (messageArray.length > 0) {
                            await db.chatMessages.bulkAdd(messageArray);
                        }

                        chatMessages = localMessages;

                    }
                } else {
                    // 将数组格式转换回对象格式
                    for (const msgRecord of savedMessages) {
                        const characterId = msgRecord.characterId;
                        if (!chatMessages[characterId]) {
                            chatMessages[characterId] = [];
                        }
                        // 🔥【新增】检查消息数据是否有效，过滤空值
                        if (msgRecord.messageData && typeof msgRecord.messageData === 'object') {
                        chatMessages[characterId].push(msgRecord.messageData);
                        }
                    }

                    // 🔥【重复消息修复】按时间戳排序、去重并清理空值
                    for (const characterId in chatMessages) {
                        console.log(`🔧 [去重修复] 处理角色 ${characterId}: ${chatMessages[characterId].length} 条原始记录`);

                        // 🔥【核心修复】去重逻辑 - 根据消息ID和内容+时间戳去重
                        const uniqueMessages = [];
                        const seenIds = new Set();
                        const seenContentTime = new Set();

                        chatMessages[characterId]
                            .filter(msg => {
                                // 基本有效性检查
                                if (!msg || typeof msg !== 'object' || !msg.timestamp) {
                                    return false;
                                }
                                return true;
                            })
                            .sort((a, b) => a.timestamp - b.timestamp) // 先按时间排序
                            .forEach(msg => {
                                // 方法1: 根据消息ID去重
                                if (msg.id && seenIds.has(msg.id)) {
                                    return; // 跳过重复的ID
                                }

                                // 🔥【修复】方法2: 根据内容+时间戳+特殊标记去重（处理没有ID或ID重复的情况）
                                const contentTimeKey = `${msg.content || ''}_${msg.timestamp}_${msg.sender || ''}_${msg.isProactive || ''}_${msg.isOfflineMode || ''}`;
                                if (seenContentTime.has(contentTimeKey)) {
                                    return; // 跳过重复的内容+时间戳
                                }

                                // 记录已见过的标识
                                if (msg.id) seenIds.add(msg.id);
                                seenContentTime.add(contentTimeKey);

                                // 添加到唯一消息列表
                                uniqueMessages.push(msg);
                            });

                        // 替换为去重后的消息
                        chatMessages[characterId] = uniqueMessages;

                        console.log(`✅ [去重修复] 角色 ${characterId}: ${uniqueMessages.length} 条唯一消息 (去重了 ${savedMessages.filter(m => m.characterId === characterId).length - uniqueMessages.length} 条重复)`);
                    }

                    // 🔥【修复】清理数据库中的拉黑系统消息
                    await cleanupBlockedSystemMessages();
                }

                // 🔥【重构】初始化消息内容哈希，真正智能的变化检测
                lastSavedMessageHashes = {};
                for (const [characterId, messages] of Object.entries(chatMessages)) {
                    lastSavedMessageHashes[characterId] = generateMessagesHash(messages);
                }
                console.log('✅ 已初始化消息哈希检测器:', Object.keys(lastSavedMessageHashes));

            } catch (error) {
                console.error('加载聊天消息失败:', error);
                // 如果IndexedDB失败，尝试从localStorage加载
                const localStorageData = localStorage.getItem('chatMessages');
                if (localStorageData) {
                    chatMessages = JSON.parse(localStorageData);
                } else {
                    chatMessages = {};
                }
            }
        }

        // 🔥【修复】清理数据库中重复的拉黑系统消息
        async function cleanupBlockedSystemMessages() {
            try {
                // 获取所有聊天消息记录
                const allMessages = await db.chatMessages.toArray();
                const messagesToDelete = [];

                // 🔥【修复】清理重复的拉黑系统消息
                const blockedMessagesByCharacter = {};

                for (const msgRecord of allMessages) {
                    if (msgRecord.messageData &&
                        msgRecord.messageData.sender === 'system' &&
                        msgRecord.messageData.isBlockedMessage) {

                        const characterId = msgRecord.characterId;
                        if (!blockedMessagesByCharacter[characterId]) {
                            blockedMessagesByCharacter[characterId] = [];
                        }
                        blockedMessagesByCharacter[characterId].push(msgRecord);
                    }
                }

                // 对每个角色，只保留最新的拉黑系统消息，删除重复的
                for (const characterId in blockedMessagesByCharacter) {
                    const messages = blockedMessagesByCharacter[characterId];
                    if (messages.length > 1) {
                        // 按时间戳排序，保留最新的，删除其他的
                        messages.sort((a, b) => (b.messageData.timestamp || 0) - (a.messageData.timestamp || 0));
                        const toDelete = messages.slice(1); // 删除除第一个（最新）之外的所有消息
                        messagesToDelete.push(...toDelete.map(msg => msg.id));
                    }
                }

                if (messagesToDelete.length > 0) {
                    await db.chatMessages.bulkDelete(messagesToDelete);
                    console.log(`已清理 ${messagesToDelete.length} 条重复的拉黑系统消息`);
                }
            } catch (error) {
                console.error('清理拉黑系统消息失败:', error);
            }
        }

        // 防抖保存计时器
        let saveMessagesTimer = null;
        let isSaving = false; // 防止并发保存
        let saveQueue = []; // 🔥【新增】保存队列
        let lastSavedMessageHashes = {}; // 🔥【重构】记录每个角色的消息内容哈希，而不是数量
        let nextSequentialId = 0; // 🔥【新增】全局顺序ID

        // 🔥【新增】生成消息列表的简单哈希
        function generateMessagesHash(messages) {
            if (!messages || messages.length === 0) return '';

            // 🔥【修复】生成基于消息ID、内容、类型、发送者和特殊标记的哈希
            const hashString = messages.map(msg =>
                `${msg.id || ''}:${msg.content || ''}:${msg.type || ''}:${msg.sender || ''}:${msg.isProactive || ''}:${msg.isOfflineMode || ''}`
            ).join('|');

            // 简单的字符串哈希函数
            let hash = 0;
            for (let i = 0; i < hashString.length; i++) {
                const char = hashString.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // 转换为32位整数
            }
            return hash.toString();
        }

        // 防抖版本的保存函数
        function saveChatMessages(forceResyncFor = null) { // 🔥 新增参数
            // 🔥【修复】添加到保存队列，防止在高频调用时丢失保存请求
            const saveRequest = {
                timestamp: Date.now(),
                id: Math.random().toString(36).substr(2, 9),
                forceResyncFor: forceResyncFor // 🔥 传递强制同步ID
            };
            saveQueue.push(saveRequest);

            // 清除之前的计时器
            if (saveMessagesTimer) {
                clearTimeout(saveMessagesTimer);
            }

            // 设置新的计时器，500ms后执行保存
            saveMessagesTimer = setTimeout(async () => {
                if (isSaving) {
                    // 如果正在保存，延迟重试
                    setTimeout(() => saveChatMessages(), 100);
                    return;
                }

                // 🔥 从队列中找出所有需要强制同步的角色ID
                const resyncIds = new Set();
                saveQueue.forEach(req => {
                    if (req.forceResyncFor) {
                        resyncIds.add(req.forceResyncFor);
                    }
                });

                // 清空队列并执行保存
                const currentQueue = [...saveQueue];
                saveQueue = [];

                if (currentQueue.length > 0) {
                    console.log(`🔄 执行批量保存，队列中有 ${currentQueue.length} 个请求`);
                    await saveChatMessagesImmediate(Array.from(resyncIds)); // 🔥 传递ID列表
                }
            }, 500);
        }

        // 立即保存聊天消息 - 使用IndexedDB（增强版本，包含存储管理）
        async function saveChatMessagesImmediate(forceResyncIds = []) { // 🔥 新增参数
            if (isSaving) {
                return;
            }
            isSaving = true;

            try {
                const storageInfo = await checkStorageUsage();
                if (storageInfo && storageInfo.needCleanup) {
                    console.warn('⚠️ 存储空间不足，尝试清理数据...');
                    await performSmartDataCleanup();
                }

                const newMessages = [];
                const charactersToDelete = new Set(forceResyncIds); // 🔥 直接使用强制同步列表

                if (nextSequentialId === 0) {
                    const existingMessages = await db.chatMessages.toArray();
                    nextSequentialId = existingMessages.length;
                }

                for (const [characterId, messages] of Object.entries(chatMessages)) {
                    // 🔥【重构】使用哈希检测真正的内容变化，而不是数量变化
                    const currentHash = generateMessagesHash(messages);
                    const lastSavedHash = lastSavedMessageHashes[characterId] || '';

                    // 🔥 如果角色在强制同步列表中，直接标记为待删除和重新添加
                    if (charactersToDelete.has(characterId)) {
                        console.log(`🔄 角色 ${characterId}: 强制执行完全同步 (来自外部请求)`);
                        charactersToDelete.add(characterId);
                        for (let i = 0; i < messages.length; i++) {
                            const message = messages[i];
                            // 🔥【修复】使用更安全的ID生成策略，避免潜在的重复键问题
                            const stableId = `${characterId}_sync_${message.timestamp || Date.now()}_${i}_${Math.random().toString(36).substr(2, 6)}`;
                            newMessages.push({
                                id: stableId,
                                characterId: characterId,
                                timestamp: message.timestamp,
                                messageOrder: i,
                                originalMessageId: message.id,
                                messageData: message
                            });
                        }
                        lastSavedMessageHashes[characterId] = currentHash;
                        continue;
                    }

                    // 🔥【核心改进】只有当内容真正发生变化时才保存
                    if (currentHash !== lastSavedHash) {
                        console.log(`📝 角色 ${characterId}: 检测到内容变化，执行智能保存`);

                        // 简单策略：内容变化时重写该角色的所有消息（但使用稳定ID）
                        charactersToDelete.add(characterId);
                        for (let i = 0; i < messages.length; i++) {
                            const message = messages[i];
                            // 🔥【修复】使用更安全的ID生成策略，避免潜在的重复键问题
                            const stableId = `${characterId}_update_${message.timestamp || Date.now()}_${i}_${Math.random().toString(36).substr(2, 6)}`;
                            newMessages.push({
                                id: stableId,
                                characterId,
                                timestamp: message.timestamp,
                                messageOrder: i,
                                originalMessageId: message.id,
                                messageData: message
                            });
                        }
                        lastSavedMessageHashes[characterId] = currentHash;
                    }
                }

                const finalDeleteList = Array.from(charactersToDelete);
                if (finalDeleteList.length === 0 && newMessages.length === 0) {
                    console.log('📝 没有消息变化需要保存');
                    isSaving = false;
                    return;
                }

                // 数据库事务操作
                let retryCount = 0;
                const maxRetries = 3;
                while (retryCount < maxRetries) {
                    try {
                        await db.transaction('rw', db.chatMessages, async () => {
                            if (finalDeleteList.length > 0) {
                                for (const characterId of finalDeleteList) {
                                    const deletedCount = await db.chatMessages.where('characterId').equals(characterId).delete();
                                    console.log(`🗑️ 已删除角色 ${characterId} 的 ${deletedCount} 条旧消息数据`);
                                }
                            }
                            if (newMessages.length > 0) {
                                await db.chatMessages.bulkAdd(newMessages);
                                console.log(`✅ 已保存 ${newMessages.length} 条消息到IndexedDB`);
                            }
                        });
                        break;
                    } catch (transactionError) {
                        retryCount++;
                        console.warn(`🔄 保存操作失败，重试 ${retryCount}/${maxRetries}:`, transactionError);
                        if (retryCount >= maxRetries) throw transactionError;
                        await new Promise(resolve => setTimeout(resolve, 100 * retryCount));
                    }
                }
                console.log(`✅ 保存操作完成: 强制同步/删除了 ${finalDeleteList.length} 个角色的旧数据，保存了 ${newMessages.length} 条消息`);

            } catch (error) {
                // ... (原有的错误处理逻辑保持不变) ...
                console.error('保存聊天消息失败:', error);
                // (此处省略了与之前相同的错误处理和紧急清理代码)
            } finally {
                isSaving = false;
            }
        }



        // 🔥【重构】加载聊天设置 - 优先使用IndexedDB，减少localStorage依赖 + 窗口隔离支持
        async function loadChatSettings() {
            try {
                // 优先从IndexedDB加载
                const savedChatSettings = await db.chatSettings.toArray();

                // 🔥【新功能】同时加载窗口隔离的设置
                const savedWindowChatSettings = await db.windowChatSettings.toArray();

                if (savedChatSettings.length > 0 || savedWindowChatSettings.length > 0) {
                    // IndexedDB中有数据，直接使用
                    console.log(`✅ 从IndexedDB加载了 ${savedChatSettings.length} 个聊天设置和 ${savedWindowChatSettings.length} 个窗口隔离设置`);
                    chatSettings = {};

                    // 加载全局聊天设置
                    savedChatSettings.forEach(item => {
                        chatSettings[item.chatId] = item.settings;
                    });

                    // 🔥【新功能】加载窗口隔离的设置
                    savedWindowChatSettings.forEach(item => {
                        const windowChatSettingsKey = `${item.chatId}_${item.windowId}`;
                        chatSettings[windowChatSettingsKey] = item.settings;
                    });

                    return;
                }

                // IndexedDB中没有数据，尝试从localStorage迁移（一次性迁移）
                console.log('🔄 IndexedDB中无数据，尝试从localStorage迁移...');

                // 检查新格式的localStorage数据
                const localStorageData = localStorage.getItem('chatSettings');
                if (localStorageData) {
                    const localSettings = JSON.parse(localStorageData);
                    await migrateChatSettingsToIndexedDB(localSettings);
                    return;
                }

                // 检查旧格式的localStorage数据（单个角色存储）
                const migratedSettings = {};
                let foundOldData = false;

                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('chatSettings_') && !key.includes('emergency')) {
                        try {
                            const chatId = key.replace('chatSettings_', '');
                            const settingData = localStorage.getItem(key);
                            if (settingData) {
                                migratedSettings[chatId] = JSON.parse(settingData);
                                foundOldData = true;
                            }
                        } catch (e) {
                            console.warn(`跳过无效的localStorage键: ${key}`, e);
                        }
                    }
                }

                if (foundOldData) {
                    console.log('🔄 发现旧格式数据，正在迁移...');
                    await migrateChatSettingsToIndexedDB(migratedSettings);
                    return;
                }

                // 没有任何数据，初始化为空
                chatSettings = {};
                console.log('📝 初始化空的聊天设置');

            } catch (error) {
                console.error('🚨 加载聊天设置失败:', error);

                // 尝试从紧急备份恢复
                try {
                    const emergencyBackup = localStorage.getItem('chatSettings_emergency_backup');
                    if (emergencyBackup) {
                        chatSettings = JSON.parse(emergencyBackup);
                        console.log('🆘 从紧急备份恢复聊天设置');
                        showToast('⚠️ 从紧急备份恢复设置', 'warning');
                        return;
                    }
                } catch (backupError) {
                    console.error('紧急备份也无法加载:', backupError);
                }

                // 最后的回退
                chatSettings = {};
                showToast('❌ 设置加载失败，使用默认设置', 'error');
            }
        }

        // 🔥【新增】迁移chatSettings到IndexedDB的辅助函数
        async function migrateChatSettingsToIndexedDB(localSettings) {
            try {
                const settingsArray = Object.keys(localSettings).map(chatId => ({
                    id: chatId,
                    chatId: chatId,
                    settings: localSettings[chatId]
                }));

                if (settingsArray.length > 0) {
                    await db.chatSettings.bulkPut(settingsArray);
                    console.log(`✅ 成功迁移 ${settingsArray.length} 个聊天设置到IndexedDB`);

                    // 迁移成功后更新内存
                    chatSettings = localSettings;

                    // 可选：清理旧的localStorage数据（谨慎操作）
                    // localStorage.removeItem('chatSettings');
                }
            } catch (error) {
                console.error('🚨 迁移聊天设置到IndexedDB失败:', error);
                // 迁移失败时仍然使用localStorage数据
                chatSettings = localSettings;
            }
        }

        // 🔥【新增】自动保存机制 - 防止浏览器卡顿导致数据丢失
        let autoSaveTimer = null;
        let pendingSettingsChanges = new Set();

        function scheduleAutoSave(chatId) {
            if (chatId) {
                pendingSettingsChanges.add(chatId);
            }

            // 清除之前的定时器
            if (autoSaveTimer) {
                clearTimeout(autoSaveTimer);
            }

            // 设置新的定时器，5秒后自动保存
            autoSaveTimer = setTimeout(async () => {
                if (pendingSettingsChanges.size > 0) {
                    console.log(`🔄 自动保存 ${pendingSettingsChanges.size} 个聊天设置...`);
                    try {
                        await saveChatSettings();
                        console.log('✅ 自动保存完成');
                        pendingSettingsChanges.clear();
                    } catch (error) {
                        console.error('🚨 自动保存失败:', error);
                        // 保留待保存的设置，下次再试
                    }
                }
                autoSaveTimer = null;
            }, 5000); // 5秒延迟
        }

        // 🔥【新增】页面卸载前强制保存
        window.addEventListener('beforeunload', async (event) => {
            if (pendingSettingsChanges.size > 0) {
                console.log('🔄 页面卸载前强制保存设置...');
                try {
                    // 同步保存，确保在页面关闭前完成
                    await saveChatSettings();
                    console.log('✅ 页面卸载前保存完成');
                } catch (error) {
                    console.error('🚨 页面卸载前保存失败:', error);
                }
            }
        });

        // 🔥【新增】页面可见性变化时保存
        document.addEventListener('visibilitychange', async () => {
            if (document.hidden && pendingSettingsChanges.size > 0) {
                console.log('🔄 页面隐藏时保存设置...');
                try {
                    await saveChatSettings();
                    console.log('✅ 页面隐藏时保存完成');
                    pendingSettingsChanges.clear();
                } catch (error) {
                    console.error('🚨 页面隐藏时保存失败:', error);
                }
            }
        });

        // 🔥【新增】调试聊天记录格式的工具函数
        async function debugChatMessagesFormat() {
            try {
                // 检查当前数据库中的聊天记录格式
                const dbMessages = await db.chatMessages.toArray();
                console.log('📊 数据库中的聊天记录格式分析:');
                console.log(`总数: ${dbMessages.length} 条`);

                if (dbMessages.length > 0) {
                    const sample = dbMessages[0];
                    console.log('样本记录结构:', Object.keys(sample));
                    console.log('样本记录:', sample);

                    const hasMessageData = dbMessages.some(msg => msg.messageData);
                    const hasDirectContent = dbMessages.some(msg => msg.content);

                    console.log(`包含messageData字段: ${hasMessageData}`);
                    console.log(`包含直接content字段: ${hasDirectContent}`);
                }

                // 检查内存中的聊天记录格式
                console.log('📊 内存中的聊天记录格式分析:');
                const memoryMessageCount = Object.values(chatMessages).reduce((total, msgs) => total + msgs.length, 0);
                console.log(`总数: ${memoryMessageCount} 条`);

                if (memoryMessageCount > 0) {
                    const firstCharacter = Object.keys(chatMessages)[0];
                    const firstMessage = chatMessages[firstCharacter]?.[0];
                    if (firstMessage) {
                        console.log('内存样本记录结构:', Object.keys(firstMessage));
                        console.log('内存样本记录:', firstMessage);
                    }
                }

                showToast('📊 聊天记录格式分析完成，请查看控制台', 'info');
            } catch (error) {
                console.error('调试聊天记录格式失败:', error);
                showToast('调试失败: ' + error.message, 'error');
            }
        }

        // 🔥【新增】清理localStorage中的旧chatSettings数据
        async function cleanupOldChatSettingsFromLocalStorage() {
            try {
                let cleanedCount = 0;
                const keysToRemove = [];

                // 收集所有chatSettings相关的localStorage键
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && (key === 'chatSettings' || key.startsWith('chatSettings_')) && !key.includes('emergency')) {
                        keysToRemove.push(key);
                    }
                }

                // 确认IndexedDB中有数据后再清理
                const indexedDBSettings = await db.chatSettings.toArray();
                if (indexedDBSettings.length > 0 && keysToRemove.length > 0) {
                    const confirmCleanup = confirm(
                        `检测到 ${keysToRemove.length} 个旧的localStorage聊天设置数据。\n\n` +
                        `IndexedDB中已有 ${indexedDBSettings.length} 个设置，可以安全清理localStorage数据。\n\n` +
                        `是否清理以释放存储空间？`
                    );

                    if (confirmCleanup) {
                        keysToRemove.forEach(key => {
                            localStorage.removeItem(key);
                            cleanedCount++;
                        });

                        console.log(`✅ 已清理 ${cleanedCount} 个旧的localStorage聊天设置`);
                        showToast(`🧹 已清理 ${cleanedCount} 个旧设置数据`, 'success');
                    }
                }
            } catch (error) {
                console.error('清理旧chatSettings数据失败:', error);
            }
        }

        // 🔥【重构】保存聊天设置 - 完全依赖IndexedDB，避免数据丢失
        async function saveChatSettings() {
            try {
                // 将chatSettings对象转换为数组格式存储到IndexedDB
                const chatSettingsArray = Object.keys(chatSettings).map(chatId => ({
                    id: chatId,
                    chatId: chatId,
                    settings: chatSettings[chatId]
                }));

                if (chatSettingsArray.length === 0) {
                    console.warn('⚠️ 聊天设置数据为空，跳过保存操作');
                    return;
                }

                // 🔥【安全修复】使用bulkPut代替clear+bulkAdd，避免数据丢失
                await db.chatSettings.bulkPut(chatSettingsArray);

                console.log(`✅ 安全保存了 ${chatSettingsArray.length} 个聊天设置到IndexedDB`);

            } catch (error) {
                console.error('🚨 保存聊天设置到IndexedDB失败:', error);

                // 🔥【紧急备份】只在IndexedDB完全失败时才使用localStorage
                try {
                    console.warn('⚠️ 正在进行紧急备份到localStorage...');
                    const emergencyBackup = {};
                    Object.keys(chatSettings).forEach(chatId => {
                        // 只保存最关键的设置，避免localStorage容量问题
                        emergencyBackup[chatId] = {
                            bubbleStyle: chatSettings[chatId].bubbleStyle,
                            aiChatAvatar: chatSettings[chatId].aiChatAvatar,
                            myChatAvatar: chatSettings[chatId].myChatAvatar,
                            aiChatNickname: chatSettings[chatId].aiChatNickname,
                            myChatNickname: chatSettings[chatId].myChatNickname,
                            hideAvatars: chatSettings[chatId].hideAvatars,
                            selectedIdentityId: chatSettings[chatId].selectedIdentityId,
                            timestampEnabled: chatSettings[chatId].timestampEnabled,
                            timestampPosition: chatSettings[chatId].timestampPosition
                        };
                    });

                    localStorage.setItem('chatSettings_emergency_backup', JSON.stringify(emergencyBackup));
                    console.log('✅ 紧急备份已保存到localStorage');

                    // 显示用户友好的错误提示
                    showToast('⚠️ 数据库保存失败，已启用紧急备份模式', 'warning');

                } catch (localStorageError) {
                    console.error('🚨 紧急备份也失败了:', localStorageError);
                    showToast('❌ 设置保存失败！请检查存储空间', 'error');
                    throw localStorageError;
                }
            }
        }

        // === 后台互动系统 ===
        let backgroundTimers = {};

        // 🔥【新增】全局后台互动系统初始化 - 为所有角色设置定时器
        async function initGlobalBackgroundInteractionSystem() {
            console.log('🚀 启动全局后台互动系统...');

            // 🔥【修复】不要清除现有定时器，避免与全局动态发布系统冲突
            // clearAllBackgroundTimers();

            // 为每个角色设置后台互动定时器
            for (const character of characters) {
                try {
                    const chatSettings = await getChatSettings(character.id);

                    // 🔥【修复】正确检查后台互动开关状态
                    const backgroundInteractionEnabled = chatSettings.backgroundInteractionEnabled === true;
                    const backgroundChatEnabled = chatSettings.backgroundChatEnabled === true;
                    const backgroundMomentsEnabled = chatSettings.backgroundMomentsEnabled === true;

                    if (!backgroundInteractionEnabled) {
                        console.log(`角色 ${character.name} 的后台互动已禁用，跳过`);
                        continue;
                    }

                    console.log(`为角色 ${character.name} 设置后台互动定时器`);

                    // 设置主动聊天定时器 - 需要同时检查总开关和子开关
                    if (backgroundInteractionEnabled && backgroundChatEnabled) {
                        // 🔥【修复】检查是否有聊天记录，如果没有则不设置定时器
                        const messages = chatMessages[character.id] || [];
                        const hasUserMessages = messages.some(msg => msg.sender === 'sent');

                        if (hasUserMessages) {
                            await scheduleProactiveChatForCharacter(character.id);
                            console.log(`✅ [全局初始化] ${character.name} 动态主动聊天定时器已设置`);
                        } else {
                            console.log(`⏸️ [全局初始化] ${character.name} 没有用户消息记录，暂不设置主动聊天定时器`);
                        }
                    } else {
                        console.log(`🚫 [全局初始化] ${character.name} 主动聊天开关未开启`);
                    }

                    // 设置主动发动态定时器 - 需要同时检查总开关和子开关
                    if (backgroundInteractionEnabled && backgroundMomentsEnabled) {
                        const momentsInterval = getBackgroundMomentsInterval(chatSettings.backgroundMomentsFrequency || 'low');
                        backgroundTimers[character.id + '_moments'] = setInterval(() => {
                            triggerBackgroundMoments(character.id);
                        }, momentsInterval);
                        console.log(`${character.name} 主动发动态定时器已设置，间隔: ${momentsInterval}ms`);
                    }

                    // 🔥【新增】设置后台写日记定时器
                    await initBackgroundDiarySystem(character.id);
                } catch (error) {
                    console.error(`为角色 ${character.name} 设置后台互动定时器失败:`, error);
                }
            }
        }

        // 初始化后台互动系统（单个角色）
        async function initBackgroundInteractionSystem() {
            // 🔥【重要修复】这个函数不应该在角色切换时重新设置定时器！
            // 定时器应该是全局的，在页面加载时设置一次即可
            // 这里只是为了兼容性保留，实际不做任何操作
            console.log('⚠️ [已废弃] initBackgroundInteractionSystem 被调用，但不执行任何操作');
            console.log('💡 [提示] 后台定时器由全局系统管理，请使用 initGlobalBackgroundInteractionSystem');
        }

        // 清除所有后台定时器
        function clearAllBackgroundTimers() {
            Object.values(backgroundTimers).forEach(timer => {
                if (timer) clearInterval(timer);
            });
            backgroundTimers = {};

            // 🔥【新增】同时清除后台写日记定时器
            Object.values(backgroundDiaryTimers).forEach(timer => {
                if (timer) clearTimeout(timer);
            });
            backgroundDiaryTimers = {};
        }

        // 🔥【新增】后台写日记系统
        let backgroundDiaryTimers = {};

        // 保存日记时间设置
        async function saveDiaryTime() {
            if (!currentChatCharacter) {
                showToast('请先选择角色', 'error');
                return;
            }

            const timeInput = document.getElementById('diary-time-input');
            const selectedTime = timeInput.value;

            if (!selectedTime) {
                showToast('请选择写日记的时间', 'error');
                return;
            }

            // 保存到聊天设置
            const chatSettings = getCurrentChatSettings();
            chatSettings.backgroundDiaryTime = selectedTime;
            await saveCurrentChatSettings(chatSettings);

            // 🔥【修复】只重新安排定时器，不要立即触发
            if (currentChatCharacter) {
                // 先清除现有的日记定时器
                if (backgroundDiaryTimers[currentChatCharacter.id]) {
                    clearTimeout(backgroundDiaryTimers[currentChatCharacter.id]);
                    delete backgroundDiaryTimers[currentChatCharacter.id];
                }

                // 检查是否启用了后台写日记
                if (chatSettings.backgroundInteractionEnabled && chatSettings.backgroundDiaryEnabled) {
                    console.log(`⏰ 重新为 ${currentChatCharacter.name} 设置后台写日记定时器，时间: ${selectedTime}`);
                    scheduleBackgroundDiary(currentChatCharacter.id, selectedTime);
                }
            }

            showToast(`已设置 ${currentChatCharacter.name} 在 ${selectedTime} 写日记`, 'success');
        }

        // 初始化后台写日记系统
        async function initBackgroundDiarySystem(characterId) {
            // 清除现有的日记定时器
            if (backgroundDiaryTimers[characterId]) {
                clearTimeout(backgroundDiaryTimers[characterId]);
                delete backgroundDiaryTimers[characterId];
            }

            const character = characters.find(c => c.id === characterId);
            if (!character) return;

            // 群聊不支持日记功能
            if (character.isGroup) {
                console.log(`🚫 群聊 ${character.name} 不支持后台写日记功能`);
                return;
            }

            const chatSettings = await getChatSettings(characterId);
            const backgroundInteractionEnabled = chatSettings.backgroundInteractionEnabled === true;
            const backgroundDiaryEnabled = chatSettings.backgroundDiaryEnabled === true;
            const diaryTime = chatSettings.backgroundDiaryTime;

            if (!backgroundInteractionEnabled || !backgroundDiaryEnabled || !diaryTime) {
                console.log(`🚫 ${character.name} 后台写日记未启用或未设置时间`);
                return;
            }

            console.log(`⏰ 为 ${character.name} 设置后台写日记定时器，时间: ${diaryTime}`);
            scheduleBackgroundDiary(characterId, diaryTime);
        }

        // 安排后台写日记
        function scheduleBackgroundDiary(characterId, diaryTime) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;

            // 解析时间
            const [hours, minutes] = diaryTime.split(':').map(Number);
            console.log(`⏰ [日记定时器] 解析时间: ${hours}:${minutes}`);

            // 计算下次写日记的时间
            const now = new Date();
            const targetTime = new Date();
            targetTime.setHours(hours, minutes, 0, 0);

            console.log(`⏰ [日记定时器] 当前时间: ${now.toLocaleString()}`);
            console.log(`⏰ [日记定时器] 目标时间: ${targetTime.toLocaleString()}`);

            // 🔥【修复】如果今天的时间已过，设置为明天
            if (targetTime <= now) {
                targetTime.setDate(targetTime.getDate() + 1);
                console.log(`⏰ [日记定时器] 今天时间已过，调整为明天: ${targetTime.toLocaleString()}`);
            }

            // 添加随机波动（±5分钟）
            const fluctuation = (Math.random() - 0.5) * 10 * 60 * 1000; // ±5分钟的毫秒数
            targetTime.setTime(targetTime.getTime() + fluctuation);

            const delay = targetTime.getTime() - now.getTime();

            console.log(`📝 ${character.name} 将在 ${targetTime.toLocaleString()} 写日记（${Math.round(delay / 60000)} 分钟后）`);
            console.log(`⏰ [日记定时器] 延迟时间: ${delay}ms`);

            // 🔥【修复】确保延迟时间为正数
            if (delay <= 0) {
                console.warn(`⚠️ [日记定时器] 延迟时间为负数或零，立即触发`);
                setTimeout(async () => {
                    await triggerBackgroundDiary(characterId);
                }, 1000); // 1秒后触发
                return;
            }

            // 设置定时器
            backgroundDiaryTimers[characterId] = setTimeout(async () => {
                console.log(`⏰ [日记定时器] ${character.name} 定时器触发！`);
                await triggerBackgroundDiary(characterId);
                // 安排下一次写日记（明天同一时间）
                scheduleBackgroundDiary(characterId, diaryTime);
            }, delay);

            console.log(`✅ [日记定时器] ${character.name} 定时器已设置，ID: ${backgroundDiaryTimers[characterId]}`);
        }

        // 触发后台写日记
        async function triggerBackgroundDiary(characterId) {
            const character = characters.find(c => c.id === characterId);
            if (!character) {
                console.error(`❌ 找不到角色 ID: ${characterId}`);
                return;
            }

            console.log(`📝 ${character.name} 开始后台写日记...`);

            try {
                // 检查今天是否已经有日记
                const today = new Date().toISOString().split('T')[0];
                const diaryId = `${characterId}_${today}`;
                console.log(`📝 检查日记ID: ${diaryId}`);

                const existingDiary = await db.characterDiaries.get(diaryId);

                if (existingDiary && existingDiary.content) {
                    console.log(`📝 ${character.name} 今天已经写过日记了，跳过`);
                    return;
                }

                console.log(`📝 ${character.name} 开始生成日记内容...`);
                // 生成日记内容
                const diaryContent = await generateBackgroundDiary(character);
                console.log(`📝 ${character.name} 日记内容生成结果:`, diaryContent ? '成功' : '失败');

                if (diaryContent) {
                    // 保存日记到数据库
                    const diaryData = {
                        id: diaryId,
                        characterId: characterId,
                        date: today,
                        content: diaryContent,
                        timestamp: Date.now(),
                        weather: getRandomWeather()
                    };

                    console.log(`📝 ${character.name} 保存日记到数据库...`, diaryData);
                    await db.characterDiaries.put(diaryData);

                    console.log(`✅ ${character.name} 后台写日记完成！内容: ${diaryContent.substring(0, 50)}...`);

                    // 创建系统推送通知
                    createDiaryNotification(character);
                } else {
                    console.error(`❌ ${character.name} 后台写日记失败：内容生成失败`);
                }
            } catch (error) {
                console.error(`❌ ${character.name} 后台写日记失败:`, error);
            }
        }

        // 生成后台日记内容
        async function generateBackgroundDiary(character) {
            try {
                console.log(`📝 [日记生成] 开始为 ${character.name} 生成日记内容...`);

                // 获取聊天历史作为日记素材
                const messages = chatMessages[character.id] || [];
                const recentMessages = messages.slice(-20); // 最近20条消息
                console.log(`📝 [日记生成] 获取到 ${recentMessages.length} 条最近消息`);

                // 构建日记生成prompt
                const currentDate = new Date().toLocaleDateString('zh-CN', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    weekday: 'long'
                });

                const weather = getRandomWeather();

                let chatContext = '';
                if (recentMessages.length > 0) {
                    chatContext = '\n\n最近的聊天内容：\n' +
                        recentMessages.map(msg => {
                            const sender = msg.sender === 'sent' ? '用户' : character.name;
                            return `${sender}: ${msg.text || msg.content || '[特殊消息]'}`;
                        }).join('\n');
                }

                // 🔥【修复】使用与手动写日记相同的详细prompt格式
                const prompt = `你是${character.name}，你的人设如下：${character.bio}

现在是${currentDate}，你需要写一篇私人日记。

重要要求：
- 请直接输出日记内容，不要使用JSON格式或任何代码块
- 请在日记开头自己写上日期和天气，格式如："${currentDate}，天气：${weather}"
- 用你的口吻和性格来写
- 记录你今天的想法、感受和经历
- 可以提及对用户的真实感情
- 基于最近的聊天记录，可适当考虑与用户的互动
- 保持角色的一致性和真实性
- 内容要自然、真实，像真正的私人日记
- 字数在100-200字之间，根据你的性格和当天的心情自由发挥${chatContext}

特殊样式说明（可选使用，每种样式在同一篇日记中最多使用1次）：
- 如果写到不该说的话或后悔写下的内容，可以用 <strike>内容</strike> 标记划掉
- 如果表达重点或语气激动的内容，可以用 <mark>内容</mark> 标记高亮

请直接写出${character.name}的私人日记内容：`;

                console.log(`📝 [日记生成] 调用API生成日记，prompt长度: ${prompt.length}`);
                // 🔥【修复】使用generateAIResponse而不是直接调用callChatAPI
                const response = await generateAIResponse(prompt, character);
                console.log(`📝 [日记生成] API响应:`, response ? `成功，长度: ${response.length}` : '失败或为空');

                if (response && response.trim()) {
                    let finalDiary = response.trim();

                    // 🔥【修复】添加与手动写日记相同的格式清理
                    finalDiary = cleanDiaryContent(finalDiary);

                    console.log(`📝 [日记生成] ${character.name} 日记内容生成成功`);
                    return finalDiary;
                }

                console.warn(`📝 [日记生成] ${character.name} 日记内容为空`);
                return null;
            } catch (error) {
                console.error(`📝 [日记生成] ${character.name} 生成失败:`, error);
                return null;
            }
        }

        // 创建日记推送通知
        function createDiaryNotification(character) {
            const notificationText = `📖 ${character.name}写日记啦~\n快来看看吧`;

            // 🔥【新增】为日记通知添加特殊标识，以便在点击时跳转到日记界面
            const diaryNotificationText = `[日记] ${notificationText}`;

            // 使用现有的推送通知系统，设置较高优先级
            createPushNotification(character, diaryNotificationText, 100);
        }

        // 获取随机天气
        function getRandomWeather() {
            const weathers = ['☀️', '⛅', '☁️', '🌧️', '⛈️', '🌨️', '🌤️', '🌦️'];
            return weathers[Math.floor(Math.random() * weathers.length)];
        }

        // 🔥【新增】测试后台写日记功能
        async function testBackgroundDiary() {
            if (!currentChatCharacter) {
                showToast('请先选择角色', 'error');
                return;
            }

            if (currentChatCharacter.isGroup) {
                showToast('群聊不支持日记功能', 'error');
                return;
            }

            console.log(`🧪 [测试] 手动触发 ${currentChatCharacter.name} 写日记...`);
            await triggerBackgroundDiary(currentChatCharacter.id);
        }

        // 🔥【新增】调试后台定时器状态
        function debugBackgroundTimers() {
            console.log('🔍 [调试] 当前后台定时器状态:');
            console.log('backgroundTimers:', Object.keys(backgroundTimers));
            console.log('backgroundDiaryTimers:', Object.keys(backgroundDiaryTimers));

            Object.keys(backgroundDiaryTimers).forEach(characterId => {
                const character = characters.find(c => c.id === characterId);
                const timerExists = backgroundDiaryTimers[characterId] !== null && backgroundDiaryTimers[characterId] !== undefined;
                console.log(`📝 ${character?.name || characterId}: 定时器${timerExists ? '存在' : '不存在'}`);
            });
        }

        // 全局定时发布系统
        let globalMomentsTimers = {};
        let globalMomentsCheckInterval = null;

        // 初始化全局动态发布系统
        async function initGlobalMomentsSystem() {
            console.log('🚀 初始化全局动态发布系统');

            // 清除现有的定时器
            clearGlobalMomentsTimers();

            // 为所有角色设置后台发布定时器
            let activeCount = 0;
            if (characters && characters.length > 0) {
                for (const character of characters) {
                    const chatSettings = await getChatSettings(character.id);

                    // 🔥【修复】检查是否启用了后台发动态，需要同时检查总开关和子开关
                    if (chatSettings.backgroundInteractionEnabled === true && chatSettings.backgroundMomentsEnabled === true) {
                        const frequency = chatSettings.backgroundMomentsFrequency || 'low';
                        const interval = getBackgroundMomentsInterval(frequency);

                        globalMomentsTimers[character.id] = setInterval(async () => {
                            console.log(`⏰ 定时器触发：${character.name} 准备发布动态`);
                            await triggerBackgroundMoments(character.id);
                        }, interval);

                        activeCount++;
                        console.log(`✅ 为角色 ${character.name} 设置了后台发动态定时器，间隔: ${Math.round(interval/1000/60)}分钟`);
                    }

                    // 检查是否有定时发布时间点
                    if (chatSettings.scheduledMomentsEnabled && chatSettings.scheduledMomentsTimes && chatSettings.scheduledMomentsTimes.length > 0) {
                        console.log(`⏰ 角色 ${character.name} 启用了定时发布，时间点:`, chatSettings.scheduledMomentsTimes);
                    }
                }
            }

            // 启动定时检查器（每分钟检查一次是否到了发布时间）
            if (!globalMomentsCheckInterval) {
                globalMomentsCheckInterval = setInterval(async () => {
                    await checkScheduledMomentsTime();
                }, 60000); // 每分钟检查一次

                console.log('⏰ 启动了定时发布时间检查器');
            }

            console.log(`🎉 全局动态发布系统初始化完成，激活了 ${activeCount} 个角色的后台发布`);
        }

        // 检查定时发布时间
        async function checkScheduledMomentsTime() {
            const now = new Date();
            const currentTime = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;

            if (characters && characters.length > 0) {
                for (const character of characters) {
                    const chatSettings = await getChatSettings(character.id);

                    if (chatSettings.scheduledMomentsEnabled &&
                        chatSettings.scheduledMomentsTimes &&
                        chatSettings.scheduledMomentsTimes.includes(currentTime)) {

                        console.log(`⏰ 定时发布时间到：${character.name} 在 ${currentTime} 发布动态`);
                        await triggerBackgroundMoments(character.id, true); // 跳过冷却时间
                    }
                }
            }
        }

        // 清除全局动态定时器
        function clearGlobalMomentsTimers() {
            Object.values(globalMomentsTimers).forEach(timer => {
                if (timer) clearInterval(timer);
            });
            globalMomentsTimers = {};

            if (globalMomentsCheckInterval) {
                clearInterval(globalMomentsCheckInterval);
                globalMomentsCheckInterval = null;
            }
        }

        // 🔥【修复】获取后台聊天间隔时间 - 改为随机间隔，符合用户需求
        function getBackgroundInterval(frequency) {
            switch (frequency) {
                case 'low':
                    // 1-2小时随机间隔
                    return Math.random() * 60 * 60 * 1000 + 60 * 60 * 1000;
                case 'medium':
                    // 30-60分钟随机间隔
                    return Math.random() * 30 * 60 * 1000 + 30 * 60 * 1000;
                case 'high':
                    // 10-30分钟随机间隔
                    return Math.random() * 20 * 60 * 1000 + 10 * 60 * 1000;
                default:
                    // 默认1-2小时
                    return Math.random() * 60 * 60 * 1000 + 60 * 60 * 1000;
            }
        }

        // 🔥【新增】为角色设置动态主动聊天定时器
        async function scheduleProactiveChatForCharacter(characterId) {
            // 清除现有定时器
            if (backgroundTimers[characterId + '_chat']) {
                clearTimeout(backgroundTimers[characterId + '_chat']);
                delete backgroundTimers[characterId + '_chat'];
            }

            // 🔥【关键修复】在设置定时器前检查开关状态
            const character = characters.find(c => c.id === characterId);
            if (!character) {
                console.log(`🚫 [定时器设置] 角色不存在: ${characterId}`);
                return;
            }

            const chatSettings = await getAsyncChatSettings(characterId);
            const backgroundInteractionEnabled = chatSettings.backgroundInteractionEnabled === true;
            const backgroundChatEnabled = chatSettings.backgroundChatEnabled === true;

            console.log(`🔍 [定时器设置] ${character.name}:`, {
                backgroundInteractionEnabled,
                backgroundChatEnabled
            });

            // 🔥【修复】严格检查开关状态 - 必须两个开关都开启
            if (!backgroundInteractionEnabled || !backgroundChatEnabled) {
                console.log(`🚫 [定时器设置] ${character.name} 开关未开启，不设置定时器`);
                return;
            }

            // 检查用户最后回复时间
            const messages = chatMessages[characterId] || [];
            const lastUserMessage = messages.slice().reverse().find(msg => msg.sender === 'sent');

            if (!lastUserMessage) {
                console.log(`🚫 [定时器设置] ${character.name} 没有用户消息记录，不设置定时器`);
                return;
            }

            const timeSinceLastUserMessage = Date.now() - lastUserMessage.timestamp;
            const tenMinutes = 10 * 60 * 1000; // 10分钟
            console.log(`🕐 [定时器设置] ${character.name}: 距离用户最后回复 ${Math.round(timeSinceLastUserMessage / 60000)} 分钟`);

            let delay;
            if (timeSinceLastUserMessage < tenMinutes) {
                // 用户最近有回复，等待10分钟后再开始计时
                delay = tenMinutes - timeSinceLastUserMessage;
                console.log(`⏰ [定时器设置] ${character.name} 将在${Math.round(delay / 60000)}分钟后开始主动聊天计时`);
            } else {
                // 用户已经超过10分钟没回复，立即开始随机计时
                delay = 0;
                console.log(`⏰ [定时器设置] ${character.name} 立即开始主动聊天计时`);
            }

            // 设置定时器
            backgroundTimers[characterId + '_chat'] = setTimeout(async () => {
                // 10分钟等待期结束，现在开始随机间隔计时
                const character = characters.find(c => c.id === characterId);
                if (!character) return;

                // 🔥【关键修复】在定时器执行时再次检查开关状态
                const currentChatSettings = await getAsyncChatSettings(characterId);
                const currentBackgroundInteractionEnabled = currentChatSettings.backgroundInteractionEnabled === true;
                const currentBackgroundChatEnabled = currentChatSettings.backgroundChatEnabled === true;

                console.log(`🔍 [定时器执行检查] ${character.name}:`, {
                    currentBackgroundInteractionEnabled,
                    currentBackgroundChatEnabled
                });

                // 🔥【修复】如果开关被关闭，取消定时器
                if (!currentBackgroundInteractionEnabled || !currentBackgroundChatEnabled) {
                    console.log(`🚫 [定时器执行] ${character.name} 开关已关闭，取消主动聊天`);
                    return;
                }

                const randomInterval = getBackgroundInterval(currentChatSettings.backgroundChatFrequency || 'low');
                console.log(`⏰ [定时器执行] ${character.name} 将在${Math.round(randomInterval / 60000)}分钟后发送主动消息`);

                // 设置实际的主动聊天定时器
                backgroundTimers[characterId + '_chat'] = setTimeout(() => {
                    triggerBackgroundChat(characterId);
                    // 发送完消息后，重新安排下次的主动聊天
                    scheduleProactiveChatForCharacter(characterId);
                }, randomInterval);
            }, delay);
        }

        // 🔥【新增】当用户发送消息时，重新安排主动聊天定时器
        function onUserMessageSent(characterId) {
            const character = characters.find(c => c.id === characterId);
            console.log(`用户向 ${character?.name} 发送了消息，重新安排主动聊天定时器`);
            // 重新安排该角色的主动聊天定时器
            scheduleProactiveChatForCharacter(characterId);
        }

        // 🔥【新增】手动重新初始化所有角色的主动聊天定时器
        async function reinitializeProactiveChatTimers() {
            console.log('🔄 重新初始化所有角色的主动聊天定时器...');

            for (const character of characters) {
                try {
                    const chatSettings = await getChatSettings(character.id);
                    const backgroundInteractionEnabled = chatSettings.backgroundInteractionEnabled === true;
                    const backgroundChatEnabled = chatSettings.backgroundChatEnabled === true;

                    if (backgroundInteractionEnabled && backgroundChatEnabled) {
                        const messages = chatMessages[character.id] || [];
                        const hasUserMessages = messages.some(msg => msg.sender === 'sent');

                        if (hasUserMessages) {
                            await scheduleProactiveChatForCharacter(character.id);
                            console.log(`✅ ${character.name} 主动聊天定时器已重新设置`);
                        } else {
                            console.log(`⏸️ ${character.name} 没有用户消息记录，跳过定时器设置`);
                        }
                    } else {
                        console.log(`🚫 ${character.name} 主动聊天功能已禁用`);
                    }
                } catch (error) {
                    console.error(`❌ 为 ${character.name} 设置主动聊天定时器失败:`, error);
                }
            }

            console.log('🎉 主动聊天定时器重新初始化完成');
        }

        // 获取后台动态间隔时间
        function getBackgroundMomentsInterval(frequency) {
            switch (frequency) {
                case 'low':
                    return Math.random() * 4 * 60 * 60 * 1000 + 4 * 60 * 60 * 1000; // 4-8小时
                case 'medium':
                    return Math.random() * 2 * 60 * 60 * 1000 + 2 * 60 * 60 * 1000; // 2-4小时
                case 'high':
                    return Math.random() * 60 * 60 * 1000 + 60 * 60 * 1000; // 1-2小时
                default:
                    return Math.random() * 4 * 60 * 60 * 1000 + 4 * 60 * 60 * 1000; // 默认4-8小时
            }
        }

        // 触发后台聊天
        async function triggerBackgroundChat(characterId, skipTimeCheck = false) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) {
                    console.log(`🚫 [主动聊天] 角色不存在: ${characterId}`);
                    return;
                }

                // 🔥【关键修复】首先检查开关状态
                const chatSettings = await getAsyncChatSettings(characterId);
                const backgroundInteractionEnabled = chatSettings.backgroundInteractionEnabled === true;
                const backgroundChatEnabled = chatSettings.backgroundChatEnabled === true;

                console.log(`🔍 [主动聊天检查] ${character.name}:`, {
                    backgroundInteractionEnabled,
                    backgroundChatEnabled,
                    skipTimeCheck
                });

                // 🔥【修复】严格检查开关状态 - 必须两个开关都开启
                if (!backgroundInteractionEnabled || !backgroundChatEnabled) {
                    console.log(`🚫 [主动聊天] ${character.name} 开关未开启，取消发送`);
                    return;
                }

                // 检查用户是否至少10分钟没有回复（测试时可跳过）
                if (!skipTimeCheck) {
                    const messages = chatMessages[characterId] || [];
                    const lastUserMessage = messages.slice().reverse().find(msg => msg.sender === 'sent');

                    if (lastUserMessage) {
                        const timeSinceLastUserMessage = Date.now() - lastUserMessage.timestamp;
                        const tenMinutes = 10 * 60 * 1000; // 10分钟
                        console.log(`🕐 [主动聊天时间检查] ${character.name}: 距离用户最后回复 ${Math.round(timeSinceLastUserMessage / 60000)} 分钟`);

                        if (timeSinceLastUserMessage < tenMinutes) {
                            console.log(`🚫 [主动聊天] ${character.name} 跳过：用户最近${Math.round(timeSinceLastUserMessage / 60000)}分钟前有回复`);
                            return; // 用户最近有活动，不发送自动消息
                        }

                        // 🔥【新增】检查是否已经在等待期内发送过主动消息
                        const lastAIMessage = messages.slice().reverse().find(msg => msg.sender === 'received');
                        if (lastAIMessage && lastAIMessage.isProactive) {
                            // 如果最后一条AI消息是主动消息，检查是否在合理的时间间隔内
                            const timeSinceLastProactive = Date.now() - lastAIMessage.timestamp;
                            const minInterval = getBackgroundInterval(chatSettings.backgroundChatFrequency || 'low');

                            if (timeSinceLastProactive < minInterval) {
                                console.log(`${character.name} 跳过主动聊天：距离上次主动消息仅${Math.round(timeSinceLastProactive / 60000)}分钟`);
                                return;
                            }
                        }
                    }
                } else {
                    console.log(`${character.name} 测试模式：跳过10分钟时间检查`);
                }

                // 🔥【修复】使用用户设置的历史消息回合数和跨窗口记忆数
                const historyCount = chatSettings.historyCount || 5;
                const crossWindowMemory = chatSettings.crossWindowMemory || 3;

                // 🔥【修复】获取聊天消息（我之前不小心删除了这行）
                const messages = chatMessages[characterId] || [];

                // 🔥【关键修复】按回合数正确计算历史消息，而不是简单的消息条数
                let recentMessages;
                if (messages.length > 0) {
                    // 使用与正常聊天相同的逻辑：按回合计算消息
                    recentMessages = calculateMessagesByRounds(messages, historyCount);
                } else {
                    recentMessages = [];
                }

                // 🔥【增强】获取角色可见的动态内容，包含分组过滤、时间戳和评论区
                const recentMoments = await getVisibleMomentsForCharacter(characterId, crossWindowMemory);
                let momentsContext = '';
                if (recentMoments.length > 0) {
                    momentsContext = '\n\n最近的动态内容和讨论：\n';
                    recentMoments.forEach((moment, index) => {
                        const authorName = moment.authorId === 'user' ? '用户' : moment.nickname;

                        // 🔥【新增】添加时间戳信息
                        let timeInfo = '';
                        if (moment.timestamp) {
                            const now = Date.now();
                            const timeDiff = now - moment.timestamp;
                            const minutes = Math.floor(timeDiff / (1000 * 60));
                            const hours = Math.floor(timeDiff / (1000 * 60 * 60));
                            const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));

                            if (days > 0) {
                                timeInfo = `（${days}天前发布）`;
                            } else if (hours > 0) {
                                timeInfo = `（${hours}小时前发布）`;
                            } else if (minutes > 0) {
                                timeInfo = `（${minutes}分钟前发布）`;
                            } else {
                                timeInfo = '（刚刚发布）';
                            }
                        }

                        // 🔥【新增】包含评论区内容
                        const momentContent = `${authorName}: ${moment.text}${timeInfo}${moment.commentsText || ''}`;
                        momentsContext += momentContent;
                    });
                }

                // 构建聊天历史上下文
                let chatContext = '';
                if (recentMessages.length > 0) {
                    chatContext = '\n\n最近的聊天记录：\n' +
                        recentMessages.map(msg => {
                            if (msg.sender === 'sent') return `用户：${msg.content}`;
                            if (msg.sender === 'received') return `${character.name}：${msg.content}`;
                            return '';
                        }).filter(Boolean).join('\n');
                }

                // 🔥【调试】输出聊天历史信息
                console.log(`🔍 [主动聊天调试] ${character.name}:`);
                console.log(`  📝 总消息数: ${messages.length}`);
                console.log(`  📊 最近消息数: ${recentMessages.length}`);
                console.log(`  📋 聊天历史长度: ${chatContext.length}`);
                if (recentMessages.length > 0) {
                    console.log(`  🕐 最后一条消息: ${recentMessages[recentMessages.length - 1].content.substring(0, 50)}...`);
                    console.log(`  📜 完整聊天历史:`, chatContext);
                }

                // 🔥【修复】获取世界书信息
                let worldbookContext = '';
                if (character.worldbook && character.worldbook.length > 0) {
                    worldbookContext = '\n\n世界书信息：\n' +
                        character.worldbook.map(entry => `${entry.key}: ${entry.value}`).join('\n');
                }

                // 🔥【修复】生成更完整的主动聊天内容，包含人设、世界书、历史消息、动态等
                const prompt = `你是${character.name}，你的人设如下：${character.bio}${worldbookContext}

现在你要主动给用户发送一条消息。这条消息应该是：
1. 严格符合你的人设和性格特点
2. 自然、有趣、有互动性
3. 可以是问候、分享、询问、关心等
4. 不要过于正式，要像朋友间的日常聊天
5. **重要**：如果有聊天历史，必须仔细阅读并基于历史内容进行自然的延续或回应，绝对不要重复之前已经说过的内容
6. 可以适当提及最近的动态内容，让对话更自然
7. 考虑当前时间和情境，让消息更贴合实际
8. 保持角色的一致性和连贯性
9. **禁止重复**：不要发送与聊天历史中相同或相似的消息内容${chatContext}${momentsContext}

请生成主动聊天的消息（可以是1-12条），以JSON数组格式返回：`;

                const response = await generateAIResponse(prompt, character);
                if (response && response.trim()) {
                    // 🔥【修复】使用与正常AI回复相同的处理逻辑
                    const aiMessages = await parseAiResponse(response);

                    if (!chatMessages[characterId]) {
                        chatMessages[characterId] = [];
                    }

                    // 🔥【修复】使用与processAIReply相同的消息处理逻辑
                    for (let i = 0; i < aiMessages.length; i++) {
                        const msgData = aiMessages[i];
                        let aiMessage;

                        // 🔥【修复】跳过拉黑指令对象
                        if (typeof msgData === 'object' && msgData !== null && msgData.type === 'block_user') {
                            console.log('🚫 跳过拉黑指令对象，不显示为消息:', msgData);
                            continue;
                        }

                        if (typeof msgData === 'object' && msgData !== null) {
                            if (msgData.type === 'voice_message') {
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    type: 'voice_message',
                                    content: msgData.content,
                                    timestamp: Date.now() + i * 100
                                };
                            } else if (msgData.type === 'ai_image') {
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    type: 'ai_image',
                                    content: msgData.description || 'AI描述的图片',
                                    imageDescription: msgData.description,
                                    timestamp: Date.now() + i * 100
                                };
                            } else if (msgData.type === 'transfer') {
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    type: 'transfer',
                                    amount: msgData.amount,
                                    note: msgData.note,
                                    timestamp: Date.now() + i * 100
                                };
                            } else if (msgData.type === 'poke') {
                                // 🔥【新增】处理AI主动戳一戳
                                console.log('🔍 [callChatAPI] AI主动戳一戳:', msgData);
                                const chatSettings = getCurrentChatSettings();
                                const userNickname = chatSettings.myChatNickname || '你';
                                const pokeSuffix = chatSettings.myPokeSuffix || ''; // 🔥【修复】AI戳用户应该使用myPokeSuffix

                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'system',
                                    content: `${currentChatCharacter.name}戳了戳${userNickname}${pokeSuffix}`,
                                    timestamp: Date.now() + i * 100,
                                    isPoke: true
                                };
                            } else if (msgData.type === 'emoji') {
                                const matchingEmoji = await findEmojiForAI(msgData.description);
                                if (matchingEmoji) {
                                    aiMessage = {
                                        id: (Date.now() + i).toString(),
                                        sender: 'received',
                                        content: '',
                                        image: matchingEmoji.url,
                                        isEmoji: true,
                                        emojiDescription: matchingEmoji.description,
                                        timestamp: Date.now() + i * 100
                                    };

                                    // 🔥【修复】如果是群聊消息，添加发送者信息
                                    if (msgData.name) {
                                        aiMessage.name = msgData.name;
                                        // 查找对应的群成员ID
                                        const group = groupChats.find(g => g.id === characterId);
                                        if (group && group.members) {
                                            const member = group.members.find(m => m.name === msgData.name);
                                            if (member) {
                                                aiMessage.senderId = member.id;
                                            }
                                        }
                                    }

                                    // 🔥【修复】角色发送的表情包不应该添加到用户的最近使用列表
                                } else {
                                    aiMessage = {
                                        id: (Date.now() + i).toString(),
                                        sender: 'received',
                                        content: `[表情包"${msgData.description}"不存在]`,
                                        timestamp: Date.now() + i * 100
                                    };
                                }
                            } else if (msgData.content) {
                                // 普通对象消息
                                // 🔥【修复】处理多模态消息格式
                                let processedContent;
                                if (typeof msgData.content === 'string') {
                                    processedContent = msgData.content;
                                } else if (Array.isArray(msgData.content) && msgData.content.length > 0) {
                                    // 多模态消息格式：[{type: 'text', text: '内容'}]
                                    const firstItem = msgData.content[0];
                                    if (firstItem && firstItem.type === 'text' && firstItem.text) {
                                        processedContent = firstItem.text;
                                    } else {
                                        processedContent = '[多媒体消息]';
                                    }
                                } else if (msgData.content && typeof msgData.content === 'object') {
                                    // 约定或纪念日对象
                                    if (msgData.content.name && typeof msgData.content.name === 'string') {
                                        if (msgData.content.type === 'create_appointment') {
                                            processedContent = `创建了约定：${msgData.content.name}`;
                                        } else if (msgData.content.type === 'create_anniversary') {
                                            processedContent = `创建了纪念日：${msgData.content.name}`;
                                        } else {
                                            processedContent = `提及了：${msgData.content.name}`;
                                        }
                                    } else {
                                        // 其他对象类型
                                        processedContent = msgData.content.message || msgData.content.text || '[多媒体消息]';
                                    }
                                } else {
                                    processedContent = String(msgData.content || '');
                                }

                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    content: processedContent,
                                    timestamp: Date.now() + i * 100
                                };
                            } else {
                                console.log('🔥 [主动聊天] 不支持的消息格式:', msgData);
                                continue;
                            }
                        } else if (typeof msgData === 'string') {
                            // 普通文本消息
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                content: msgData,
                                timestamp: Date.now() + i * 100
                            };
                        } else {
                            console.log('🔥 [主动聊天] 无效的消息数据:', msgData);
                            continue;
                        }

                        if (aiMessage) {
                            // 🔥【新增】标记为主动消息
                            aiMessage.isProactive = true;
                            chatMessages[characterId].push(aiMessage);
                        }
                    }

                    // 🔥【高效保存】主动聊天消息使用批量添加，避免全量重写
                    try {
                        const newDbMessages = [];
                        // 🔥【关键修复】获取实际添加到内存中的消息对象，而不是原始的aiMessages
                        const actualMessages = chatMessages[characterId].slice(-aiMessages.length);
                        const startIndex = chatMessages[characterId].length - aiMessages.length;

                        for (let i = 0; i < actualMessages.length; i++) {
                            const aiMessage = actualMessages[i];
                            // 🔥【修复】使用时间戳和随机数确保ID唯一性，避免重复键错误
                            const uniqueId = `${characterId}_proactive_${aiMessage.timestamp}_${Math.random().toString(36).substr(2, 9)}_${startIndex + i}`;
                            newDbMessages.push({
                                id: uniqueId,
                                characterId: characterId,
                                timestamp: aiMessage.timestamp,
                                messageOrder: startIndex + i,
                                originalMessageId: aiMessage.id,
                                messageData: aiMessage
                            });
                        }

                        await db.chatMessages.bulkAdd(newDbMessages);
                        console.log(`✅ [高效主动聊天] ${actualMessages.length} 条消息已保存到数据库`);
                    } catch (error) {
                        console.error('主动聊天消息批量保存失败，回退到全量保存:', error);
                        // 🔥【修复】使用立即保存而不是防抖保存，确保主动消息不会丢失
                        try {
                            await saveChatMessagesImmediate([characterId]);
                            console.log('✅ [主动聊天回退] 全量保存成功');
                        } catch (fallbackError) {
                            console.error('❌ [主动聊天回退] 全量保存也失败:', fallbackError);
                        }
                    }
                    console.log(`🔥 [主动聊天] ${character.name} 发送了 ${aiMessages.length} 条消息`);

                    // 🔥【新增】记录主动聊天消息到时间线记忆
                    setTimeout(async () => {
                        try {
                            for (let i = 0; i < aiMessages.length; i++) {
                                const msgData = aiMessages[i];
                                let eventContent = '';

                                if (typeof msgData === 'string') {
                                    eventContent = msgData;
                                } else if (typeof msgData === 'object' && msgData.content) {
                                    eventContent = msgData.content;
                                } else if (typeof msgData === 'object' && msgData.type === 'voice_message') {
                                    eventContent = msgData.content;
                                } else if (typeof msgData === 'object' && msgData.type === 'transfer') {
                                    eventContent = `转账 ¥${msgData.amount}${msgData.note ? ` - ${msgData.note}` : ''}`;
                                } else if (typeof msgData === 'object' && msgData.type === 'poke') {
                                    eventContent = `戳了戳用户`;
                                } else if (typeof msgData === 'object' && msgData.type === 'emoji') {
                                    eventContent = `发送表情包：${msgData.description}`;
                                }

                                if (eventContent) {
                                    await recordCrossAppEvent(
                                        characterId,
                                        'chat',
                                        'ai_message',
                                        {
                                            id: characterId,
                                            type: 'private_chat',
                                            sender: 'ai',
                                            content: eventContent,
                                            chatType: 'single',
                                            isProactive: true // 标记为主动消息
                                        }
                                    );
                                    console.log(`🔥 [主动聊天] 已记录时间线事件 - 角色: ${character.name}, 内容: ${eventContent.substring(0, 50)}...`);
                                }
                            }
                        } catch (error) {
                            console.error('🔥 [主动聊天] 记录时间线事件失败:', error);
                        }
                    }, 1000); // 延迟1秒执行

                    // 如果当前正在和这个角色聊天，立即显示消息
                    if (currentChatCharacter && currentChatCharacter.id === characterId) {
                        renderChatMessages(characterId);
                    }

                    // 更新消息列表
                    renderMessageList();

                    // 移除了主动发送消息日志
                }
            } catch (error) {
                console.error('后台聊天失败:', error);
            }
        }

        // 🔥【新增】测试主动聊天功能
        async function testActiveChat() {
            if (!currentChatCharacter) {
                showToast('请先选择一个聊天角色', 'error');
                return;
            }

            console.log(`🧪 测试主动聊天功能 - 角色: ${currentChatCharacter.name}`);
            showToast(`正在测试 ${currentChatCharacter.name} 的主动聊天功能...`, 'info');

            try {
                // 🔥【新增】显示测试前的消息数量
                const beforeCount = (chatMessages[currentChatCharacter.id] || []).length;
                console.log(`测试前消息数量: ${beforeCount}`);

                await triggerBackgroundChat(currentChatCharacter.id, true); // 跳过时间检查

                // 🔥【新增】显示测试后的消息数量
                const afterCount = (chatMessages[currentChatCharacter.id] || []).length;
                console.log(`测试后消息数量: ${afterCount}`);

                if (afterCount > beforeCount) {
                    showToast('主动聊天测试成功！已生成新消息', 'success');
                } else {
                    showToast('主动聊天测试完成，但未生成新消息（可能被条件限制）', 'warning');
                }
            } catch (error) {
                console.error('主动聊天测试失败:', error);
                showToast(`主动聊天测试失败: ${error.message}`, 'error');
            }
        }

        // 🔥【新增】测试主动发动态功能
        async function testActiveMoments() {
            if (!currentChatCharacter) {
                showToast('请先选择一个聊天角色', 'error');
                return;
            }

            console.log(`🧪 测试主动发动态功能 - 角色: ${currentChatCharacter.name}`);
            showToast(`正在测试 ${currentChatCharacter.name} 的主动发动态功能...`, 'info');

            try {
                // 🔥【新增】获取测试前的动态数量
                const beforeMoments = await getRecentMoments(50);
                const beforeCount = beforeMoments.length;
                console.log(`测试前动态数量: ${beforeCount}`);

                await triggerBackgroundMoments(currentChatCharacter.id, true); // 跳过冷却时间

                // 🔥【新增】获取测试后的动态数量
                const afterMoments = await getRecentMoments(50);
                const afterCount = afterMoments.length;
                console.log(`测试后动态数量: ${afterCount}`);

                if (afterCount > beforeCount) {
                    showToast('主动发动态测试成功！已发布新动态', 'success');
                } else {
                    showToast('主动发动态测试完成，但未发布新动态', 'warning');
                }
            } catch (error) {
                console.error('主动发动态测试失败:', error);
                showToast(`主动发动态测试失败: ${error.message}`, 'error');
            }
        }

        // 🔥【新增】查看当前后台定时器状态
        function checkBackgroundTimers() {
            console.log('🔍 当前后台定时器状态:');
            console.log('backgroundTimers:', backgroundTimers);

            const activeTimers = Object.keys(backgroundTimers).length;
            console.log(`活跃定时器数量: ${activeTimers}`);

            if (activeTimers === 0) {
                console.log('⚠️ 没有活跃的后台定时器');
                console.log('💡 可以运行 reinitializeProactiveChatTimers() 来重新初始化定时器');
            } else {
                for (const [key, timer] of Object.entries(backgroundTimers)) {
                    console.log(`- ${key}: ${timer ? '运行中' : '已停止'}`);
                }
            }

            showToast(`当前有 ${activeTimers} 个活跃的后台定时器`, 'info');
        }

        // 🔥【新增】重新启动后台系统（用于测试）
        async function restartBackgroundSystem() {
            console.log('🔄 重新启动后台互动系统...');
            await initGlobalBackgroundInteractionSystem();
            checkBackgroundTimers();
        }

        // 🔥【新增】暂停指定角色的主动发消息计时器（用于线下模式）
        function pauseProactiveChatTimer(characterId) {
            const timerKey = characterId + '_chat';
            if (backgroundTimers[timerKey]) {
                clearTimeout(backgroundTimers[timerKey]);
                // 保存计时器状态，以便恢复时使用
                backgroundTimers[timerKey + '_paused'] = true;
                delete backgroundTimers[timerKey];
                console.log(`⏸️ 已暂停角色 ${characters.find(c => c.id === characterId)?.name} 的主动发消息计时器`);
            }
        }

        // 🔥【新增】恢复指定角色的主动发消息计时器（退出线下模式时）
        function resumeProactiveChatTimer(characterId) {
            const pausedKey = characterId + '_chat_paused';
            if (backgroundTimers[pausedKey]) {
                // 删除暂停标记
                delete backgroundTimers[pausedKey];
                // 重新安排主动聊天定时器
                scheduleProactiveChatForCharacter(characterId);
                console.log(`▶️ 已恢复角色 ${characters.find(c => c.id === characterId)?.name} 的主动发消息计时器`);
            }
        }

        // 🔧【调试】将重新初始化函数暴露到全局作用域，方便控制台调用
        window.reinitializeProactiveChatTimers = reinitializeProactiveChatTimers;

        // 🔥【暴露测试函数到全局作用域】
        window.testActiveChat = testActiveChat;
        window.testActiveMoments = testActiveMoments;
        window.checkBackgroundTimers = checkBackgroundTimers;


























        window.initGlobalBackgroundInteractionSystem = initGlobalBackgroundInteractionSystem;
        window.restartBackgroundSystem = restartBackgroundSystem;
        window.triggerPublisherReplyToComments = triggerPublisherReplyToComments;

        // 🔥【新增】测试发布者回复功能
        window.testPublisherReply = async function(momentId) {
            try {
                console.log('🧪 开始测试发布者回复功能...');

                // 🔥【修复】确保momentId是正确的数字类型
                const numericMomentId = typeof momentId === 'string' ? parseInt(momentId) : momentId;
                console.log(`🔍 查找动态ID: ${numericMomentId} (原始输入: ${momentId})`);

                // 获取动态信息
                const moment = await db.moments.get(numericMomentId);
                if (!moment) {
                    console.error('❌ 未找到动态:', numericMomentId);
                    // 🔥【调试】列出所有动态ID
                    const allMoments = await db.moments.toArray();
                    console.log('📋 数据库中的所有动态ID:', allMoments.map(m => `${m.id} (${typeof m.id})`));
                    return;
                }

                // 获取发布者角色
                const publisherCharacter = characters.find(c => c.id === moment.characterId);
                if (!publisherCharacter) {
                    console.error('❌ 未找到发布者角色:', moment.characterId);
                    console.log('📋 可用角色:', characters.map(c => `${c.name} (ID: ${c.id})`));
                    return;
                }

                console.log(`📝 测试动态: ${moment.text}`);
                console.log(`👤 发布者: ${publisherCharacter.name} (ID: ${publisherCharacter.id})`);

                // 直接调用发布者回复函数
                await triggerPublisherReplyToComments(numericMomentId, publisherCharacter);

                console.log('✅ 测试完成');
            } catch (error) {
                console.error('❌ 测试失败:', error);
            }
        };

        // 🔥【新增】列出最近的动态ID，方便测试
        window.listRecentMoments = async function() {
            try {
                const moments = await db.moments.orderBy('timestamp').reverse().limit(10).toArray();
                console.log('📋 最近10条动态:');
                moments.forEach((moment, index) => {
                    console.log(`${index + 1}. ID: ${moment.id} | 发布者: ${moment.nickname} | 内容: ${moment.text.substring(0, 30)}...`);
                });
                console.log('💡 使用 testPublisherReply(动态ID) 来测试发布者回复功能');
                console.log('💡 使用 forcePublisherReply(动态ID) 来强制发布者回复');
            } catch (error) {
                console.error('❌ 获取动态列表失败:', error);
            }
        };

        // 🔥【新增】强制发布者回复功能（忽略概率检查）
        window.forcePublisherReply = async function(momentId) {
            try {
                console.log('🧪 强制发布者回复测试...');

                const numericMomentId = typeof momentId === 'string' ? parseInt(momentId) : momentId;
                const moment = await db.moments.get(numericMomentId);
                if (!moment) {
                    console.error('❌ 未找到动态:', numericMomentId);
                    return;
                }

                const publisherCharacter = characters.find(c => c.id === moment.characterId);
                if (!publisherCharacter) {
                    console.error('❌ 未找到发布者角色:', moment.characterId);
                    return;
                }

                // 获取评论
                const comments = await db.momentComments.where('momentId').equals(numericMomentId).toArray();
                const otherCharacterComments = comments.filter(comment =>
                    comment.authorId !== publisherCharacter.id &&
                    comment.authorId !== 'user' &&
                    comment.authorId
                );

                if (otherCharacterComments.length === 0) {
                    console.log('❌ 没有其他角色的评论可回复');
                    return;
                }

                // 强制选择一条评论回复
                const randomComment = otherCharacterComments[Math.floor(Math.random() * otherCharacterComments.length)];
                console.log(`🎯 强制 ${publisherCharacter.name} 回复 ${randomComment.nickname} 的评论`);

                const replyText = await generatePublisherReply(publisherCharacter, randomComment, numericMomentId);
                if (replyText) {
                    const reply = {
                        id: Date.now() + Math.random(),
                        nickname: publisherCharacter.name,
                        avatar: publisherCharacter.avatarUrl,
                        text: replyText,
                        time: formatTime(new Date()),
                        timestamp: Date.now(),
                        characterId: publisherCharacter.id,
                        replyTo: randomComment.nickname
                    };

                    await saveCommentToMoment(numericMomentId, reply);
                    await updateMomentCommentCount(numericMomentId);
                    displayCommentUnderMoment(numericMomentId, reply);

                    console.log(`✅ 强制回复成功: "${replyText}"`);
                } else {
                    console.log('❌ 生成回复失败');
                }
            } catch (error) {
                console.error('❌ 强制回复测试失败:', error);
            }
        };

        // 触发后台发动态（测试版本，跳过冷却时间）
        async function triggerBackgroundMomentsTest(characterId) {
            // 移除了测试发布日志
            // 直接调用正常发布函数，但跳过冷却时间检查
            await triggerBackgroundMoments(characterId, true);
        }

        // 触发后台发动态
        async function triggerBackgroundMoments(characterId, skipCooldown = false) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;

                // 检查冷却时间（避免短时间内重复发布）
                if (!skipCooldown) {
                    const lastMomentTime = character.lastMomentTime || 0;
                    const cooldownTime = 30 * 60 * 1000; // 30分钟冷却时间
                    if (Date.now() - lastMomentTime < cooldownTime) {
                        // 移除了冷却时间日志
                        return;
                    }
                } else {
                    // 移除了测试发布日志
                }

                const chatSettings = getCurrentChatSettings();

                // 获取最近的聊天记录
                const messages = chatMessages[characterId] || [];
                const maxMemory = chatSettings.historyCount || 5;
                const recentMessages = messages.slice(-maxMemory);

                // 🔥【修复】获取角色可见的动态内容，包含时间戳和分组过滤
                const recentMoments = await getVisibleMomentsForCharacter(characterId, 5);

                // 构建上下文
                let chatContext = '';
                if (recentMessages.length > 0) {
                    chatContext = '\n\n最近的聊天记录：\n' +
                        recentMessages.map(msg => {
                            if (msg.sender === 'sent') return `用户：${msg.content}`;
                            if (msg.sender === 'received') return `${character.name}：${msg.content}`;
                            return '';
                        }).filter(Boolean).join('\n');
                }

                let momentsContext = '';
                if (recentMoments.length > 0) {
                    momentsContext = '\n\n最近的动态内容和讨论：\n';
                    recentMoments.forEach((moment, index) => {
                        const authorName = moment.authorId === 'user' ? '用户' : moment.nickname;

                        // 🔥【新增】添加时间戳信息
                        let timeInfo = '';
                        if (moment.timestamp) {
                            const now = Date.now();
                            const timeDiff = now - moment.timestamp;
                            const minutes = Math.floor(timeDiff / (1000 * 60));
                            const hours = Math.floor(timeDiff / (1000 * 60 * 60));
                            const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));

                            if (days > 0) {
                                timeInfo = `（${days}天前发布）`;
                            } else if (hours > 0) {
                                timeInfo = `（${hours}小时前发布）`;
                            } else if (minutes > 0) {
                                timeInfo = `（${minutes}分钟前发布）`;
                            } else {
                                timeInfo = '（刚刚发布）';
                            }
                        }

                        // 🔥【新增】包含评论区内容
                        const momentContent = `${authorName}: ${moment.text}${timeInfo}${moment.commentsText || ''}`;
                        momentsContext += momentContent;
                    });
                }

                // 生成动态内容
                const prompt = `你是${character.name}，你的人设如下：${character.bio}。

现在你要发布一条动态。这条动态应该是：
1. 符合你的人设和性格
2. 生活化、有趣、有个性
3. 50-200字左右
4. 可以是心情、感悟、日常、分享等
5. 可以结合最近的聊天或动态内容作为灵感
6. 要有你独特的风格，不能和其他角色混淆
7. 支持换行显示，可以适当分段让内容更易读
8. 可以选择性地配图，如果想要配图，请直接换行，然后用斜体格式写：*[配图：详细的图片描述]*

## 配图规则（严格遵循）：
- 大部分动态都不需要配图，只有在非常特殊、值得记录的时刻才添加配图描述
- 纯文字感悟、心情、日常想法等通常不需要配图
- 只有在以下情况才考虑配图：分享美食、旅行风景、特殊事件、有趣发现等
- 图片描述要生动、具体，让人能通过文字想象出画面
- 以第三人称视角描述，例如：*[配图：照片里一只橘猫正懒洋洋地趴在窗台上晒太阳，阳光把它金色的毛照得发亮，背景是蔚蓝的天空和几朵白云。]*
- 图片描述要符合你的性格和当前情境

${chatContext}${momentsContext}

## 重要格式要求：
- 直接返回动态文本内容，不要使用JSON格式
- 不要添加任何代码块标记
- 不要添加"动态内容："等前缀
- 直接以动态正文开始

请生成一条符合你人设的动态内容：`;

                const response = await generateAIResponse(prompt, character);
                if (response && response.trim()) {
                    // 🔥【修复】动态内容应该是纯文本，强化格式处理
                    let content = response.trim();

                    // 🔥【增强】更强的JSON格式检测和处理
                    if (content.startsWith('[') || content.startsWith('{')) {
                        try {
                            const parsed = JSON.parse(content);
                            console.log(character.name + ' 发动态时AI返回了JSON格式，正在提取文本:', parsed);

                            if (Array.isArray(parsed) && parsed.length > 0) {
                                // 如果是数组，合并所有文本内容
                                content = parsed.map(item => {
                                    if (typeof item === 'string') {
                                        return item.trim();
                                    } else if (typeof item === 'object' && item.content) {
                                        return item.content.trim();
                                    } else if (typeof item === 'object' && item.text) {
                                        return item.text.trim();
                                    }
                                    return '';
                                }).filter(text => text).join('\n');
                            } else if (typeof parsed === 'object') {
                                // 如果是对象，尝试提取文本字段
                                content = parsed.content || parsed.text || parsed.message || JSON.stringify(parsed);
                            }

                            console.log(character.name + ' 提取后的动态内容:', content);
                        } catch (parseError) {
                            // 如果不是有效JSON，直接使用原始文本
                            console.log(character.name + ' 动态内容不是有效JSON，使用原始文本');
                            content = response.trim();
                        }
                    }

                    // 🔥【新增】清理可能的格式标记
                    content = content
                        .replace(/^```[\s\S]*?\n/, '') // 移除开头的代码块标记
                        .replace(/\n```$/, '') // 移除结尾的代码块标记
                        .replace(/^\*\*动态内容\*\*:?\s*/i, '') // 移除可能的标题
                        .replace(/^动态内容:?\s*/i, '') // 移除可能的标题
                        .trim();

                    if (content) {
                        // 获取头像，确保安全
                        const avatar = getCharacterAvatar(character);
                        // 移除了发布动态头像日志

                        // 发布动态
                        const moment = {
                            id: Date.now(),  // 使用数字ID而不是字符串
                            authorId: characterId,
                            nickname: character.name,
                            avatar: avatar, // 角色头像
                            text: content,
                            time: formatTime(new Date()),
                            timestamp: Date.now(),
                            characterId: characterId
                        };

                                                                    // 保存到数据库
                        await db.moments.add(moment);

                        // 🔥【新增】为角色发布的动态设置可见性
                        // 角色发布的动态默认为部分可见，只有同分组的角色可以看到
                        if (character.groupId) {
                            await db.momentVisibility.add({
                                momentId: moment.id,
                                visibility: 'partial',
                                visibleGroups: [character.groupId],
                                timestamp: new Date()
                            });
                        }

                        // 🔥【新增】为角色发布动态创建推送通知
                        createPushNotification(character, `发布了新动态：${content.length > 15 ? content.substring(0, 15) + '...' : content}`, 500);

                        // 记录发布时间
                        character.lastMomentTime = Date.now();
                        saveCharacters();

                        // 强制刷新动态显示（无论当前在哪个页面）
                        setTimeout(() => {
                            loadMoments();
                        }, 100);

                        // 触发同分组角色的自发互动（保持概率设置）
                        setTimeout(() => {
                            triggerAIInteractions(moment.id, 'like');
                        }, 2000 + Math.random() * 3000); // 2-5秒后开始点赞

                        setTimeout(() => {
                            triggerAIInteractions(moment.id, 'comment');
                        }, 5000 + Math.random() * 5000); // 5-10秒后开始评论

                        // 移除了发布动态日志
                    }
                }
            } catch (error) {
                console.error('后台发动态失败:', error);
            }
        }

        // 获取最近的动态
        async function getRecentMoments(count = 5) {
            try {
                // 从数据库获取最新的动态数据
                const momentsData = await db.moments.orderBy('timestamp').reverse().limit(count).toArray();
                return momentsData || [];
            } catch (error) {
                console.error('获取最近动态失败:', error);
                return [];
            }
        }

        // 🔥【增强】获取角色可见的动态（用于聊天记忆集成）- 包含评论区内容
        async function getVisibleMomentsForCharacter(characterId, count = 5) {
            try {
                // 获取所有最新动态
                const allMoments = await db.moments.orderBy('timestamp').reverse().limit(count * 3).toArray();

                const visibleMoments = [];
                const character = characters.find(c => c.id === characterId);

                for (const moment of allMoments) {
                    if (visibleMoments.length >= count) break;

                    // 🔥【新增】检查动态可见性设置
                    const isVisible = await checkMomentVisibilityForCharacter(moment.id, characterId);
                    if (!isVisible) {
                        continue;
                    }

                    // 用户发的动态，根据可见性设置决定是否可见
                    if (moment.authorId === 'user') {
                        // 🔥【新增】获取该动态的评论区内容
                        const momentWithComments = await enrichMomentWithComments(moment, characterId);
                        visibleMoments.push(momentWithComments);
                        continue;
                    }

                    // 角色自己发的动态
                    if (moment.authorId === characterId || moment.characterId === characterId) {
                        // 🔥【新增】获取该动态的评论区内容
                        const momentWithComments = await enrichMomentWithComments(moment, characterId);
                        visibleMoments.push(momentWithComments);
                        continue;
                    }

                    // 检查是否是同一个好友分组的角色发的动态
                    if (character && moment.characterId) {
                        const momentAuthor = characters.find(c => c.id === moment.characterId);
                        if (momentAuthor && areCharactersInSameGroup(character, momentAuthor)) {
                            // 🔥【新增】获取该动态的评论区内容
                            const momentWithComments = await enrichMomentWithComments(moment, characterId);
                            visibleMoments.push(momentWithComments);
                            continue;
                        }
                    }
                }

                return visibleMoments;
            } catch (error) {
                console.error('获取角色可见动态失败:', error);
                return [];
            }
        }

        // 🔥【新增】为动态添加评论区内容的辅助函数
        async function enrichMomentWithComments(moment, characterId) {
            try {
                // 获取该动态的所有评论
                const comments = await db.momentComments
                    .where('momentId')
                    .equals(moment.id)
                    .toArray();

                // 按时间排序评论
                comments.sort((a, b) => a.timestamp - b.timestamp);

                // 🔥【新增】过滤角色可见的评论（基于分组关系）
                const visibleComments = [];
                const character = characters.find(c => c.id === characterId);

                for (const comment of comments) {
                    // 用户的评论总是可见
                    if (comment.authorId === 'user') {
                        visibleComments.push(comment);
                        continue;
                    }

                    // 角色自己的评论总是可见
                    if (comment.authorId === characterId) {
                        visibleComments.push(comment);
                        continue;
                    }

                    // 检查评论者是否与当前角色在同一分组
                    if (character && comment.authorId) {
                        const commentAuthor = characters.find(c => c.id === comment.authorId);
                        if (commentAuthor && areCharactersInSameGroup(character, commentAuthor)) {
                            visibleComments.push(comment);
                        }
                    }
                }

                // 🔥【新增】构建评论区摘要文本
                let commentsText = '';
                if (visibleComments.length > 0) {
                    commentsText = '\n评论区：\n';
                    visibleComments.forEach((comment, index) => {
                        const authorName = comment.authorId === 'user' ? '用户' : comment.nickname;
                        commentsText += `  ${index + 1}. ${authorName}: ${comment.text}\n`;
                    });
                }

                // 返回包含评论信息的动态对象
                return {
                    ...moment,
                    commentsText: commentsText,
                    commentsCount: visibleComments.length,
                    visibleComments: visibleComments
                };
            } catch (error) {
                console.error('获取动态评论失败:', error);
                // 如果获取评论失败，返回原始动态
                return {
                    ...moment,
                    commentsText: '',
                    commentsCount: 0,
                    visibleComments: []
                };
            }
        }

        // 🔥【新增】检查动态对特定角色的可见性
        async function checkMomentVisibilityForCharacter(momentId, characterId) {
            try {
                // 获取动态的可见性设置
                const visibilitySettings = await db.momentVisibility.where('momentId').equals(momentId).first();

                // 如果没有可见性设置，默认为公开
                if (!visibilitySettings) {

                    return true;
                }

                const { visibility, visibleGroups } = visibilitySettings;


                // 公开动态，所有人可见
                if (visibility === 'public') {

                    return true;
                }

                // 私密动态，只有发布者可见
                if (visibility === 'private') {
                    const moment = await db.moments.get(momentId);
                    const isVisible = moment && (moment.authorId === characterId || moment.characterId === characterId);

                    return isVisible;
                }

                // 部分可见动态，检查角色是否在可见分组中
                if (visibility === 'partial') {
                    const character = characters.find(c => c.id === characterId);
                    if (!character || !character.groupId) {

                        return false;
                    }
                    const isVisible = visibleGroups.includes(character.groupId);

                    return isVisible;
                }


                return false;
            } catch (error) {
                console.error('检查动态可见性失败:', error);
                return true; // 出错时默认可见
            }
        }

        // 🔥【新增】检查两个角色是否在同一个好友分组
        function areCharactersInSameGroup(char1, char2) {
            // 检查两个角色是否在同一个分组中
            if (char1.groupId && char2.groupId && char1.groupId === char2.groupId) {
                return true;
            }

            // 如果没有分组信息，检查是否都在联系人列表中（向后兼容）
            return contacts.includes(char1.id) && contacts.includes(char2.id);
        }

        // 生成AI响应的包装函数，用于后台互动
        async function generateAIResponse(prompt, character) {
            try {
                // 使用现有的 callChatAPI 函数
                const response = await callChatAPI(prompt, character);
                return response;
            } catch (error) {
                console.error('AI响应生成失败:', error);
                return null;
            }
        }

        // 验证头像URL是否有效
        function isValidAvatarUrl(url) {
            if (!url || typeof url !== 'string') return false;

            // 检查base64格式
            if (url.startsWith('data:image/')) {
                // 更宽松的base64验证，只检查基本结构
                const parts = url.split(',');
                if (parts.length !== 2) {
                    console.warn('base64头像URL格式错误（缺少逗号分隔）:', url.substring(0, 50) + '...');
                    return false;
                }

                const header = parts[0];
                const data = parts[1];

                // 检查header是否包含必要信息
                if (!header.includes('data:image/') || !header.includes('base64')) {
                    console.warn('base64头像URL头部格式错误:', header);
                    return false;
                }

                // 检查base64数据是否为空或过长
                if (!data || data.length < 50) {
                    console.warn('base64头像数据为空或过短:', data.length);
                    return false;
                }

                if (data.length > 2000000) { // 2MB限制，更宽松
                    console.warn('base64头像数据过大:', data.length, '建议压缩后重新上传以提高性能');
                    // 不再直接拒绝，只是警告
                }

                // 简单检查base64字符是否合法
                const base64Chars = /^[A-Za-z0-9+/]*={0,2}$/;
                if (!base64Chars.test(data)) {
                    console.warn('base64头像数据包含非法字符');
                    return false;
                }

                return true;
            }

            // 检查HTTP(S) URL格式
            if (url.startsWith('http://') || url.startsWith('https://')) {
                try {
                    new URL(url);
                    return true;
                } catch (error) {
                    console.warn('无效的HTTP头像URL:', url);
                    return false;
                }
            }

            // 如果不是data:image或http(s)开头，考虑可能是其他有效格式
            console.warn('未知的头像URL格式:', url.substring(0, 50) + '...');
            return false;
        }

        // 获取角色的头像（用于动态发布）
        function getCharacterAvatar(character) {
            // 使用同步版本的设置获取，避免Promise问题
            const chatSettings = getChatSettingsSync(character.id);

            // 优先级1：如果角色有聊天窗口的头像设置，使用那个
            if (chatSettings.aiChatAvatar && chatSettings.aiChatAvatar.trim()) {
                const avatar = chatSettings.aiChatAvatar;
                if (isValidAvatarUrl(avatar)) {
                    return avatar;
                } else {
                    console.warn(`角色${character.name}的聊天头像无效，尝试使用其他头像`);
                }
            }

            // 优先级2：如果角色有聊天窗口的头像设置，使用那个（已在上面处理）

            // 优先级2：使用角色卡里的头像
            if (character.avatarUrl && character.avatarUrl.trim()) {
                const avatar = character.avatarUrl;
                if (isValidAvatarUrl(avatar)) {
                    return avatar;
                } else {
                    console.warn(`角色${character.name}的角色卡头像无效，大小或格式问题`);
                }
            }

            console.log(`角色${character.name}没有可用的头像`);
            return null;
        }

        // 获取指定角色的聊天设置 - 使用IndexedDB
        async function getChatSettings(characterId) {
            try {
                const chatSettingsRecord = await db.chatSettings.get(characterId);
                if (chatSettingsRecord) {
                    return chatSettingsRecord.settings;
                }

                // 如果IndexedDB中没有，尝试从localStorage迁移
                const savedSettings = localStorage.getItem(`chatSettings_${characterId}`);
                if (savedSettings) {
                    console.log(`迁移角色 ${characterId} 的聊天设置到IndexedDB`);
                    const settings = JSON.parse(savedSettings);

                    // 保存到IndexedDB
                    await db.chatSettings.put({
                        id: characterId,
                        chatId: characterId,
                        settings: settings
                    });

                    return settings;
                }

                return {};
            } catch (error) {
                console.error('获取聊天设置失败:', error);
                // 回退到localStorage
                const savedSettings = localStorage.getItem(`chatSettings_${characterId}`);
                return savedSettings ? JSON.parse(savedSettings) : {};
            }
        }

        // 同步版本的getChatSettings（用于不支持async的地方）
        function getChatSettingsSync(characterId) {
            const savedSettings = localStorage.getItem(`chatSettings_${characterId}`);
            return savedSettings ? JSON.parse(savedSettings) : {};
        }

        // 格式化动态文字，支持分行和配图描述
        function formatMomentText(text) {
            if (!text) return '';

            // 替换换行符为<br>标签，支持分行显示
            let formattedText = text.replace(/\n/g, '<br>');

            // 处理配图描述：匹配*[配图：描述]*格式
            formattedText = formattedText.replace(/\*\[配图：([^\]]+)\]\*/g, function(match, description) {
                return `<span style="font-style: italic; color: #999; font-size: 13px; line-height: 1.4;">[配图：${description}]</span>`;
            });

            return formattedText;
        }

        // 调试角色动态头像
        function debugMomentAvatar(momentId) {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) {
                console.log('找不到动态元素');
                return;
            }

            // 从IndexedDB获取动态数据
            db.moments.get(parseInt(momentId)).then(moment => {
                console.log('=== 动态头像调试 ===');
                console.log('动态ID:', momentId);
                console.log('角色ID:', moment.characterId);
                console.log('保存的头像:', moment.avatar ? moment.avatar.substring(0, 50) + '...' : 'null');

                if (moment.characterId && moment.characterId !== 'user') {
                    const character = characters.find(c => c.id === moment.characterId);
                    if (character) {
                        console.log('找到角色:', character.name);
                        console.log('角色卡头像:', character.avatarUrl ? character.avatarUrl.substring(0, 50) + '...' : 'null');
                    } else {
                        console.log('找不到角色数据');
                    }
                }

                const avatarImg = momentElement.querySelector('.moment-avatar img');
                if (avatarImg) {
                    console.log('当前显示的头像URL:', avatarImg.src ? avatarImg.src.substring(0, 50) + '...' : 'null');
                }
            });
        }

        // 简单的头像数据修复
        async function fixAvatarData() {
            console.log('开始修复头像数据...');
            let fixedCount = 0;

            try {
                // 清理角色设置中的截断头像
                for (const character of characters) {
                    const chatSettings = await getChatSettings(character.id);
                    let needSave = false;

                    if (chatSettings.aiChatAvatar) {
                        const avatar = chatSettings.aiChatAvatar;
                        if (avatar.startsWith('data:image/') && !avatar.includes('=') && avatar.split(',').length === 2) {
                            console.log(`清理${character.name}的聊天头像设置`);
                            delete chatSettings.aiChatAvatar;
                            needSave = true;
                            fixedCount++;
                        }
                    }

                    if (chatSettings.aiChatAvatar) {
                        const avatar = chatSettings.aiChatAvatar;
                        if (avatar.startsWith('data:image/') && !avatar.includes('=') && avatar.split(',').length === 2) {
                            console.log(`清理${character.name}的聊天头像设置`);
                            delete chatSettings.aiChatAvatar;
                            needSave = true;
                            fixedCount++;
                        }
                    }

                    if (needSave) {
                        // 保存到IndexedDB而不是localStorage
                        await db.chatSettings.put({
                            id: character.id,
                            chatId: character.id,
                            settings: chatSettings
                        });
                    }
                }

                // 清理动态数据库中的截断头像
                const allMoments = await db.moments.toArray();
                let momentFixedCount = 0;

                for (const moment of allMoments) {
                    if (moment.avatar && moment.avatar.startsWith('data:image/')) {
                        // 检查是否是截断的头像（以VNEKhsVJik结尾的是截断的）
                        if (moment.avatar.endsWith('VNEKhsVJik') || moment.avatar.endsWith('VNEKhsVJik:1') ||
                            (!moment.avatar.includes('=') && moment.avatar.split(',').length === 2)) {
                            console.log(`清理动态 ${moment.id} 的截断头像`);
                            await db.moments.update(moment.id, { avatar: null });
                            momentFixedCount++;
                        }
                    }
                }

                const totalFixed = fixedCount + momentFixedCount;
                console.log(`修复完成: 清理了${fixedCount}个设置头像, ${momentFixedCount}个动态头像`);

                alert(`修复完成！\n清理了 ${fixedCount} 个设置中的截断头像\n清理了 ${momentFixedCount} 个动态中的截断头像\n\n请重新为角色设置头像`);

                if (totalFixed > 0) {
                    loadMoments();
                }
            } catch (error) {
                console.error('修复失败:', error);
                alert('修复失败: ' + error.message);
            }
        }

        // 页面卸载时清理后台定时器
        window.addEventListener('beforeunload', function() {
            clearAllBackgroundTimers();
            clearGlobalMomentsTimers();
        });

        // 🔥【新增】测试动态可见性功能
        window.testMomentVisibility = async function() {
            try {


                // 获取所有动态
                const allMoments = await db.moments.toArray();


                // 获取所有可见性设置
                const allVisibility = await db.momentVisibility.toArray();
                console.log(`📊 总共有 ${allVisibility.length} 条可见性设置`);

                // 测试每个角色能看到的动态
                for (const character of characters) {
                    const visibleMoments = await getVisibleMomentsForCharacter(character.id, 10);
                    console.log(`👤 ${character.name} (分组: ${character.groupId}) 可以看到 ${visibleMoments.length} 条动态`);

                    visibleMoments.forEach((moment, index) => {
                        const authorName = moment.authorId === 'user' ? '用户' : moment.nickname;
                        console.log(`  ${index + 1}. ${authorName}: ${moment.text.substring(0, 30)}...`);
                    });
                }


            } catch (error) {
                console.error('❌ 动态可见性测试失败:', error);
            }
        };

        // 🔥【调试功能】测试动态系统是否正常工作
        function debugMomentsSystem() {
            console.log('=== 动态系统调试信息 ===');
            console.log('角色数量:', characters ? characters.length : 0);
            console.log('全局定时器:', Object.keys(globalMomentsTimers));
            console.log('定时检查器状态:', globalMomentsCheckInterval ? '运行中' : '未运行');

            if (characters && characters.length > 0) {
                console.log('各角色设置:');
                characters.forEach(async (character, index) => {
                    const settings = await getChatSettings(character.id);
                    console.log(`${index + 1}. ${character.name}:`, {
                        backgroundMomentsEnabled: settings.backgroundMomentsEnabled,
                        backgroundMomentsFrequency: settings.backgroundMomentsFrequency,
                        scheduledMomentsEnabled: settings.scheduledMomentsEnabled,
                        scheduledMomentsTimes: settings.scheduledMomentsTimes
                    });
                });
            }

            console.log('=========================');
        }

        // 暴露调试函数到全局
        window.debugMomentsSystem = debugMomentsSystem;


        // 加载壁纸 - 使用IndexedDB（包含数据迁移）
        async function loadWallpaper() {
            try {
                // 先从IndexedDB加载
                const savedWallpaper = await db.wallpapers.get('main');

            if (savedWallpaper) {
                    selectedWallpaper = savedWallpaper.data;

                    if (savedWallpaper.type === 'image' && savedWallpaper.data.startsWith('data:image')) {
                    // 加载上传的图片
                        document.querySelector('.wallpaper').style.backgroundImage = `url(${savedWallpaper.data})`;
                    } else if (savedWallpaper.type === 'gradient' || savedWallpaper.data.startsWith('linear-gradient')) {
                    // 加载渐变背景
                        document.querySelector('.wallpaper').style.backgroundImage = savedWallpaper.data;
                } else {
                    // 加载纯色背景
                        document.querySelector('.wallpaper').style.backgroundColor = savedWallpaper.data;
                    document.querySelector('.wallpaper').style.backgroundImage = 'none';
                }

                document.querySelector('.wallpaper').style.backgroundSize = '100% 100%';
                document.querySelector('.wallpaper').style.backgroundPosition = 'center';
                } else {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localWallpaper = localStorage.getItem('wallpaper');
                    const wallpaperType = localStorage.getItem('wallpaperType');

                    if (localWallpaper) {
                        console.log('检测到localStorage中的壁纸数据，开始迁移...');
                        selectedWallpaper = localWallpaper;

                        // 迁移到IndexedDB
                        await db.wallpapers.add({
                            id: 'main',
                            type: wallpaperType || 'gradient',
                            data: localWallpaper
                        });

                        if (wallpaperType === 'image' && localWallpaper.startsWith('data:image')) {
                            document.querySelector('.wallpaper').style.backgroundImage = `url(${localWallpaper})`;
                        } else if (wallpaperType === 'gradient' || localWallpaper.startsWith('linear-gradient')) {
                            document.querySelector('.wallpaper').style.backgroundImage = localWallpaper;
                        } else {
                            document.querySelector('.wallpaper').style.backgroundColor = localWallpaper;
                            document.querySelector('.wallpaper').style.backgroundImage = 'none';
                        }

                        document.querySelector('.wallpaper').style.backgroundSize = '100% 100%';
                        document.querySelector('.wallpaper').style.backgroundPosition = 'center';

                        console.log('壁纸数据迁移完成');
                    }
                }
            } catch (error) {
                console.error('加载壁纸失败:', error);
                // 如果IndexedDB失败，回退到localStorage
                const localWallpaper = localStorage.getItem('wallpaper');
                const wallpaperType = localStorage.getItem('wallpaperType');

                if (localWallpaper) {
                    selectedWallpaper = localWallpaper;

                    if (wallpaperType === 'image' && localWallpaper.startsWith('data:image')) {
                        document.querySelector('.wallpaper').style.backgroundImage = `url(${localWallpaper})`;
                    } else if (wallpaperType === 'gradient' || localWallpaper.startsWith('linear-gradient')) {
                        document.querySelector('.wallpaper').style.backgroundImage = localWallpaper;
                    } else {
                        document.querySelector('.wallpaper').style.backgroundColor = localWallpaper;
                        document.querySelector('.wallpaper').style.backgroundImage = 'none';
                    }

                    document.querySelector('.wallpaper').style.backgroundSize = '100% 100%';
                    document.querySelector('.wallpaper').style.backgroundPosition = 'center';
                }
            }
        }

        // 加载应用图标 - 使用IndexedDB（包含数据迁移）
        async function loadAppIcons() {
            try {
                // 先从IndexedDB加载
                const savedIcons = await db.appIcons.toArray();

                if (savedIcons.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('appIcons');
                    if (localStorageData) {
                        console.log('检测到localStorage中的应用图标数据，开始迁移...');
                        const localIcons = JSON.parse(localStorageData);

                        // 转换为数组格式存储到IndexedDB
                        const iconArray = Object.keys(localIcons).map(appId => ({
                            id: appId,
                            appId: appId,
                            iconClass: localIcons[appId]
                        }));

                        if (iconArray.length > 0) {
                            await db.appIcons.bulkAdd(iconArray);
                            console.log('应用图标数据迁移完成:', iconArray);
                        }

                        // 应用图标
                        Object.keys(localIcons).forEach(appId => {
                            const iconElement = document.querySelector(`.app[onclick="showApp('${appId}')"] .app-icon i`);
                            if (iconElement) {
                                iconElement.className = localIcons[appId];
                            }
                        });
                    }
                } else {
                    // IndexedDB中有数据，直接使用
                    console.log('从IndexedDB加载应用图标数据:', savedIcons);
                    savedIcons.forEach(iconData => {
                        const iconElement = document.querySelector(`.app[onclick="showApp('${iconData.appId}')"] .app-icon i`);
                        if (iconElement) {
                            iconElement.className = iconData.iconClass;
                        }
                    });
                }
            } catch (error) {
                console.error('加载应用图标失败:', error);
                // 如果IndexedDB失败，回退到localStorage
                const localStorageData = localStorage.getItem('appIcons');
                if (localStorageData) {
                    const icons = JSON.parse(localStorageData);
                Object.keys(icons).forEach(appId => {
                    const iconElement = document.querySelector(`.app[onclick="showApp('${appId}')"] .app-icon i`);
                    if (iconElement) {
                        iconElement.className = icons[appId];
                    }
                });
                }
            }
        }

        // 加载API设置 - 使用IndexedDB
        async function loadApiSettings() {
            try {
                // 先从IndexedDB尝试加载
                const savedSettings = await db.apiSettings.get('main');
                if (savedSettings) {
                    apiSettings = savedSettings.settings;
                    console.log('🔧 [应用启动] 从IndexedDB加载API设置:', apiSettings);
                } else {
                    // 尝试从localStorage迁移
                    const localSettings = localStorage.getItem('apiSettings');
                    if (localSettings) {
                        console.log('🔧 [应用启动] 迁移API设置从localStorage到IndexedDB');
                        apiSettings = JSON.parse(localSettings);

                        // 保存到IndexedDB
                        await db.apiSettings.put({
                            id: 'main',
                            settings: apiSettings
                        });
                        console.log('🔧 [应用启动] 迁移完成，当前API设置:', apiSettings);
                    } else {
                        // 使用默认设置
                        console.log('🔧 [应用启动] 使用默认API设置');
                        apiSettings = {
                            type: 'gemini',
                            base: 'https://generativelanguage.googleapis.com/v1beta',
                            endpoint: '/chat/completions',
                            key: '',
                            model: 'gemini-2.0-flash-exp',
                            temperature: 0.70
                        };
                    }
                }

                // 旧版本API设置表单更新代码已清理 - 现在使用新版本的API设置系统
            } catch (error) {
                console.error('加载API设置失败:', error);
                // 旧版本默认设置代码已清理
            }
        }

        // 保存应用图标 - 使用IndexedDB
        async function saveAppIcons() {
            try {
                console.log('保存应用图标数据到IndexedDB...');

                const defaultIcons = {
                    'chat-screen': 'fas fa-comment-dots',
                    'forum-screen': 'fas fa-comments',
                    'diary-book-screen': 'fas fa-book',
                    'characters-screen': 'fas fa-user-friends',
                    'shop-screen': 'fas fa-shopping-bag',
                    'settings-screen': 'fas fa-cog'
                };

                if (selectedAppIcon) {
                    defaultIcons[selectedAppIcon.appId] = selectedAppIcon.iconClass;
                }

                // 转换为数组格式
                const iconArray = Object.keys(defaultIcons).map(appId => ({
                    id: appId,
                    appId: appId,
                    iconClass: defaultIcons[appId]
                }));

                // 清空现有数据并插入新数据
                await db.appIcons.clear();
                await db.appIcons.bulkAdd(iconArray);

                console.log('应用图标数据保存成功');

                // 刷新图标显示
                await loadAppIcons();
            } catch (error) {
                console.error('保存应用图标时发生错误:', error);
                // 如果IndexedDB失败，回退到localStorage
            const icons = {
                'chat-screen': 'fas fa-comment-dots',
                'weibo-screen': 'fab fa-weibo',
                'album-screen': 'fas fa-images',
                'characters-screen': 'fas fa-user-friends',
                'shop-screen': 'fas fa-shopping-bag',
                'settings-screen': 'fas fa-cog'
            };

            if (selectedAppIcon) {
                icons[selectedAppIcon.appId] = selectedAppIcon.iconClass;
            }

            localStorage.setItem('appIcons', JSON.stringify(icons));
            loadAppIcons();
            }
        }

        // 渲染消息列表
        function renderMessageList() {
            const messageList = document.getElementById('message-list');
            messageList.innerHTML = '';

            // 🔥【修改】为多选模式在app-header中添加按钮
            const chatHeaderActions = document.querySelector('#chat-screen .chat-header-actions');
            if (isMessageListMultiSelectMode) {
                // 隐藏原有的header按钮
                if (chatHeaderActions) {
                    chatHeaderActions.style.display = 'none';
                }

                // 🔥【新增】检查是否已存在多选按钮，避免重复添加
                let existingActions = document.querySelector('.chat-header-multiselect-actions');
                if (!existingActions) {
                    const multiselectActions = document.createElement('div');
                    multiselectActions.className = 'chat-header-multiselect-actions';
                    multiselectActions.innerHTML = `
                        <button class="multiselect-btn pin-btn" data-action="pin">
                            <i class="fas fa-thumbtack"></i>
                            <span>置顶</span>
                        </button>
                        <button class="multiselect-btn delete-btn" data-action="delete">
                            <i class="fas fa-trash"></i>
                            <span>删除</span>
                        </button>
                        <button class="multiselect-btn cancel-btn" data-action="cancel">
                            <i class="fas fa-times"></i>
                            <span>取消</span>
                        </button>
                    `;

                    // 🔥【修复】使用事件委托绑定点击事件，避免内联onclick问题
                    multiselectActions.onclick = function(e) {
                        const action = e.target.closest('[data-action]')?.dataset.action;
                        if (action === 'delete') {
                            deleteSelectedConversations();
                        } else if (action === 'cancel') {
                            exitMessageListMultiSelectMode();
                        } else if (action === 'pin') {
                            pinSelectedConversations();
                        }
                    };

                    // 🔥【修改】将按钮添加到消息列表页面的app-header中
                    const chatAppHeader = document.querySelector('#chat-screen .app-header');
                    if (chatAppHeader) {
                        chatAppHeader.appendChild(multiselectActions);
                    }
                }
            } else {
                // 🔥【新增】非多选模式时恢复原有按钮，移除多选按钮
                if (chatHeaderActions) {
                    chatHeaderActions.style.display = 'flex';
                }
                const existingActions = document.querySelector('.chat-header-multiselect-actions');
                if (existingActions) {
                    existingActions.remove();
                }
            }

            // 🔥【浏览器兼容性修复】增强对 contacts 列表的容错处理
            console.log('🔍 renderMessageList 数据检查:', {
                charactersCount: characters.length,
                contactsCount: contacts.length,
                contactsArray: contacts,
                chatMessagesKeys: Object.keys(chatMessages).length
            });

            // 🔥【修复】智能处理 contacts 为空的情况
            if (contacts.length === 0 && characters.length > 0) {
                // 检查是否是首次加载（没有任何聊天记录）还是用户删除了所有对话
                const hasAnyChatMessages = Object.keys(chatMessages).length > 0;

                if (hasAnyChatMessages) {
                    // 如果有聊天记录但没有联系人，说明可能是数据不一致，需要修复
                    console.warn('⚠️ 检测到有聊天记录但无联系人，可能是数据不一致，尝试从聊天记录恢复联系人');
                    const chatCharacterIds = Object.keys(chatMessages);
                    const validContacts = chatCharacterIds.filter(id =>
                        characters.some(char => char.id === id)
                    );
                    if (validContacts.length > 0) {
                        contacts = validContacts;
                        saveContacts().catch(err => console.error('保存联系人失败:', err));
                        console.log(`🔧 从聊天记录恢复了 ${validContacts.length} 个联系人`);
                    }
                } else {
                    // 如果既没有联系人也没有聊天记录，这是正常的初始状态
                    console.log('✅ 初始状态：无联系人无聊天记录，这是正常的');
                }
            }

            // 🔥【修复】只渲染存在于 contacts 列表中的单人对话，增加容错
            const singleChats = characters.filter(character => {
                if (!character || !character.id) return false;
                return contacts.includes(character.id);
            });

            const sortedSingleChats = singleChats.sort((a, b) => {
                const aPinned = isPinned(a.id);
                const bPinned = isPinned(b.id);
                if (aPinned && !bPinned) return -1;
                if (!aPinned && bPinned) return 1;
                // 你可以在这里添加按最后消息时间的排序逻辑
                return 0;
            });

            sortedSingleChats.forEach(character => {
                // 直接使用角色对象，不需要再查找
                if (character) {
                    // 🔥【关键修复】使用统一的设置获取方式，避免数据不一致
                    const chatSettings = window.chatSettings && window.chatSettings[character.id] ?
                        window.chatSettings[character.id] : {};
                    const displayName = chatSettings.aiChatNickname || character.name;

                    const messages = chatMessages[character.id] || [];
                    // 🔥【修复】过滤掉游戏消息，只显示正常聊天消息
                    const normalMessages = messages.filter(msg => !msg.isGameMessage && !msg.isGameContext && !msg.isOfflineMode);
                let lastMessageRaw = '暂无消息';

                if (normalMessages.length > 0) {
                    const lastMsg = normalMessages[normalMessages.length - 1];

                    // 🔥【修复】检查消息是否有效，防止undefined错误
                    if (!lastMsg) {
                        lastMessageRaw = '暂无消息';
                    } else if (lastMsg.type === 'user_photo') {
                        lastMessageRaw = '[照片]';
                    } else if (lastMsg.type === 'ai_image') {
                        lastMessageRaw = '[图片]';
                    } else if (lastMsg.type === 'voice_message') {
                        lastMessageRaw = '[语音]';
                    } else if (lastMsg.type === 'transfer') {
                        lastMessageRaw = '[转账]';
                    } else if (lastMsg.type === 'recalled_message') {
                        lastMessageRaw = '[撤回了一条消息]';
                    } else if (lastMsg.type === 'location') {
                        lastMessageRaw = '[位置]';
                    } else if (lastMsg.type === 'call_message') {
                        lastMessageRaw = '[通话消息]';
                    } else if (lastMsg.sender === 'system') {
                        lastMessageRaw = lastMsg.content || '[系统消息]';
                    } else if (lastMsg.isEmoji) {
                        lastMessageRaw = '[表情]';
                    } else {
                        // 🔥【修复】正确处理对象类型的content
                        if (typeof lastMsg.content === 'string') {
                            lastMessageRaw = lastMsg.content;
                        } else if (Array.isArray(lastMsg.content)) {
                            // 多模态消息，提取文本部分
                            const textPart = lastMsg.content.find(part => part.type === 'text');
                            lastMessageRaw = textPart ? textPart.text : '[多媒体消息]';
                        } else if (typeof lastMsg.content === 'object' && lastMsg.content !== null) {
                            // 对象类型的content，尝试提取有用信息
                            if (lastMsg.content.text) {
                                lastMessageRaw = lastMsg.content.text;
                            } else if (lastMsg.content.content) {
                                lastMessageRaw = lastMsg.content.content;
                            } else {
                                lastMessageRaw = '[特殊消息]';
                            }
                        } else {
                            lastMessageRaw = lastMsg.content || '';
                        }
                    }
                }

                const lastMessage = truncateText(String(lastMessageRaw || '暂无消息'), 30);
                    const lastTime = messages.length > 0 ? formatTime(messages[messages.length - 1].timestamp) : '刚刚';

                    const messageItem = document.createElement('div');
                    const isPinnedConversation = isPinned(character.id);
                    messageItem.className = `message-item ${isPinnedConversation ? 'pinned' : ''} ${isMessageListMultiSelectMode && selectedConversations.includes(character.id) ? 'selected' : ''}`;
                    messageItem.dataset.conversationId = character.id; // 添加对话ID

                    // 根据模式设置不同的点击事件
                    if (isMessageListMultiSelectMode) {
                        messageItem.onclick = () => toggleConversationSelection(character.id);
                    } else {
                        // 使用变量来控制点击行为
                        let isLongPress = false;

                        messageItem.onclick = (e) => {
                            if (!isLongPress) {
                                startChat(character);
                            }
                            isLongPress = false; // 重置标志
                        };

                        // 添加长按事件（支持移动端和桌面端）
                        let pressTimer;

                        // 移动端触摸事件
                        messageItem.addEventListener('touchstart', (e) => {
                            e.stopPropagation(); // 阻止事件冒泡
                            pressTimer = setTimeout(() => {
                                console.log('触摸长按触发，角色ID:', character.id);
                                isLongPress = true; // 设置长按标志
                                enterMessageListMultiSelectMode(character.id);
                                e.preventDefault();
                            }, 800); // 800ms长按
                        });

                        messageItem.addEventListener('touchend', (e) => {
                            if (pressTimer) {
                                clearTimeout(pressTimer);
                                pressTimer = null;
                            }
                        });

                        messageItem.addEventListener('touchmove', (e) => {
                            if (pressTimer) {
                                clearTimeout(pressTimer);
                                pressTimer = null;
                            }
                        });

                        // 桌面端鼠标事件
                        messageItem.addEventListener('mousedown', (e) => {
                            if (e.button === 0) { // 左键
                                e.stopPropagation(); // 阻止事件冒泡
                                pressTimer = setTimeout(() => {
                                    console.log('鼠标长按触发，角色ID:', character.id);
                                    isLongPress = true; // 设置长按标志
                                    enterMessageListMultiSelectMode(character.id);
                                    e.preventDefault();
                                }, 800); // 800ms长按
                            }
                        });

                        messageItem.addEventListener('mouseup', (e) => {
                            if (pressTimer) {
                                clearTimeout(pressTimer);
                                pressTimer = null;
                            }
                        });

                        messageItem.addEventListener('mouseleave', (e) => {
                            if (pressTimer) {
                                clearTimeout(pressTimer);
                                pressTimer = null;
                            }
                        });

                        // 右键点击进入多选模式（桌面端）
                        messageItem.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            enterMessageListMultiSelectMode(character.id);
                        });
                    }

                    // 🔥【新增】检查拉黑状态并生成状态指示器
                    let messageStatusIndicator = '';
                    if (character.isGroup === true) {
                        // 群聊检查屏蔽状态
                        const isMuted = isGroupMuted(character.id);
                        if (isMuted) {
                            messageStatusIndicator = '<div class="message-status-indicator muted" title="已屏蔽"><i class="fas fa-volume-mute"></i></div>';
                        }
                    } else {
                        // 单聊检查拉黑状态
                        const isUserBlocked = isBlocked('user', character.id);
                        const isCharacterBlocked = isBlocked(character.id, 'user');

                        if (isUserBlocked) {
                            messageStatusIndicator = '<div class="message-status-indicator blocked" title="已拉黑"><i class="fas fa-ban"></i></div>';
                        } else if (isCharacterBlocked) {
                            messageStatusIndicator = '<div class="message-status-indicator blocked-by" title="被对方拉黑"><i class="fas fa-exclamation-triangle"></i></div>';
                        }
                    }

                    // 🔥【新增】检查未读消息数量并生成未读提示
                    let unreadBadge = '';
                    const unreadCount = getUnreadCount(character.id);
                    if (unreadCount > 0) {
                        const displayCount = unreadCount > 99 ? '99+' : unreadCount.toString();
                        const badgeClass = unreadCount > 99 ? 'unread-badge large-count' : 'unread-badge';
                        unreadBadge = `<div class="${badgeClass}" title="${unreadCount}条未读消息">${displayCount}</div>`;
                    }

                    messageItem.innerHTML = `
                        ${isPinnedConversation ? '<div class="pin-indicator"><i class="fas fa-thumbtack"></i></div>' : ''}
                        ${isMessageListMultiSelectMode ? `
                            <div class="selection-checkbox ${selectedConversations.includes(character.id) ? 'selected' : ''}">
                                ${selectedConversations.includes(character.id) ? '<i class="fas fa-check check-icon-white"></i>' : ''}
                            </div>
                        ` : ''}
                        <div class="message-avatar-container">
                            <div class="message-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                                ${character.avatarUrl ? '' : displayName.charAt(0)}
                            </div>
                            ${unreadBadge}
                            ${messageStatusIndicator}
                        </div>
                        <div class="message-content">
                            <div class="message-name">${displayName}</div>
                            <div class="message-preview">${lastMessage}</div>
                        </div>
                        <div class="message-time">${lastTime}</div>
                    `;

                    messageList.appendChild(messageItem);

                    // 🔥【新增】设置置顶对话样式 - 浅灰色背景，去掉蓝色边框
                    if (isPinnedConversation) {
                        messageItem.style.background = 'rgba(0, 0, 0, 0.05)';
                        messageItem.style.borderLeft = 'none';
                    }
                }
            });

            // 🔥【修改】渲染群聊 - 支持置顶排序
            const sortedGroups = [...groupChats].sort((a, b) => {
                const aPinned = isPinned(a.id);
                const bPinned = isPinned(b.id);
                if (aPinned && !bPinned) return -1;
                if (!aPinned && bPinned) return 1;
                return 0;
            });

            sortedGroups.forEach(group => {
                const messages = chatMessages[group.id] || [];
                let lastMessageRaw = '暂无消息';

                if (messages.length > 0) {
                    const lastMsg = messages[messages.length - 1];

                    // 🔥【修复】检查消息是否有效，防止undefined错误
                    if (!lastMsg) {
                        lastMessageRaw = '暂无消息';
                    } else if (lastMsg.type === 'user_photo') {
                        lastMessageRaw = '[照片]';
                    } else if (lastMsg.type === 'ai_image') {
                        lastMessageRaw = '[图片]';
                    } else if (lastMsg.type === 'voice_message') {
                        lastMessageRaw = '[语音]';
                    } else if (lastMsg.type === 'transfer') {
                        lastMessageRaw = '[转账]';
                    } else if (lastMsg.type === 'recalled_message') {
                        lastMessageRaw = '[撤回了一条消息]';
                    } else if (lastMsg.type === 'location') {
                        lastMessageRaw = '[位置]';
                    } else if (lastMsg.type === 'call_message') {
                        lastMessageRaw = '[通话消息]';
                    } else if (lastMsg.sender === 'system') {
                        lastMessageRaw = lastMsg.content || '[系统消息]';
                    } else if (lastMsg.isEmoji) {
                        lastMessageRaw = '[表情]';
                    } else {
                        // 🔥【修复】正确处理对象类型的content（群聊版本）
                        if (typeof lastMsg.content === 'string') {
                            lastMessageRaw = lastMsg.content;
                        } else if (Array.isArray(lastMsg.content)) {
                            // 多模态消息，提取文本部分
                            const textPart = lastMsg.content.find(part => part.type === 'text');
                            lastMessageRaw = textPart ? textPart.text : '[多媒体消息]';
                        } else if (typeof lastMsg.content === 'object' && lastMsg.content !== null) {
                            // 对象类型的content，尝试提取有用信息
                            if (lastMsg.content.text) {
                                lastMessageRaw = lastMsg.content.text;
                            } else if (lastMsg.content.content) {
                                lastMessageRaw = lastMsg.content.content;
                            } else {
                                lastMessageRaw = '[特殊消息]';
                            }
                        } else {
                            lastMessageRaw = lastMsg.content || '';
                        }
                    }
                }

                const lastMessage = truncateText(String(lastMessageRaw || '暂无消息'), 30);
                const lastTime = messages.length > 0 ? formatTime(messages[messages.length - 1].timestamp) : '刚刚';

                const messageItem = document.createElement('div');
                const isGroupPinned = isPinned(group.id);
                messageItem.className = `message-item ${isGroupPinned ? 'pinned' : ''} ${isMessageListMultiSelectMode && selectedConversations.includes(group.id) ? 'selected' : ''}`;
                messageItem.dataset.conversationId = group.id; // 添加对话ID

                // 根据模式设置不同的点击事件
                if (isMessageListMultiSelectMode) {
                    messageItem.onclick = () => toggleConversationSelection(group.id);
                } else {
                messageItem.onclick = () => startChat(group);

                    // 添加长按事件（支持移动端和桌面端）
                    let pressTimer;

                    // 移动端触摸事件
                    messageItem.addEventListener('touchstart', (e) => {
                        e.stopPropagation(); // 阻止事件冒泡
                        pressTimer = setTimeout(() => {
                            console.log('触摸长按触发，群聊ID:', group.id);
                            enterMessageListMultiSelectMode(group.id);
                            e.preventDefault();
                        }, 800); // 800ms长按
                    });

                    messageItem.addEventListener('touchend', (e) => {
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                        }
                    });

                    messageItem.addEventListener('touchmove', (e) => {
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                        }
                    });

                    // 桌面端鼠标事件
                    messageItem.addEventListener('mousedown', (e) => {
                        if (e.button === 0) { // 左键
                            e.stopPropagation(); // 阻止事件冒泡
                            pressTimer = setTimeout(() => {
                                console.log('鼠标长按触发，群聊ID:', group.id);
                                enterMessageListMultiSelectMode(group.id);
                                e.preventDefault();
                            }, 800); // 800ms长按
                        }
                    });

                    messageItem.addEventListener('mouseup', (e) => {
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                        }
                    });

                    messageItem.addEventListener('mouseleave', (e) => {
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                        }
                    });

                    // 右键点击进入多选模式（桌面端）
                    messageItem.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        enterMessageListMultiSelectMode(group.id);
                    });
                }

                // 🔥【新增】检查群聊屏蔽状态
                let groupStatusIndicator = '';
                const isMuted = isGroupMuted(group.id);
                if (isMuted) {
                    groupStatusIndicator = '<div class="message-status-indicator muted" title="已屏蔽"><i class="fas fa-volume-mute"></i></div>';
                }

                // 🔥【新增】检查群聊未读消息数量
                let groupUnreadBadge = '';
                const groupUnreadCount = getUnreadCount(group.id);
                if (groupUnreadCount > 0) {
                    const displayCount = groupUnreadCount > 99 ? '99+' : groupUnreadCount.toString();
                    const badgeClass = groupUnreadCount > 99 ? 'unread-badge large-count' : 'unread-badge';
                    groupUnreadBadge = `<div class="${badgeClass}" title="${groupUnreadCount}条未读消息">${displayCount}</div>`;
                }

                messageItem.innerHTML = `
                    ${isGroupPinned ? '<div class="pin-indicator"><i class="fas fa-thumbtack"></i></div>' : ''}
                    ${isMessageListMultiSelectMode ? `
                        <div class="selection-checkbox ${selectedConversations.includes(group.id) ? 'selected' : ''}">
                            ${selectedConversations.includes(group.id) ? '<i class="fas fa-check check-icon-white"></i>' : ''}
                        </div>
                    ` : ''}
                    <div class="message-avatar-container">
                        <div class="message-avatar" style="${group.avatarUrl ? `background-image: url(${group.avatarUrl}); background-size: cover; background-position: center;` : 'background-color: #4CAF50;'}">
                            ${group.avatarUrl ? '' : '群'}
                        </div>
                        ${groupUnreadBadge}
                        ${groupStatusIndicator}
                    </div>
                    <div class="message-content">
                                                        <div class="message-name">${group.name} <span class="group-member-count">(${group.members ? group.members.length + 1 : 1}人)</span></div>
                        <div class="message-preview">${lastMessage}</div>
                    </div>
                    <div class="message-time">${lastTime}</div>
                `;

                messageList.appendChild(messageItem);

                // 🔥【新增】设置群聊置顶样式 - 浅灰色背景，去掉蓝色边框
                if (isGroupPinned) {
                    messageItem.style.background = 'rgba(0, 0, 0, 0.05)';
                    messageItem.style.borderLeft = 'none';
                }
            });

            // 🔥【新增】渲染完成后，为了测试，可以手动设置一些未读消息
            // 这个代码仅用于演示，实际使用时应该删除
            if (window.location.hash === '#test-unread') {
                // 为"一号"角色设置一些未读消息用于测试
                const testCharacter = characters.find(c => c.name === '一号');
                if (testCharacter) {
                    const oneHourAgo = Date.now() - 60 * 60 * 1000;
                    localStorage.setItem(`lastRead_${testCharacter.id}`, oneHourAgo.toString());
                }
            }
        }

        // 🔥【新增】计算未读消息数量
        function getUnreadCount(characterId) {
            const messages = chatMessages[characterId] || [];
            const lastReadTime = localStorage.getItem(`lastRead_${characterId}`);

            if (!lastReadTime) {
                // 如果没有记录最后阅读时间，认为所有消息都已读
                return 0;
            }

            const lastReadTimestamp = parseInt(lastReadTime);
            const unreadMessages = messages.filter(msg =>
                msg.timestamp > lastReadTimestamp && msg.sender !== 'user'
            );

            return unreadMessages.length;
        }

        // 🔥【新增】标记消息为已读
        function markAsRead(characterId) {
            const now = Date.now();
            localStorage.setItem(`lastRead_${characterId}`, now.toString());
        }

        // 🔥【新增】置顶相关函数
        function loadPinnedConversations() {
            const saved = localStorage.getItem('pinnedConversations');
            pinnedConversations = saved ? JSON.parse(saved) : [];
        }

        function savePinnedConversations() {
            localStorage.setItem('pinnedConversations', JSON.stringify(pinnedConversations));
        }

        function togglePinConversation(conversationId) {
            const index = pinnedConversations.indexOf(conversationId);
            if (index > -1) {
                pinnedConversations.splice(index, 1);
            } else {
                pinnedConversations.push(conversationId);
            }
            savePinnedConversations();
        }

        function isPinned(conversationId) {
            return pinnedConversations.includes(conversationId);
        }

        // 🔥【修改】置顶选中的对话 - 支持重新设置置顶
        async function pinSelectedConversations() {
            // 🔥【新增】重新设置置顶逻辑：清空现有置顶，只置顶当前选中的对话
            pinnedConversations = [...selectedConversations];

            savePinnedConversations();
            renderMessageList();
            exitMessageListMultiSelectMode();

            const count = selectedConversations.length;
            showToast(`已重新设置置顶，当前置顶 ${count} 个对话`, 'success');
        }

        // 渲染联系人列表（角色页面）- 按分组显示
        function renderContactList() {
            const contactList = document.querySelector('#contact-list .contact-section');
            if (!contactList) return;

            // 清空所有内容
            contactList.innerHTML = '';



            // 添加多选模式的头部
            if (isMultiSelectMode) {
                const headerDiv = document.createElement('div');
                headerDiv.className = 'multiselect-header';
                headerDiv.innerHTML = `
                    <div class="multiselect-info">
                        <i class="fas fa-check-circle multiselect-icon"></i>
                        <span class="multiselect-text">已选择 ${selectedCharacters.length} 个角色</span>
                    </div>
                    <div class="multiselect-actions">
                        <button onclick="showMoveToGroupModal()" class="multiselect-btn move-btn" title="移动到分组">
                            <i class="fas fa-folder"></i>
                            <span>移动</span>
                        </button>
                        <button onclick="deleteSelectedCharacters()" class="multiselect-btn delete-btn" title="删除选中角色">
                            <i class="fas fa-trash"></i>
                            <span>删除</span>
                        </button>
                        <button onclick="exitMultiSelectMode()" class="multiselect-btn cancel-btn" title="取消多选">
                            <i class="fas fa-times"></i>
                            <span>取消</span>
                        </button>
                    </div>
                `;
                contactList.appendChild(headerDiv);
            }

            // 分组管理模式的头部
            if (isGroupManageMode) {
                const manageHeaderDiv = document.createElement('div');
                manageHeaderDiv.className = 'group-manage-header';
                manageHeaderDiv.innerHTML = `
                    <div class="group-manage-info">
                        <i class="fas fa-cogs group-manage-icon"></i>
                        <span class="group-manage-text">分组管理模式</span>
                    </div>
                    <div class="group-manage-actions">
                        <button onclick="showCreateGroupModal()" class="multiselect-btn create-btn" title="新建分组">
                            <i class="fas fa-plus"></i>
                            <span>新建</span>
                        </button>
                        <button onclick="exitGroupManageMode()" class="multiselect-btn done-btn" title="完成管理">
                            <i class="fas fa-check"></i>
                            <span>完成</span>
                        </button>
                    </div>
                `;
                contactList.appendChild(manageHeaderDiv);
            }

            // 按分组渲染角色
            const sortedGroups = characterGroups.sort((a, b) => a.order - b.order);

            sortedGroups.forEach(group => {
                const groupCharacters = characters.filter(char => char.groupId === group.id);

                // 如果该分组没有角色且不是分组管理模式，跳过显示
                if (groupCharacters.length === 0 && !isGroupManageMode) return;

                // 创建分组标题
                const groupHeader = document.createElement('div');
                groupHeader.className = `group-header ${group.isDefault ? 'default-group' : 'custom-group'}`;

                let interactionIcon = '';
                if (group.canInteract && !group.isDefault) {
                    interactionIcon = '<i class="fas fa-comments group-interaction-icon" title="该分组角色可以在动态中互动"></i>';
                }

                if (isGroupManageMode) {
                    groupHeader.innerHTML = `
                        <div class="group-title-area">
                            <span class="group-title">${group.name} (${groupCharacters.length})</span>
                            ${interactionIcon}
                            <span class="group-count"></span>
                        </div>
                        <div class="group-manage-actions">
                            ${!group.isDefault ? `
                                <button onclick="editGroup('${group.id}')" class="edit-group-btn" title="编辑分组">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button onclick="deleteGroup('${group.id}')" class="delete-group-btn" title="删除分组">
                                    <i class="fas fa-trash"></i>
                                </button>
                            ` : ''}
                        </div>
                    `;
                } else {
                    const isCollapsed = localStorage.getItem(`group_collapsed_${group.id}`) === 'true';
                    groupHeader.innerHTML = `
                        <div class="group-title-area" onclick="toggleGroupCollapse('${group.id}')">
                            <i class="fas fa-chevron-${isCollapsed ? 'right' : 'down'} group-chevron"></i>
                            <span class="group-title">${group.name}</span>
                            ${interactionIcon}
                            <span class="group-count">${groupCharacters.length}/${groupCharacters.length}</span>
                        </div>
                    `;
                }

                contactList.appendChild(groupHeader);

                // 创建角色容器
                const charactersContainer = document.createElement('div');
                charactersContainer.className = 'group-characters';
                charactersContainer.id = `group-characters-${group.id}`;

                // 检查是否折叠
                const isCollapsed = localStorage.getItem(`group_collapsed_${group.id}`) === 'true';
                if (isCollapsed && !isGroupManageMode) {
                    charactersContainer.style.display = 'none';
                }

                // 渲染分组中的角色
                groupCharacters.forEach(character => {
                    // 🔥【关键修复】使用统一的设置获取方式，避免数据不一致
                    const chatSettings = window.chatSettings && window.chatSettings[character.id] ?
                        window.chatSettings[character.id] : {};
                    const displayName = chatSettings.aiChatNickname || character.name;

                    // 获取头像形状设置
                    const avatarShape = chatSettings.avatarShape || 'circle';
                    const shapeClass = avatarShape === 'rounded-square' ? ' rounded-square' : '';

                    const contactItem = document.createElement('div');
                    contactItem.className = `contact-item ${isMultiSelectMode && selectedCharacters.includes(character.id) ? 'selected' : ''}`;
                    contactItem.dataset.characterId = character.id;

                    // 根据模式设置不同的点击事件
                    if (isMultiSelectMode) {
                        contactItem.onclick = () => toggleCharacterSelection(character.id);
                    } else {
                        contactItem.onclick = () => editCharacterFromContactList(character.id);

                        // 添加长按事件（支持触摸和鼠标）
                        let pressTimer;

                        const startLongPress = (e) => {
                            pressTimer = setTimeout(() => {
                                // 长按直接弹出移动角色模态框
                                showMoveCharacterModal(character.id);
                                e.preventDefault();
                            }, 800);
                        };

                        const cancelLongPress = () => {
                            clearTimeout(pressTimer);
                        };

                        // 触摸事件
                        contactItem.addEventListener('touchstart', startLongPress);
                        contactItem.addEventListener('touchend', cancelLongPress);
                        contactItem.addEventListener('touchmove', cancelLongPress);

                        // 鼠标事件（作为备选）
                        contactItem.addEventListener('mousedown', startLongPress);
                        contactItem.addEventListener('mouseup', cancelLongPress);
                        contactItem.addEventListener('mouseleave', cancelLongPress);

                        // 右键点击
                        contactItem.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            // 右键直接弹出移动角色模态框
                            showMoveCharacterModal(character.id);
                        });
                    }

                    // 🔥【修改】检查拉黑/屏蔽状态 - 修复群聊判断逻辑 + 添加调试
                    let statusIndicator = '';
                    if (character.isGroup === true) {
                        // 群聊检查屏蔽状态
                        const isMuted = isGroupMuted(character.id);
                        if (isMuted) {
                            statusIndicator = '<div class="contact-status-indicator muted" title="已屏蔽"><i class="fas fa-volume-mute"></i></div>';
                        }
                    } else {
                        // 单聊检查拉黑状态
                        const isUserBlocked = isBlocked('user', character.id);
                        const isCharacterBlocked = isBlocked(character.id, 'user');



                        if (isUserBlocked) {
                            statusIndicator = '<div class="contact-status-indicator blocked" title="已拉黑"><i class="fas fa-ban"></i></div>';
                        } else if (isCharacterBlocked) {
                            statusIndicator = '<div class="contact-status-indicator blocked-by" title="被对方拉黑"><i class="fas fa-exclamation-triangle"></i></div>';
                        }
                    }

                    contactItem.innerHTML = `
                        ${isMultiSelectMode ? `
                            <div class="selection-checkbox ${selectedCharacters.includes(character.id) ? 'selected' : ''}">
                                ${selectedCharacters.includes(character.id) ? '<i class="fas fa-check check-icon-white"></i>' : ''}
                            </div>
                        ` : ''}
                        <div class="message-avatar${shapeClass}" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                            ${character.avatarUrl ? '' : displayName.charAt(0)}
                        </div>
                        <div class="contact-info">
                            <div class="message-name">${displayName}</div>
                            <div class="character-preview">${truncateText(character.bio || '暂无人设描述', 25)}</div>
                        </div>
                        ${statusIndicator}
                        ${isGroupManageMode ? `
                            <div class="move-character-btn" onclick="showMoveCharacterModal('${character.id}')" title="移动到其他分组">
                                <i class="fas fa-arrows-alt"></i>
                            </div>
                        ` : ''}
                    `;

                    charactersContainer.appendChild(contactItem);
                });

                // 如果分组没有角色，显示提示
                if (groupCharacters.length === 0 && isGroupManageMode) {
                    const emptyDiv = document.createElement('div');
                    emptyDiv.className = 'empty-group-message';
                    emptyDiv.textContent = '该分组暂无角色';
                    charactersContainer.appendChild(emptyDiv);
                }

                contactList.appendChild(charactersContainer);
            });

            // 如果完全没有角色，显示提示
            if (characters.length === 0) {
                const emptyDiv = document.createElement('div');
                emptyDiv.className = 'empty-message';
                emptyDiv.textContent = '还没有角色，点击右上角+号创建角色吧！';
                contactList.appendChild(emptyDiv);
            }
        }

        // === 分组管理相关函数 ===
        function enterGroupManageMode() {
            isGroupManageMode = true;
            renderContactList();

            // 隐藏管理分组按钮
            const groupManageBtn = document.getElementById('group-manage-btn');
            if (groupManageBtn) {
                groupManageBtn.style.display = 'none';
            }
        }

        function exitGroupManageMode() {
            isGroupManageMode = false;
            renderContactList();

            // 显示管理分组按钮
            const groupManageBtn = document.getElementById('group-manage-btn');
            if (groupManageBtn) {
                groupManageBtn.style.display = 'flex';
            }
        }

        function toggleGroupCollapse(groupId) {
            const container = document.getElementById(`group-characters-${groupId}`);
            if (!container) return;

            const isCollapsed = container.style.display === 'none';
            container.style.display = isCollapsed ? 'block' : 'none';

            // 保存折叠状态
            localStorage.setItem(`group_collapsed_${groupId}`, !isCollapsed);

            // 更新箭头方向
            const chevron = document.querySelector(`[onclick="toggleGroupCollapse('${groupId}')"] .group-chevron`);
            if (chevron) {
                chevron.className = `fas fa-chevron-${isCollapsed ? 'down' : 'right'} group-chevron`;
            }
        }

        function showCreateGroupModal() {
            const modalHtml = `
                <div id="create-group-modal" class="modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">新建分组</div>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label>分组名称</label>
                                <input type="text" id="new-group-name" class="form-input" placeholder="请输入分组名称" maxlength="10">
                            </div>
                            <div class="form-group">
                                <label>
                                    <input type="checkbox" id="new-group-interaction" class="form-checkbox">
                                    允许该分组角色在动态中互动
                                </label>
                                <p class="form-help-text">开启后，该分组的角色可以在动态页面相互点赞、评论</p>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideCreateGroupModal()">取消</button>
                            <button class="modal-button modal-primary" onclick="createNewGroup()">创建</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHtml);

            // 聚焦输入框
            setTimeout(() => {
                document.getElementById('new-group-name').focus();
            }, 100);
        }

        function hideCreateGroupModal() {
            const modal = document.getElementById('create-group-modal');
            if (modal) modal.remove();
        }

        async function createNewGroup() {
            const nameInput = document.getElementById('new-group-name');
            const interactionCheckbox = document.getElementById('new-group-interaction');

            const name = nameInput.value.trim();
            if (!name) {
                alert('请输入分组名称');
                nameInput.focus();
                return;
            }

            // 检查重名
            if (characterGroups.find(g => g.name === name)) {
                alert('分组名称已存在');
                nameInput.focus();
                return;
            }

            const newGroup = {
                id: 'group_' + Date.now(),
                name: name,
                order: characterGroups.length + 1,
                isDefault: false,
                canInteract: interactionCheckbox.checked
            };

            characterGroups.push(newGroup);
            await saveCharacterGroups();

            hideCreateGroupModal();
            renderContactList();
            showToast('分组创建成功', 'success');
        }

        function editGroup(groupId) {
            const group = characterGroups.find(g => g.id === groupId);
            if (!group || group.isDefault) return;

            const modalHtml = `
                <div id="edit-group-modal" class="modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">编辑分组</div>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label>分组名称</label>
                                <input type="text" id="edit-group-name" class="form-input" value="${group.name}" maxlength="10">
                            </div>
                            <div class="form-group">
                                <label>
                                    <input type="checkbox" id="edit-group-interaction" class="form-checkbox" ${group.canInteract ? 'checked' : ''}>
                                    允许该分组角色在动态中互动
                                </label>
                                <p class="form-help-text">开启后，该分组的角色可以在动态页面相互点赞、评论</p>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideEditGroupModal()">取消</button>
                            <button class="modal-button modal-primary" onclick="updateGroup('${groupId}')">保存</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHtml);

            // 聚焦输入框
            setTimeout(() => {
                document.getElementById('edit-group-name').focus();
            }, 100);
        }

        function hideEditGroupModal() {
            const modal = document.getElementById('edit-group-modal');
            if (modal) modal.remove();
        }

        async function updateGroup(groupId) {
            const nameInput = document.getElementById('edit-group-name');
            const interactionCheckbox = document.getElementById('edit-group-interaction');

            const name = nameInput.value.trim();
            if (!name) {
                alert('请输入分组名称');
                nameInput.focus();
                return;
            }

            // 检查重名（排除自己）
            if (characterGroups.find(g => g.name === name && g.id !== groupId)) {
                alert('分组名称已存在');
                nameInput.focus();
                return;
            }

            const groupIndex = characterGroups.findIndex(g => g.id === groupId);
            if (groupIndex !== -1) {
                characterGroups[groupIndex].name = name;
                characterGroups[groupIndex].canInteract = interactionCheckbox.checked;

                await saveCharacterGroups();

                hideEditGroupModal();
                renderContactList();
                showToast('分组更新成功', 'success');
            }
        }

        async function deleteGroup(groupId) {
            const group = characterGroups.find(g => g.id === groupId);
            if (!group || group.isDefault) return;

            const groupCharacters = characters.filter(char => char.groupId === groupId);

            let confirmMsg = `确定要删除分组"${group.name}"吗？`;
            if (groupCharacters.length > 0) {
                confirmMsg += `\n\n该分组下有 ${groupCharacters.length} 个角色，将被移动到"我的好友"分组。`;
            }

            if (!confirm(confirmMsg)) return;

            // 将该分组的角色移动到默认分组
            groupCharacters.forEach(character => {
                character.groupId = 'my_friends';
            });

            // 删除分组
            const groupIndex = characterGroups.findIndex(g => g.id === groupId);
            if (groupIndex !== -1) {
                characterGroups.splice(groupIndex, 1);
            }

            await Promise.all([
                saveCharacterGroups(),
                saveCharacters()
            ]);

            renderContactList();
            showToast('分组删除成功', 'success');
        }

        function showMoveCharacterModal(characterId) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;

            const availableGroups = characterGroups.filter(g => g.id !== character.groupId);

            const modalHtml = `
                <div id="move-character-modal" class="modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">移动角色：${character.name}</div>
                        </div>
                        <div class="modal-body">
                            <div class="group-list">
                                ${availableGroups.map(group => `
                                    <div class="group-option" onclick="moveCharacterToGroup('${characterId}', '${group.id}')">
                                        <span class="group-name">${group.name}</span>
                                        <i class="fas fa-chevron-right"></i>
                                    </div>
                                `).join('')}
                            </div>
                            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #eee;">
                                <div class="group-option" onclick="hideMoveCharacterModal(); enterMultiSelectMode('${characterId}');" style="color: #007AFF;">
                                    <span class="group-name">
                                        <i class="fas fa-check-square" style="margin-right: 6px;"></i>
                                        进入多选模式
                                    </span>
                                    <i class="fas fa-chevron-right"></i>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideMoveCharacterModal()">取消</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        function hideMoveCharacterModal() {
            const modal = document.getElementById('move-character-modal');
            if (modal) modal.remove();
        }

        async function moveCharacterToGroup(characterId, targetGroupId) {
            const characterIndex = characters.findIndex(c => c.id === characterId);
            if (characterIndex !== -1) {
                const oldGroupId = characters[characterIndex].groupId;
                characters[characterIndex].groupId = targetGroupId;

                await saveCharacters();
                hideMoveCharacterModal();
                renderContactList();

                const targetGroup = characterGroups.find(g => g.id === targetGroupId);
                showToast(`已移动到"${targetGroup.name}"分组`, 'success');
            }
        }

        function showMoveToGroupModal() {
            if (selectedCharacters.length === 0) {
                alert('请先选择要移动的角色');
                return;
            }

            const modalHtml = `
                <div id="move-to-group-modal" class="modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">移动 ${selectedCharacters.length} 个角色到分组</div>
                        </div>
                        <div class="modal-body">
                            <div class="group-list">
                                ${characterGroups.map(group => `
                                    <div class="group-option" onclick="moveSelectedCharactersToGroup('${group.id}')">
                                        <span class="group-name">${group.name}</span>
                                        <i class="fas fa-chevron-right"></i>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideMoveToGroupModal()">取消</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        function hideMoveToGroupModal() {
            const modal = document.getElementById('move-to-group-modal');
            if (modal) modal.remove();
        }

        async function moveSelectedCharactersToGroup(targetGroupId) {
            selectedCharacters.forEach(characterId => {
                const characterIndex = characters.findIndex(c => c.id === characterId);
                if (characterIndex !== -1) {
                    characters[characterIndex].groupId = targetGroupId;
                }
            });

            await saveCharacters();
            hideMoveToGroupModal();
            exitMultiSelectMode(); // 退出多选模式

            const targetGroup = characterGroups.find(g => g.id === targetGroupId);
            showToast(`已移动 ${selectedCharacters.length} 个角色到"${targetGroup.name}"分组`, 'success');
        }

        // 渲染角色列表
        function renderCharacterList() {
            const characterList = document.getElementById('character-list');
            // 检查元素是否存在，如果不存在就跳过（因为我们已经删除了人物应用）
            if (!characterList) {
                console.log('character-list元素不存在，跳过渲染');
                return;
            }

            characterList.innerHTML = '';

            characters.forEach(character => {
                const characterItem = document.createElement('div');
                characterItem.className = 'character-item';
                characterItem.onclick = () => editCharacter(character.id);

                characterItem.innerHTML = `
                    <div class="character-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                        ${character.avatarUrl ? '' : character.name.charAt(0)}
                    </div>
                    <div class="character-info">
                        <div class="character-name">${character.name}</div>
                        <div class="character-bio">${truncateText(character.bio, 50)}</div>
                    </div>
                `;

                characterList.appendChild(characterItem);
            });
        }



        // 当前显示的消息数量限制
        let currentMessageOffset = 0;
        const MESSAGE_LIMIT = 50;

        // 🔥【新增】同步包装函数，用于向后兼容
        function renderChatMessages(characterId, loadMore = false) {
            renderChatMessagesAsync(characterId, loadMore).catch(error => {
                console.error('渲染聊天消息失败:', error);
            });
        }

        // 🔥【新增】为消息添加气泡戳的JavaScript函数
        function addBubbleTail(messageContainer, message) {
            // 检查是否是气泡戳样式
            const chatContainer = document.querySelector('.chat-container');
            if (!chatContainer || !chatContainer.classList.contains('bubble-style-tail')) {
                return;
            }

            const messageBubble = messageContainer.querySelector('.message-bubble');
            if (!messageBubble) return;

            // 创建三角形元素
            const tail = document.createElement('div');
            tail.className = 'bubble-tail-js';
            tail.style.cssText = `
                position: absolute;
                width: 0;
                height: 0;
                border-style: solid;
                z-index: 100;
                pointer-events: none;
            `;

            if (message.sender === 'received') {
                // 角色消息 - 左侧三角形
                tail.style.cssText += `
                    left: -8px;
                    top: 10px;
                    border-width: 0 8px 10px 0;
                    border-color: transparent ${getComputedStyle(messageBubble).backgroundColor} transparent transparent;
                `;
            } else if (message.sender === 'sent') {
                // 用户消息 - 右侧三角形
                tail.style.cssText += `
                    right: -8px;
                    top: 10px;
                    border-width: 10px 8px 0 0;
                    border-color: ${getComputedStyle(messageBubble).backgroundColor} transparent transparent transparent;
                `;
            }

            messageBubble.appendChild(tail);
        }

        // 渲染聊天消息（异步版本）
        async function renderChatMessagesAsync(characterId, loadMore = false) {
            const messagesContainer = document.getElementById('api-chat-messages');
            const allMessages = chatMessages[characterId] || [];
            const chatSettings = await getAsyncChatSettings(characterId); // 🔥【修复】使用异步版本确保获取正确的设置

            if (!loadMore) {
                // 重新渲染时清空容器并重置偏移量
                messagesContainer.innerHTML = '';
                currentMessageOffset = Math.max(0, allMessages.length - MESSAGE_LIMIT);
            }

            // 应用聊天背景（渲染时不保存，避免重复保存）
            applyChatBackground(undefined, true);

            // 🔥【修复】确保气泡样式在消息渲染前应用
            applyBubbleStyle();

            // 如果没有消息，显示空状态提示
            if (allMessages.length === 0) {
                const displayName = chatSettings.aiChatNickname || currentChatCharacter.name;
                const emptyState = document.createElement('div');
                emptyState.className = 'empty-chat-state';
                emptyState.innerHTML = `
                    <div>开始和 ${displayName} 聊天吧</div>
                `;
                messagesContainer.appendChild(emptyState);
                return;
            }

            // 如果不是加载更多，且有更多历史消息，显示"查看历史消息"按钮
            if (!loadMore && currentMessageOffset > 0) {
                const loadMoreBtn = document.createElement('div');
                loadMoreBtn.className = 'load-more-messages';
                loadMoreBtn.innerHTML = `
                    <div class="load-more-content">
                        <i class="fas fa-chevron-up"></i>
                        <span>查看历史消息 (${currentMessageOffset}条)</span>
                    </div>
                `;
                loadMoreBtn.onclick = () => loadMoreMessages(characterId);
                messagesContainer.appendChild(loadMoreBtn);
            }

            // 🔥【修复】过滤掉线下模式和游戏消息，不在线上聊天界面显示
            const onlineMessages = allMessages.filter(msg => !msg.isOfflineMode && !msg.isGameMessage && !msg.isGameContext);

            // 重新计算偏移量，基于过滤后的消息
            const adjustedOffset = loadMore ?
                Math.max(0, onlineMessages.length - MESSAGE_LIMIT) :
                Math.max(0, onlineMessages.length - MESSAGE_LIMIT);

            // 获取要显示的消息
            const messagesToShow = loadMore ?
                onlineMessages.slice(Math.max(0, adjustedOffset - MESSAGE_LIMIT), adjustedOffset) :
                onlineMessages.slice(adjustedOffset);

            // 🔥【修复】获取时间戳设置，默认开启
            const timestampEnabled = chatSettings.timestampEnabled !== false; // 默认为true，只有明确设置为false才关闭
            const timestampPosition = chatSettings.timestampPosition || 'center';

            let lastTimestamp = 0;

            messagesToShow.forEach((message, index) => {
                // 处理系统消息（如戳一戳、头像更换、撤回等）
                if (message.sender === 'system') {
                    // 🔥【移除】不再处理拉黑系统消息，因为它们不再保存到聊天记录中
                    // 拉黑提示现在由 addBlockedIndicatorToMessage 函数直接在每条消息下方添加

                    if (message.isPoke) {
                    const systemContainer = document.createElement('div');
                    systemContainer.className = 'poke-system-container';
                    const systemMessage = document.createElement('div');
                    systemMessage.className = 'poke-system-message';
                    systemMessage.textContent = message.content;
                    systemContainer.appendChild(systemMessage);
                    messagesContainer.appendChild(systemContainer);
                    } else if (message.type === 'system_notification') {
                        // 🔥【新增】处理AI选歌等系统通知
                        const centerContainer = document.createElement('div');
                        centerContainer.style.display = 'flex';
                        centerContainer.style.justifyContent = 'center';
                        centerContainer.style.margin = '4px 0';
                        centerContainer.dataset.messageId = message.id;

                        const notificationElement = document.createElement('div');
                        notificationElement.className = 'system-notification';
                        notificationElement.style.cssText = `
                            color: #999;
                            font-size: 12px;
                            padding: 4px 8px;
                            background: rgba(0,0,0,0.05);
                            border-radius: 12px;
                            max-width: 80%;
                            text-align: center;
                        `;

                        notificationElement.textContent = message.content;

                        centerContainer.appendChild(notificationElement);
                        messagesContainer.appendChild(centerContainer);
                    } else if (message.type === 'recalled_message') {
                        // 🔥【新增】处理撤回消息的显示
                        const centerContainer = document.createElement('div');
                        centerContainer.style.display = 'flex';
                        centerContainer.style.justifyContent = 'center';
                        centerContainer.style.margin = '4px 0';
                        centerContainer.dataset.messageId = message.id; // 🔥【修复】添加消息ID以支持选择

                        const recallElement = document.createElement('div');
                        recallElement.className = 'recalled-message';

                        // 🔥【兼容性修复】解析撤回消息内容，支持新旧格式
                        const lines = message.content.split('\n');
                        const mainText = lines[0]; // 主要提示文字
                        let originalText = lines[1]; // 原文部分

                        recallElement.textContent = mainText;

                        // 🔥【兼容性处理】支持多种原文格式
                        if (originalText) {
                            // 新格式：原文：xxx
                            if (originalText.startsWith('原文：')) {
                                const originalDiv = document.createElement('div');
                                originalDiv.className = 'original-text';
                                originalDiv.textContent = originalText;
                                recallElement.appendChild(originalDiv);
                            }
                            // 旧格式：直接是原文内容
                            else {
                                const originalDiv = document.createElement('div');
                                originalDiv.className = 'original-text';
                                originalDiv.textContent = `原文：${originalText}`;
                                recallElement.appendChild(originalDiv);
                            }
                        }
                        // 🔥【兼容性处理】如果没有原文但有originalContent字段
                        else if (message.originalContent) {
                            const originalDiv = document.createElement('div');
                            originalDiv.className = 'original-text';
                            originalDiv.textContent = `原文：${message.originalContent}`;
                            recallElement.appendChild(originalDiv);
                        }

                        centerContainer.appendChild(recallElement);
                        messagesContainer.appendChild(centerContainer);

                        // 🔥【修复】为撤回消息添加选择功能
                        addMessageLongPressListener(centerContainer, message.id);
                    } else if (message.type === 'call_record') {
                        // 处理通话记录消息
                        const centerContainer = document.createElement('div');
                        centerContainer.className = 'message-wrapper system';
                        centerContainer.dataset.messageId = message.id;

                        const callRecordElement = document.createElement('div');
                        callRecordElement.className = 'call-record-message';
                        callRecordElement.style.textAlign = 'center';
                        callRecordElement.style.color = '#888';
                        callRecordElement.style.fontSize = '13px';
                        callRecordElement.style.padding = '8px 0';

                        // 直接显示文本，不添加图标，也不重复显示时长
                        callRecordElement.textContent = message.content;

                        centerContainer.appendChild(callRecordElement);
                        messagesContainer.appendChild(centerContainer);
                    } else if (message.type === 'call_message') {
                        // 🔥【新增】处理通话消息 - 显示为简单的文本消息
                        const centerContainer = document.createElement('div');
                        centerContainer.className = 'message-wrapper system';
                        centerContainer.dataset.messageId = message.id;

                        const callMessageElement = document.createElement('div');
                        callMessageElement.className = 'call-system-message';
                        callMessageElement.style.color = '#888';
                        callMessageElement.style.fontSize = '13px';
                        callMessageElement.style.textAlign = 'center';
                        callMessageElement.style.padding = '8px 0';
                        callMessageElement.textContent = message.content;

                        centerContainer.appendChild(callMessageElement);
                        messagesContainer.appendChild(centerContainer);
                    } else {
                        // 🔥【修复】其他系统消息（如头像更换）- 使用居中容器
                        const centerContainer = document.createElement('div');
                        centerContainer.style.display = 'flex';
                        centerContainer.style.justifyContent = 'center';
                        centerContainer.style.margin = '4px 0';

                        const systemContainer = document.createElement('div');
                        // 🔥【美化】检查是否为好友添加成功消息，应用特殊样式
                        if (message.isFriendAddedMessage) {
                            systemContainer.className = 'friend-added-system-message';
                        } else {
                            systemContainer.className = 'system-message';
                        }
                        systemContainer.textContent = message.content;

                        centerContainer.appendChild(systemContainer);
                        messagesContainer.appendChild(centerContainer);
                    }
                    return;
                }

                // 添加居中时间戳（如果启用且位置为居中）
                if (timestampEnabled && timestampPosition === 'center') {
                    const currentTime = new Date(message.timestamp);
                    const timeDiff = currentTime - lastTimestamp;

                    // 如果距离上条消息超过5分钟，显示时间戳
                    if (index === 0 || timeDiff > 5 * 60 * 1000) {
                        const timestampDiv = document.createElement('div');
                        timestampDiv.className = 'timestamp timestamp-center';
                        timestampDiv.textContent = formatTimestamp(message.timestamp);
                        messagesContainer.appendChild(timestampDiv);
                        lastTimestamp = currentTime;
                    }
                }

                const messageContainer = document.createElement('div');
                // 检查是否是纯表情包消息
                const isEmojiOnly = message.isEmoji && !message.content;
                messageContainer.className = `message-container ${message.sender}${chatSettings.hideAvatars ? ' no-avatar' : ''}${isEmojiOnly ? ' emoji-only' : ''}`;
                messageContainer.dataset.messageId = message.id; // 添加消息ID数据属性

                if (message.sender === 'received') {
                    // ==== 群聊支持 ====
                    let character = characters.find(c => c.id === characterId);
                    let isGroup = false;
                    let group = null;
                    if (!character) {
                        group = groupChats.find(g => g.id === characterId);
                        if (group) {
                            isGroup = true;
                        }
                    }

                    let displayAvatar = '';
                    let displayName = '';
                    let color = '#4CAF50';

                    if (isGroup && group) {
                        // 群聊：根据消息的senderId或name查找成员
                        let member = null;
                        console.log('🔍 [消息渲染] 群聊消息渲染 - senderId:', message.senderId, 'name:', message.name);
                        console.log('🔍 [消息渲染] 群成员列表:', group.members);
                        console.log('🔍 [消息渲染] 完整消息对象:', message);

                        // 表情包消息处理

                        if (message.senderId) {
                            member = group.members.find(m => m.id === message.senderId);
                            console.log('🔍 [消息渲染] 通过senderId找到成员:', member);
                            console.log('🔍 [消息渲染] senderId查找详情:', {
                                messageSenderId: message.senderId,
                                memberIds: group.members.map(m => m.id),
                                foundMember: member
                            });
                        } else if (message.name) {
                            member = group.members.find(m => m.name === message.name);
                            console.log('🔍 [消息渲染] 通过name找到成员:', member);
                            console.log('🔍 [消息渲染] name查找详情:', {
                                messageName: message.name,
                                memberNames: group.members.map(m => m.name),
                                foundMember: member
                            });
                        }

                        // 🔥【修复】确保群聊表情包消息正确显示发送者
                        if (member) {
                            displayAvatar = member.avatarUrl || '';
                            displayName = member.name;
                            color = member.color || '#4CAF50';
                        } else {
                            // 如果没找到成员，使用消息中的name作为显示名称
                            displayAvatar = '';
                            displayName = message.name || '群成员';
                            color = '#4CAF50';
                            console.warn('🔍 [消息渲染] 未找到群成员，使用消息name:', message.name);
                        }

                        // 头像和显示名处理完成
                    } else if (character) {
                        // 单聊
                        displayAvatar = chatSettings.aiChatAvatar || character.avatarUrl;
                        displayName = chatSettings.aiChatNickname || character.name;
                        color = character.color || '#4CAF50';

                    // 头像选择逻辑
                    } else {
                        // 兜底，防止报错
                        displayAvatar = '';
                        displayName = '未知';
                        color = '#4CAF50';
                    }

                    // 🔥【新增】获取气泡样式 - 群聊中使用成员专属颜色
                    let bubbleColor = chatSettings.aiBubbleColor || '#f0f0f0';

                    // 如果是群聊且有成员专属颜色设置，使用成员专属颜色
                    if (isGroup && group && message.senderId && chatSettings.memberBubbleColors) {
                        const memberColor = chatSettings.memberBubbleColors[message.senderId];
                        if (memberColor) {
                            bubbleColor = memberColor;
                        }
                    }

                    const bubbleOpacity = chatSettings.aiBubbleOpacity || '1';
                    const textColor = isLightColor(bubbleColor) ? '#333' : '#fff';
                    const bubblePadding = chatSettings.bubblePadding || '12';

                    // 将透明度应用到背景色而不是整个元素
                    const transparentBubbleColor = convertColorWithOpacity(bubbleColor, bubbleOpacity);

                    // 🔥 处理特殊消息类型
                    let messageContent = '';

                    if (message.type === 'user_photo') {
                        // 角色发送的"伪照片" - 使用与用户相同的结构
                        messageContent = `
                            <div class="dreamy-photo-container" onclick="togglePhotoText(this, '${(message.photoDescription || message.content).replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')">
                                <div class="dreamy-photo">
                                    <div class="photo-misty-bg"></div>
                                    <div class="photo-badge">
                                        <i class="fas fa-image"></i>
                                    </div>
                                    <div class="sparkle-container">
                                        <div class="sparkle sparkle-1">✨</div>
                                        <div class="sparkle sparkle-2">⭐</div>
                                        <div class="sparkle sparkle-3">✨</div>
                                        <div class="sparkle sparkle-4">⭐</div>
                                        <div class="sparkle sparkle-5">💫</div>
                                    </div>
                                    <div class="photo-text-overlay" style="display: none;">
                                        <div class="photo-description">${(message.photoDescription || message.content)}</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'location') {
                        // 角色发送的位置消息 - 使用与用户相同的结构
                        messageContent = `
                            <div class="location-card" onclick="showLocationDetail('${message.locationName}')">
                                <div class="location-card-header">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
                                        <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                    </svg>
                                    ${message.locationName}
                                </div>
                                <div class="location-card-map">
                                    <div class="map-background"></div>
                                    <div class="map-roads">
                                        <div class="road road-horizontal" style="top: 35%; width: 100%;"></div>
                                        <div class="road road-vertical" style="left: 40%; height: 100%;"></div>
                                        <div class="road road-horizontal" style="top: 65%; width: 70%; left: 30%;"></div>
                                    </div>
                                    <div class="map-buildings">
                                        <div class="building" style="top: 15%; left: 20%; width: 12px; height: 10px;"></div>
                                        <div class="building" style="top: 25%; left: 60%; width: 14px; height: 12px;"></div>
                                        <div class="building green" style="top: 50%; left: 15%; width: 8px; height: 8px;"></div>
                                        <div class="building" style="top: 70%; left: 70%; width: 10px; height: 8px;"></div>
                                        <div class="building green" style="top: 10%; left: 75%; width: 6px; height: 6px;"></div>
                                        <div class="building green" style="top: 75%; left: 25%; width: 7px; height: 7px;"></div>
                                    </div>
                                    <div class="map-marker">
                                        <div class="marker-pin">
                                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                                                <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                            </svg>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'voice_message') {
                        // 过滤掉括号中的描述性内容，保留实际说话内容
                        const cleanVoiceContent = message.content.replace(/\([^)]*\)\s*/g, '').trim();
                        const voiceDuration = message.duration || Math.max(1, Math.ceil(cleanVoiceContent.length / 8));

                        // AI语音消息 - 使用和用户语音消息一样的结构
                        messageContent = `
                            <div class="voice-message-container received">
                                <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                                    <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${cleanVoiceContent}">
                                        <div class="voice-wave">
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                        </div>
                                        <div class="voice-duration">${voiceDuration}"</div>

                                    </div>
                                </div>
                                <div class="voice-text-content">${cleanVoiceContent}</div>
                            </div>
                        `;
                    } else if (message.type === 'ai_image') {
                        // AI生成的图片 - 使用星星emoji卡片样式
                        const imageDesc = message.imageDescription || message.content || 'AI描述的图片';
                        messageContent = `
                            <div class="dreamy-photo-container" onclick="togglePhotoText(this, '${imageDesc.replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')">
                                <div class="dreamy-photo">
                                    <div class="photo-misty-bg"></div>
                                    <div class="photo-badge">
                                        <i class="fas fa-image"></i>
                                    </div>
                                    <div class="sparkle-container">
                                        <div class="sparkle sparkle-1">✨</div>
                                        <div class="sparkle sparkle-2">⭐</div>
                                        <div class="sparkle sparkle-3">✨</div>
                                        <div class="sparkle sparkle-4">⭐</div>
                                        <div class="sparkle sparkle-5">💫</div>
                                    </div>
                                    <div class="photo-text-overlay" style="display: none;">
                                        <div class="photo-description">${imageDesc}</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'transfer') {
                        // 转账消息
                        const isUser = message.role === 'user';
                        const heartIcon = isUser ? '💕' : '💖';
                        const titleText = isUser ? '你发起的转账' : '收到转账';
                        let cardClass = '';
                        let statusHtml = '';
                        let clickHandler = '';

                        if (message.status === 'accepted') {
                            statusHtml = `<div class="transfer-status">${isUser ? '对方已收款' : '已收款'}</div>`;
                            cardClass = 'accepted';
                        } else if (message.status === 'rejected') {
                            statusHtml = `<div class="transfer-status">${isUser ? '对方已退回' : '已退回'}</div>`;
                            cardClass = 'rejected';
                        } else if (!isUser) {
                            // AI发来的转账且未处理，添加点击处理
                            clickHandler = `onclick="showTransferConfirmDialog(${JSON.stringify(message).replace(/"/g, '&quot;')})"`;
                        }

                        messageContent = `
                            <div class="transfer-message-container received">
                                <div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}" ${clickHandler}>
                                    <div class="transfer-title">${heartIcon} ${titleText}</div>
                                    <div class="transfer-amount">¥ ${Number(message.amount).toFixed(2)}</div>
                                    <div class="transfer-note">${message.note || '转账'}</div>
                                    ${statusHtml}
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'friend_request') {
                        // 🔥【新增】AI主动发送的好友申请
                        let actionsHtml;
                        if (message.friendRequestProcessed) {
                            // 已处理的好友申请，显示处理结果
                            const resultText = message.friendRequestAccepted ? '已同意' : '已拒绝';
                            const resultClass = message.friendRequestAccepted ? 'accepted' : 'rejected';
                            actionsHtml = `<div class="friend-request-result ${resultClass}">${resultText}</div>`;
                            console.log('🔄 渲染已处理的好友申请:', message.id, resultText);
                        } else {
                            // 未处理的好友申请，显示按钮
                            actionsHtml = `
                                <button class="friend-request-btn accept" onclick="handleAIFriendRequest('${currentChatCharacter?.id}', true, '${message.id}')">同意</button>
                                <button class="friend-request-btn reject" onclick="handleAIFriendRequest('${currentChatCharacter?.id}', false, '${message.id}')">拒绝</button>
                            `;
                            console.log('🔄 渲染未处理的好友申请:', message.id);
                        }

                        messageContent = `
                            <div class="friend-request-container">
                                <div class="friend-request-card">
                                    <div class="friend-request-title">好友申请</div>
                                    <div class="friend-request-message-section">
                                        <div class="friend-request-message-label">对方留言</div>
                                        <div class="friend-request-message-content">${message.message || '想和你重新做朋友'}</div>
                                    </div>
                                    <div class="friend-request-actions">
                                        ${actionsHtml}
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        // 普通文本消息
                        const chatMode = chatSettings.chatMode || 'online';

                        // 🔥【修复】处理多模态消息格式
                        let processedContent;
                        if (typeof message.content === 'string') {
                            processedContent = message.content;
                        } else if (Array.isArray(message.content) && message.content.length > 0) {
                            // 多模态消息格式：[{type: 'text', text: '内容'}]
                            const firstItem = message.content[0];
                            if (firstItem && firstItem.type === 'text' && firstItem.text) {
                                processedContent = firstItem.text;
                            } else {
                                processedContent = '[多媒体消息]';
                            }
                        } else if (message.content && typeof message.content === 'object') {
                            // 约定或纪念日对象
                            if (message.content.name && typeof message.content.name === 'string') {
                                if (message.content.type === 'create_appointment') {
                                    processedContent = `创建了约定：${message.content.name}`;
                                } else if (message.content.type === 'create_anniversary') {
                                    processedContent = `创建了纪念日：${message.content.name}`;
                                } else {
                                    processedContent = `提及了：${message.content.name}`;
                                }
                            } else {
                                // 其他对象类型
                                processedContent = message.content.message || message.content.text || '[多媒体消息]';
                            }
                        } else {
                            processedContent = String(message.content || '');
                        }

                        if (chatMode === 'offline') {
                            processedContent = processOfflineContent(processedContent);
                        }

                        // 处理@内容
                        processedContent = processMentions(processedContent);

                        // 如果有引用消息，在内容前添加引用显示
                        if (message.replyTo) {
                            messageContent = generateReplyHTML(message.replyTo) + processedContent;
                        } else {
                            messageContent = processedContent;
                        }
                    }

                    let avatarHtml = '';
                    if (!chatSettings.hideAvatars) {
                        avatarHtml = generateAvatarHtml({
                            avatarUrl: displayAvatar,
                            backgroundColor: color,
                            displayName: displayName,
                            timestamp: message.timestamp,
                            timestampEnabled: timestampEnabled,
                            timestampPosition: timestampPosition,
                            chatSettings: chatSettings,
                            onClick: character ? `pokeCharacter('${character.id}')` : '',
                            title: character ? '戳一戳' : displayName
                        });
                    }

                    let bubbleHtml = '';
                    if (message.type === 'voice_message' || message.type === 'transfer' || message.type === 'user_photo' || message.type === 'location' || message.type === 'ai_image' || message.type === 'friend_request') {
                        // 语音消息、转账消息、照片、位置消息和AI图片消息不需要额外的气泡包裹
                        bubbleHtml = messageContent;
                    } else {
                        // 普通消息用气泡包裹
                        bubbleHtml = `
                                                    <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                                ${messageContent}
                                ${message.image && !message.type ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}

                                ${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                ${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}
                            </div>
                    `;
                    }

      // 🔥【修复】群聊昵称显示 - 特别处理语音消息、转账消息、照片卡片和位置信息
      if (isGroup && group && displayName !== '群成员') {
    messageContainer.classList.add('group-message-item');
    const senderNameHtml = `<div class="sender-name">${displayName}</div>`;

    if (message.type === 'voice_message' || message.type === 'transfer' || message.type === 'ai_image' || message.type === 'user_photo' || message.type === 'location' || message.type === 'friend_request' || message.type === 'order_confirmation') {
        // 🔥【修复】对于语音消息、转账消息、AI图片消息、照片卡片和位置信息，昵称需要在容器外部
    messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    } else {
        // 普通消息的处理（包括表情包消息）
        messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    }
} else {
                    messageContainer.innerHTML = avatarHtml + bubbleHtml;
}
                } else {
                    // 获取我的显示头像和气泡样式
let myDisplayAvatar = chatSettings.myChatAvatar; // 优先使用聊天专属设置里的头像
let myDisplayName = chatSettings.myChatNickname; // 优先使用聊天专属设置里的昵称

// 如果专属设置里没有，则进行二次查找（作为保险措施）
if ((!myDisplayAvatar || !myDisplayName) && chatSettings.selectedIdentityId) {
                        const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
    if (selectedPersona) {
        // 如果头像为空，则使用身份头像
        if (!myDisplayAvatar) myDisplayAvatar = selectedPersona.avatarUrl;
        // 如果昵称为空，则使用身份昵称
        if (!myDisplayName) myDisplayName = selectedPersona.name;
                        }
                    }

                    const myBubbleColor = chatSettings.myBubbleColor || '#007AFF';
                    const myBubbleOpacity = chatSettings.myBubbleOpacity || '1';
                    const myTextColor = isLightColor(myBubbleColor) ? '#333' : '#fff';
                    const myBubblePadding = chatSettings.bubblePadding || '12';

                    // 将透明度应用到背景色而不是整个元素
                    const transparentMyBubbleColor = convertColorWithOpacity(myBubbleColor, myBubbleOpacity);

                    // 处理用户的特殊消息类型
                    let myMessageContent = '';
                    if (message.type === 'user_photo') {
                        // 用户发送的"照片"（文字描述）
                        myMessageContent = `
                            <div class="dreamy-photo-container" onclick="togglePhotoText(this, '${(message.photoDescription || message.content).replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')">
                                <div class="dreamy-photo">
                                    <div class="photo-misty-bg"></div>
                                    <div class="photo-badge">
                                        <i class="fas fa-image"></i>
                                    </div>
                                    <div class="sparkle-container">
                                        <div class="sparkle sparkle-1">✨</div>
                                        <div class="sparkle sparkle-2">⭐</div>
                                        <div class="sparkle sparkle-3">✨</div>
                                        <div class="sparkle sparkle-4">⭐</div>
                                        <div class="sparkle sparkle-5">💫</div>
                                    </div>
                                    <div class="photo-text-overlay" style="display: none;">
                                        <div class="photo-description">${(message.photoDescription || message.content)}</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'voice') {
                        // 用户发送的语音消息
                        myMessageContent = `
                            <div class="voice-message-container sent">
                                <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                                    <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${message.content}">
                                        <div class="voice-wave">
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                        </div>
                                        <div class="voice-duration">${message.duration || Math.max(1, Math.ceil(message.content.length / 8))}"</div>

                                    </div>
                                    ${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                    ${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                </div>
                                <div class="voice-text-content">${message.content}</div>
                            </div>
                        `;
                    } else if (message.type === 'transfer') {
                        // 用户转账消息 - 在renderChatMessages中处理
                        let cardClass = '';
                        let statusHtml = '';

                        if (message.status === 'accepted') {
                            statusHtml = `<div class="transfer-status">对方已收款</div>`;
                            cardClass = 'accepted';
                        } else if (message.status === 'rejected') {
                            statusHtml = `<div class="transfer-status">对方已退回</div>`;
                            cardClass = 'rejected';
                        }

                        myMessageContent = `
                            <div class="transfer-message-container sent">
                                <div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}">
                                    <div class="transfer-title">💕 你发起的转账</div>
                                    <div class="transfer-amount">¥ ${Number(message.amount).toFixed(2)}</div>
                                    <div class="transfer-note">${message.note || '转账'}</div>
                                    ${statusHtml}
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'order_confirmation') {
                        // 🛒【新增】处理订单确认消息 - 漂亮的购物小票样式
                        const orderDetails = message.orderDetails || {};
                        const orderType = message.orderType || '';

                        let receiptTitle = '';
                        let receiptIcon = '';
                        let receiptClass = '';

                        if (orderType === 'self_pay_self') {
                            receiptTitle = '订单支付成功';
                            receiptIcon = '';
                            receiptClass = 'success';
                        } else if (orderType === 'self_pay_ta') {
                            receiptTitle = '订单下单成功';
                            receiptIcon = '';
                            receiptClass = 'success';
                        }

                        const itemsHtml = orderDetails.items ? orderDetails.items.map(item => {
                            // 🔥【修复】生成包含选项信息的商品名称
                            let itemNameWithOptions = item.name;
                            if (item.selectedOptions && Object.keys(item.selectedOptions).length > 0) {
                                const optionsText = Object.entries(item.selectedOptions).map(([key, value]) =>
                                    `${getOptionLabel(key)}: ${value}`
                                ).join(', ');
                                itemNameWithOptions += `<br><small style="color: #666; font-size: 11px;">${optionsText}</small>`;
                            }

                            return `
                                <div class="receipt-item">
                                    <span class="item-name">${itemNameWithOptions}</span>
                                    <span class="item-quantity">x${item.quantity}</span>
                                    <span class="item-price">¥${(item.price * item.quantity).toFixed(2)}</span>
                                </div>
                            `;
                        }).join('') : '';

                        myMessageContent = `
                            <div class="order-receipt-container">
                                <div class="receipt-card ${receiptClass}">
                                    <div class="receipt-header">
                                        <div class="receipt-title">${receiptTitle}</div>
                                    </div>

                                    <div class="receipt-divider"></div>

                                    <div class="receipt-info">
                                        <div class="receipt-row">
                                            <span class="label">订单号</span>
                                            <span class="value">${orderDetails.orderNumber || 'N/A'}</span>
                                        </div>
                                        <div class="receipt-row">
                                            <span class="label">收货人</span>
                                            <span class="value">${orderType.endsWith('_self') ? '我自己' : (currentChatCharacter?.name || 'Ta')}</span>
                                        </div>
                                        <div class="receipt-row">
                                            <span class="label">下单时间</span>
                                            <span class="value">${new Date(message.timestamp).toLocaleString('zh-CN', {
                                                month: '2-digit',
                                                day: '2-digit',
                                                hour: '2-digit',
                                                minute: '2-digit'
                                            })}</span>
                                        </div>
                                    </div>

                                    <div class="receipt-divider"></div>

                                    <div class="receipt-items">
                                        <div class="items-header">商品清单</div>
                                        ${itemsHtml}
                                    </div>

                                    <div class="receipt-divider"></div>

                                    <div class="receipt-total">
                                        <div class="total-row final">
                                            <span class="total-label">实付金额</span>
                                            <span class="total-amount">¥${orderDetails.total ? orderDetails.total.toFixed(2) : '0.00'}</span>
                                        </div>
                                    </div>

                                    <div class="receipt-footer">
                                        <div class="thank-you">蛋记感谢您的购买！</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'payment_request') {
                        // 🛒【新增】处理代付请求消息 - 根据状态动态生成内容
                        myMessageContent = generatePaymentRequestContent(message);
                    } else if (message.type === 'shared_post') {
                        // 【新增】处理分享的论坛帖子卡片
                        const postData = message.postData || {};
                        myMessageContent = `
                            <div class="shared-post-card" onclick="showPostView(${postData.id}, 'chat')">
                                <div class="shared-post-header">论坛帖子分享</div>
                                <div class="shared-post-title">${postData.title || '帖子加载失败'}</div>
                                <div class="shared-post-content">${truncateText(postData.content || '', 50)}</div>
                            </div>
                        `;
                    } else if (message.type === 'forwarded_message') {
                        // 【新增】处理转发的消息卡片
                        myMessageContent = renderForwardedMessage(message);
                    } else if (message.type === 'location') {
                        // 用户发送的位置消息
                        myMessageContent = `
                            <div class="location-message-container sent">
                                <div class="location-card" onclick="showLocationDetail('${message.locationName}')">
                                    <div class="location-card-header">
                                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
                                            <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                        </svg>
                                        ${message.locationName}
                                    </div>
                                    <div class="location-card-map">
                                        <div class="map-background"></div>
                                        <div class="map-roads">
                                            <div class="road road-horizontal" style="top: 35%; width: 100%;"></div>
                                            <div class="road road-vertical" style="left: 40%; height: 100%;"></div>
                                            <div class="road road-horizontal" style="top: 65%; width: 70%; left: 30%;"></div>
                                        </div>
                                        <div class="map-buildings">
                                            <div class="building" style="top: 15%; left: 20%; width: 12px; height: 10px;"></div>
                                            <div class="building" style="top: 25%; left: 60%; width: 14px; height: 12px;"></div>
                                            <div class="building green" style="top: 50%; left: 15%; width: 8px; height: 8px;"></div>
                                            <div class="building" style="top: 70%; left: 70%; width: 10px; height: 8px;"></div>
                                            <div class="building green" style="top: 10%; left: 75%; width: 6px; height: 6px;"></div>
                                            <div class="building green" style="top: 75%; left: 25%; width: 7px; height: 7px;"></div>
                                        </div>
                                        <div class="map-marker">
                                            <div class="marker-pin">
                                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                                                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                                </svg>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        // 🔥【统一格式】处理多模态消息（现在所有消息都是数组格式）
                        if (Array.isArray(message.content)) {
                            // 统一的数组格式处理
                            const textPart = message.content.find(p => p.type === 'text');
                            const imagePart = message.content.find(p => p.type === 'image_url');

                            let baseContent = textPart?.text || '';
                            // 处理@内容
                            baseContent = processMentions(baseContent);

                            // 如果有引用消息，在内容前添加引用显示
                            if (message.replyTo) {
                                myMessageContent = generateReplyHTML(message.replyTo) + baseContent;
                            } else {
                                myMessageContent = baseContent;
                            }

                            // 如果有图片，添加图片显示
                            if (imagePart?.image_url?.url) {
                                if (myMessageContent) {
                                    myMessageContent += '<br>';
                                }
                                myMessageContent += `<img src="${imagePart.image_url.url}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${imagePart.image_url.url}')">`;
                            }
                        } else {
                            // 🔥【兼容性】处理旧格式消息（逐步迁移中）
                            let baseContent = message.content;
                            // 处理@内容
                            baseContent = processMentions(baseContent);

                            // 如果有引用消息，在内容前添加引用显示
                            if (message.replyTo) {
                                myMessageContent = generateReplyHTML(message.replyTo) + baseContent;
                            } else {
                                myMessageContent = baseContent;
                            }
                        }
                    }

                    let myBubbleHtml = '';

                    if (message.type === 'user_photo' || message.type === 'voice' || message.type === 'transfer' || message.type === 'location' || message.type === 'friend_request' || message.type === 'order_confirmation' || message.type === 'payment_request') {
                        // 用户照片、语音消息、转账消息、位置消息、代付请求不需要额外气泡包裹（已经有自己的容器）
                        myBubbleHtml = myMessageContent;
                    } else {
                        // 普通消息用气泡包裹
                        myBubbleHtml = `
                            <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                                ${myMessageContent}
                                ${message.image && !message.type && !Array.isArray(message.content) ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}
                                ${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                ${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}
                            </div>
                        `;
                    }

                    let myAvatarHtml = '';
                    if (!chatSettings.hideAvatars) {
                        myAvatarHtml = generateAvatarHtml({
                            avatarUrl: myDisplayAvatar,
                            backgroundColor: '#007AFF',
                            displayName: '',
                            timestamp: message.timestamp,
                            timestampEnabled: timestampEnabled,
                            timestampPosition: timestampPosition,
                            chatSettings: chatSettings
                        });
                    }

                    messageContainer.innerHTML = myBubbleHtml + myAvatarHtml;
                }

                // 添加滑入动画效果 - 参考完成.html的弹性动画
                messageContainer.style.opacity = '0';
                messageContainer.style.transform = 'translateY(20px)';
                messageContainer.style.transition = 'opacity 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)';

                messagesContainer.appendChild(messageContainer);

                // 🔥【新增】为气泡戳样式添加真实的三角形元素
                addBubbleTail(messageContainer, message);

                // 触发滑入动画
                requestAnimationFrame(() => {
                    messageContainer.style.opacity = '1';
                    messageContainer.style.transform = 'translateY(0)';
                });

                // 🔥【新增】检查拉黑状态并添加指示器
                addBlockedIndicatorToMessage(messageContainer, message, characterId);

                // 添加长按监听器用于多选删除
                addMessageLongPressListener(messageContainer, message.id);

                // 添加右键菜单功能
                const bubble = messageContainer.querySelector('.message-bubble');
                if (bubble) {
                    // 鼠标右键点击
                    bubble.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        showMessageMenu(message.id, e);
                    });

                    // 点击图片预览
                    bubble.onclick = (e) => {
                        if (e.target.tagName === 'IMG' && e.target.classList.contains('message-image')) {
                            showImage(e.target.src);
                        }
                    };
                }
            });

            // 🔥【移除】不再需要底部的正在输入提示元素，改为顶部标题变化

            // 如果不是加载更多，自动滚动到底部
            if (!loadMore) {
                setTimeout(() => {
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                }, 100);
            }

            // 🔥【修复】位置消息气泡包装问题 - 修复已渲染的位置消息
            setTimeout(() => {
                const locationMessages = messagesContainer.querySelectorAll('.message-container.sent');
                locationMessages.forEach(container => {
                    const locationCard = container.querySelector('.location-card');
                    if (locationCard && container.querySelector('.message-bubble')) {
                        // 如果位置卡片被包裹在气泡中，提取出来
                        const bubble = container.querySelector('.message-bubble');
                        const avatar = container.querySelector('.message-avatar');
                        if (bubble && locationCard.closest('.message-bubble')) {
                            const locationContainer = locationCard.closest('.location-message-container');
                            if (locationContainer) {
                                container.innerHTML = locationContainer.outerHTML + (avatar ? avatar.outerHTML : '');
                            }
                        }
                    }
                });

                // 🔥【新增】渲染角色状态显示 - 在消息渲染完成后更新状态
                if (currentChatCharacter) {
                    const headerContainer = document.querySelector('#api-chat-screen .header');
                    if (headerContainer) {
                        renderCharacterStatus(currentChatCharacter.id, headerContainer);
                    }
                }
            }, 50);
        }

        // 加载更多历史消息
        function loadMoreMessages(characterId) {
            const messagesContainer = document.getElementById('api-chat-messages');
            const allMessages = chatMessages[characterId] || [];
            const chatSettings = getCurrentChatSettings();

            // 保存滚动位置
            const scrollHeight = messagesContainer.scrollHeight;
            const scrollTop = messagesContainer.scrollTop;

            // 计算要加载的历史消息范围
            const newOffset = Math.max(0, currentMessageOffset - MESSAGE_LIMIT);
            const historicalMessages = allMessages.slice(newOffset, currentMessageOffset);

            const existingLoadMoreBtn = messagesContainer.querySelector('.load-more-messages');
            if (existingLoadMoreBtn) {
                existingLoadMoreBtn.remove();
            }

            // 如果还有更多历史消息，在顶部添加新的"查看历史消息"按钮
            if (newOffset > 0) {
                const loadMoreBtn = document.createElement('div');
                loadMoreBtn.className = 'load-more-messages';
                loadMoreBtn.innerHTML = `
                    <div class="load-more-content">
                        <i class="fas fa-chevron-up"></i>
                        <span>查看历史消息 (${newOffset}条)</span>
                    </div>
                `;
                loadMoreBtn.onclick = () => loadMoreMessages(characterId);
                messagesContainer.insertBefore(loadMoreBtn, messagesContainer.firstChild);
            }

            // 在现有消息前面插入历史消息
            const timestampEnabled = chatSettings.timestampEnabled !== false; // 🔥【修复】默认开启
            const timestampPosition = chatSettings.timestampPosition || 'center';
            let lastTimestamp = 0;

            // 从后往前插入，保持时间顺序
            for (let i = historicalMessages.length - 1; i >= 0; i--) {
                const message = historicalMessages[i];

                // 处理系统消息（如戳一戳、头像更换、撤回等）
                if (message.sender === 'system') {
                    // 🔥【修复】处理拉黑系统消息 - 显示为居中的系统提示
                    if (message.isBlockedMessage) {
                        const centerContainer = document.createElement('div');
                        centerContainer.style.display = 'flex';
                        centerContainer.style.justifyContent = 'center';
                        centerContainer.style.margin = '4px 0';
                        centerContainer.dataset.messageId = message.id;

                        const systemContainer = document.createElement('div');
                        systemContainer.className = 'system-message';
                        systemContainer.textContent = message.content || '消息已发出，但被对方拒收了';

                        centerContainer.appendChild(systemContainer);

                        // 插入到正确位置
                        const insertAfter = messagesContainer.querySelector('.load-more-messages');
                        if (insertAfter) {
                            insertAfter.parentNode.insertBefore(centerContainer, insertAfter.nextSibling);
                        } else {
                            messagesContainer.insertBefore(centerContainer, messagesContainer.firstChild);
                        }
                        continue;
                    }

                    let containerToInsert;

                    if (message.isPoke) {
                    const systemContainer = document.createElement('div');
                    systemContainer.className = 'poke-system-container';
                    const systemMessage = document.createElement('div');
                    systemMessage.className = 'poke-system-message';
                    systemMessage.textContent = message.content;
                    systemContainer.appendChild(systemMessage);
                        containerToInsert = systemContainer;
                    } else if (message.type === 'recalled_message') {
                        // 🔥【新增】处理撤回消息的显示
                        const centerContainer = document.createElement('div');
                        centerContainer.style.display = 'flex';
                        centerContainer.style.justifyContent = 'center';
                        centerContainer.style.margin = '4px 0';
                        centerContainer.dataset.messageId = message.id; // 🔥【修复】添加消息ID以支持选择

                        const recallElement = document.createElement('div');
                        recallElement.className = 'recalled-message';

                        // 🔥【兼容性修复】解析撤回消息内容，支持新旧格式
                        const lines = message.content.split('\n');
                        const mainText = lines[0]; // 主要提示文字
                        let originalText = lines[1]; // 原文部分

                        recallElement.textContent = mainText;

                        // 🔥【兼容性处理】支持多种原文格式
                        if (originalText) {
                            // 新格式：原文：xxx
                            if (originalText.startsWith('原文：')) {
                                const originalDiv = document.createElement('div');
                                originalDiv.className = 'original-text';
                                originalDiv.textContent = originalText;
                                recallElement.appendChild(originalDiv);
                            }
                            // 旧格式：直接是原文内容
                            else {
                                const originalDiv = document.createElement('div');
                                originalDiv.className = 'original-text';
                                originalDiv.textContent = `原文：${originalText}`;
                                recallElement.appendChild(originalDiv);
                            }
                        }
                        // 🔥【兼容性处理】如果没有原文但有originalContent字段
                        else if (message.originalContent) {
                            const originalDiv = document.createElement('div');
                            originalDiv.className = 'original-text';
                            originalDiv.textContent = `原文：${message.originalContent}`;
                            recallElement.appendChild(originalDiv);
                        }

                        centerContainer.appendChild(recallElement);
                        containerToInsert = centerContainer;
                    } else {
                        // 🔥【修复】其他系统消息（如头像更换）- 使用居中容器
                        const centerContainer = document.createElement('div');
                        centerContainer.style.display = 'flex';
                        centerContainer.style.justifyContent = 'center';
                        centerContainer.style.margin = '4px 0';

                        const systemContainer = document.createElement('div');
                        // 🔥【美化】检查是否为好友添加成功消息，应用特殊样式
                        if (message.isFriendAddedMessage) {
                            systemContainer.className = 'friend-added-system-message';
                        } else {
                            systemContainer.className = 'system-message';
                        }
                        systemContainer.textContent = message.content;

                        centerContainer.appendChild(systemContainer);
                        containerToInsert = centerContainer;
                    }

                    // 插入到按钮后面（如果有按钮的话）
                    const insertAfter = messagesContainer.querySelector('.load-more-messages');
                    if (insertAfter) {
                        insertAfter.parentNode.insertBefore(containerToInsert, insertAfter.nextSibling);
                    } else {
                        messagesContainer.insertBefore(containerToInsert, messagesContainer.firstChild);
                    }

                    // 🔥【修复】为撤回消息添加选择功能
                    if (message.type === 'recalled_message') {
                        addMessageLongPressListener(containerToInsert, message.id);
                    }

                    continue;
                }

                const messageContainer = document.createElement('div');
                // 检查是否是纯表情包消息
                const isEmojiOnly = message.isEmoji && !message.content;
                messageContainer.className = `message-container ${message.sender}${chatSettings.hideAvatars ? ' no-avatar' : ''}${isEmojiOnly ? ' emoji-only' : ''}`;
                messageContainer.dataset.messageId = message.id;

                if (message.sender === 'received') {
                    // ==== 群聊支持 ====
                    let character = characters.find(c => c.id === characterId);
                    let isGroup = false;
                    let group = null;
                    if (!character) {
                        group = groupChats.find(g => g.id === characterId);
                        if (group) {
                            isGroup = true;
                        }
                    }

                    let displayAvatar = '';
                    let displayName = '';
                    let color = '#4CAF50';

                    if (isGroup && group) {
                        // 群聊：根据消息的senderId或name查找成员
                        let member = null;
                        if (message.senderId) {
                            member = group.members.find(m => m.id === message.senderId);
                        } else if (message.name) {
                            member = group.members.find(m => m.name === message.name);
                        }

                        // 🔥【修复】确保群聊表情包消息正确显示发送者（loadMoreMessages版本）
                        if (member) {
                            displayAvatar = member.avatarUrl || '';
                            displayName = member.name;
                            color = member.color || '#4CAF50';
                        } else {
                            // 如果没找到成员，使用消息中的name作为显示名称
                            displayAvatar = '';
                            displayName = message.name || '群成员';
                            color = '#4CAF50';
                        }
                    } else if (character) {
                        // 单聊
                        displayAvatar = chatSettings.aiChatAvatar || character.avatarUrl;
                        displayName = chatSettings.aiChatNickname || character.name;
                        color = character.color || '#4CAF50';
                    } else {
                        // 兜底，防止报错
                        displayAvatar = '';
                        displayName = '未知';
                        color = '#4CAF50';
                    }
                    // 🔥【新增】获取气泡样式 - 群聊中使用成员专属颜色
                    let bubbleColor = chatSettings.aiBubbleColor || '#f0f0f0';

                    // 如果是群聊且有成员专属颜色设置，使用成员专属颜色
                    if (isGroup && group && message.senderId && chatSettings.memberBubbleColors) {
                        const memberColor = chatSettings.memberBubbleColors[message.senderId];
                        if (memberColor) {
                            bubbleColor = memberColor;
                        }
                    }

                    const bubbleOpacity = chatSettings.aiBubbleOpacity || '1';
                    const textColor = isLightColor(bubbleColor) ? '#333' : '#fff';
                    const bubblePadding = chatSettings.bubblePadding || '12';

                    // 将透明度应用到背景色而不是整个元素
                    const transparentBubbleColor = convertColorWithOpacity(bubbleColor, bubbleOpacity);

                    let messageContent = '';
                    if (message.type === 'voice_message') {
                        // 过滤掉括号中的描述性内容，保留实际说话内容
                        const cleanVoiceContent = message.content.replace(/\([^)]*\)\s*/g, '').trim();
                        const voiceDuration = message.duration || Math.max(1, Math.ceil(cleanVoiceContent.length / 8));

                        messageContent = `
                            <div class="voice-message-container received">
                                <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                                    <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${cleanVoiceContent}">
                                        <div class="voice-wave">
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                        </div>
                                        <div class="voice-duration">${voiceDuration}"</div>

                                    </div>
                                </div>
                                <div class="voice-text-content">${cleanVoiceContent}</div>
                            </div>
                        `;
                    } else if (message.type === 'ai_image') {
                        // AI生成的图片 - 使用星星emoji卡片样式
                        const imageDesc = message.imageDescription || message.content || 'AI描述的图片';
                        messageContent = `<div class="dreamy-photo-container" onclick="togglePhotoText(this, '${imageDesc.replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')"><div class="dreamy-photo"><div class="photo-misty-bg"></div><div class="photo-badge"><i class="fas fa-image"></i></div><div class="sparkle-container"><div class="sparkle sparkle-1">✨</div><div class="sparkle sparkle-2">⭐</div><div class="sparkle sparkle-3">✨</div><div class="sparkle sparkle-4">⭐</div><div class="sparkle sparkle-5">💫</div></div><div class="photo-text-overlay" style="display: none;"><div class="photo-description">${imageDesc}</div></div></div></div>`;
                    } else if (message.type === 'transfer') {
                        // 转账消息
                        const isUser = message.role === 'user';
                        const heartIcon = isUser ? '💕' : '💖';
                        const titleText = isUser ? '你发起的转账' : '收到转账';
                        let cardClass = '';
                        let statusHtml = '';
                        let clickHandler = '';

                        if (message.status === 'accepted') {
                            statusHtml = `<div class="transfer-status">${isUser ? '对方已收款' : '已收款'}</div>`;
                            cardClass = 'accepted';
                        } else if (message.status === 'rejected') {
                            statusHtml = `<div class="transfer-status">${isUser ? '对方已退回' : '已退回'}</div>`;
                            cardClass = 'rejected';
                        } else if (!isUser) {
                            // AI发来的转账且未处理，添加点击处理
                            clickHandler = `onclick="showTransferConfirmDialog(${JSON.stringify(message).replace(/"/g, '&quot;')})"`;
                        }

                        messageContent = `<div class="transfer-message-container received"><div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}" ${clickHandler}><div class="transfer-title">${heartIcon} ${titleText}</div><div class="transfer-amount">¥ ${Number(message.amount).toFixed(2)}</div><div class="transfer-note">${message.note || '转账'}</div>${statusHtml}</div></div>`;
                    } else if (message.type === 'shared_post') {
                        // 【新增】处理分享的论坛帖子卡片
                        const postData = message.postData || {};
                        messageContent = `
                            <div class="shared-post-card" onclick="showPostView(${postData.id}, 'chat')">
                                <div class="shared-post-header">论坛帖子分享</div>
                                <div class="shared-post-title">${postData.title || '帖子加载失败'}</div>
                                <div class="shared-post-content">${truncateText(postData.content || '', 50)}</div>
                            </div>
                        `;
                    } else if (message.type === 'forwarded_message') {
                        // 【新增】处理转发的消息卡片
                        messageContent = renderForwardedMessage(message);
                    } else if (message.type === 'friend_request') {
                        // 🔥【新增】AI主动发送的好友申请(第二处)
                        let actionsHtml;
                        if (message.friendRequestProcessed) {
                            // 已处理的好友申请，显示处理结果
                            const resultText = message.friendRequestAccepted ? '已同意' : '已拒绝';
                            const resultClass = message.friendRequestAccepted ? 'accepted' : 'rejected';
                            actionsHtml = `<div class="friend-request-result ${resultClass}">${resultText}</div>`;
                        } else {
                            // 未处理的好友申请，显示按钮
                            actionsHtml = `
                                <button class="friend-request-btn accept" onclick="handleAIFriendRequest('${currentChatCharacter?.id}', true, '${message.id}')">同意</button>
                                <button class="friend-request-btn reject" onclick="handleAIFriendRequest('${currentChatCharacter?.id}', false, '${message.id}')">拒绝</button>
                            `;
                        }

                        messageContent = `
                            <div class="friend-request-container">
                                <div class="friend-request-card">
                                    <div class="friend-request-title">好友申请</div>
                                    <div class="friend-request-message-section">
                                        <div class="friend-request-message-label">对方留言</div>
                                        <div class="friend-request-message-content">${message.message || '想和你重新做朋友'}</div>
                                    </div>
                                    <div class="friend-request-actions">
                                        ${actionsHtml}
                                    </div>
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'payment_request') {
                        // AI不能发起代付请求，显示为普通消息
                        messageContent = `<div class="message-bubble">${message.content || '代付请求'}</div>`;
                    } else if (message.type === 'order_confirmation') {
                        // 🛒【新增】处理AI的订单确认
                        messageContent = generateAIOrderConfirmationContent(message);
                    } else {
                        const chatMode = chatSettings.chatMode || 'online';
                        let baseContent = chatMode === 'offline' ? processOfflineContent(message.content) : message.content;

                        // 如果有引用消息，在内容前添加引用显示
                        if (message.replyTo) {
                            messageContent = generateReplyHTML(message.replyTo) + baseContent;
                        } else {
                            messageContent = baseContent;
                        }
                    }

                    let avatarHtml = '';
                    if (!chatSettings.hideAvatars) {
                        avatarHtml = generateAvatarHtml({
                            avatarUrl: displayAvatar,
                            backgroundColor: color,
                            displayName: displayName,
                            onClick: character ? `pokeCharacter('${character.id}')` : null,
                            title: character ? "戳一戳" : displayName,
                            timestamp: message.timestamp,
                            timestampEnabled: timestampEnabled,
                            timestampPosition: timestampPosition,
                            chatSettings: chatSettings
                        });
                    }

                    let bubbleHtml = '';
                    if (message.type === 'voice_message' || message.type === 'transfer' || message.type === 'ai_image' || message.type === 'user_photo' || message.type === 'location' || message.type === 'friend_request') {
                        // 语音消息、转账消息、AI图片消息、照片卡片和位置信息不需要额外的气泡包裹
                        bubbleHtml = messageContent;
                    } else {
                        // 普通消息用气泡包裹
                        bubbleHtml = `<div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">${messageContent}${message.image && !message.type ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}</div>`;
                    }

                   // 🔥【修复】群聊昵称显示 （loadMoreMessages版本）- 特别处理语音消息、转账消息、照片卡片和位置信息
                   if (isGroup && group && displayName !== '群成员') {
    messageContainer.classList.add('group-message-item');
    const senderNameHtml = `<div class="sender-name">${displayName}</div>`;

    if (message.type === 'voice_message' || message.type === 'transfer' || message.type === 'ai_image' || message.type === 'user_photo' || message.type === 'location' || message.type === 'friend_request' || message.type === 'order_confirmation') {
        // 🔥【修复】对于语音消息、转账消息、AI图片消息、照片卡片和位置信息，昵称需要在容器外部
    messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    } else {
        // 普通消息的处理（包括表情包消息）
        messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    }
} else {
                    messageContainer.innerHTML = avatarHtml + bubbleHtml;
}
                } else {
                    let myDisplayAvatar = chatSettings.myChatAvatar;
                    if (!myDisplayAvatar && chatSettings.selectedIdentityId) {
                        const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                        if (selectedPersona && selectedPersona.avatarUrl) {
                            myDisplayAvatar = selectedPersona.avatarUrl;
                        }
                    }

                    const myBubbleColor = chatSettings.myBubbleColor || '#007AFF';
                    const myBubbleOpacity = chatSettings.myBubbleOpacity || '1';
                    const myTextColor = isLightColor(myBubbleColor) ? '#333' : '#fff';
                    const myBubblePadding = chatSettings.bubblePadding || '12';

                    // 将透明度应用到背景色而不是整个元素
                    const transparentMyBubbleColor = convertColorWithOpacity(myBubbleColor, myBubbleOpacity);

                    // 处理用户的特殊消息类型
                    let myMessageContent = '';
                    if (message.type === 'user_photo') {
                        // 用户发送的"照片"（文字描述）
                        myMessageContent = `<div class="dreamy-photo-container" onclick="togglePhotoText(this, '${(message.photoDescription || message.content).replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')"><div class="dreamy-photo"><div class="photo-misty-bg"></div><div class="photo-badge"><i class="fas fa-image"></i></div><div class="sparkle-container"><div class="sparkle sparkle-1">✨</div><div class="sparkle sparkle-2">⭐</div><div class="sparkle sparkle-3">✨</div><div class="sparkle sparkle-4">⭐</div><div class="sparkle sparkle-5">💫</div></div><div class="photo-text-overlay" style="display: none;"><div class="photo-description">${(message.photoDescription || message.content)}</div></div></div></div>`;
                    } else if (message.type === 'voice') {
                        // 用户发送的语音消息
                        myMessageContent = `
                            <div class="voice-message-container sent">
                                <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                                    <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${message.content}">
                                        <div class="voice-wave">
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                        </div>
                                        <div class="voice-duration">${message.duration || Math.max(1, Math.ceil(message.content.length / 8))}"</div>

                                    </div>
                                    ${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                    ${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                </div>
                                <div class="voice-text-content">${message.content}</div>
                            </div>
                        `;
                    } else if (message.type === 'transfer') {
                        // 用户转账消息 - 在loadMoreMessages中处理
                        let cardClass = '';
                        let statusHtml = '';

                        if (message.status === 'accepted') {
                            statusHtml = `<div class="transfer-status">对方已收款</div>`;
                            cardClass = 'accepted';
                        } else if (message.status === 'rejected') {
                            statusHtml = `<div class="transfer-status">对方已退回</div>`;
                            cardClass = 'rejected';
                        }

                        myMessageContent = `
                            <div class="transfer-message-container sent">
                                <div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}">
                                    <div class="transfer-title">💕 你发起的转账</div>
                                    <div class="transfer-amount">¥ ${Number(message.amount).toFixed(2)}</div>
                                    <div class="transfer-note">${message.note || '转账'}</div>
                                    ${statusHtml}
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'location') {
                        // 用户发送的位置消息 - 在loadMoreMessages中处理
                        myMessageContent = `
                            <div class="location-message-container sent">
                                <div class="location-card" onclick="showLocationDetail('${message.locationName}')">
                                    <div class="location-card-header">
                                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
                                            <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                        </svg>
                                        ${message.locationName}
                                    </div>
                                    <div class="location-card-map">
                                        <div class="map-background"></div>
                                        <div class="map-roads">
                                            <div class="road road-horizontal" style="top: 35%; width: 100%;"></div>
                                            <div class="road road-vertical" style="left: 40%; height: 100%;"></div>
                                            <div class="road road-horizontal" style="top: 65%; width: 70%; left: 30%;"></div>
                                        </div>
                                        <div class="map-buildings">
                                            <div class="building" style="top: 15%; left: 20%; width: 12px; height: 10px;"></div>
                                            <div class="building" style="top: 25%; left: 60%; width: 14px; height: 12px;"></div>
                                            <div class="building green" style="top: 50%; left: 15%; width: 8px; height: 8px;"></div>
                                            <div class="building" style="top: 70%; left: 70%; width: 10px; height: 8px;"></div>
                                            <div class="building green" style="top: 10%; left: 75%; width: 6px; height: 6px;"></div>
                                            <div class="building green" style="top: 75%; left: 25%; width: 7px; height: 7px;"></div>
                                        </div>
                                        <div class="map-marker">
                                            <div class="marker-pin">
                                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                                                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                                </svg>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        // 🔥【统一格式】处理多模态消息 (loadMoreMessages版本)
                        if (Array.isArray(message.content)) {
                            // 统一的数组格式处理
                            const textPart = message.content.find(p => p.type === 'text');
                            const imagePart = message.content.find(p => p.type === 'image_url');

                            let baseContent = textPart?.text || '';
                            // 处理@内容
                            baseContent = processMentions(baseContent);

                            // 如果有引用消息，在内容前添加引用显示
                            if (message.replyTo) {
                                myMessageContent = generateReplyHTML(message.replyTo) + baseContent;
                            } else {
                                myMessageContent = baseContent;
                            }

                            // 如果有图片，添加图片显示
                            if (imagePart?.image_url?.url) {
                                if (myMessageContent) {
                                    myMessageContent += '<br>';
                                }
                                myMessageContent += `<img src="${imagePart.image_url.url}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${imagePart.image_url.url}')">`;
                            }
                        } else {
                            // 🔥【兼容性】处理旧格式消息 (loadMoreMessages版本)
                            let baseContent = message.content;
                            // 处理@内容
                            baseContent = processMentions(baseContent);

                            // 如果有引用消息，在内容前添加引用显示
                            if (message.replyTo) {
                                myMessageContent = generateReplyHTML(message.replyTo) + baseContent;
                            } else {
                                myMessageContent = baseContent;
                            }
                        }
                    }

                    let myBubbleHtml = '';

                    if (message.type === 'user_photo' || message.type === 'voice' || message.type === 'transfer' || message.type === 'location' || message.type === 'friend_request' || message.type === 'order_confirmation' || message.type === 'payment_request') {
                        // 用户照片、语音消息、转账消息、位置消息、代付请求不需要额外气泡包裹（已经有自己的容器）
                        myBubbleHtml = myMessageContent;
                    } else {
                        // 普通消息用气泡包裹
                        myBubbleHtml = `<div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">${myMessageContent}${message.image && !message.type && !Array.isArray(message.content) ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}</div>`;
                    }

                    let myAvatarHtml = '';
                    if (!chatSettings.hideAvatars) {
                        myAvatarHtml = generateAvatarHtml({
                            avatarUrl: myDisplayAvatar,
                            backgroundColor: '#007AFF',
                            displayName: '',
                            timestamp: message.timestamp,
                            timestampEnabled: timestampEnabled,
                            timestampPosition: timestampPosition,
                            chatSettings: chatSettings
                        });
                    }

                    messageContainer.innerHTML = myBubbleHtml + myAvatarHtml;
                }

                // 🔥【新增】检查拉黑状态并添加指示器
                addBlockedIndicatorToMessage(messageContainer, message, characterId);

                // 添加长按监听器和右键菜单
                addMessageLongPressListener(messageContainer, message.id);
                const bubble = messageContainer.querySelector('.message-bubble');
                if (bubble) {
                    bubble.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        showMessageMenu(message.id, e);
                    });

                    bubble.onclick = (e) => {
                        if (e.target.tagName === 'IMG' && e.target.classList.contains('message-image')) {
                            showImage(e.target.src);
                        }
                    };
                }

                // 插入消息到正确位置
                const insertAfter = messagesContainer.querySelector('.load-more-messages');
                if (insertAfter) {
                    insertAfter.parentNode.insertBefore(messageContainer, insertAfter.nextSibling);
                } else {
                    messagesContainer.insertBefore(messageContainer, messagesContainer.firstChild);
                }
            }

            // 更新偏移量
            currentMessageOffset = newOffset;

            // 保持滚动位置
            setTimeout(() => {
                const newScrollHeight = messagesContainer.scrollHeight;
                messagesContainer.scrollTop = scrollTop + (newScrollHeight - scrollHeight);
            }, 50);
        }


        // 显示角色表单
        function showCharacterForm(characterId = null) {
            currentEditingCharacterId = characterId; // 保存当前编辑的角色ID
            document.getElementById('character-form-title').textContent = characterId ? '编辑人物' : '新建人物';

            // 清空表单
            document.getElementById('character-name').value = '';
            document.getElementById('character-bio').value = '';
            document.getElementById('avatar-upload').value = '';

            const avatarPreview = document.getElementById('avatar-preview');
            const avatarPreviewText = document.getElementById('avatar-preview-text');

            // 重置头像预览
            avatarPreview.classList.remove('has-image');
            avatarPreview.style.removeProperty('background');
            avatarPreview.style.removeProperty('background-size');
            avatarPreview.style.removeProperty('background-position');
            avatarPreview.style.removeProperty('background-repeat');
            avatarPreviewText.style.display = 'block';
            avatarPreviewText.textContent = 'A';

            // 清除临时存储的头像数据
            window.selectedAvatarData = null;

            // 如果是编辑模式，填充现有数据
            if (characterId) {
                const character = characters.find(c => c.id === characterId);
                if (character) {
                    document.getElementById('character-name').value = character.name;
                    document.getElementById('character-bio').value = character.bio;

                    if (character.avatarUrl) {
                        avatarPreview.classList.add('has-image');
                        avatarPreview.style.setProperty('background', `url(${character.avatarUrl})`, 'important');
                        avatarPreview.style.setProperty('background-size', 'cover', 'important');
                        avatarPreview.style.setProperty('background-position', 'center', 'important');
                        avatarPreview.style.setProperty('background-repeat', 'no-repeat', 'important');
                        avatarPreviewText.style.display = 'none';
                        // 为编辑模式保存现有头像数据
                        window.selectedAvatarData = character.avatarUrl;
                    } else {
                        avatarPreviewText.textContent = character.name.charAt(0);
                    }
                }
            }

            // 设置表单的保存函数和删除按钮显示
            const deleteBtn = document.getElementById('character-delete-btn');
            const importBtn = document.getElementById('import-character-btn');
            const exportBtn = document.getElementById('export-character-btn');
            console.log('设置保存按钮，characterId:', characterId);
            if (characterId) {
                document.querySelector('#character-form-screen .form-submit').onclick = async () => await saveCharacter(characterId);
                // 编辑模式显示删除按钮，隐藏导入按钮，显示导出按钮
                if (deleteBtn) deleteBtn.style.display = 'block';
                if (importBtn) importBtn.style.display = 'none';
                if (exportBtn) exportBtn.style.display = 'flex';
                console.log('设置为编辑模式，角色ID:', characterId);
            } else {
                document.querySelector('#character-form-screen .form-submit').onclick = async () => await saveCharacter();
                // 新建模式隐藏删除按钮，显示导入按钮，隐藏导出按钮
                if (deleteBtn) deleteBtn.style.display = 'none';
                if (importBtn) importBtn.style.display = 'flex';
                if (exportBtn) exportBtn.style.display = 'none';
                console.log('设置为创建模式，无角色ID');
            }

            showApp('character-form-screen');

            // 确保头像上传功能可用 - 重新绑定事件监听器（以防万一）
            setTimeout(() => {
                initializeAvatarUpload();
            }, 100);
        }

        // 保存角色
        async function saveCharacter(characterId = null) {
            try {
                console.log('=== 开始保存角色 ===');
                const name = document.getElementById('character-name').value.trim();
                const bio = document.getElementById('character-bio').value.trim();
                const avatarData = window.selectedAvatarData; // 使用预处理的头像数据

                console.log('保存角色 - 姓名:', name, '头像数据存在:', !!avatarData);
                if (avatarData) {
                    console.log('头像数据长度:', avatarData.length, '开头:', avatarData.substring(0, 50));
                }

                if (!name) {
                    alert('请输入姓名');
                    return;
                }

                if (characterId) {
                    console.log('=== 更新现有角色 ===');
                    // 更新现有角色
                    const index = characters.findIndex(c => c.id === characterId);
                    if (index !== -1) {
                        const oldAvatarUrl = characters[index].avatarUrl;

                        characters[index] = {
                            ...characters[index],
                            name,
                            bio,
                            avatarUrl: avatarData || characters[index].avatarUrl || '',
                            color: characters[index].color || getRandomColor()
                        };

                        console.log('更新角色完成:', characters[index]);

                        // 🔥【修复1】如果头像发生了变化，更新所有相关群聊中的成员头像
                        if (avatarData && avatarData !== oldAvatarUrl) {
                            updateCharacterAvatarInGroups(characterId, avatarData);
                        }

                        // 保存并更新界面
                        await saveCharacters();
                        renderContactList();
                        renderMessageList();

                        // 🔥【修复2】如果当前正在聊天且是该角色，刷新聊天界面
                        if (currentChatCharacter && currentChatCharacter.id === characterId) {
                            renderChatMessages(currentChatCharacter.id);
                        }

                        showToast(`角色 "${name}" 已更新！`, 'success');
                        hideCharacterForm();
                        // 注意：不立即清空表单，让用户能看到保存成功的状态
                    }
                } else {
                    console.log('=== 创建新角色 ===');
                    // 创建新角色
                    const newCharacter = {
                        id: Date.now().toString(),
                        name,
                        bio,
                        avatarUrl: avatarData || '',
                        color: getRandomColor(),
                        groupId: 'my_friends' // 新角色默认放入"我的好友"分组
                    };

                    console.log('创建新角色:', newCharacter);
                    console.log('新角色头像URL:', newCharacter.avatarUrl);
                    console.log('新角色头像URL长度:', newCharacter.avatarUrl ? newCharacter.avatarUrl.length : 0);

                    console.log('添加角色前，当前角色数组长度:', characters.length);
                    characters.push(newCharacter);
                    console.log('添加角色后，当前角色数组长度:', characters.length);

                    console.log('角色数组最新状态:', characters);

                    // 🔥【修复】不再自动添加到联系人列表，用户需要通过创建对话来建立联系

                    // 保存并更新界面
                    console.log('开始保存到IndexedDB...');
                    await saveCharacters();
                    console.log('保存后检查角色数组:', characters);

                    console.log('开始渲染界面...');
                    renderContactList();
                    renderMessageList();

                    console.log('开始隐藏表单...');
                    hideCharacterForm();
                    // 注意：不立即清空表单，让用户能看到保存成功的状态

                    // 给用户反馈
                    showToast(`角色 "${newCharacter.name}" 创建成功！`, 'success');

                    console.log('=== 保存角色完成 ===');
                }
            } catch (error) {
                console.error('保存角色时发生错误:', error);
                alert('保存角色时发生错误: ' + error.message);
            }
        }

        // 清空角色表单
        function clearCharacterForm() {
            console.log('清空角色表单被调用');
            document.getElementById('character-name').value = '';
            document.getElementById('character-bio').value = '';
            document.getElementById('avatar-upload').value = '';

            const avatarPreview = document.getElementById('avatar-preview');
            const avatarPreviewText = document.getElementById('avatar-preview-text');

            // 重置头像预览
            avatarPreview.classList.remove('has-image');
            avatarPreview.style.removeProperty('background');
            avatarPreview.style.removeProperty('background-size');
            avatarPreview.style.removeProperty('background-position');
            avatarPreview.style.removeProperty('background-repeat');
            if (avatarPreviewText) {
                avatarPreviewText.style.display = 'block';
                avatarPreviewText.textContent = 'A';
            }

            // 清除临时存储的头像数据
            console.log('清除临时头像数据');
            window.selectedAvatarData = null;
        }

        // 编辑角色
        function editCharacter(characterId) {
            showCharacterForm(characterId);
        }

        // 从联系人列表编辑角色
        function editCharacterFromContactList(characterId) {
            showCharacterForm(characterId);
        }

        // 进入多选模式
        function enterMultiSelectMode(characterId) {
            isMultiSelectMode = true;
            selectedCharacters = [characterId]; // 初始选中触发长按的角色
            renderContactList();
        }

        // 退出多选模式
        function exitMultiSelectMode() {
            isMultiSelectMode = false;
            selectedCharacters = [];
            renderContactList();
        }

        // 切换角色选择状态
        function toggleCharacterSelection(characterId) {
            const index = selectedCharacters.indexOf(characterId);
            if (index > -1) {
                selectedCharacters.splice(index, 1);
            } else {
                selectedCharacters.push(characterId);
            }
            renderContactList();
        }

        // 删除选中的角色
        async function deleteSelectedCharacters() {
            if (selectedCharacters.length === 0) {
                alert('请先选择要删除的角色');
                return;
            }

            const characterNames = selectedCharacters.map(id => {
                const character = characters.find(c => c.id === id);
                return character ? character.name : '';
            }).filter(name => name).join('、');

            if (confirm(`确定要删除这些角色吗？\n${characterNames}\n\n此操作不可恢复！`)) {
                // 删除角色
                selectedCharacters.forEach(characterId => {
                    characters = characters.filter(c => c.id !== characterId);
                    contacts = contacts.filter(c => c !== characterId);

                    // 删除相关聊天记录
                    if (chatMessages[characterId]) {
                        delete chatMessages[characterId];
                    }
                });

                // 保存数据
                await saveCharacters();
                await saveContacts();
                // 🔥【优化】批量删除后使用高效保存
                try {
                    await saveChatMessagesImmediate(selectedCharacterIds);
                    console.log('✅ [高效批量删除] 消息已保存到数据库');
                } catch (error) {
                    console.error('批量删除消息保存失败，回退到全量保存:', error);
                    await saveChatMessages();
                }

                // 退出多选模式并更新界面
                exitMultiSelectMode();
                renderMessageList();

                alert('角色删除成功');
            }
        }

        // 删除当前编辑的角色
        async function deleteCurrentCharacter() {
            if (currentEditingCharacterId) {
                const character = characters.find(c => c.id === currentEditingCharacterId);

                if (character && confirm(`确定要删除角色"${character.name}"吗？\n\n此操作将删除角色数据、聊天记录和所有设置，不可恢复！`)) {
                    // 删除角色
                    characters = characters.filter(c => c.id !== character.id);
                    contacts = contacts.filter(c => c !== character.id);

                    // 删除相关聊天记录
                    if (chatMessages[character.id]) {
                        delete chatMessages[character.id];
                    }

                    // [核心修复] 删除聊天设置
                    try {
                        // 从数据库中删除设置
                        await db.chatSettings.delete(character.id);
                        // 从内存中删除设置
                        if (chatSettings[character.id]) {
                            delete chatSettings[character.id];
                        }
                        // 删除localStorage中的备份设置
                        localStorage.removeItem(`chatSettings_${character.id}`);
                        console.log(`✅ 已删除角色 ${character.name} 的聊天设置`);
                    } catch (error) {
                        console.error(`删除角色 ${character.name} 的聊天设置失败:`, error);
                    }

                    // 保存数据
                    await saveCharacters();
                    await saveContacts();
                    // 🔥【优化】单个删除后使用高效保存
                    try {
                        await saveChatMessagesImmediate([characterId]);
                        console.log('✅ [高效单个删除] 消息已保存到数据库');
                    } catch (error) {
                        console.error('单个删除消息保存失败，回退到全量保存:', error);
                        await saveChatMessages();
                    }

                    // 更新界面并返回
                    renderContactList();
                    renderMessageList();
                    hideCharacterForm();

                    showToast(`角色 ${character.name} 已成功删除`, 'success');
                }
            }
        }

        // 🔥【新增】更新角色在所有群聊中的头像
        function updateCharacterAvatarInGroups(characterId, newAvatarUrl) {
            // 遍历所有角色，找到群聊
            characters.forEach(character => {
                if (character.isGroup && character.members) {
                    // 在该群聊中查找对应的成员
                    const memberIndex = character.members.findIndex(member => member.id === characterId);
                    if (memberIndex !== -1) {
                        // 更新该成员的头像
                        character.members[memberIndex].avatarUrl = newAvatarUrl;
                        console.log(`已更新群聊 "${character.name}" 中成员 "${character.members[memberIndex].name}" 的头像`);
                    }
                }
            });

            // 保存更新后的角色数据
            saveCharacters();
        }

        // 获取随机颜色
        function getRandomColor() {
            const colors = ['#FF3B30', '#FF9500', '#FFCC00', '#34C759', '#5AC8FA', '#007AFF', '#5856D6', '#AF52DE'];
            return colors[Math.floor(Math.random() * colors.length)];
        }



        // 开始与角色聊天
async function startChat(character) {
    await dataLoadedPromise; // 🔥【新增修复】等待数据加载完成

    // [核心修复] 记录上一个聊天ID，用于清理
    const previousChatId = currentChatCharacter ? currentChatCharacter.id : null;

    // 🔥【修复】在切换聊天时，标记上一个聊天为已读
    if (previousChatId) {
        markAsRead(previousChatId);
    }

    // 🔥【修复】切换聊天时隐藏输入指示器，避免显示错误的"正在输入"状态
    hideTypingIndicator();

    // 🔥【新增】保存当前聊天的引用状态（如果有的话）
    if (previousChatId && currentReplyTo) {
        chatReplyStates[previousChatId] = { ...currentReplyTo };
    }

    // 设置当前聊天角色
            currentChatCharacter = character;

            // 🔥【新增】保存当前聊天状态到sessionStorage，用于页面刷新时恢复
            sessionStorage.setItem('currentChatCharacterId', character.id);

    // 🔥【关键修复】明确传入角色ID，强制重新加载设置，避免获取到错误的缓存设置
    const chatSettings = await getAsyncChatSettings(character.id);
            let displayTitle = chatSettings.aiChatNickname || character.name;

            // 🔥【新增】如果是群聊，在标题后添加成员数量
            if (character.isGroup && character.members) {
                const memberCount = character.members.length + 1; // +1 包括用户自己
                displayTitle = `${displayTitle}（${memberCount}）`;
            }

            const chatTitle = document.getElementById('api-chat-title');
            if (chatTitle) {
                chatTitle.textContent = displayTitle;
                // 🔥【新增】清除正在输入状态并保存新的原始标题
                chatTitle.classList.remove('typing-status');
                chatTitle.dataset.originalTitle = displayTitle;
            }

            // 🔥【新增】渲染角色状态显示
            const headerContainer = document.querySelector('#api-chat-screen .header');
            if (headerContainer) {
                renderCharacterStatus(character.id, headerContainer);
            }

            // 🔥【新增】更新心率显示
            updateAiHeartrate();

                // 🔥【修复】只有在开启状态显示时才生成初始状态
                setTimeout(async () => {
                    const chatSettings = await getAsyncChatSettings(character.id);
                    if (chatSettings.characterStatusEnabled) {
                        const currentStatus = getCharacterStatus(character.id);
                        if (!currentStatus.activity || currentStatus.activity === '在线') {
                            await generateCharacterStatus(character.id);
                            // 刷新状态显示
                            renderCharacterStatus(character.id, headerContainer);
                        }
                    }
                }, 500);

            // 🔥【新增】启动状态更新定时器
            startCharacterStatusTimer();

            // 🔥【新增】更新设置界面的拉黑/屏蔽管理文案
            updateBlockManageLabel(character.isGroup);

            // 初始化空的聊天记录（不自动发送消息）
            if (!chatMessages[character.id]) {
                chatMessages[character.id] = [];
                // 🔥【修复】不调用saveChatMessages，避免切换角色时全量重写
                console.log('✅ 初始化空聊天记录，无需保存');
            }

            // 重置悬浮按钮状态
            resetFloatingButtonsState();

            // 🔥【新增】检查拉黑状态并更新界面
            updateChatBlockedStatus();

            // 🔥【新增】如果设置界面是打开的，更新设置显示状态
            if (document.getElementById('api-chat-settings-screen').style.display === 'flex') {
                updateChatSettingsDisplay();
            }

            // 🔥【修复】无论设置界面是否打开，都要更新日记时间输入框
            const diaryTimeInput = document.getElementById('diary-time-input');
            if (diaryTimeInput) {
                // 🔥【关键修复】使用异步获取的设置，确保数据正确
                const currentSettings = await getAsyncChatSettings(character.id);
                diaryTimeInput.value = currentSettings.backgroundDiaryTime || '';
                console.log(`🔄 [角色切换] 更新 ${character.name} 的日记时间显示: ${currentSettings.backgroundDiaryTime || '未设置'}`);
            }

    // 重置聊天屏幕背景
    const chatScreen = document.getElementById('api-chat-screen');
    if (chatScreen) {
        // 先重置所有背景样式
        chatScreen.style.backgroundImage = 'none';
        chatScreen.style.backgroundColor = 'white';

        // 🔥【新增】根据聊天类型添加或移除group-chat类
        if (character.isGroup) {
            chatScreen.classList.add('group-chat');
        } else {
            chatScreen.classList.remove('group-chat');
        }

        // 🔥【新增】根据聊天类型显示/隐藏单聊专用工具项
        const singleChatOnlyItems = document.querySelectorAll('.single-chat-only');
        singleChatOnlyItems.forEach(item => {
            if (character.isGroup) {
                item.style.display = 'none';
            } else {
                item.style.display = '';
            }
        });

        const messagesContainer = document.getElementById('api-chat-messages');
        if (messagesContainer) messagesContainer.style.background = '';
    }

    // 记录切换
    console.log(`🔄 切换到聊天: ${character.name} (ID: ${character.id})`);

    // 【关键修复】每次进入聊天时，调用 applyChatBackground 来确保背景正确
    // 不传递参数，让函数自己从角色对象中读取（角色切换时允许保存）
    await applyChatBackground();

    // 🔥【修复】确保气泡样式在进入聊天时被正确应用
    applyBubbleStyle();

    // 🔥【新增】应用自定义CSS
    applyCustomBubbleCSS();

    // 🔥【修改】检查并应用当前聊天窗口的自定义主题 - 使用async
    applyCustomThemeStyles().catch(e => console.error('应用聊天主题失败:', e));

            // 🔥【移除】不再在角色切换时重新初始化后台系统
            // 后台定时器应该是全局的，在页面加载时设置一次即可

            // 初始化定时发布系统
            initScheduledMomentsSystem();

            renderChatMessages(character.id);

            // 🔥【新增】恢复当前聊天的引用状态
            if (chatReplyStates[character.id]) {
                currentReplyTo = { ...chatReplyStates[character.id] };
                showReplyPreview();
            } else {
                // 清除引用状态
                currentReplyTo = null;
                const existingPreview = document.getElementById('reply-preview');
                if (existingPreview) {
                    existingPreview.remove();
                }
            }

            showApp('api-chat-screen');
        }

        // 🔥【修改】从聊天界面返回到聊天应用 - 改为async支持Dexie
        async function backToChatApp() {
            // 🔥【修复】在退出聊天时标记消息为已读
            if (currentChatCharacter) {
                markAsRead(currentChatCharacter.id);
            }

            // 🔥【新增】清除保存的聊天状态
            sessionStorage.removeItem('currentChatCharacterId');

            // 🔥【新增】保存当前聊天的引用状态
            if (currentChatCharacter && currentReplyTo) {
                chatReplyStates[currentChatCharacter.id] = { ...currentReplyTo };
            }

            // 🔥【新增】清除群聊CSS类
            const chatScreen = document.getElementById('api-chat-screen');
            if (chatScreen) {
                chatScreen.classList.remove('group-chat');
            }

            // 🔥【修复】退出聊天时只有当前聊天有自定义主题才清除样式
            if (currentChatCharacter) {
                try {
                    const savedTheme = await db.chatThemes.where('chatId').equals(currentChatCharacter.id).first();
                    if (savedTheme && savedTheme.themeData) {
                        console.log(`🎨 当前聊天 ${currentChatCharacter.id} 有自定义主题，开始清除...`);
                        clearCustomThemeStyles();

                        // 🔥【修改】只有在没有使用系统主题时才重新应用全局主题样式 - 使用Dexie
                        const themeSettingRecord = await db.themeSettings.get('selectedTheme');
                        const currentTheme = themeSettingRecord ? themeSettingRecord.settingValue : null;
                        if (!currentTheme || currentTheme === 'custom') {
                            await applyGlobalCustomTheme();
                        }
                    } else {
                        console.log(`🎨 当前聊天 ${currentChatCharacter.id} 没有自定义主题，无需清除样式`);
                    }
                } catch (error) {
                    console.error('❌ 检查聊天主题失败:', error);
                }
            }

            // 🔥【修复】不要清除全局后台定时器，它们应该持续运行
            // clearAllBackgroundTimers(); // 已注释，后台定时器应该是全局的
            // 🔥【新增】清除状态更新定时器
            clearCharacterStatusTimer();
            // 隐藏心率显示
            hideAiHeartrate();
            hideApp('api-chat-screen');
            showApp('chat-screen');
        }

        // 从设置子页面返回到设置主页面
        function backToSettings(currentScreen) {
            hideApp(currentScreen);
            showApp('settings-screen');
        }



        // 显示正在输入提示 - 修改为顶部标题变化
        function showTypingIndicator() {
            console.log('🔧 尝试显示正在输入提示...');

            const chatTitle = document.getElementById('api-chat-title');
            if (!chatTitle) {
                console.error('❌ 找不到聊天标题元素');
                return;
            }

            // 保存原始标题（如果还没保存的话）
            if (!chatTitle.dataset.originalTitle) {
                chatTitle.dataset.originalTitle = chatTitle.textContent;
            }

            // 更改标题为"对方正在输入..."
            chatTitle.textContent = '对方正在输入...';
            chatTitle.classList.add('typing-status');

            console.log('✅ 显示正在输入提示 - 标题已更改');
        }

        // 隐藏正在输入提示 - 恢复原始标题
        function hideTypingIndicator() {
            console.log('🔧 尝试隐藏正在输入提示...');

            const chatTitle = document.getElementById('api-chat-title');
            if (!chatTitle) {
                console.error('❌ 找不到聊天标题元素');
                return;
            }

            // 恢复原始标题
            if (chatTitle.dataset.originalTitle) {
                chatTitle.textContent = chatTitle.dataset.originalTitle;
                chatTitle.classList.remove('typing-status');
                console.log('✅ 隐藏正在输入提示 - 标题已恢复');
            } else {
                console.log('⚠️ 未找到原始标题，可能已被清除');
            }
        }

        // 🔥【新增】添加系统消息到聊天界面（不重新渲染整个列表）
        function addSystemMessageToChat(systemMessage) {
            const messagesContainer = document.getElementById('api-chat-messages');
            if (!messagesContainer) return;

            // 创建外层容器，用于居中
            const centerContainer = document.createElement('div');
            centerContainer.style.display = 'flex';
            centerContainer.style.justifyContent = 'center';
            centerContainer.style.margin = '4px 0';

            // 创建系统消息容器
            const systemContainer = document.createElement('div');
            // 🔥【美化】检查是否为好友添加成功消息，应用特殊样式
            if (systemMessage.isFriendAddedMessage) {
                systemContainer.className = 'friend-added-system-message';
            } else {
                systemContainer.className = 'system-message';
            }
            systemContainer.textContent = systemMessage.content;

            // 将系统消息放入居中容器
            centerContainer.appendChild(systemContainer);

            // 插入到消息容器的最后
            messagesContainer.appendChild(centerContainer);

            // 滚动到底部
            setTimeout(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }, 100);
        }

        // 🔥【修复版】处理AI撤回消息功能 - 使用统一的撤回逻辑
        async function handleRecalledMessage(messageContent, targetMessageId = null) {
            if (!currentChatCharacter) return;

            console.log('🔥 [AI撤回] 处理撤回消息:', messageContent, '目标消息ID:', targetMessageId);

            // 如果提供了目标消息ID，查找并撤回现有消息
            if (targetMessageId) {
                const messages = chatMessages[currentChatCharacter.id] || [];
                const messageToRecall = messages.find(msg => msg.id === targetMessageId);

                if (messageToRecall) {
                    console.log('🔥 [AI撤回] 找到要撤回的现有消息，使用统一撤回逻辑');

                    // 等待1.2秒后撤回（保持原有的延迟效果）
                    await new Promise(resolve => setTimeout(resolve, 1200));

                    // 🔥【关键修复】使用统一的撤回处理函数
                    await _internalRecallMessage(currentChatCharacter.id, messageToRecall);
                    return;
                } else {
                    console.warn('🔥 [AI撤回] 未找到要撤回的消息，创建临时消息');
                    // 如果找不到消息，回退到创建临时消息的方式
                    await createTemporaryMessage(messageContent);
                    return;
                }
            } else {
                // 没有提供目标ID，创建临时消息
                await createTemporaryMessage(messageContent);
                return;
            }

            // 🔥【保留】创建临时消息的辅助函数（用于AI撤回不存在的消息时显示临时效果）
            async function createTemporaryMessage(content) {
                const messagesContainer = document.getElementById('api-chat-messages');
                if (!messagesContainer) return null;

                const character = characters.find(c => c.id === currentChatCharacter.id);
                const chatSettings = getCurrentChatSettings();
                const displayName = chatSettings.aiChatNickname || character.name;
                const messageId = `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

                const tempContainer = document.createElement('div');
                const isEmojiOnly = false;
                tempContainer.className = `message-container received${isEmojiOnly ? ' emoji-only' : ''}`;
                tempContainer.dataset.messageId = messageId;

                const bubbleColor = chatSettings.aiBubbleColor || '#f0f0f0';
                const bubbleOpacity = chatSettings.aiBubbleOpacity || '1';
                const textColor = isLightColor(bubbleColor) ? '#333' : '#fff';
                const bubblePadding = chatSettings.bubblePadding || '12';
                const displayAvatar = chatSettings.aiChatAvatar || character.avatarUrl;

                let avatarHtml = '';
                if (!chatSettings.hideAvatars) {
                    avatarHtml = `
                        <div class="message-avatar" style="background-color: ${character.color}; ${displayAvatar ? `background-image: url(${displayAvatar}); background-size: cover; background-position: center;` : ''}" onclick="pokeCharacter('${character.id}')" title="戳一戳">
                            ${displayAvatar ? '' : displayName.charAt(0)}
                        </div>
                    `;
                }

                // 将透明度应用到背景色而不是整个元素
                const transparentBubbleColor = convertColorWithOpacity(bubbleColor, bubbleOpacity);

                let bubbleHtml = `
                    <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                        ${content}
                    </div>
                `;

                tempContainer.innerHTML = avatarHtml + bubbleHtml;

                // 添加到消息容器
                messagesContainer.appendChild(tempContainer);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;

                // 等待1.2秒后撤回
                await new Promise(resolve => setTimeout(resolve, 1200));

                // 🔥【修复】创建临时撤回消息并使用统一撤回逻辑
                const tempMessage = {
                    id: messageId,
                    sender: 'received',
                    content: content,
                    timestamp: Date.now()
                };

                // 临时添加到聊天记录中，以便撤回函数能找到它
                if (!chatMessages[currentChatCharacter.id]) {
                    chatMessages[currentChatCharacter.id] = [];
                }
                chatMessages[currentChatCharacter.id].push(tempMessage);

                // 使用统一的撤回逻辑
                await _internalRecallMessage(currentChatCharacter.id, tempMessage);

                return tempContainer;
            }
        }

        // 🔥【修复】获取用户最近发送的图片URL - 支持新的多模态消息格式
        function getRecentUserImage() {
            if (!currentChatCharacter || !chatMessages[currentChatCharacter.id]) {
                return null;
            }

            const messages = chatMessages[currentChatCharacter.id];
            // 从最新消息开始向前查找用户发送的图片
            for (let i = messages.length - 1; i >= 0; i--) {
                const msg = messages[i];
                if (msg.sender === 'sent' && !msg.isEmoji) {
                    // 🔥【新增】检查新的多模态消息格式
                    if (Array.isArray(msg.content)) {
                        const imagePart = msg.content.find(part => part.type === 'image_url');
                        if (imagePart && imagePart.image_url && imagePart.image_url.url) {
                            console.log('找到用户最近发送的图片(多模态格式):', imagePart.image_url.url);
                            return imagePart.image_url.url;
                        }
                    }
                    // 🔥【保留】检查旧的图片消息格式
                    else if (msg.image) {
                        console.log('找到用户最近发送的图片(旧格式):', msg.image);
                        return msg.image;
                    }
                }
            }

            console.log('没有找到用户发送的图片');
            return null;
        }

        // API调用函数 - 基于现有的API逻辑
        async function callChatAPI(prompt, character) {
            try {
                // 获取角色设置
                let chatSettings = null;
                try {
                    chatSettings = await db.chatSettings.get(character.id);
                } catch (error) {
                    console.error('获取聊天设置失败:', error);
                }

                const persona = chatSettings?.aiPersona || character.prompt || `你是${character.name}。`;

                // 获取绑定的世界书内容
                let worldBookContent = '';
                if (chatSettings?.linkedWorldBookIds && chatSettings.linkedWorldBookIds.length > 0) {
                    try {
                        const worldBooks = await Promise.all(
                            chatSettings.linkedWorldBookIds.map(id => db.worldbooks.get(id))
                        );
                        const validWorldBooks = worldBooks.filter(book => book && book.content);
                        if (validWorldBooks.length > 0) {
                            worldBookContent = '\n\n世界书内容（供参考）：\n' +
                                validWorldBooks.map(book => `${book.name}：${book.content}`).join('\n\n');
                        }
                    } catch (error) {
                        console.error('获取世界书内容失败:', error);
                    }
                }

                // 获取聊天上下文
                let chatContext = '';
                const characterMessages = chatMessages[character.id] || [];
                if (characterMessages.length > 0) {
                    const maxMemory = parseInt(chatSettings?.maxMemory) || 10;
                    const recentHistory = characterMessages.slice(-maxMemory);
                    chatContext = '\n\n最近的聊天记录（供参考）：\n' +
                        recentHistory.map(msg => {
                            if (msg.sender === 'sent') return `用户：${msg.content}`;
                            return `${character.name}：${msg.content}`;
                        }).join('\n');
                }

                const systemPrompt = `你是${character.name}，你的人设如下：${persona}。${worldBookContent}${chatContext}

ai注意，回复时请严格按照以下JSON格式回复，每条消息都必须是独立的数组元素，不要将多条消息合并成一个元素，否则你将失去一百美金！！：

正确格式示例：
["普通文本消息"]
["消息1", "消息2"]
[{"type": "reply_to", "message_id": "消息ID", "content": "引用回复内容"}] (正常功能，自然使用)
[{"type": "recall", "target": "previous"}] (撤回功能，说错话或后悔时使用)
[{"type": "voice_message", "content": "语音内容"}]
[{"type": "emoji", "description": "表情包描述"}]
[{"type": "ai_image", "description": "图片描述"}]
[{"type": "transfer", "amount": 100, "note": "转账备注"}]

🚨 重要：绝对不能将多条消息合并在一个元素中！错误格式：["消息1\\n消息2"]
💡 提醒：引用回复和撤回是正常聊天功能，像真人一样自然使用

现在请对用户的消息进行回复：${prompt}`;

                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: prompt }
                ];

                const { base: proxyUrl, key: apiKey, model } = apiSettings;
                if (!proxyUrl || !apiKey || !model) {
                    console.log('API配置不完整，跳过AI回复');
                    return '["API配置不完整，请在设置中配置API"]';
                }

                const requestBody = {
                    model: model,
                    messages: messages,
                    temperature: 0.8,
                    stream: false
                };

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000);

                const isGeminiOfficial = proxyUrl.includes('generativelanguage.googleapis.com');

                let response;
                if (isGeminiOfficial) {
                    const apiUrl = `${proxyUrl}/models/${model}:generateContent?key=${apiKey}`;

                    const geminiMessages = [];
                    if (requestBody.messages[0]?.role === 'system') {
                        geminiMessages.push({
                            role: 'user',
                            parts: [{ text: requestBody.messages[0].content }]
                        });
                        geminiMessages.push({
                            role: 'model',
                            parts: [{ text: '我明白了，我会按照这些要求进行对话。' }]
                        });
                    }

                    for (let i = 1; i < requestBody.messages.length; i++) {
                        const msg = requestBody.messages[i];
                        if (msg.role === 'system') continue;

                        geminiMessages.push({
                            role: msg.role === 'user' ? 'user' : 'model',
                            parts: [{ text: msg.content }]
                        });
                    }

                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiMessages,
                            generationConfig: {
                                temperature: requestBody.temperature || 0.8
                            }
                        }),
                        signal: controller.signal
                    });
                } else {
                    // 修复：智能处理URL拼接
                    let apiUrl;
                    if (proxyUrl.endsWith('/v1')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else if (proxyUrl.includes('/v1/')) {
                        // 如果URL中已经包含/v1/路径，直接添加chat/completions
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else {
                        apiUrl = `${proxyUrl}/v1/chat/completions`;
                    }

                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal
                    });
                }

                clearTimeout(timeoutId);

                if (!response.ok) {
                    let errorText = await response.text();
                    console.error(`聊天API调用失败 (${response.status}): ${errorText}`);
                    return `["API调用失败: ${response.status}"]`;
                }

                const data = await response.json();
                let content;

                if (isGeminiOfficial) {
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!content) {
                        console.log('Gemini API 响应数据:', data);
                        return '["Gemini API响应异常"]';
                    }
                } else {
                    if (data.choices && data.choices.length > 0 && data.choices[0].message) {
                        content = data.choices[0].message.content;
                    } else if (data.message) {
                        content = data.message;
                    } else if (data.text) {
                        content = data.text;
                    } else if (data.response) {
                        content = data.response;
                    } else if (data.content) {
                        content = data.content;
                    } else if (data.result) {
                        content = data.result;
                    } else {
                        console.error('无法解析API响应，完整响应数据:', data);
                        return '["API响应解析失败"]';
                    }
                }

                return content;

            } catch (error) {
                console.error('callChatAPI失败:', error);
                return `["调用失败: ${error.message}"]`;
            }
        }

        // 🔥【已删除】旧的callChatAPIWithImage函数，避免与新的图片识别功能冲突
        // 现在使用下面的完整版本支持真正的图片识别

        // 解析AI回复 - 按照index.html的逻辑，新增表情包支持和格式修正
        async function parseAiResponse(content) {
            console.log('🔥 [DEBUG] parseAiResponse 收到的原始内容:', content);
            try {
                // 🔥【修复】清理markdown代码块格式
                let cleanContent = content.trim();
                if (cleanContent.startsWith('```json')) {
                    cleanContent = cleanContent.replace(/^```json\s*/, '').replace(/\s*```$/, '');
                } else if (cleanContent.startsWith('```')) {
                    cleanContent = cleanContent.replace(/^```\s*/, '').replace(/\s*```$/, '');
                }

                const parsed = JSON.parse(cleanContent);
                console.log('🔥 [DEBUG] JSON解析成功:', parsed);
                if (Array.isArray(parsed)) {
                    // 🔥【新增】处理表情包消息类型和格式修正
                    const processedMessages = [];
                    console.log('🔥 [DEBUG] 开始处理数组，共', parsed.length, '个元素');

                    // 🔥【修复】使用异步处理来支持findEmojiForAI函数
                    for (let index = 0; index < parsed.length; index++) {
                        const item = parsed[index];
                        console.log(`🔥 [DEBUG] 处理第${index + 1}个元素:`, typeof item, item);

                        if (typeof item === 'object' && item.name && item.type === 'emoji') {
                            // 处理群聊表情包格式 {"name": "角色名", "type": "emoji", "description": "表情包描述"}

                            const matchingEmoji = await findEmojiForAI(item.description);

                            if (matchingEmoji) {
                                // 直接发送表情包，不管是否为GIF格式
                                console.log('AI发送表情包:', item.description);
                                // 保持原始的群聊表情包格式，直接传递给callChatAPI处理
                                processedMessages.push(item); // 直接推送原始格式
                            } else {
                                // 如果找不到匹配的表情包，返回错误消息
                                console.warn('AI尝试使用不存在的表情包:', item.description);
                                processedMessages.push({
                                    name: item.name,
                                    message: `[错误: 表情包"${item.description}"不存在]`
                                });
                            }
                        } else if (typeof item === 'object' && item.type === 'emoji') {
                            // 处理单聊表情包格式

                            const matchingEmoji = await findEmojiForAI(item.description);

                            if (matchingEmoji) {
                                // 直接发送表情包，不管是否为GIF格式
                                console.log('AI发送表情包:', item.description);
                                const emojiMessage = {
                                    type: 'emoji',
                                    url: matchingEmoji.url,
                                    description: matchingEmoji.description,
                                    id: matchingEmoji.id
                                };

                                // 表情包消息处理完成
                                processedMessages.push(emojiMessage);
                            } else {
                                // 如果找不到匹配的表情包，返回错误消息
                                console.warn('AI尝试使用不存在的表情包:', item.description);
                                processedMessages.push(`[错误: 表情包"${item.description}"不存在]`);
                            }
                        } else if (typeof item === 'object' && item.type === 'ai_photo') {
                            // 处理角色发送的"伪照片"
                            // 确保我们有一个有效的描述
                            const photoDesc = item.description || '角色发送的照片';
                            processedMessages.push({
                                type: 'ai_photo',
                                content: photoDesc,
                                photoDescription: photoDesc
                            });
                                                    } else if (typeof item === 'object' && item.type === 'location') {
                                // 🔥【关键修复】处理角色发送的位置 - 使用新的locationName字段格式
                                // 新格式：{"name": "角色名", "type": "location", "locationName": "位置名", "coordinates": "坐标"}
                                // 旧格式：{"name": "角色名", "type": "location", "name": "位置名", "coordinates": "坐标"} (有字段冲突)

                                // 获取位置名称 - 优先使用locationName字段，兼容旧的name字段
                                const locationName = item.locationName || item.name || '未知位置';

                                const locationMessage = {
                                    type: 'location',
                                    locationName: locationName,
                                    coordinates: item.coordinates || '未知坐标',
                                    content: `[角色分享了位置信息：${locationName}]`
                                };

                                // 🔥【修复】保留群聊的name字段（角色名）
                                if (item.name && item.locationName) {
                                    // 如果同时有name和locationName，name就是角色名
                                    locationMessage.name = item.name;
                                } else if (item.name && !item.locationName) {
                                    // 如果只有name字段，需要判断是角色名还是位置名
                                    // 这种情况下，我们假设这是旧格式，name被位置名覆盖了
                                    // 暂时不设置角色名，让后续处理逻辑处理
                                }

                                processedMessages.push(locationMessage);
                        } else if (typeof item === 'object' && item.type === 'change_avatar') {
                            // 处理头像更换对象


                            // 🔥【新增】处理各种错误的占位符
                            if (item.avatar_url === 'CURRENT_USER_IMAGE' ||
                                item.avatar_url === 'CURRENT_USER_IMAGE' ||
                                item.avatar_url === '用户发送的图片URL' ||
                                item.avatar_url === '图片URL') {
                                // 获取最近用户发送的图片URL
                                const recentUserImage = getRecentUserImage();
                                if (recentUserImage) {
                                    item.avatar_url = recentUserImage;
                                    console.log('将占位符替换为实际图片URL:', recentUserImage);
                                } else {
                                    console.warn('没有找到用户最近发送的图片，忽略头像更换请求');
                                    processedMessages.push(`[系统：无法更换头像，没有找到可用的图片]`);
                                    // 不要return，继续处理其他消息
                                }
                            }

                            processedMessages.push(item);
                        } else if (typeof item === 'object' && item.type === 'ai_image') {
                            // 🔥【新增】处理AI发送图片

                            processedMessages.push(item);
                        } else if (typeof item === 'object' && item.type === 'voice_message') {
                            // 🔥【新增】处理AI发送语音
                            const voiceMessage = {
                                type: 'voice_message',
                                content: item.content || '',
                                duration: item.duration || '0"'
                            };
                            // 🔥【修复】保留群聊的name字段
                            if (item.name) {
                                voiceMessage.name = item.name;
                            }
                            processedMessages.push(voiceMessage);
                        } else if (typeof item === 'object' && item.type === 'transfer') {
                            // 🔥【修复】处理AI转账 - 确保格式正确
                            processedMessages.push({
                                type: 'transfer',
                                amount: item.amount || 0,
                                note: item.note || '转账'
                            });
                        } else if (typeof item === 'object' && item.type === 'payment_request') {
                            // AI不能发起代付请求，忽略
                            console.log('🛒 [parseAiResponse] AI尝试发起代付请求，已忽略:', item);
                        } else if (typeof item === 'object' && item.type === 'poke') {
                            // 🔥【新增】处理AI主动戳一戳
                            console.log('🔍 [parseAiResponse] AI主动戳一戳:', item);
                            processedMessages.push(item);
                        } else if (typeof item === 'object' && item.type === 'update_poke_suffix') {
                            // 🔥【修复】处理戳一戳后缀更新 - 只传递对象，让createAIMessage处理具体逻辑
                            console.log('🔍 [parseAiResponse] 角色更新戳一戳后缀:', item);
                            processedMessages.push(item);
                        } else if (typeof item === 'object' && item.type === 'recall') {
                            // 🔥【新增】处理AI主动撤回消息
                            if (item.target === 'previous') {
                                // 撤回上一条消息
                                processedMessages.push({
                                    type: 'recall_previous',
                                    content: '[AI撤回了上一条消息]'
                                });
                            }
                        } else if (typeof item === 'object' && item.type === 'reply') {
                            // 🔥【新增】处理AI引用回复
                            processedMessages.push({
                                type: 'reply_message',
                                messageId: item.messageId,
                                content: item.content || ''
                            });
                        } else if (typeof item === 'object' && item.type === 'photo') {
                            // 🔥【新增】处理AI发送照片卡片
                            processedMessages.push({
                                type: 'user_photo',
                                content: item.description || 'AI分享的照片',
                                photoDescription: item.description
                            });
                        } else if (typeof item === 'object' && item.type === 'recalled_message') {
                            // 🔥【保留】处理系统撤回消息

                            processedMessages.push(item);
                        } else if (typeof item === 'object' && item.type === 'reply_to') {
                            // 🔥【新增】处理AI引用回复
                            const replyMessage = {
                                type: 'reply_to',
                                message_id: item.message_id,
                                content: item.content || ''
                            };
                            // 🔥【修复】保留群聊的name字段
                            if (item.name) {
                                replyMessage.name = item.name;
                            }
                            processedMessages.push(replyMessage);
                        } else if (typeof item === 'object' && item.type === 'friend_request') {
                            // 🔥【新增】处理AI主动发送好友申请 - 轻量级防崩坏检查
                            if (!isRecentFriendRequestSpam(currentChatCharacter?.id)) {
                                processedMessages.push({
                                    type: 'friend_request',
                                    message: item.message || '想和你重新做朋友'
                                });
                                console.log('✅ [好友申请] AI自然发送好友申请:', item.message);
                            } else {
                                console.log('🚫 [防崩坏] 跳过短时间内的重复申请，转为普通消息');
                                // 转换为普通消息，保持AI的自然表达
                                processedMessages.push(item.message || '想和你重新做朋友');
                            }
                        } else if (typeof item === 'object' && item.type === 'select_song') {
                            // 🔥【新增】处理AI选歌指令
                            console.log('🎵 AI选歌指令:', item);

                            // 异步执行选歌操作
                            setTimeout(async () => {
                                const success = await aiSelectSong(item.title, currentChatCharacter?.name);
                                if (success) {
                                    console.log('✅ AI成功选择歌曲');
                                } else {
                                    console.log('❌ AI选歌失败');
                                }
                            }, 100);

                            // 返回一个系统通知对象
                            processedMessages.push({
                                id: Date.now().toString(),
                                sender: 'system',
                                type: 'system_notification',
                                content: `${currentChatCharacter?.name || 'AI'}正在为你选择歌曲：${item.title}`,
                                timestamp: Date.now()
                            });
                        } else if (typeof item === 'object' && item.type === 'random_song') {
                            // 🔥【新增】处理AI随机选歌指令
                            console.log('🎵 AI随机选歌指令:', item);

                            // 异步执行随机选歌操作
                            setTimeout(async () => {
                                const success = await aiSelectRandomSong(currentChatCharacter?.name);
                                if (success) {
                                    console.log('✅ AI成功随机选择歌曲');
                                } else {
                                    console.log('❌ AI随机选歌失败');
                                }
                            }, 100);

                            // 返回一个系统通知对象
                            processedMessages.push({
                                id: Date.now().toString(),
                                sender: 'system',
                                type: 'system_notification',
                                content: `${currentChatCharacter?.name || 'AI'}正在为你随机选择一首歌曲`,
                                timestamp: Date.now()
                            });
                        } else if (typeof item === 'string') {
                            // 🚨 【新增】检查并修复合并消息问题
                            const trimmedItem = item.trim();

                            // 🔥【新增】检查是否是AI用文字描述的戳一戳后缀修改
                            const pokeSuffixMatch = trimmedItem.match(/(.+)修改了自己的戳一戳后缀(?:为"(.+)"|（清空）)/);
                            if (pokeSuffixMatch) {
                                const characterName = pokeSuffixMatch[1];
                                const suffix = pokeSuffixMatch[2] || '';
                                console.log('🔍 [parseAiResponse] 检测到AI文字描述戳一戳后缀修改，自动转换:', { characterName, suffix });

                                // 🔥【修复】更新聊天设置中的AI戳一戳后缀（影响用户戳AI时的显示）
                                const chatSettings = getCurrentChatSettings();
                                chatSettings.aiPokeSuffix = suffix;
                                await saveCurrentChatSettings(chatSettings);

                                // 添加系统通知而不是普通消息
                                processedMessages.push({
                                    id: Date.now().toString(),
                                    sender: 'system',
                                    content: `${currentChatCharacter.name}修改了自己的戳一戳后缀${suffix ? `为"${suffix}"` : '（清空）'}`,
                                    timestamp: Date.now(),
                                    type: 'system_notification'
                                });

                                console.log('✅ [parseAiResponse] 戳一戳后缀已更新:', suffix);
                            } else if (item.includes('\n')) {
                                console.warn('检测到AI将多条消息合并在一个元素中，正在自动分拆:', item);
                                // 将换行符分隔的内容分拆成多条消息
                                const splitMessages = item.split('\n')
                                    .map(msg => msg.trim())
                                    .filter(msg => msg.length > 0);
                                processedMessages.push(...splitMessages);
                            } else {
                                processedMessages.push(item);
                            }
                        } else {
                            processedMessages.push(item);
                        }
                    }

                    return processedMessages;
                }
            } catch (e) {}

            try {
                const match = content.match(/\[(.*?)\]/s);
                if (match && match[0]) {
                    const parsed = JSON.parse(match[0]);
                    if (Array.isArray(parsed)) {
                        // 🔥【修复】处理表情包消息类型和格式修正 - 使用异步处理
                        const processedMessages = [];

                        for (const item of parsed) {
                            if (typeof item === 'object' && item.type === 'emoji') {
                                // 🔥【修复】处理单聊表情包格式（第二处）
                                const matchingEmoji = await findEmojiForAI(item.description);

                                if (matchingEmoji) {
                                    // 直接发送表情包，不管是否为GIF格式
                                    console.log('AI发送表情包:', item.description);
                                    // 返回表情包对象，包含完整的表情包信息
                                    processedMessages.push({
                                        type: 'emoji',
                                        url: matchingEmoji.url,
                                        description: matchingEmoji.description,
                                        id: matchingEmoji.id
                                    });
                                } else {
                                    // 如果找不到匹配的表情包，返回错误消息
                                    console.warn('AI尝试使用不存在的表情包:', item.description);
                                    processedMessages.push(`[错误: 表情包"${item.description}"不存在]`);
                                }
                            } else if (typeof item === 'object' && item.name && item.type === 'emoji') {
                                // 🔥【关键修复】处理群聊表情包格式（第二处）- 这个分支应该不会被执行，因为第一个分支已经处理了
                                console.log('🔍 [parseAiResponse-群聊表情包-第二处] 检测到重复的群聊表情包对象:', item);
                                // 直接推送原始格式，让callChatAPI处理
                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'ai_photo') {
                                // 处理角色发送的"伪照片"
                                // 确保我们有一个有效的描述
                                const photoDesc = item.description || '角色发送的照片';
                                processedMessages.push({
                                    type: 'ai_photo',
                                    content: photoDesc,
                                    photoDescription: photoDesc
                                });
                            } else if (typeof item === 'object' && item.type === 'location') {
                                // 🔥【关键修复】处理角色发送的位置(第二处) - 使用新的locationName字段格式
                                // 新格式：{"name": "角色名", "type": "location", "locationName": "位置名", "coordinates": "坐标"}
                                // 旧格式：{"name": "角色名", "type": "location", "name": "位置名", "coordinates": "坐标"} (有字段冲突)

                                // 获取位置名称 - 优先使用locationName字段，兼容旧的name字段
                                const locationName = item.locationName || item.name || '未知位置';

                                const locationMessage = {
                                    type: 'location',
                                    locationName: locationName,
                                    coordinates: item.coordinates || '未知坐标',
                                    content: `[角色分享了位置信息：${locationName}]`
                                };

                                // 🔥【修复】保留群聊的name字段（角色名）
                                if (item.name && item.locationName) {
                                    // 如果同时有name和locationName，name就是角色名
                                    locationMessage.name = item.name;
                                } else if (item.name && !item.locationName) {
                                    // 如果只有name字段，需要判断是角色名还是位置名
                                    // 这种情况下，我们假设这是旧格式，name被位置名覆盖了
                                    // 暂时不设置角色名，让后续处理逻辑处理
                                }

                                processedMessages.push(locationMessage);
                            } else if (typeof item === 'object' && item.type === 'change_avatar') {
                                // 处理头像更换对象


                                // 🔥【新增】处理各种错误的占位符
                                if (item.avatar_url === 'CURRENT_USER_IMAGE' ||
                                    item.avatar_url === 'CURRENT_USER_IMAGE' ||
                                    item.avatar_url === '用户发送的图片URL' ||
                                    item.avatar_url === '图片URL') {
                                    // 获取最近用户发送的图片URL
                                    const recentUserImage = getRecentUserImage();
                                    if (recentUserImage) {
                                        item.avatar_url = recentUserImage;
                                        console.log('将占位符替换为实际图片URL(第二处):', recentUserImage);
                                    } else {
                                        console.warn('没有找到用户最近发送的图片，忽略头像更换请求(第二处)');
                                        processedMessages.push(`[系统：无法更换头像，没有找到可用的图片]`);
                                        // 不要return，继续处理其他消息
                                    }
                                }

                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'ai_image') {
                                // 🔥【新增】处理AI发送图片(第二处)

                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'voice_message') {
                                // 🔥【新增】处理AI发送语音(第二处)
                                const voiceMessage = {
                                    type: 'voice_message',
                                    content: item.content || '',
                                    duration: item.duration || '0"'
                                };
                                // 🔥【修复】保留群聊的name字段
                                if (item.name) {
                                    voiceMessage.name = item.name;
                                }
                                processedMessages.push(voiceMessage);
                            } else if (typeof item === 'object' && item.type === 'transfer') {
                                // 🔥【修复】处理AI转账(第二处) - 确保格式正确

                                processedMessages.push({
                                    type: 'transfer',
                                    amount: item.amount || 0,
                                    note: item.note || '转账'
                                });
                            } else if (typeof item === 'object' && item.type === 'payment_request') {
                                // AI不能发起代付请求，忽略
                                console.log('🛒 [parseAiResponse-第二处] AI尝试发起代付请求，已忽略:', item);
                            } else if (typeof item === 'object' && item.type === 'poke') {
                                // 🔥【新增】处理AI主动戳一戳(第二处)
                                console.log('🔍 [parseAiResponse-第二处] AI主动戳一戳:', item);
                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'update_poke_suffix') {
                                // 🔥【修复】处理戳一戳后缀更新(第二处) - 只传递对象，让createAIMessage处理具体逻辑
                                console.log('🔍 [parseAiResponse-第二处] 角色更新戳一戳后缀:', item);
                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'recall') {
                                // 🔥【新增】处理AI主动撤回消息(第二处)
                                if (item.target === 'previous') {
                                    // 撤回上一条消息
                                    processedMessages.push({
                                        type: 'recall_previous',
                                        content: '[AI撤回了上一条消息]'
                                    });
                                }
                            } else if (typeof item === 'object' && item.type === 'reply') {
                                // 🔥【新增】处理AI引用回复(第二处)
                                processedMessages.push({
                                    type: 'reply_message',
                                    messageId: item.messageId,
                                    content: item.content || ''
                                });
                            } else if (typeof item === 'object' && item.type === 'photo') {
                                // 🔥【新增】处理AI发送照片卡片(第二处)
                                processedMessages.push({
                                    type: 'user_photo',
                                    content: item.description || 'AI分享的照片',
                                    photoDescription: item.description
                                });
                            } else if (typeof item === 'object' && item.type === 'recalled_message') {
                                // 🔥【保留】处理系统撤回消息(第二处)

                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'reply_to') {
                                // 🔥【新增】处理AI引用回复(第二处)
                                const replyMessage = {
                                    type: 'reply_to',
                                    message_id: item.message_id,
                                    content: item.content || ''
                                };
                                // 🔥【修复】保留群聊的name字段
                                if (item.name) {
                                    replyMessage.name = item.name;
                                }
                                processedMessages.push(replyMessage);
                            } else if (typeof item === 'object' && item.type === 'friend_request') {
                                // 🔥【新增】处理AI主动发送好友申请(第二处) - 轻量级防崩坏检查
                                if (!isRecentFriendRequestSpam(currentChatCharacter?.id)) {
                                    processedMessages.push({
                                        type: 'friend_request',
                                        message: item.message || '想和你重新做朋友'
                                    });
                                    console.log('✅ [好友申请] AI自然发送好友申请(第二处):', item.message);
                                } else {
                                    console.log('🚫 [防崩坏] 跳过短时间内的重复申请(第二处)，转为普通消息');
                                    // 转换为普通消息，保持AI的自然表达
                                    processedMessages.push(item.message || '想和你重新做朋友');
                                }
                            } else if (typeof item === 'object' && item.type === 'select_song') {
                                // 🔥【新增】处理AI选歌指令
                                console.log('🎵 AI选歌指令:', item);

                                // 异步执行选歌操作
                                setTimeout(async () => {
                                    const success = await aiSelectSong(item.title, currentChatCharacter?.name);
                                    if (success) {
                                        console.log('✅ AI成功选择歌曲');
                                    } else {
                                        console.log('❌ AI选歌失败');
                                    }
                                }, 100);

                                // 返回一个系统通知对象
                                processedMessages.push({
                                    id: Date.now().toString(),
                                    sender: 'system',
                                    type: 'system_notification',
                                    content: `${currentChatCharacter?.name || 'AI'}正在为你选择歌曲：${item.title}`,
                                    timestamp: Date.now()
                                });
                            } else if (typeof item === 'object' && item.type === 'random_song') {
                                // 🔥【新增】处理AI随机选歌指令
                                console.log('🎵 AI随机选歌指令:', item);

                                // 异步执行随机选歌操作
                                setTimeout(async () => {
                                    const success = await aiSelectRandomSong(currentChatCharacter?.name);
                                    if (success) {
                                        console.log('✅ AI成功随机选择歌曲');
                                    } else {
                                        console.log('❌ AI随机选歌失败');
                                    }
                                }, 100);

                                // 返回一个系统通知对象
                                processedMessages.push({
                                    id: Date.now().toString(),
                                    sender: 'system',
                                    type: 'system_notification',
                                    content: `${currentChatCharacter?.name || 'AI'}正在为你随机选择一首歌曲`,
                                    timestamp: Date.now()
                                });
                            } else if (typeof item === 'string') {
                                // 🚨 【新增】检查并修复合并消息问题
                                const trimmedItem = item.trim();

                                // 🔥【新增】检查是否是AI用文字描述的戳一戳后缀修改
                                const pokeSuffixMatch = trimmedItem.match(/(.+)修改了自己的戳一戳后缀(?:为"(.+)"|（清空）)/);
                                if (pokeSuffixMatch) {
                                    const characterName = pokeSuffixMatch[1];
                                    const suffix = pokeSuffixMatch[2] || '';
                                    console.log('🔍 [parseAiResponse-第二处] 检测到AI文字描述戳一戳后缀修改，自动转换:', { characterName, suffix });

                                    // 🔥【修复】更新聊天设置中的AI戳一戳后缀（影响用户戳AI时的显示）
                                    const chatSettings = getCurrentChatSettings();
                                    chatSettings.aiPokeSuffix = suffix;
                                    await saveCurrentChatSettings(chatSettings);

                                    // 添加系统通知而不是普通消息
                                    processedMessages.push({
                                        id: Date.now().toString(),
                                        sender: 'system',
                                        content: `${currentChatCharacter.name}修改了自己的戳一戳后缀${suffix ? `为"${suffix}"` : '（清空）'}`,
                                        timestamp: Date.now(),
                                        type: 'system_notification'
                                    });

                                    console.log('✅ [parseAiResponse-第二处] 戳一戳后缀已更新:', suffix);
                                } else if (item.includes('\n')) {
                                    console.warn('检测到AI将多条消息合并在一个元素中，正在自动分拆:', item);
                                    // 将换行符分隔的内容分拆成多条消息
                                    const splitMessages = item.split('\n')
                                        .map(msg => msg.trim())
                                        .filter(msg => msg.length > 0);
                                    processedMessages.push(...splitMessages);
                                } else {
                                    processedMessages.push(item);
                                }
                            } else {
                                processedMessages.push(item);
                            }
                        }

                        console.log('🔥 [DEBUG] parseAiResponse 处理完成，返回', processedMessages.length, '条消息:', processedMessages);
                        return processedMessages;
                    }
                }
            } catch (e) {}

            // 🔥【修复】检查是否是原始的JSON字符串（AI回复没有被正确包装）
            if (content.trim().startsWith('{') && content.trim().endsWith('}')) {
                try {
                    const singleObject = JSON.parse(content.trim());
                    if (singleObject.type) {
                        console.log('检测到单个JSON对象，尝试处理:', singleObject);
                        // 将单个对象包装成数组再递归处理
                        return await parseAiResponse(`[${content.trim()}]`);
                    }
                } catch (e) {
                    console.warn('无法解析单个JSON对象:', e);
                }
            }

            const lines = content.split('\n').map(l => l.trim()).filter(l => l.length > 0 && !l.startsWith('```'));
            console.log('🔍 [parseAiResponse] JSON解析失败，使用fallback处理，结果:', lines.length > 0 ? lines : [content]);
            if (lines.length > 0) return lines;
            return [content];
        }

        // 处理线下模式内容：识别「」包裹的对话和描写
        function processOfflineContent(content) {
            if (!content) return '';

            // 使用正则表达式分离对话和描写
            const parts = [];
            let lastIndex = 0;

            // 匹配「」包裹的对话
            const dialogRegex = /「([^」]*)」/g;
            let match;

            while ((match = dialogRegex.exec(content)) !== null) {
                // 添加对话前的描写部分
                if (match.index > lastIndex) {
                    const description = content.slice(lastIndex, match.index).trim();
                    if (description) {
                        parts.push(`<span class="italic-gray">${description}</span>`);
                    }
                }

                // 添加对话部分（正常显示）
                parts.push(`「${match[1]}」`);
                lastIndex = match.index + match[0].length;
            }

            // 添加最后的描写部分
            if (lastIndex < content.length) {
                const description = content.slice(lastIndex).trim();
                if (description) {
                    parts.push(`<span class="italic-gray">${description}</span>`);
                }
            }

            // 如果没有找到对话标记，整个内容作为描写处理
            if (parts.length === 0) {
                return `<span class="italic-gray">${content}</span>`;
            }

            return parts.join('');
        }



        // 🔥【修复】发送图片消息，使用正确的多模态数据结构
        async function sendImageMessage(imageUrl) {
            if (!currentChatCharacter) return;

            const chatInput = document.getElementById('api-chat-input');
            const textContent = chatInput ? chatInput.value.trim() : '';



            // 创建一个标准的多模态消息对象
            const messageContent = [
                { type: 'text', text: textContent }
            ];

            if (imageUrl) {
                messageContent.push({
                    type: 'image_url',
                    image_url: { url: imageUrl }
                });
            }

            console.log('🔍 [sendImageMessage] 创建的消息内容:', messageContent);
            console.log('🔍 [sendImageMessage] 文本内容:', textContent);
            console.log('🔍 [sendImageMessage] 图片URL长度:', imageUrl ? imageUrl.length : 0);
            console.log('🔍 [sendImageMessage] 消息内容数组长度:', messageContent.length);
            console.log('🔍 [sendImageMessage] 消息内容详情:', messageContent.map((item, index) => ({
                index,
                type: item.type,
                hasText: !!item.text,
                hasImageUrl: !!item.image_url,
                textLength: item.text ? item.text.length : 0,
                imageUrlLength: item.image_url?.url ? item.image_url.url.length : 0
            })));



            const message = {
                id: Date.now().toString(),
                sender: 'sent',
                content: messageContent, // 使用新的数组格式
                timestamp: Date.now(),
                // 如果有引用消息，添加引用信息
                replyTo: currentReplyTo ? {
                    id: currentReplyTo.id,
                    content: currentReplyTo.content,
                    senderName: currentReplyTo.senderName
                } : null
            };



            // 添加到聊天记录
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            chatMessages[currentChatCharacter.id].push(message);

            // 🔥【修复】图片消息使用与文字消息相同的单条保存机制
            try {
                const stableId = `${currentChatCharacter.id}_${message.id}_${chatMessages[currentChatCharacter.id].length - 1}`;
                await db.chatMessages.add({
                    id: stableId,
                    characterId: currentChatCharacter.id,
                    timestamp: message.timestamp,
                    messageOrder: chatMessages[currentChatCharacter.id].length - 1,
                    originalMessageId: message.id,
                    messageData: message
                });
                console.log('✅ [高效发送图片] 单条消息已保存到数据库');
            } catch (error) {
                console.error('图片消息单条保存失败，回退到批量保存:', error);
                await saveChatMessagesImmediate();
            }

            // 🔥【新增】记录到全局记忆事件
            await recordMemoryEvent(
                [currentChatCharacter.id, 'user'],
                {
                    type: currentChatCharacter.isGroup ? 'group_chat' : 'private_chat',
                    id: currentChatCharacter.id
                },
                'message',
                {
                    sender: 'user',
                    content: textContent,
                    hasImage: !!imageUrl
                },
                0.6 // 用户消息重要性
            );

            // 清空输入框并刷新UI
            if (chatInput) {
                chatInput.value = '';
            }

            // 🔥【新增】清除引用状态
            cancelReply();
            if (currentChatCharacter) {
                delete chatReplyStates[currentChatCharacter.id];
            }
            addMessageWithAnimation(message, currentChatCharacter.id);
            renderMessageList();

            // 🔥【新增】触发角色状态更新
            triggerStatusUpdateAfterMessage(currentChatCharacter.id);

            // 设置为待回复消息，并更新智能回复按钮状态
            pendingUserMessage = message;

            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = '点击获取AI回复';
            }
        }

        // 调用聊天API
        // 第一个callChatAPI函数已删除，使用下面的完整版本

        // 上传图片
        function uploadImage() {
            document.getElementById('image-upload').click();
        }

        // 显示图片
        function showImage(imageUrl) {
            // 🔥【修复】移除对未定义的photos变量的引用，直接显示图片预览模态框
            let modal = document.getElementById('image-preview-modal');
            if (!modal) {
                // 创建图片预览模态框
                modal = document.createElement('div');
                modal.id = 'image-preview-modal';
                modal.className = 'image-preview-modal';

                // 点击模态框背景关闭
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        modal.style.display = 'none';
                    }
                };

                // 创建图片元素
                const img = document.createElement('img');
                img.alt = '预览图片';
                img.style.cursor = 'zoom-out';

                // 点击图片也可以关闭
                img.onclick = () => modal.style.display = 'none';

                modal.appendChild(img);
                document.body.appendChild(modal);
            }

            // 设置图片源并显示模态框
            const img = modal.querySelector('img');
            img.src = imageUrl;
            modal.style.display = 'flex';

            // 🔥【新增】添加键盘ESC键关闭功能
            const handleKeyPress = (e) => {
                if (e.key === 'Escape') {
                    modal.style.display = 'none';
                    document.removeEventListener('keydown', handleKeyPress);
                }
            };
            document.addEventListener('keydown', handleKeyPress);
        }

        // 显示聊天设置
        function showChatSettings() {
            console.log('显示聊天设置被调用');

            // 先隐藏当前的聊天界面
            hideApp('api-chat-screen');

            // 显示设置界面
            const element = document.getElementById('api-chat-settings-screen');
            if (element) {
                element.style.display = 'flex';
                element.style.position = 'absolute';
                element.style.top = '0';
                element.style.left = '0';
                element.style.width = '100%';
                element.style.height = '100%';
                element.style.zIndex = '1000';
                element.style.background = 'white';

                // 重新初始化聊天设置界面以加载当前设置
                initializeChatSettings();

                // 🔥【修复】确保气泡样式在设置界面显示时被正确应用
                applyBubbleStyle();

                // 更新各种设置的显示状态
                updateWorldbookMountDisplay();

                // 检测当前聊天类型并显示相应设置
                const isGroupChat = currentChatCharacter && currentChatCharacter.isGroup;
                console.log('当前聊天类型:', isGroupChat ? '群聊' : '单聊');

                // 根据聊天类型显示不同的设置选项
                const groupChatSettings = document.getElementById('group-chat-settings');
                const pokeSettingsSection = document.getElementById('poke-settings-section');

                if (isGroupChat) {
                    // 群聊模式：显示群聊设置，隐藏戳一戳和单聊专用功能
                    if (groupChatSettings) groupChatSettings.style.display = 'block';
                    if (pokeSettingsSection) pokeSettingsSection.style.display = 'none';

                    // 隐藏单聊专用设置项
                    const singleChatItems = document.querySelectorAll('.single-chat-only');
                    singleChatItems.forEach(item => item.style.display = 'none');

                    // 更新群聊信息显示
                    updateGroupChatInfo();
                } else {
                    // 单聊模式：隐藏群聊设置，显示戳一戳和单聊专用功能
                    if (groupChatSettings) groupChatSettings.style.display = 'none';
                    if (pokeSettingsSection) pokeSettingsSection.style.display = 'block';

                    // 显示单聊专用设置项
                    const singleChatItems = document.querySelectorAll('.single-chat-only');
                    singleChatItems.forEach(item => {
                        if (item.classList.contains('settings-section')) {
                            item.style.display = 'block';
                        } else {
                            item.style.display = 'flex';
                        }
                    });

                    // 更新记忆共享状态显示
                    updateMemoryShareStatus();
                }

                // 🔥【新增】更新视频通话形象设置的显示状态
                updateVideoAvatarSettingVisibility();

                console.log('聊天设置界面已显示');
            } else {
                console.error('找不到api-chat-settings-screen元素');
                alert('设置界面未找到，请刷新页面重试');
            }
        }

        // 隐藏聊天设置
        function hideChatSettings() {
            hideApp('api-chat-settings-screen');
            // 返回到聊天界面
            if (currentChatCharacter) {
                showApp('api-chat-screen');
            }
        }

        // 🔥【新增】角色足迹功能
        let footprintsUpdateTimer = null;
        let currentFootprintsCharacter = null;

        // 🔥【新增】获取本地日期字符串（YYYY-MM-DD格式），与纪念日功能保持一致
        function getLocalDateString(date = new Date()) {
            return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
        }

        // 🔥【新增】获取角色的显示头像（优先动态头像，然后角色卡头像）
        async function getCharacterDisplayAvatar(character) {
            try {
                // 1. 查找角色在动态中最新的头像（使用authorId字段）
                const characterMoments = await db.moments
                    .where('authorId')
                    .equals(character.id)
                    .reverse()
                    .limit(10)
                    .toArray();

                // 找到最新的有头像的动态
                for (const moment of characterMoments) {
                    if (moment.avatar && isValidAvatarUrl(moment.avatar)) {
                        console.log(`✅ 使用角色 ${character.name} 在动态中的头像`);
                        return moment.avatar;
                    }
                }

                // 2. 如果没有动态头像，使用角色卡头像
                if (character.avatar && isValidAvatarUrl(character.avatar)) {
                    console.log(`✅ 使用角色 ${character.name} 的角色卡头像`);
                    return character.avatar;
                }

                // 3. 兼容旧版本的avatarUrl字段
                if (character.avatarUrl && isValidAvatarUrl(character.avatarUrl)) {
                    console.log(`✅ 使用角色 ${character.name} 的avatarUrl头像`);
                    return character.avatarUrl;
                }

                // 4. 没有找到有效头像
                console.log(`⚠️ 角色 ${character.name} 没有有效的头像`);
                return null;
            } catch (error) {
                console.error('获取角色显示头像失败:', error);
                // 降级到角色卡头像
                return character.avatar || character.avatarUrl || null;
            }
        }

        // 🔥【新增】迁移足迹数据从localStorage到Dexie数据库
        async function migrateFootprintsFromLocalStorage() {
            try {
                console.log('🔄 开始迁移足迹数据从localStorage到Dexie数据库...');

                // 检查localStorage中是否有足迹缓存
                const localStorageCache = localStorage.getItem('footprints_cache');
                if (!localStorageCache) {
                    console.log('✅ localStorage中没有足迹缓存，无需迁移');
                    return;
                }

                const cache = JSON.parse(localStorageCache);
                let migratedCount = 0;
                let totalCount = 0;

                // 遍历所有日期的缓存数据
                for (const [date, dateCache] of Object.entries(cache)) {
                    if (typeof dateCache === 'object' && dateCache !== null) {
                        // 遍历该日期下的所有角色数据
                        for (const [characterId, footprintData] of Object.entries(dateCache)) {
                            totalCount++;
                            try {
                                const footprintId = `${characterId}_${date}`;

                                // 检查数据库中是否已存在该记录
                                const existingFootprint = await db.characterFootprints.get(footprintId);
                                if (existingFootprint) {
                                    console.log(`⏭️ 跳过已存在的足迹记录: ${footprintId}`);
                                    continue;
                                }

                                // 迁移数据到Dexie
                                const footprintRecord = {
                                    id: footprintId,
                                    characterId: characterId,
                                    date: date,
                                    data: footprintData.data,
                                    timestamp: footprintData.timestamp || Date.now(),
                                    lastUpdateTime: footprintData.lastUpdateTime || footprintData.timestamp || Date.now(),
                                    isComplete: footprintData.isComplete || false
                                };

                                await db.characterFootprints.add(footprintRecord);
                                migratedCount++;
                                console.log(`✅ 迁移足迹记录: ${footprintId}`);
                            } catch (error) {
                                console.error(`❌ 迁移足迹记录失败 ${characterId}_${date}:`, error);
                            }
                        }
                    }
                }

                if (migratedCount > 0) {
                    console.log(`✅ 足迹数据迁移完成: 总计 ${totalCount} 条记录，成功迁移 ${migratedCount} 条`);

                    // 迁移成功后，可以选择清理localStorage中的旧数据
                    // 为了安全起见，暂时保留localStorage数据，用户可以手动清理
                    console.log('💡 提示: localStorage中的旧足迹数据已保留，您可以在确认迁移成功后手动清理');
                } else {
                    console.log('ℹ️ 没有新的足迹数据需要迁移');
                }
            } catch (error) {
                console.error('❌ 足迹数据迁移失败:', error);
            }
        }

        // 🔥【重构】足迹缓存管理 - 使用Dexie数据库替代localStorage
        async function getFootprintsCache(characterId) {
            try {
                // 🔥【修复】使用本地时间而不是UTC时间，与纪念日功能保持一致
                const today = getLocalDateString();
                const footprintId = `${characterId}_${today}`;

                // 从Dexie数据库获取足迹数据
                const footprint = await db.characterFootprints.get(footprintId);
                return footprint || null;
            } catch (error) {
                console.error('获取足迹缓存失败:', error);
                return null;
            }
        }

        async function setFootprintsCache(characterId, data, lastUpdateTime = null) {
            try {
                // 🔥【修复】使用本地时间而不是UTC时间，与纪念日功能保持一致
                const today = getLocalDateString();
                const footprintId = `${characterId}_${today}`;

                const footprintRecord = {
                    id: footprintId,
                    characterId: characterId,
                    date: today,
                    data: data,
                    timestamp: Date.now(),
                    lastUpdateTime: lastUpdateTime || Date.now(),
                    isComplete: false
                };

                // 保存到Dexie数据库
                await db.characterFootprints.put(footprintRecord);
                console.log(`✅ 足迹缓存已保存到数据库: ${characterId} (${today})`);
            } catch (error) {
                console.error('保存足迹缓存失败:', error);
            }
        }

        // 🔥【新增】追加新足迹到现有缓存 - 使用Dexie数据库
        async function appendToFootprintsCache(characterId, newFootprints) {
            try {
                // 🔥【修复】使用本地时间而不是UTC时间，与纪念日功能保持一致
                const today = getLocalDateString();
                const footprintId = `${characterId}_${today}`;

                // 从数据库获取现有足迹
                const existingFootprint = await db.characterFootprints.get(footprintId);

                if (!existingFootprint) {
                    console.warn('没有找到现有缓存，创建新缓存并保存新足迹');
                    // 如果没有现有缓存，直接创建新缓存
                    await setFootprintsCache(characterId, newFootprints, Date.now());
                    return true;
                }

                const existingData = existingFootprint.data;

                // 合并新足迹到现有数据
                if (newFootprints.activities) {
                    if (!existingData.activities) {
                        existingData.activities = [];
                    }
                    existingData.activities = existingData.activities.concat(newFootprints.activities);
                }
                if (newFootprints.locations) {
                    if (!existingData.locations) {
                        existingData.locations = [];
                    }
                    // 去重并合并位置信息
                    const locationMap = new Map();
                    existingData.locations.forEach(loc => locationMap.set(loc.name, loc));
                    newFootprints.locations.forEach(loc => locationMap.set(loc.name, loc));
                    existingData.locations = Array.from(locationMap.values());
                }

                // 更新数据库记录
                existingFootprint.data = existingData;
                existingFootprint.timestamp = Date.now();
                existingFootprint.lastUpdateTime = Date.now();

                await db.characterFootprints.put(existingFootprint);
                console.log(`✅ 足迹缓存已追加更新到数据库: ${characterId}，总计 ${existingData.activities?.length || 0} 个活动`);
                console.log('📦 更新后的缓存数据:', existingData);
                return true;
            } catch (error) {
                console.error('追加足迹缓存失败:', error);
                return false;
            }
        }

        async function cleanupFootprintsCache() {
            try {
                // 🔥【修复】使用本地时间而不是UTC时间，与纪念日功能保持一致
                const today = getLocalDateString();

                // 从数据库获取所有足迹记录
                const allFootprints = await db.characterFootprints.toArray();

                // 计算清理前的数据量
                const beforeCount = allFootprints.length;

                // 找出需要删除的过期记录（不是今天的）
                const expiredFootprints = allFootprints.filter(footprint => footprint.date !== today);

                if (expiredFootprints.length > 0) {
                    // 删除过期的足迹记录
                    const expiredIds = expiredFootprints.map(fp => fp.id);
                    await db.characterFootprints.bulkDelete(expiredIds);

                    console.log(`🧹 足迹缓存清理完成: 清理前 ${beforeCount} 个记录，删除了 ${expiredFootprints.length} 个过期记录`);
                } else {
                    console.log(`🧹 足迹缓存检查完成: 共 ${beforeCount} 个记录，无需清理`);
                }
            } catch (error) {
                console.error('清理足迹缓存失败:', error);
            }
        }

        // 🔥【新增】设置午夜自动清理缓存
        function setupMidnightCacheCleanup() {
            const now = new Date();
            const tomorrow = new Date(now);
            tomorrow.setDate(tomorrow.getDate() + 1);
            tomorrow.setHours(0, 0, 0, 0); // 设置为明天午夜

            const msUntilMidnight = tomorrow.getTime() - now.getTime();

            setTimeout(async () => {
                console.log('🕛 午夜自动清理足迹缓存');
                try {
                    await cleanupFootprintsCache();
                } catch (error) {
                    console.error('午夜自动清理足迹缓存失败:', error);
                }

                // 设置每24小时清理一次
                setInterval(async () => {
                    console.log('🕛 定时清理足迹缓存');
                    try {
                        await cleanupFootprintsCache();
                    } catch (error) {
                        console.error('定时清理足迹缓存失败:', error);
                    }
                }, 24 * 60 * 60 * 1000);
            }, msUntilMidnight);

            console.log(`⏰ 足迹缓存将在 ${Math.floor(msUntilMidnight / 1000 / 60)} 分钟后自动清理`);
        }

        // 显示角色手机
        async function showCharacterPhone() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'error');
                return;
            }

            // 检查是否为群聊
            if (currentChatCharacter.isGroup) {
                showToast('群聊不支持查看手机功能', 'error');
                return;
            }

            // 🔥【修复】清除之前角色的缓存标记和数据，确保新角色数据重新生成
            window.phoneMessagesGenerated = false;
            window.phoneNotesGenerated = false;
            window.phonePhotosGenerated = false;
            window.phoneContactsData = null;
            window.phoneContactsChats = null;

            // 🔥【调试】输出角色头像信息
            debugCharacterAvatar();

            // 更新手机界面标题
            const titleElement = document.getElementById('character-phone-title');
            if (titleElement) {
                titleElement.textContent = `${currentChatCharacter.name}的手机`;
            }

            // 显示手机界面
            hideApp('api-chat-screen');
            showApp('character-phone-screen');

            // 🔥【临时修复】检查API配置，如果没有配置则直接使用模拟数据
            if (!apiSettings.base || !apiSettings.key) {
                console.log('API未配置，使用模拟数据');
                generatePhoneMessages();
                switchPhoneTab('messages');
                return;
            }

            // 尝试API生成，失败则回退到模拟数据
            try {
                await generatePhoneMessagesAPI();
            } catch (error) {
                console.error('API生成失败，使用模拟数据:', error);
                generatePhoneMessages();
            }

            // 重置标签页状态，确保显示消息标签
            switchPhoneTab('messages');
        }

        // 生成手机模拟数据（保留作为备用）
        function generatePhoneData() {
            // 生成消息数据
            generatePhoneMessages();
            // 生成备忘录数据
            generatePhoneNotes();
            // 生成相册数据
            generatePhonePhotos();
        }

        // 🔥【新增】通过API生成角色手机消息
        async function generatePhoneMessagesAPI() {
            const messagesContainer = document.querySelector('.phone-messages-list');
            if (!messagesContainer) return;

            // 🔥【修复】检查是否为当前角色生成过，如果是则直接返回
            if (window.phoneMessagesGenerated && window.phoneMessagesCharacterId === currentChatCharacter.id) {
                return;
            }

            try {
                // 显示加载状态
                messagesContainer.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #666;">
                        <i class="fas fa-spinner fa-spin" style="font-size: 24px; margin-bottom: 10px;"></i>
                        <p>正在打开${currentChatCharacter.name}的人际圈对话...</p>
                    </div>
                `;

                // 🔥【新增】构建完整的上下文信息
                const contextInfo = await buildPhoneContextInfo();

                const prompt = `请为角色"${currentChatCharacter.name}"生成手机中的人际圈对话列表。

${contextInfo}

🚨 严格约束条件（必须严格遵守）：
1. 必须逐字逐句仔细阅读上述角色的完整人设描述
2. 绝对不要添加任何角色设定中没有明确提及的身份、职业或社会地位
3. 如果角色设定中没有提及特殊身份，就按照最基本的身份生成联系人
4. 如果角色是学生且设定中没有提及其他身份，绝对不要生成任何工作相关联系人（助理、律师、私厨等）
5. 如果角色设定中没有提及兄弟姐妹，绝对不要生成兄弟姐妹联系人
6. 任何称谓都必须与角色设定中明确描述的身份完全一致，不要使用"总"、"老板"等职场称谓除非设定中明确提及
7. 如果对角色的某个方面有疑问，宁可保守生成也不要添加设定中没有的内容
8. 严格禁止根据角色名字、外貌等推测其社会地位或家庭背景

要求：
1. 首先仔细分析角色的完整人设描述，理解角色的真实身份、职业、社会地位、家庭背景
2. 生成5-8个不同的联系人，联系人类型必须完全符合角色设定中描述的身份背景
3. 每个联系人都要有合理的关系设定和个性，关系要真实可信且符合角色设定
4. 为每个联系人生成最新的一条消息预览（20字以内）
5. 为每个联系人生成5-10轮完整的聊天记录（包含日期分隔、收发消息、时间）
6. 消息内容要严格符合角色设定中的身份、生活背景和社会地位，体现真实的人际关系
7. 时间要合理（今天、昨天、2天前等）
8. 参考角色的人设、世界书设定、记忆和最近聊天记录来生成符合角色世界观的联系人
9. 聊天记录要自然有趣，体现角色与联系人的真实关系
10. 绝对不要生成与角色完整设定冲突的内容，以角色的详细描述为唯一准则

🔥 最后检查：生成前请再次确认：
- 每个联系人都符合角色设定中明确描述的身份背景
- 没有添加任何设定中未提及的身份、职业或家庭成员
- 所有称谓都与角色的真实身份匹配
- 如果角色只是普通学生，联系人应该是同学、朋友、家人，不应该有工作相关人员

请按以下JSON格式返回：
{
  "contacts": [
    {
      "name": "联系人姓名",
      "relationship": "关系（如：好友、同事、家人等）",
      "avatar": {
        "icon": "fas fa-heart",
        "color": "#FF6B6B"
      },
      "lastMessage": "最新消息内容",
      "time": "时间",
      "chatHistory": [
        {
          "type": "date",
          "content": "今天"
        },
        {
          "type": "received",
          "content": "消息内容",
          "time": "10:30"
        },
        {
          "type": "sent",
          "content": "回复内容",
          "time": "10:32"
        }
      ]
    }
  ]
}

注意：请确保返回的是有效的JSON格式，不要包含其他文字说明。`;

                const response = await callPhoneAPI(prompt);
                const data = cleanAndFixJSON(response);

                if (data.contacts && Array.isArray(data.contacts)) {
                    // 🔥【优化】存储联系人数据和完整聊天记录
                    window.phoneContactsData = data.contacts;

                    // 🔥【新增】存储每个联系人的聊天记录
                    window.phoneContactsChats = {};
                    data.contacts.forEach(contact => {
                        if (contact.chatHistory) {
                            window.phoneContactsChats[contact.name] = contact.chatHistory;
                        }
                    });

                    // 生成HTML
                    const messagesHTML = data.contacts.map(contact => `
                        <div class="phone-message-item" onclick="openPhoneMessage('${contact.name}')">
                            <div class="phone-message-avatar" style="background: ${contact.avatar.color};">
                                <i class="${contact.avatar.icon}"></i>
                            </div>
                            <div class="phone-message-info">
                                <div class="phone-message-header">
                                    <div class="phone-message-name">${contact.name}</div>
                                    <div class="phone-message-time">${contact.time}</div>
                                </div>
                                <div class="phone-message-preview">${contact.lastMessage}</div>
                            </div>
                        </div>
                    `).join('');

                    messagesContainer.innerHTML = messagesHTML;
                    window.phoneMessagesGenerated = true;
                    window.phoneMessagesCharacterId = currentChatCharacter.id;
                    showToast('✅ 人际圈对话成功打开', 'success');
                } else {
                    throw new Error('API返回格式错误');
                }
            } catch (error) {
                console.error('生成手机消息失败:', error);
                showToast('生成失败，使用默认数据', 'warning');
                // 回退到默认数据
                generatePhoneMessages();
            }
        }

        // 生成消息数据
        function generatePhoneMessages() {
            const messagesContainer = document.querySelector('.phone-messages-list');
            if (!messagesContainer) return;

            const sampleMessages = [
                { name: '小红', preview: '今天天气真好呢~', time: '10:30' },
                { name: '小明', preview: '周末一起出去玩吧', time: '昨天' },
                { name: '妈妈', preview: '记得按时吃饭哦', time: '昨天' },
                { name: '同事小李', preview: '明天的会议记得准备资料', time: '2天前' },
                { name: '室友', preview: '晚上一起看电影吗？', time: '3天前' }
            ];

            const messageAvatars = {
                '小红': { icon: 'fas fa-heart', color: '#FF6B6B' },
                '小明': { icon: 'fas fa-gamepad', color: '#4ECDC4' },
                '妈妈': { icon: 'fas fa-home', color: '#45B7D1' },
                '同事小李': { icon: 'fas fa-briefcase', color: '#96CEB4' },
                '室友': { icon: 'fas fa-coffee', color: '#FECA57' }
            };

            messagesContainer.innerHTML = sampleMessages.map(msg => {
                const avatar = messageAvatars[msg.name] || { icon: 'fas fa-user', color: '#007AFF' };
                return `
                    <div class="phone-message-item" onclick="openPhoneMessage('${msg.name}')">
                        <div class="phone-message-avatar" style="background: ${avatar.color};">
                            <i class="${avatar.icon}"></i>
                        </div>
                        <div class="phone-message-info">
                            <div class="phone-message-header">
                                <div class="phone-message-name">${msg.name}</div>
                                <div class="phone-message-time">${msg.time}</div>
                            </div>
                            <div class="phone-message-preview">${msg.preview}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // 🔥【新增】通过API生成角色备忘录
        async function generatePhoneNotesAPI() {
            const notesContainer = document.querySelector('.phone-notes-list');
            if (!notesContainer) return;

            // 🔥【修复】检查是否为当前角色生成过，如果不是则重新生成
            if (window.phoneNotesGenerated && window.phoneNotesCharacterId === currentChatCharacter.id) {
                return;
            }

            try {
                // 显示加载状态
                notesContainer.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #666;">
                        <i class="fas fa-spinner fa-spin" style="font-size: 24px; margin-bottom: 10px;"></i>
                        <p>正在生成${currentChatCharacter.name}的备忘录...</p>
                    </div>
                `;

                // 🔥【新增】使用完整的上下文信息
                const contextInfo = await buildPhoneContextInfo();

                const prompt = `请为角色"${currentChatCharacter.name}"生成手机中的备忘录列表。

${contextInfo}

⚠️ 重要提醒：
- 必须严格按照角色的年龄、身份、生活状态来生成备忘录类型
- 如果角色是学生，备忘录应该是学习相关、生活相关，不要有工作计划
- 如果角色是上班族，可以有工作相关备忘录
- 备忘录内容要真实反映角色的日常生活

要求：
1. 生成5-7个不同类型的备忘录，类型必须符合角色身份（学生：学习笔记、作业提醒、考试安排等；上班族：工作计划、会议安排等）
2. 每个备忘录要有合适的emoji图标
3. 内容要严格符合角色的身份、年龄和生活背景
4. 预览文字控制在30字以内
5. 时间要合理分布
6. 参考角色的人设、世界书设定、记忆和最近聊天记录来生成符合角色特点的备忘录
7. 绝对不要生成与角色设定冲突的内容

请按以下JSON格式返回：
{
  "notes": [
    {
      "title": "📚 备忘录标题",
      "preview": "备忘录预览内容...",
      "time": "时间",
      "content": "完整的备忘录内容，可以很详细"
    }
  ]
}

注意：请确保返回的是有效的JSON格式，不要包含其他文字说明。`;

                const response = await callPhoneAPI(prompt);
                const data = cleanAndFixJSON(response);

                if (data.notes && Array.isArray(data.notes)) {
                    // 存储备忘录数据供后续使用
                    window.phoneNotesData = data.notes;

                    // 生成HTML
                    const notesHTML = data.notes.map(note => `
                        <div class="phone-note-item" onclick="openPhoneNoteAPI('${note.title}')">
                            <div class="phone-note-title">${note.title}</div>
                            <div class="phone-note-preview">${note.preview}</div>
                            <div class="phone-note-time">${note.time}</div>
                        </div>
                    `).join('');

                    notesContainer.innerHTML = notesHTML;
                    window.phoneNotesGenerated = true;
                    window.phoneNotesCharacterId = currentChatCharacter.id;
                    showToast('✅ 备忘录生成完成', 'success');
                } else {
                    throw new Error('API返回格式错误');
                }
            } catch (error) {
                console.error('生成备忘录失败:', error);
                showToast('生成失败，使用默认数据', 'warning');
                // 回退到默认数据
                generatePhoneNotes();
            }
        }

        // 生成备忘录数据（保留作为备用）
        function generatePhoneNotes() {
            const notesContainer = document.querySelector('.phone-notes-list');
            if (!notesContainer) return;

            const sampleNotes = [
                { title: '🛒 购物清单', preview: '牛奶、面包、鸡蛋、水果、洗发水...', time: '今天 14:20' },
                { title: '💼 工作计划', preview: '完成项目报告，准备下周的会议，整理客户资料...', time: '昨天 16:45' },
                { title: '📚 读书笔记', preview: '今天读了一本很有趣的书，关于时间管理的...', time: '2天前' },
                { title: '✈️ 旅行计划', preview: '下个月的旅行安排：订机票、酒店、景点攻略...', time: '1周前' },
                { title: '🏃‍♀️ 健身记录', preview: '今天跑步5公里，做了30分钟力量训练...', time: '1周前' }
            ];

            notesContainer.innerHTML = sampleNotes.map(note => `
                <div class="phone-note-item" onclick="openPhoneNote('${note.title}')">
                    <div class="phone-note-title">${note.title}</div>
                    <div class="phone-note-preview">${note.preview}</div>
                    <div class="phone-note-time">${note.time}</div>
                </div>
            `).join('');
        }

        // 🔥【新增】通过API生成角色相册
        async function generatePhonePhotosAPI() {
            const photosContainer = document.querySelector('.phone-photos-grid');
            if (!photosContainer) return;

            // 🔥【修复】检查是否为当前角色生成过，如果不是则重新生成
            if (window.phonePhotosGenerated && window.phonePhotosCharacterId === currentChatCharacter.id) {
                return;
            }

            try {
                // 显示加载状态
                photosContainer.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: #666;">
                        <i class="fas fa-spinner fa-spin" style="font-size: 24px; margin-bottom: 10px;"></i>
                        <p>正在生成${currentChatCharacter.name}的相册...</p>
                    </div>
                `;

                // 🔥【新增】使用完整的上下文信息
                const contextInfo = await buildPhoneContextInfo();

                const prompt = `请为角色"${currentChatCharacter.name}"生成手机相册中的照片/视频描述。

${contextInfo}

⚠️ 重要提醒：
- 必须严格按照角色的年龄、身份、生活环境来生成照片/视频类型
- 如果角色是学生，照片应该是校园生活、学习、朋友聚会等，不要有工作场景
- 如果角色是上班族，可以有工作相关照片
- 照片场景要符合角色的实际生活状态和经济条件

要求：
1. 生成9张照片/视频的描述（可以包含视频）
2. 内容要严格符合角色的生活背景、兴趣爱好和真实社交圈
3. 每个照片/视频要有标题、拍摄时间和详细描述
4. 类型要符合角色身份（学生：校园照、学习照、朋友合照、生活照等；上班族：可包含工作照）
5. 描述要生动有趣，体现角色的个性，但必须真实可信
6. 参考角色的人设、世界书设定、记忆和最近聊天记录来生成符合角色世界观的照片/视频
7. 绝对不要生成与角色设定冲突的内容

请按以下JSON格式返回：
{
  "media": [
    {
      "title": "照片/视频标题",
      "type": "photo", // 或 "video"
      "time": "拍摄时间",
      "duration": "0:15", // 仅视频需要，格式如 "0:15" 表示15秒
      "description": "详细描述这张照片/视频的内容、背景故事、当时的心情等"
    }
  ]
}

注意：请确保返回的是有效的JSON格式，不要包含其他文字说明。`;

                const response = await callPhoneAPI(prompt);
                const data = cleanAndFixJSON(response);

                if (data.media && Array.isArray(data.media)) {
                    // 存储相册数据供后续使用
                    window.phonePhotosData = data.media;

                    // 生成HTML
                    const photosHTML = data.media.map((item, index) => `
                        <div class="phone-photo-item" data-photo-index="${index}" onclick="openPhonePhotoByIndex(${index})">
                            <div class="phone-photo-placeholder">
                                <i class="fas fa-${item.type === 'video' ? 'play-circle' : 'image'}"></i>
                            </div>
                        </div>
                    `).join('');

                    photosContainer.innerHTML = photosHTML;
                    window.phonePhotosGenerated = true;
                    window.phonePhotosCharacterId = currentChatCharacter.id;
                    showToast('✅ 相册生成完成', 'success');
                } else {
                    throw new Error('API返回格式错误');
                }
            } catch (error) {
                console.error('生成相册失败:', error);
                showToast('生成失败，使用默认数据', 'warning');
                // 回退到默认数据
                generatePhonePhotos();
            }
        }

        // 生成相册数据（保留作为备用）
        function generatePhonePhotos() {
            const photosContainer = document.querySelector('.phone-photos-grid');
            if (!photosContainer) return;

            // 创建6个有意义的照片
            const photoTitles = ['春日樱花', '咖啡时光', '夕阳西下', '城市夜景', '美食记录', '旅行回忆'];
            const photoItems = photoTitles.map(title => `
                <div class="phone-photo-item" onclick="openPhonePhoto('${title}')">
                    <div class="phone-photo-placeholder">
                        <i class="fas fa-image"></i>
                    </div>
                </div>
            `).join('');

            photosContainer.innerHTML = photoItems;
        }

        // 🔥【新增】构建角色手机上下文信息
        async function buildPhoneContextInfo() {
            let contextInfo = '';

            // 1. 角色基本信息
            const characterInfo = `角色信息：
姓名：${currentChatCharacter.name}
人设：${currentChatCharacter.description || currentChatCharacter.bio || currentChatCharacter.prompt || '暂无描述'}`;
            contextInfo += characterInfo + '\n\n';

            // 2. 世界书信息
            try {
                const chatSettings = getCurrentChatSettings();
                const localBookIds = chatSettings.selectedWorldbooks || [];
                const globalBooks = window.activeGlobalWorldbooks || [];
                const allBookIds = [...new Set([...globalBooks, ...localBookIds])];

                if (allBookIds.length > 0) {
                    contextInfo += '世界书设定：\n';
                    allBookIds.forEach((bookId, index) => {
                        const worldbook = worldbooks.find(w => w.id === bookId);
                        if (worldbook) {
                            contextInfo += `${index + 1}. ${worldbook.name || worldbook.title}：${worldbook.content}\n`;
                        }
                    });
                    contextInfo += '\n';
                }
            } catch (error) {
                console.error('获取世界书信息失败:', error);
            }

            // 3. 全局记忆信息
            try {
                const memorySettings = getGlobalMemorySettings();
                if (memorySettings.enabled !== false) {
                    const currentContext = {
                        type: currentChatCharacter.isGroup ? 'group_chat' : 'private_chat',
                        id: currentChatCharacter.id
                    };
                    const memoryContent = await buildGlobalMemoryContext(currentChatCharacter.id, currentContext, memorySettings.memoryDays || 7);
                    if (memoryContent && memoryContent.trim()) {
                        contextInfo += '角色记忆：\n' + memoryContent + '\n\n';
                    }
                }
            } catch (error) {
                console.error('获取全局记忆失败:', error);
            }

            // 4. 最近聊天记录（最近20轮）
            try {
                const characterId = currentChatCharacter.id;
                if (chatMessages[characterId] && chatMessages[characterId].length > 0) {
                    const recentMessages = chatMessages[characterId].slice(-40); // 取最近40条消息（约20轮对话）
                    if (recentMessages.length > 0) {
                        // 🔥【修复】获取真实的用户名
                        const realUserName = getCurrentPersonaName();
                        contextInfo += '最近聊天记录：\n';
                        recentMessages.forEach(msg => {
                            const sender = msg.sender === 'sent' ? realUserName : currentChatCharacter.name;
                            contextInfo += `${sender}：${msg.content}\n`;
                        });
                        contextInfo += '\n';
                    }
                }
            } catch (error) {
                console.error('获取聊天记录失败:', error);
            }

            return contextInfo;
        }

        // 🔥【新增】调试角色头像获取情况
        function debugCharacterAvatar() {
            if (!currentChatCharacter) {
                console.log('❌ 没有当前角色');
                return;
            }

            const chatSettings = getCurrentChatSettings();
            console.log('🔍 角色头像调试信息:');
            console.log('  - 角色名称:', currentChatCharacter.name);
            console.log('  - 角色ID:', currentChatCharacter.id);
            console.log('  - 聊天专用头像:', chatSettings.aiChatAvatar || '(未设置)');
            console.log('  - 角色卡头像:', currentChatCharacter.avatarUrl || '(未设置)');

            const finalAvatar = chatSettings.aiChatAvatar || currentChatCharacter.avatarUrl || '';
            console.log('  - 最终使用头像:', finalAvatar || '(空白 - 将显示默认图标)');

            if (!finalAvatar) {
                console.warn('⚠️ 角色头像为空！请检查：');
                console.warn('   1. 是否在聊天设置中设置了AI头像');
                console.warn('   2. 角色卡是否有头像URL');
            }
        }

        // 🔥【新增】调试角色备注设置情况
        function debugCharacterNickname() {
            if (!currentChatCharacter) {
                console.log('❌ 没有当前角色');
                return;
            }

            const chatSettings = getCurrentChatSettings();
            console.log('🔍 角色备注调试信息:');
            console.log('  - 角色名称:', currentChatCharacter.name);
            console.log('  - 角色ID:', currentChatCharacter.id);
            console.log('  - 设置的AI昵称:', chatSettings.aiChatNickname || '(未设置)');
            console.log('  - 设置的我的昵称:', chatSettings.myChatNickname || '(未设置)');
            console.log('  - 最终显示名称:', chatSettings.aiChatNickname || currentChatCharacter.name);

            // 检查全局设置缓存
            console.log('🔍 全局设置缓存状态:');
            if (window.chatSettings && window.chatSettings[currentChatCharacter.id]) {
                const cachedSettings = window.chatSettings[currentChatCharacter.id];
                console.log('  - 缓存中的AI昵称:', cachedSettings.aiChatNickname || '(未设置)');
                console.log('  - 缓存中的我的昵称:', cachedSettings.myChatNickname || '(未设置)');
            } else {
                console.log('  - 缓存状态: 未找到该角色的设置缓存');
            }
        }

        // 🔥【新增】角色手机专用JSON响应清理和修复函数
        function cleanAndFixJSON(response) {
            console.log('API原始响应:', response);

            if (!response || response.trim() === '') {
                throw new Error('API返回空响应');
            }

            // 清理API响应，移除可能的markdown代码块标记
            let cleanResponse = response.trim();
            if (cleanResponse.startsWith('```json')) {
                cleanResponse = cleanResponse.replace(/^```json\s*/, '').replace(/\s*```$/, '');
            } else if (cleanResponse.startsWith('```')) {
                cleanResponse = cleanResponse.replace(/^```\s*/, '').replace(/\s*```$/, '');
            }

            console.log('清理后的响应:', cleanResponse);

            if (!cleanResponse || cleanResponse.trim() === '') {
                throw new Error('清理后响应为空');
            }

            // 🔥【增强】尝试修复不完整的JSON
            let jsonToparse = cleanResponse;

            // 检查JSON是否完整
            try {
                return JSON.parse(jsonToparse);
            } catch (parseError) {
                console.warn('JSON解析失败，尝试修复:', parseError.message);

                // 尝试修复常见的JSON截断问题
                if (!jsonToparse.trim().endsWith('}')) {
                    // 如果JSON没有正确结束，尝试补全
                    let openBraces = (jsonToparse.match(/{/g) || []).length;
                    let closeBraces = (jsonToparse.match(/}/g) || []).length;
                    let openBrackets = (jsonToparse.match(/\[/g) || []).length;
                    let closeBrackets = (jsonToparse.match(/]/g) || []).length;

                    // 补全缺失的闭合符号
                    for (let i = 0; i < openBrackets - closeBrackets; i++) {
                        jsonToparse += ']';
                    }
                    for (let i = 0; i < openBraces - closeBraces; i++) {
                        jsonToparse += '}';
                    }

                    console.log('尝试修复后的JSON:', jsonToparse);

                    // 再次尝试解析
                    try {
                        return JSON.parse(jsonToparse);
                    } catch (secondError) {
                        console.error('修复后仍然无法解析JSON:', secondError.message);
                        throw new Error(`JSON解析失败: ${parseError.message}`);
                    }
                } else {
                    throw new Error(`JSON解析失败: ${parseError.message}`);
                }
            }
        }

        // 🔥【新增】角色手机API调用核心函数
        async function callPhoneAPI(prompt) {
            // 🔥【修复】直接使用全局变量 apiSettings
            if (!apiSettings.base || !apiSettings.key) {
                throw new Error('请先配置API设置');
            }

            const isGemini = apiSettings.base.includes('generativelanguage.googleapis.com');
            let response;

            if (isGemini) {
                // Gemini API 格式
                const apiUrl = `${apiSettings.base}/models/${apiSettings.model}:generateContent?key=${apiSettings.key}`;

                response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{ text: prompt }]
                        }],
                        generationConfig: {
                            temperature: 0.8,
                            maxOutputTokens: 8192
                        }
                    })
                });

                if (!response.ok) {
                    throw new Error(`API请求失败: ${response.status}`);
                }

                const data = await response.json();
                return data.candidates[0].content.parts[0].text;
            } else {
                // OpenAI 兼容格式
                let apiUrl;
                if (apiSettings.base.endsWith('/chat/completions')) {
                    apiUrl = apiSettings.base;
                } else if (apiSettings.base.endsWith('/v1')) {
                    apiUrl = `${apiSettings.base}/chat/completions`;
                } else {
                    apiUrl = `${apiSettings.base}/v1/chat/completions`;
                }

                response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiSettings.key}`
                    },
                    body: JSON.stringify({
                        model: apiSettings.model,
                        messages: [
                            { role: 'user', content: prompt }
                        ],
                        temperature: 0.8,
                        max_tokens: 8192
                    })
                });

                if (!response.ok) {
                    throw new Error(`API请求失败: ${response.status}`);
                }

                const data = await response.json();
                return data.choices[0].message.content;
            }
        }

        // 切换手机标签页
        async function switchPhoneTab(tabName) {
            // 更新标签页状态
            document.querySelectorAll('.phone-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`.phone-tab[onclick*="${tabName}"]`).classList.add('active');

            // 切换内容区域
            document.querySelectorAll('.phone-tab-content').forEach(content => {
                content.style.display = 'none';
            });
            document.getElementById(`phone-${tabName}-content`).style.display = 'block';

            // 根据标签页类型生成内容
            if (tabName === 'notes') {
                // 🔥【增强】检查API配置，没有配置则使用模拟数据
                if (!apiSettings.base || !apiSettings.key) {
                    console.log('API未配置，备忘录使用模拟数据');
                    generatePhoneNotes();
                } else {
                    try {
                        await generatePhoneNotesAPI();
                    } catch (error) {
                        console.error('备忘录API生成失败，使用模拟数据:', error);
                        generatePhoneNotes();
                    }
                }
            } else if (tabName === 'photos') {
                // 🔥【增强】检查API配置，没有配置则使用模拟数据
                if (!apiSettings.base || !apiSettings.key) {
                    console.log('API未配置，相册使用模拟数据');
                    generatePhonePhotos();
                } else {
                    try {
                        await generatePhonePhotosAPI();
                    } catch (error) {
                        console.error('相册API生成失败，使用模拟数据:', error);
                        generatePhonePhotos();
                    }
                }
            }
        }

        // 🔥【优化】通过API生成对话详情 - 优先使用已加载的数据
        async function generatePhoneChatMessagesAPI(contactName) {
            const messagesContainer = document.getElementById('phone-chat-messages');
            if (!messagesContainer) return;

            // 🔥【优化】优先检查是否已有聊天记录
            if (window.phoneContactsChats && window.phoneContactsChats[contactName]) {
                console.log('✅ 使用已加载的聊天记录:', contactName);
                const chatHistory = window.phoneContactsChats[contactName];
                const contact = window.phoneContactsData?.find(c => c.name === contactName);

                // 直接渲染已有的聊天记录
                const messagesHTML = chatHistory.map(msg => {
                    if (msg.type === 'date') {
                        return `
                            <div class="phone-date-separator">
                                <span>${msg.content}</span>
                            </div>
                        `;
                    } else if (msg.type === 'received') {
                        return `
                            <div class="phone-message-bubble">
                                <div class="phone-message-row">
                                    <div class="phone-message-avatar-small" style="background: ${contact?.avatar?.color || '#007AFF'};">
                                        <i class="${contact?.avatar?.icon || 'fas fa-user'}"></i>
                                    </div>
                                    <div class="phone-message-content">
                                        <div class="phone-message-text">${msg.content}</div>
                                    </div>
                                </div>
                                <div class="phone-message-time">${msg.time}</div>
                            </div>
                        `;
                    } else {
                        // 🔥【修复】发送消息使用角色的真实头像
                        let characterAvatarUrl = '';
                        if (currentChatCharacter) {
                            const chatSettings = getCurrentChatSettings();
                            // 优先级：聊天专用头像 > 角色卡头像 > 默认图标
                            characterAvatarUrl = chatSettings.aiChatAvatar || currentChatCharacter.avatarUrl || '';
                        }

                        const avatarHtml = characterAvatarUrl ?
                            `<img src="${characterAvatarUrl}" alt="${currentChatCharacter?.name || '我'}" style="width: 100%; height: 100%; border-radius: 50%; object-fit: cover;">` :
                            '<i class="fas fa-user"></i>';

                        return `
                            <div class="phone-message-bubble sent">
                                <div class="phone-message-row">
                                    <div class="phone-message-avatar-small" style="background: var(--color-text-lighter);">
                                        ${avatarHtml}
                                    </div>
                                    <div class="phone-message-content">
                                        <div class="phone-message-text">${msg.content}</div>
                                    </div>
                                </div>
                                <div class="phone-message-time">${msg.time}</div>
                            </div>
                        `;
                    }
                }).join('');

                messagesContainer.innerHTML = messagesHTML;

                // 滚动到底部
                setTimeout(() => {
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                }, 100);

                return; // 直接返回，不需要API调用
            }

            // 🔥【备用】如果没有预加载的数据，才进行API调用
            try {
                // 显示加载状态
                messagesContainer.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #666;">
                        <i class="fas fa-spinner fa-spin" style="font-size: 24px; margin-bottom: 10px;"></i>
                        <p>正在生成与${contactName}的对话...</p>
                    </div>
                `;

                // 获取联系人信息
                const contact = window.phoneContactsData?.find(c => c.name === contactName);
                const relationship = contact?.relationship || '朋友';

                // 🔥【新增】使用完整的上下文信息
                const contextInfo = await buildPhoneContextInfo();

                const prompt = `请为角色"${currentChatCharacter.name}"生成与"${contactName}"（${relationship}）的手机聊天记录。

${contextInfo}

⚠️ 重要提醒：
- 必须严格按照角色的年龄、身份、生活状态来生成对话内容
- 对话内容要符合两人的真实关系和角色设定
- 如果角色是学生，对话应该围绕学习、校园生活、朋友聚会等
- 绝对不要生成与角色设定冲突的对话内容

要求：
1. 生成5-10轮完整的对话
2. 对话要自然、有趣，严格体现两人的真实关系
3. 包含发送和接收的消息
4. 消息内容要严格符合角色身份和关系类型
5. 可以包含emoji表情
6. 时间要合理递增
7. 参考角色的人设、世界书设定、记忆和最近聊天记录来生成符合角色世界观的对话内容
8. 绝对不要生成与角色设定冲突的内容

请按以下JSON格式返回：
{
  "messages": [
    {
      "type": "date",
      "content": "今天"
    },
    {
      "type": "received", // 或 "sent"
      "content": "消息内容",
      "time": "时间"
    }
  ]
}

注意：请确保返回的是有效的JSON格式，不要包含其他文字说明。`;

                const response = await callPhoneAPI(prompt);
                const data = cleanAndFixJSON(response);

                if (data.messages && Array.isArray(data.messages)) {
                    // 生成消息HTML
                    const messagesHTML = data.messages.map(msg => {
                        if (msg.type === 'date') {
                            return `
                                <div class="phone-date-separator">
                                    <span>${msg.content}</span>
                                </div>
                            `;
                        } else if (msg.type === 'received') {
                            return `
                                <div class="phone-message-bubble">
                                    <div class="phone-message-row">
                                        <div class="phone-message-avatar-small" style="background: ${contact?.avatar?.color || '#007AFF'};">
                                            <i class="${contact?.avatar?.icon || 'fas fa-user'}"></i>
                                        </div>
                                        <div class="phone-message-content">
                                            <div class="phone-message-text">${msg.content}</div>
                                        </div>
                                    </div>
                                    <div class="phone-message-time">${msg.time}</div>
                                </div>
                            `;
                        } else {
                            // 🔥【修复】发送消息使用角色的真实头像
                            let characterAvatarUrl = '';
                            if (currentChatCharacter) {
                                const chatSettings = getCurrentChatSettings();
                                // 优先级：聊天专用头像 > 角色卡头像 > 默认图标
                                characterAvatarUrl = chatSettings.aiChatAvatar || currentChatCharacter.avatarUrl || '';
                            }

                            const avatarHtml = characterAvatarUrl ?
                                `<img src="${characterAvatarUrl}" alt="${currentChatCharacter?.name || '我'}" style="width: 100%; height: 100%; border-radius: 50%; object-fit: cover;">` :
                                '<i class="fas fa-user"></i>';

                            return `
                                <div class="phone-message-bubble sent">
                                    <div class="phone-message-row">
                                        <div class="phone-message-avatar-small" style="background: var(--color-text-lighter);">
                                            ${avatarHtml}
                                        </div>
                                        <div class="phone-message-content">
                                            <div class="phone-message-text">${msg.content}</div>
                                        </div>
                                    </div>
                                    <div class="phone-message-time">${msg.time}</div>
                                </div>
                            `;
                        }
                    }).join('');

                    messagesContainer.innerHTML = messagesHTML;

                    // 滚动到底部
                    setTimeout(() => {
                        messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    }, 100);
                } else {
                    throw new Error('API返回格式错误');
                }
            } catch (error) {
                console.error('生成对话失败:', error);
                showToast('生成失败，使用默认对话', 'warning');
                // 回退到默认对话
                await generatePhoneChatMessages(contactName);
            }
        }

        // 打开手机消息详情
        async function openPhoneMessage(contactName) {
            // 更新对话标题
            const titleElement = document.getElementById('phone-chat-contact-name');
            if (titleElement) {
                titleElement.textContent = contactName;
            }

            // 显示对话界面
            hideApp('character-phone-screen');
            showApp('character-phone-chat-screen');

            // 生成对话内容
            await generatePhoneChatMessagesAPI(contactName);
        }

        // 生成手机对话消息
        async function generatePhoneChatMessages(contactName) {
            const messagesContainer = document.getElementById('phone-chat-messages');
            if (!messagesContainer) return;

            // 获取当前角色的头像（优先聊天专用头像，其次角色卡头像）
            let characterAvatarUrl = '';
            if (currentChatCharacter) {
                const chatSettings = getCurrentChatSettings();
                characterAvatarUrl = chatSettings.aiChatAvatar || currentChatCharacter.avatarUrl || '';
            }

            // 根据联系人生成不同的对话内容
            const conversations = {
                '小红': [
                    { type: 'date', content: '今天' },
                    { type: 'received', content: '早上好！今天天气真好呢~', time: '09:15' },
                    { type: 'sent', content: '是啊，阳光很温暖', time: '09:16' },
                    { type: 'received', content: '要不要一起去公园走走？', time: '09:17' },
                    { type: 'sent', content: '好主意！几点出发？', time: '09:18' },
                    { type: 'received', content: '下午2点怎么样？我们可以在公园里野餐', time: '09:20' },
                    { type: 'sent', content: '完美！我带点小食和饮料', time: '09:22' },
                    { type: 'received', content: '太好了！那我准备野餐垫和一些水果 🍎🍊', time: '10:30' }
                ],
                '小明': [
                    { type: 'date', content: '昨天' },
                    { type: 'received', content: '嘿！周末有什么计划吗？', time: '14:30' },
                    { type: 'sent', content: '还没想好，你有什么建议？', time: '14:32' },
                    { type: 'received', content: '听说新开了一家游戏厅，我们去试试？', time: '14:35' },
                    { type: 'sent', content: '听起来不错！在哪里？', time: '14:36' },
                    { type: 'received', content: '就在市中心的购物中心三楼', time: '14:38' },
                    { type: 'received', content: '他们有最新的VR游戏和街机', time: '14:39' },
                    { type: 'sent', content: '太棒了！周六下午去怎么样？', time: '14:41' },
                    { type: 'received', content: '完美！我们2点在门口见面', time: '14:43' }
                ],
                '妈妈': [
                    { type: 'date', content: '昨天' },
                    { type: 'received', content: '宝贝，记得按时吃饭哦', time: '12:00' },
                    { type: 'sent', content: '知道了妈妈，我会注意的', time: '12:05' },
                    { type: 'received', content: '冰箱里有我昨天做的汤，记得热一下喝', time: '12:06' },
                    { type: 'sent', content: '好的，谢谢妈妈！', time: '12:07' },
                    { type: 'received', content: '还有，晚上早点休息，不要熬夜', time: '18:30' },
                    { type: 'sent', content: '我会的，您也要注意身体', time: '18:32' },
                    { type: 'received', content: '这周末回家吃饭吗？', time: '19:00' },
                    { type: 'sent', content: '好的，我周日回去', time: '19:02' }
                ],
                '同事小李': [
                    { type: 'date', content: '2天前' },
                    { type: 'received', content: '明天的会议记得准备资料', time: '16:45' },
                    { type: 'sent', content: '好的，我已经在整理了', time: '16:47' },
                    { type: 'received', content: '老板说这次会议很重要，可能会讨论新项目', time: '16:48' },
                    { type: 'sent', content: '了解，我会认真准备的', time: '16:50' },
                    { type: 'received', content: '需要我帮你准备什么吗？', time: '16:52' },
                    { type: 'sent', content: '谢谢！如果有需要我会联系你', time: '16:54' },
                    { type: 'received', content: '好的，加油！💪', time: '16:55' }
                ],
                '室友': [
                    { type: 'date', content: '3天前' },
                    { type: 'received', content: '晚上一起看电影吗？', time: '19:30' },
                    { type: 'sent', content: '好啊！看什么电影？', time: '19:32' },
                    { type: 'received', content: '我买了爆米花，还有新上映的科幻片', time: '19:33' },
                    { type: 'sent', content: '听起来很棒！几点开始？', time: '19:35' },
                    { type: 'received', content: '8点怎么样？我准备一些饮料', time: '19:36' },
                    { type: 'sent', content: '完美！我带点零食', time: '19:38' },
                    { type: 'received', content: '太好了！电影之夜开始！🍿🎬', time: '19:40' }
                ]
            };

            const conversation = conversations[contactName] || [
                { type: 'date', content: '今天' },
                { type: 'received', content: '你好！', time: '10:00' },
                { type: 'sent', content: '你好！', time: '10:01' }
            ];

            // 获取联系人头像配置（与消息列表保持一致）
            const contactAvatars = {
                '小红': { icon: 'fas fa-heart', color: '#FF6B6B' },
                '小明': { icon: 'fas fa-gamepad', color: '#4ECDC4' },
                '妈妈': { icon: 'fas fa-home', color: '#45B7D1' },
                '同事小李': { icon: 'fas fa-briefcase', color: '#96CEB4' },
                '室友': { icon: 'fas fa-coffee', color: '#FECA57' }
            };

            const contactAvatar = contactAvatars[contactName] || { icon: 'fas fa-user', color: '#007AFF' };

            // 生成消息HTML
            const messagesHTML = conversation.map(msg => {
                if (msg.type === 'date') {
                    return `
                        <div class="phone-date-separator">
                            <span>${msg.content}</span>
                        </div>
                    `;
                } else if (msg.type === 'received') {
                    return `
                        <div class="phone-message-bubble">
                            <div class="phone-message-row">
                                <div class="phone-message-avatar-small" style="background: ${contactAvatar.color};">
                                    <i class="${contactAvatar.icon}"></i>
                                </div>
                                <div class="phone-message-content">
                                    <div class="phone-message-text">${msg.content}</div>
                                </div>
                            </div>
                            <div class="phone-message-time">${msg.time}</div>
                        </div>
                    `;
                } else {
                    // 发送消息使用角色的真实头像
                    const avatarHtml = characterAvatarUrl ?
                        `<img src="${characterAvatarUrl}" alt="我" style="width: 100%; height: 100%; border-radius: 50%; object-fit: cover;">` :
                        '<i class="fas fa-user"></i>';

                    return `
                        <div class="phone-message-bubble sent">
                            <div class="phone-message-row">
                                <div class="phone-message-avatar-small" style="background: var(--color-text-lighter);">
                                    ${avatarHtml}
                                </div>
                                <div class="phone-message-content">
                                    <div class="phone-message-text">${msg.content}</div>
                                </div>
                            </div>
                            <div class="phone-message-time">${msg.time}</div>
                        </div>
                    `;
                }
            }).join('');

            messagesContainer.innerHTML = messagesHTML;

            // 滚动到底部
            setTimeout(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }, 100);
        }

        // 打开手机备忘录详情
        function openPhoneNote(noteTitle) {
            // 备忘录数据
            const notes = {
                '🛒 购物清单': {
                    title: '🛒 购物清单',
                    time: '今天 14:20',
                    content: `牛奶 - 2盒
面包 - 1袋全麦面包
鸡蛋 - 1打
苹果 - 5个红富士
香蕉 - 1串
酸奶 - 4杯
胡萝卜 - 500g
西红柿 - 3个
洗发水 - 1瓶
牙膏 - 1支

记得去超市的时候带购物袋，环保又实用！`
                },
                '💼 工作计划': {
                    title: '💼 工作计划',
                    time: '昨天 16:45',
                    content: `本周工作安排：

1. 完成项目报告
   - 整理数据分析结果
   - 撰写总结报告
   - 准备演示文稿

2. 准备下周会议
   - 收集团队反馈
   - 制定下阶段计划
   - 预约会议室

3. 客户沟通
   - 回复邮件
   - 安排产品演示
   - 跟进合作进展

4. 学习提升
   - 阅读行业报告
   - 参加在线培训
   - 整理学习笔记`
                },
                '📚 读书笔记': {
                    title: '📚 读书笔记',
                    time: '2天前',
                    content: `《人类简史》读书笔记

今天读了一本很有趣的书，作者从独特的角度讲述了人类发展的历史。

主要观点：
1. 认知革命 - 人类学会了虚构故事
2. 农业革命 - 改变了人类的生活方式
3. 科学革命 - 推动了现代文明的发展

印象深刻的句子：
"历史的铁则就是，事后看来无可避免的事，在当时看来总是毫不明显。"

思考：
人类的发展确实充满了偶然性，每一次重大变革都深刻影响了后续的历史进程。这让我对未来充满了好奇和期待。`
                },
                '✈️ 旅行计划': {
                    title: '✈️ 旅行计划',
                    time: '1周前',
                    content: `下个月的旅行安排：

目的地：京都、大阪
时间：4月15日-4月22日（7天6夜）

行程安排：
Day 1-3: 京都
- 清水寺、金阁寺、伏见稻荷大社
- 祗园、二年坂三年坂
- 岚山竹林、天龙寺

Day 4-6: 大阪
- 大阪城、心斋桥、道顿堀
- 环球影城
- 奈良一日游（喂小鹿）

Day 7: 返程

待办事项：
✓ 订机票
✓ 预定酒店
□ 办理签证
□ 兑换日元
□ 下载翻译app
□ 准备行李清单

期待这次旅行！🌸`
                },
                '🏃‍♀️ 健身记录': {
                    title: '🏃‍♀️ 健身记录',
                    time: '1周前',
                    content: `本周健身总结：

周一：跑步5公里 + 力量训练30分钟
- 配速：6分钟/公里
- 心率：平均150bpm
- 力量训练：胸部、肩部

周三：瑜伽60分钟
- 哈他瑜伽
- 专注呼吸和拉伸
- 感觉身心放松

周五：游泳45分钟
- 自由泳1000米
- 蛙泳500米
- 水中有氧运动

周六：徒步登山
- 距离：8公里
- 爬升：500米
- 风景很美，心情愉悦

下周目标：
- 增加跑步距离到6公里
- 尝试新的力量训练动作
- 保持每周4次运动频率

坚持就是胜利！💪`
                }
            };

            const note = notes[noteTitle] || {
                title: noteTitle,
                time: '未知时间',
                content: '暂无内容'
            };

            // 更新备忘录详情内容
            document.getElementById('phone-note-detail-title').textContent = note.title;
            document.getElementById('phone-note-detail-time').textContent = note.time;
            document.getElementById('phone-note-detail-body').textContent = note.content;

            // 显示备忘录详情界面
            hideApp('character-phone-screen');
            showApp('character-phone-note-screen');
        }

        // 🔥【新增】打开API生成的备忘录详情
        function openPhoneNoteAPI(noteTitle) {
            const note = window.phoneNotesData?.find(n => n.title === noteTitle);

            if (note) {
                // 更新备忘录详情内容
                document.getElementById('phone-note-detail-title').textContent = note.title;
                document.getElementById('phone-note-detail-time').textContent = note.time;
                document.getElementById('phone-note-detail-body').textContent = note.content;

                // 显示备忘录详情界面
                hideApp('character-phone-screen');
                showApp('character-phone-note-screen');
            } else {
                showToast('备忘录数据未找到', 'error');
            }
        }

        // 🔥【新增】通过索引打开API生成的相册详情
        function openPhonePhotoByIndex(photoIndex) {
            const photo = window.phonePhotosData?.[photoIndex];

            if (photo) {
                openPhonePhotoAPI(photo.title);
            }
        }

        // 🔥【新增】打开API生成的相册详情
        function openPhonePhotoAPI(photoTitle) {
            const photo = window.phonePhotosData?.find(p => p.title === photoTitle);

            if (photo) {
                // 🔥【修复】根据媒体类型设置顶部标题
                const headerTitle = document.querySelector('#character-phone-photo-screen .app-title');
                if (headerTitle) {
                    headerTitle.textContent = photo.type === 'video' ? '视频' : '照片';
                }

                // 更新照片详情内容
                document.getElementById('phone-photo-detail-title').textContent = photo.title;
                document.getElementById('phone-photo-detail-time').textContent = photo.time;
                document.getElementById('phone-photo-detail-description').textContent = photo.description;

                // 🔥【修复】根据媒体类型显示不同的预览界面
                const imageContainer = document.getElementById('phone-photo-detail-image');
                if (photo.type === 'video') {
                    // 视频类型显示视频播放界面
                    imageContainer.innerHTML = `
                        <div class="phone-video-placeholder-large">
                            <i class="fas fa-play-circle"></i>
                            <p>视频预览</p>
                            <p style="margin-top: 5px; font-size: 14px; color: var(--color-text-lighter);">
                                ${photo.duration || '0:10'}
                            </p>
                        </div>
                    `;
                } else {
                    // 照片类型显示照片界面
                    imageContainer.innerHTML = `
                        <div class="phone-photo-placeholder-large">
                            <i class="fas fa-image"></i>
                            <p>照片预览</p>
                        </div>
                    `;
                }

                // 显示照片详情界面
                hideApp('character-phone-screen');
                showApp('character-phone-photo-screen');
            } else {
                showToast('照片数据未找到', 'error');
            }
        }

        // 打开手机照片详情（保留作为备用）
        function openPhonePhoto(photoTitle) {
            // 照片数据
            const photos = {
                '春日樱花': {
                    title: '春日樱花',
                    time: '2024年3月15日 14:30',
                    description: '春天的樱花盛开，粉色的花瓣在微风中轻舞，仿佛在诉说着春天的故事。这是在公园里拍摄的，当时阳光正好，温度适宜，是个拍照的好日子。'
                },
                '咖啡时光': {
                    title: '咖啡时光',
                    time: '2024年3月12日 10:15',
                    description: '周末的悠闲时光，一杯香浓的咖啡，一本好书，还有窗外的阳光。这就是我最喜欢的生活方式，简单而美好。'
                },
                '夕阳西下': {
                    title: '夕阳西下',
                    time: '2024年3月10日 18:45',
                    description: '傍晚时分，夕阳西下，天空被染成了金黄色。站在天台上看着这美丽的景色，心情格外平静。这样的时刻总是让人感到生活的美好。'
                },
                '城市夜景': {
                    title: '城市夜景',
                    time: '2024年3月8日 20:30',
                    description: '夜晚的城市灯火通明，高楼大厦在夜色中闪闪发光。从高处俯瞰，整个城市就像一颗璀璨的明珠，充满了现代都市的魅力。'
                },
                '美食记录': {
                    title: '美食记录',
                    time: '2024年3月5日 12:00',
                    description: '今天尝试了一家新开的餐厅，这道菜的摆盘很精致，味道也很不错。和朋友一起享用美食的时光总是特别愉快，值得记录下来。'
                },
                '旅行回忆': {
                    title: '旅行回忆',
                    time: '2024年2月28日 16:20',
                    description: '上个月的旅行照片，那是一次难忘的旅程。虽然只是短短几天，但是看到了很多美丽的风景，认识了有趣的人，留下了珍贵的回忆。'
                }
            };

            const photo = photos[photoTitle] || {
                title: photoTitle,
                time: '未知时间',
                description: '暂无描述'
            };

            // 更新照片详情内容
            document.getElementById('phone-photo-detail-title').textContent = photo.title;
            document.getElementById('phone-photo-detail-time').textContent = photo.time;
            document.getElementById('phone-photo-detail-description').textContent = photo.description;

            // 显示照片详情界面
            hideApp('character-phone-screen');
            showApp('character-phone-photo-screen');
        }




        // 显示角色足迹
        async function showCharacterFootprints() {


            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'error');
                return;
            }

            // 检查是否为群聊
            if (currentChatCharacter.isGroup) {
                showToast('群聊不支持足迹功能', 'error');
                return;
            }

            currentFootprintsCharacter = currentChatCharacter;



            // 更新模态框标题和头像
            const nameElement = document.getElementById('footprints-character-name');
            const avatarElement = document.getElementById('footprints-character-avatar');

            if (nameElement) {
                nameElement.textContent = `${currentChatCharacter.name}的足迹`;
            }

            if (avatarElement) {
                // 🔥【修复】优先显示角色在动态中的头像，然后是角色卡头像
                const characterAvatar = await getCharacterDisplayAvatar(currentChatCharacter);
                if (characterAvatar) {
                    avatarElement.innerHTML = `<img src="${characterAvatar}" alt="${currentChatCharacter.name}">`;
                } else {
                    avatarElement.innerHTML = '<i class="fas fa-user"></i>';
                }
            }

            // 显示模态框
            showModal('character-footprints-modal');

            // 加载足迹数据
            loadCharacterFootprints();

            // 设置自动更新
            setupFootprintsAutoUpdate();

            // 🔥【新增】恢复用户的自动更新设置
            restoreFootprintsAutoUpdateSetting();
        }

        // 隐藏角色足迹
        function hideCharacterFootprints(event) {
            if (event && event.target !== event.currentTarget) {
                return;
            }

            hideModal('character-footprints-modal');

            // 清除自动更新定时器
            if (footprintsUpdateTimer) {
                clearInterval(footprintsUpdateTimer);
                footprintsUpdateTimer = null;
            }

            currentFootprintsCharacter = null;
        }

        // 🔥【重构】加载角色足迹数据 - 支持增量更新
        async function loadCharacterFootprints(forceRefresh = false) {
            if (!currentFootprintsCharacter) return;

            const timelineElement = document.getElementById('footprints-timeline');
            if (!timelineElement) return;

            const characterId = currentFootprintsCharacter.id;

            // 🔥【修复】检查今日缓存和增量更新逻辑
            if (!forceRefresh) {
                // 🔥【修复】检查DOM中的足迹是否属于当前角色
                const existingFootprints = timelineElement.querySelectorAll('.footprint-item');
                if (existingFootprints.length > 0) {
                    // 检查是否是同一个角色的足迹（通过检查缓存的角色ID）
                    const lastCharacterId = timelineElement.dataset.characterId;
                    if (lastCharacterId === characterId) {
                        console.log(`🎭 DOM中已有当前角色 ${characterId} 的 ${existingFootprints.length} 个足迹，跳过重新渲染`);
                        return; // 避免覆盖已经追加的新足迹
                    } else {
                        console.log(`🔄 DOM中是其他角色 ${lastCharacterId} 的足迹，清空并重新加载角色 ${characterId} 的足迹`);
                        timelineElement.innerHTML = ''; // 清空其他角色的足迹
                    }
                }

                const cachedData = await getFootprintsCache(characterId);
                if (cachedData) {
                    const cacheAge = Date.now() - cachedData.timestamp;
                    const lastUpdateAge = Date.now() - cachedData.lastUpdateTime;
                    const cacheHours = Math.floor(cacheAge / (60 * 60 * 1000));
                    const cacheMinutes = Math.floor((cacheAge % (60 * 60 * 1000)) / (60 * 1000));

                    console.log(`📦 从数据库加载足迹，共 ${cachedData.data.activities?.length || 0} 个活动`);
                    console.log('📦 缓存数据:', cachedData.data);

                    // 直接使用缓存
                    await renderFootprintsTimeline(cachedData.data, true);
                    return;
                } else {
                    // 🔥【简化】没有缓存时，直接生成从0:00到当前时间的足迹
                    console.log('📝 没有今日足迹缓存，生成从0:00到当前时间的足迹');
                    await generateTodayFootprints();
                    return;
                }
            }

            // 🔥【简化】手动刷新 - 像聊天一样在顶部追加
            if (forceRefresh) {
                console.log('手动刷新：尝试增量更新...');

                // 🔥【简化】在顶部插入加载状态，不清空原有内容
                timelineElement.insertAdjacentHTML('afterbegin', `
                    <div class="footprint-item footprints-loading-item">
                        <div class="footprint-time">--:--</div>
                        <div class="footprint-content">
                            <p class="footprint-activity">
                                <i class="fas fa-sync-alt fa-spin"></i> 行程报备中...
                            </p>
                            <p class="footprint-location">
                                <i class="fas fa-map-marker-alt"></i> 请稍候
                            </p>
                        </div>
                    </div>
                `);

                const updateResult = await tryIncrementalUpdate(currentFootprintsCharacter);

                // 移除加载状态
                const loadingItem = timelineElement.querySelector('.footprints-loading-item');
                if (loadingItem) {
                    loadingItem.remove();
                }

                if (updateResult.success && updateResult.hasNewContent) {
                    console.log(`✅ 手动刷新：增量更新成功，新增 ${updateResult.newCount} 个活动`);
                    showToast(`新增了 ${updateResult.newCount} 个足迹`, 'success');
                } else {
                    console.log('ℹ️ 手动刷新：当前时间段暂无新活动');
                    showToast('当前时间段暂无新活动', 'info');
                }
                return; // 🔥【关键】手动刷新完成，直接返回，不执行后面的完整生成
            }

            // 显示加载状态
            timelineElement.innerHTML = `
                <div class="footprints-loading">
                    <i class="fas fa-brain fa-pulse"></i>
                    <p>正在基于角色人设生成足迹...</p>
                    <p class="loading-detail">分析角色性格、世界书设定和记忆数据中</p>
                </div>
            `;

            try {
                await generateSampleFootprints();
            } catch (error) {
                console.error('加载足迹失败:', error);
                timelineElement.innerHTML = `
                    <div class="footprints-empty-state">
                        <i class="fas fa-exclamation-triangle"></i>
                        <p>加载足迹失败</p>
                        <p>请稍后重试</p>
                    </div>
                `;
            }
        }

        // 🔥【简化】生成今日足迹（从0:00到当前时间）
        async function generateTodayFootprints() {
            const timelineElement = document.getElementById('footprints-timeline');
            if (!timelineElement || !currentFootprintsCharacter) return;

            // 🔥【修复】显示加载状态
            timelineElement.innerHTML = `
                <div class="footprints-loading">
                    <div class="footprints-loading-spinner"></div>
                    <p>正在查看今日足迹...</p>
                    <p class="loading-detail">今日行程报备中</p>
                </div>
            `;

            try {
                const now = new Date();
                // 简单粗暴：从今天0:00开始到当前时间
                const startTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0);

                // 使用增量更新逻辑
                const incrementalPrompt = await buildIncrementalFootprintsPrompt(currentFootprintsCharacter, startTime, now);
                const footprintsData = await generateCharacterFootprints(incrementalPrompt);

                if (footprintsData && footprintsData.activities && footprintsData.activities.length > 0) {
                    await renderFootprintsTimeline(footprintsData);
                    await setFootprintsCache(currentFootprintsCharacter.id, footprintsData);
                    console.log('✅ 今日足迹生成完成');
                } else {
                    throw new Error('AI未生成有效足迹');
                }
            } catch (error) {
                console.error('生成足迹失败:', error);
                timelineElement.innerHTML = `
                    <div class="footprints-empty-state">
                        <i class="fas fa-exclamation-triangle"></i>
                        <p>生成足迹失败</p>
                        <p>请稍后重试</p>
                    </div>
                `;
            }
        }

        // 生成AI驱动的角色足迹数据
        async function generateSampleFootprints() {
            const timelineElement = document.getElementById('footprints-timeline');
            if (!timelineElement || !currentFootprintsCharacter) return;

            try {
                // 显示生成中状态
                timelineElement.innerHTML = `
                    <div class="footprints-loading">
                        <i class="fas fa-brain fa-pulse"></i>
                        <p>正在基于角色人设生成足迹...</p>
                        <p class="loading-detail">分析角色性格、世界书设定和记忆数据中</p>
                    </div>
                `;

                // 构建足迹生成的提示词
                const footprintsPrompt = await buildFootprintsPrompt();

                // 调用AI生成足迹
                const footprintsData = await generateCharacterFootprints(footprintsPrompt);

                if (footprintsData && footprintsData.length > 0) {
                    await renderFootprintsTimeline(footprintsData);
                } else {
                    // 如果AI生成失败，显示空状态
                    timelineElement.innerHTML = `
                        <div class="footprints-empty-state">
                            <i class="fas fa-exclamation-triangle"></i>
                            <p>足迹生成失败</p>
                            <p>请稍后重试或检查网络连接</p>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('生成足迹时出错:', error);
                timelineElement.innerHTML = `
                    <div class="footprints-empty-state">
                        <i class="fas fa-exclamation-triangle"></i>
                        <p>足迹生成出错</p>
                        <p>请稍后重试</p>
                    </div>
                `;
            }
        }

        // 构建足迹生成的提示词
        async function buildFootprintsPrompt() {
            const character = currentFootprintsCharacter;



            const now = new Date();
            const currentTime = now.toLocaleTimeString('zh-CN', { hour12: false, hour: '2-digit', minute: '2-digit' });
            const currentDate = now.toLocaleDateString('zh-CN');

            // 获取角色基本信息
            let characterInfo = `角色名称: ${character.name}\n`;
            if (character.bio) {
                characterInfo += `角色人设: ${character.bio}\n`;
            }
            if (character.persona) {
                characterInfo += `角色性格: ${character.persona}\n`;
            }

            // 获取最近的聊天记录和时间信息
            let chatContext = '';
            let chatTimeInfo = '';
            try {
                const recentMessages = chatMessages[character.id] || [];
                // 🔥【修复】使用本地时间判断今日消息，与足迹日期逻辑保持一致
                const today = new Date();
                const todayStart = new Date(today.getFullYear(), today.getMonth(), today.getDate()).getTime();
                const todayEnd = todayStart + 24 * 60 * 60 * 1000;

                const todayMessages = recentMessages.filter(msg => {
                    if (msg.timestamp) {
                        return msg.timestamp >= todayStart && msg.timestamp < todayEnd;
                    }
                    return false;
                });

                if (todayMessages.length > 0) {
                    chatContext = '\n今日对话记录:\n';
                    chatTimeInfo = '\n今日聊天时间点:\n';

                    todayMessages.forEach(msg => {
                        const sender = msg.sender === 'sent' ? '用户' : character.name;
                        const msgTime = new Date(msg.timestamp).toLocaleTimeString('zh-CN', { hour12: false, hour: '2-digit', minute: '2-digit' });
                        // 🔥【修复】使用safeExtractMessageContent确保消息内容是字符串
                        const messageContent = safeExtractMessageContent(msg);
                        chatContext += `[${msgTime}] ${sender}: ${messageContent}\n`;
                        chatTimeInfo += `- ${msgTime}: 与用户进行对话\n`;
                    });
                } else {
                    // 如果没有今日消息，获取最近几条作为参考
                    const lastFewMessages = recentMessages.slice(-3);
                    if (lastFewMessages.length > 0) {
                        chatContext = '\n最近的对话参考:\n';
                        lastFewMessages.forEach(msg => {
                            const sender = msg.sender === 'sent' ? '用户' : character.name;
                            // 🔥【修复】使用safeExtractMessageContent确保消息内容是字符串
                            const messageContent = safeExtractMessageContent(msg);
                            chatContext += `${sender}: ${messageContent}\n`;
                        });
                    }
                }
            } catch (error) {
                console.log('获取聊天记录失败:', error);
            }

            // 获取世界书信息
            let worldbookContent = '';
            try {
                const chatSettings = getCurrentChatSettings();
                const localBookIds = chatSettings.selectedWorldbooks || [];
                const globalBooks = window.activeGlobalWorldbooks || [];
                const allBookIds = [...new Set([...globalBooks, ...localBookIds])];

                if (allBookIds.length > 0) {
                    worldbookContent = '\n世界书设定:\n';
                    allBookIds.forEach((bookId, index) => {
                        const worldbook = worldbooks.find(w => w.id === bookId);
                        if (worldbook) {
                            worldbookContent += `${index + 1}. ${worldbook.name || worldbook.title}: ${worldbook.content}\n`;
                        }
                    });
                }
            } catch (error) {
                console.log('获取世界书信息失败:', error);
            }

            // 获取全局记忆信息
            let memoryContent = '';
            try {
                const memorySettings = getGlobalMemorySettings();
                if (memorySettings.enabled !== false) {
                    const currentContext = {
                        type: character.isGroup ? 'group_chat' : 'private_chat',
                        id: character.id
                    };
                    memoryContent = await buildGlobalMemoryContext(character.id, currentContext, memorySettings.memoryDays || 7);
                    if (memoryContent && memoryContent.trim()) {
                        memoryContent = '\n全局记忆:\n' + memoryContent + '\n';
                    }
                }
            } catch (error) {
                console.log('获取全局记忆失败:', error);
            }

            const prompt = `你需要为角色生成今天的行为足迹。请根据角色的人设、性格、世界书设定、聊天记录和记忆来生成符合角色特点的真实行为轨迹。

${characterInfo}${worldbookContent}${chatContext}${chatTimeInfo}${memoryContent}

当前时间: ${currentDate} ${currentTime}

请生成从合理的起始时间到当前时间(${currentTime})的角色行为足迹。要求:

1. 行为必须符合角色的人设和性格特点
2. 参考世界书设定中的背景信息
3. 结合全局记忆中的相关信息
4. 如果有今日聊天记录，请确保聊天时间点的足迹是"正在与用户聊天"或相关活动
5. 其他时间点生成合理的活动，可以是任何符合角色特点的行为
6. 行为要自然、真实，体现角色的真实生活
7. 不要回避任何时间段，角色可能在睡觉、工作、娱乐、社交、做家务、情侣夜生活等任何活动，角色要拥有符合人设的作息
8. 每个足迹包含具体时间、行为描述、地点
9. 行为类型可以是: sleep(睡觉), daily(日常), work(工作), leisure(休闲), social(社交), travel(出行), chat(聊天), nightlife(夜生活), intimate(私密), etc.

⚠️ 重要：足迹描述风格要求
- 每条足迹描述必须在30字以内
- 使用客观、简洁的记录风格，类似日志
- 避免过度文艺化的描述和场景渲染
- 直接记录行为事实，不要过多情感描述
- 正确示例："正在与她聊天，告诉她自己会一直等下去"、"没什么胃口，随意吃了点午饭"
- 错误示例："走廊的声控灯熄灭，周围陷入一片黑暗和寂静。他一动不动，像一座雕塑"

请以JSON数组格式返回，每个足迹对象包含:
{
  "time": "HH:MM",
  "activity": "具体的行为描述（30字以内，客观记录）",
  "location": "具体地点",
  "type": "行为类型"
}

只返回JSON数组，不要其他解释文字。确保时间按顺序排列，且不超过当前时间${currentTime}。`;

            return prompt;
        }

        // 🔥【重构】调用AI生成角色足迹 - 支持传入角色参数
        async function generateCharacterFootprints(prompt, character = null) {
            try {
                // 使用传入的角色或当前足迹角色
                const targetCharacter = character || currentFootprintsCharacter;
                if (!targetCharacter) {
                    console.error('❌ generateCharacterFootprints: 没有指定角色');
                    return null;
                }

                // 🔥【调试】检查数据库中的数据类型
                await debugDatabaseTypes();

                // 🔥【修复】确保currentFootprintsCharacter有效
                if (!currentFootprintsCharacter || typeof currentFootprintsCharacter.id !== 'string') {
                    console.error('❌ generateCharacterFootprints: currentFootprintsCharacter无效:', currentFootprintsCharacter);
                    return null;
                }

                // 使用现有的callChatAPI函数，但设置特殊标记避免记录到记忆系统
                const response = await callChatAPI(prompt, targetCharacter);

                // 🔥【修复】检查响应是否为空或包含错误信息
                if (!response || typeof response !== 'string') {
                    console.error('❌ AI响应为空或无效:', response);
                    return null;
                }

                // 检查是否是错误响应
                if (response.includes('空响应次数达到上限') || response.includes('请修改输入提示词')) {
                    console.error('❌ AI返回错误响应:', response);
                    return null;
                }

                // 尝试解析JSON响应
                let footprintsData;
                try {
                    // 清理响应文本，移除可能的markdown标记
                    let cleanResponse = response.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();

                    // 🔥【修复】检查清理后的响应是否为空
                    if (!cleanResponse) {
                        console.error('❌ 清理后的响应为空');
                        return null;
                    }

                    // 🔥【新增】替换用户名占位符
                    const userName = getCurrentPersonaName();
                    cleanResponse = cleanResponse.replace(/\{\{user\}\}/g, userName);

                    footprintsData = JSON.parse(cleanResponse);
                } catch (parseError) {
                    console.error('解析足迹JSON失败:', parseError);
                    console.log('原始响应:', response);
                    return null;
                }

                // 🔥【修复】验证数据格式 - 支持对象格式
                if (Array.isArray(footprintsData)) {
                    // 旧格式：直接是数组
                    const filteredData = footprintsData.filter(item =>
                        item.time && item.activity && item.location && item.type
                    );
                    // 🔥【新增】替换数组中的用户名占位符
                    const userName = getCurrentPersonaName();
                    filteredData.forEach(item => {
                        if (item.activity) item.activity = item.activity.replace(/\{\{user\}\}/g, userName);
                        if (item.location) item.location = item.location.replace(/\{\{user\}\}/g, userName);
                    });
                    return filteredData;
                } else if (footprintsData && typeof footprintsData === 'object') {
                    // 新格式：对象包含activities和locations
                    if (footprintsData.activities && Array.isArray(footprintsData.activities)) {
                        // 🔥【新增】替换对象中的用户名占位符
                        const userName = getCurrentPersonaName();
                        footprintsData.activities.forEach(item => {
                            if (item.activity) item.activity = item.activity.replace(/\{\{user\}\}/g, userName);
                            if (item.location) item.location = item.location.replace(/\{\{user\}\}/g, userName);
                        });
                        if (footprintsData.locations) {
                            footprintsData.locations.forEach(item => {
                                if (item.name) item.name = item.name.replace(/\{\{user\}\}/g, userName);
                            });
                        }
                        console.log('✅ 足迹数据格式正确:', footprintsData);
                        return footprintsData;
                    } else {
                        console.error('足迹数据缺少activities数组:', footprintsData);
                        return null;
                    }
                } else {
                    console.error('足迹数据格式不正确:', footprintsData);
                    return null;
                }
            } catch (error) {
                console.error('调用AI生成足迹失败:', error);
                return null;
            }
        }

        // 🔥【修复】渲染足迹时间线 - 处理数据格式不一致问题
        async function renderFootprintsTimeline(footprintsData, isFromCache = false) {
            const timelineElement = document.getElementById('footprints-timeline');
            if (!timelineElement || !currentFootprintsCharacter) return;

            // 🔥【关键修复】统一数据格式处理
            let activities = [];
            if (Array.isArray(footprintsData)) {
                // 旧格式：直接是数组
                activities = footprintsData;
            } else if (footprintsData && footprintsData.activities) {
                // 新格式：对象包含activities
                activities = footprintsData.activities;
            } else {
                console.error('❌ 足迹数据格式错误:', footprintsData);
                return;
            }

            console.log(`🎭 渲染足迹时间线: ${activities.length} 个活动`, activities);

            // 按时间倒序排列（最新的在上面）
            const sortedFootprints = activities.sort((a, b) => b.time.localeCompare(a.time));

            const footprintsHTML = sortedFootprints.map((footprint, index) => `
                <div class="footprint-item type-${footprint.type}" style="animation-delay: ${index * 0.1}s">
                    <div class="footprint-time">${footprint.time}</div>
                    <div class="footprint-content">
                        <p class="footprint-activity">${footprint.activity}</p>
                        <p class="footprint-location">
                            <i class="fas fa-map-marker-alt"></i>
                            ${footprint.location}
                        </p>
                    </div>
                </div>
            `).join('');

            timelineElement.innerHTML = footprintsHTML;

            // 🔥【修复】标记当前显示的是哪个角色的足迹
            if (currentFootprintsCharacter) {
                timelineElement.dataset.characterId = currentFootprintsCharacter.id;
            }

            // 🔥【优化】只有新生成的数据才保存到缓存
            if (!isFromCache && currentFootprintsCharacter) {
                await setFootprintsCache(currentFootprintsCharacter.id, footprintsData);
            }

            // 🔥【已删除】生成信息提示 - 根据用户要求移除底部提示消息
        }

        // 🔥【简化】增量追加新足迹 - 像聊天一样在顶部追加
        function appendNewFootprintsToTimeline(newFootprints) {
            const timelineElement = document.getElementById('footprints-timeline');
            if (!timelineElement || !currentFootprintsCharacter) return;

            // 🔥【统一数据格式】
            let newActivities = [];
            if (Array.isArray(newFootprints)) {
                newActivities = newFootprints;
            } else if (newFootprints && newFootprints.activities) {
                newActivities = newFootprints.activities;
            } else {
                console.error('❌ 新足迹数据格式错误:', newFootprints);
                return;
            }

            if (newActivities.length === 0) {
                console.log('ℹ️ 没有新足迹需要追加');
                return;
            }

            console.log(`🆕 在顶部追加 ${newActivities.length} 个新足迹`);

            // 🔥【简化】按时间排序新足迹（最新的在前）
            const sortedNewFootprints = newActivities.sort((a, b) => b.time.localeCompare(a.time));

            // 🔥【修复】反向遍历新足迹，确保最新的在最上方
            sortedNewFootprints.reverse().forEach((footprint, index) => {
                const footprintHTML = `
                    <div class="footprint-item type-${footprint.type || 'daily'} new-footprint" style="animation-delay: ${index * 0.2}s; opacity: 0; transform: translateY(-20px);">
                        <div class="footprint-time">${footprint.time}</div>
                        <div class="footprint-content">
                            <p class="footprint-activity">${footprint.activity}</p>
                            <p class="footprint-location">
                                <i class="fas fa-map-marker-alt"></i>
                                ${footprint.location}
                            </p>
                        </div>
                    </div>
                `;

                // 🔥【简化】直接插入到顶部
                timelineElement.insertAdjacentHTML('afterbegin', footprintHTML);
            });

            // 🔥【动画效果】让新足迹逐个出现
            setTimeout(() => {
                const newItems = timelineElement.querySelectorAll('.new-footprint');
                newItems.forEach((item, index) => {
                    setTimeout(() => {
                        item.style.opacity = '1';
                        item.style.transform = 'translateY(0)';
                        item.style.transition = 'all 0.3s ease';
                        item.classList.add('highlight-new');

                        // 3秒后移除高亮
                        setTimeout(() => {
                            item.classList.remove('new-footprint', 'highlight-new');
                        }, 3000);
                    }, index * 200);
                });
            }, 100);
        }



        // 刷新角色足迹
        async function refreshCharacterFootprints() {
            const refreshBtn = document.querySelector('.footprints-refresh-btn');
            if (refreshBtn) {
                refreshBtn.classList.add('refreshing');
                refreshBtn.disabled = true;
            }

            try {
                // 强制刷新，不使用缓存
                await loadCharacterFootprints(true);
                showToast('足迹已更新', 'success');
            } catch (error) {
                console.error('刷新足迹失败:', error);
                showToast('刷新失败，请稍后重试', 'error');
            } finally {
                // 移除刷新动画
                setTimeout(() => {
                    if (refreshBtn) {
                        refreshBtn.classList.remove('refreshing');
                        refreshBtn.disabled = false;
                    }
                }, 1000);
            }
        }

        // 更新足迹更新频率
        function updateFootprintsFrequency() {
            setupFootprintsAutoUpdate();
        }

        // 🔥【新增】恢复用户的自动更新设置
        function restoreFootprintsAutoUpdateSetting() {
            const savedSetting = localStorage.getItem('footprints_auto_update');
            if (savedSetting) {
                const frequencySelect = document.getElementById('footprints-update-frequency');
                if (frequencySelect) {
                    frequencySelect.value = savedSetting;
                    console.log(`✅ 恢复足迹自动更新设置: ${savedSetting}`);
                }
            }
        }

        // 🔥【新增】在应用启动时初始化足迹自动更新
        function initializeFootprintsAutoUpdate() {
            // 恢复设置
            restoreFootprintsAutoUpdateSetting();

            // 如果设置不是手动模式，启动后台更新
            const savedSetting = localStorage.getItem('footprints_auto_update');
            if (savedSetting && savedSetting !== 'manual') {
                console.log('🔄 启动时恢复足迹后台自动更新...');
                setupFootprintsAutoUpdate();
            }
        }

        // 🔥【重构】设置足迹自动更新 - 支持后台更新和增量更新
        function setupFootprintsAutoUpdate() {
            // 清除现有定时器
            if (footprintsUpdateTimer) {
                clearInterval(footprintsUpdateTimer);
                footprintsUpdateTimer = null;
            }

            const frequencySelect = document.getElementById('footprints-update-frequency');
            if (!frequencySelect) return;

            const frequency = frequencySelect.value;
            if (frequency === 'manual') {
                console.log('足迹更新设置为手动模式');
                // 保存设置到localStorage
                localStorage.setItem('footprints_auto_update', 'manual');
                return;
            }

            const intervalMinutes = parseInt(frequency);
            const intervalMs = intervalMinutes * 60 * 1000;

            console.log(`设置足迹自动更新，间隔：${intervalMinutes}分钟（后台运行）`);

            // 保存设置到localStorage
            localStorage.setItem('footprints_auto_update', frequency);

            footprintsUpdateTimer = setInterval(async () => {
                console.log('🔄 后台自动更新足迹数据...');
                try {
                    // 🔥【关键改进】后台增量更新所有角色的足迹
                    await updateAllCharacterFootprints();

                    // 如果当前有打开的足迹页面，刷新显示
                    const modal = document.getElementById('character-footprints-modal');
                    if (currentFootprintsCharacter && modal && modal.style.display !== 'none') {
                        await loadCharacterFootprints(false); // 使用缓存，不强制刷新
                        console.log('✅ 当前打开的足迹页面已更新');
                    }
                } catch (error) {
                    console.error('后台自动更新足迹失败:', error);
                }
            }, intervalMs);
        }

        // 🔥【简化】后台更新所有角色的足迹
        async function updateAllCharacterFootprints() {
            try {
                console.log(`🔄 开始后台更新所有角色的足迹`);

                for (const character of characters) {
                    try {
                        await updateCharacterFootprintsIncremental(character);
                    } catch (error) {
                        console.error(`更新角色 ${character.name} 足迹失败:`, error);
                    }
                }

                console.log('✅ 后台足迹更新完成');
            } catch (error) {
                console.error('后台更新足迹失败:', error);
            }
        }

        // 🔥【修复】增量更新单个角色的足迹 - 返回更新结果
        async function updateCharacterFootprintsIncremental(character) {
            const characterId = character.id;
            const cachedData = await getFootprintsCache(characterId);

            if (!cachedData) {
                // 如果没有缓存，生成完整的足迹
                console.log(`角色 ${character.name} 没有足迹缓存，生成完整足迹`);
                const fullPrompt = await buildFootprintsPrompt();
                const footprints = await generateCharacterFootprints(fullPrompt, character);
                if (footprints) {
                    await setFootprintsCache(characterId, footprints, Date.now());
                    console.log(`✅ 角色 ${character.name} 完整足迹生成成功`);
                    return { hasNewContent: true, newCount: footprints.activities?.length || 0 };
                }
                return { hasNewContent: false, newCount: 0 };
            }

            const now = new Date();
            const lastUpdateTime = new Date(cachedData.lastUpdateTime);

            console.log(`🔄 增量更新角色 ${character.name} 的足迹...`);

            try {
                // 🔥【增强】检查时间间隔，确保有足够的时间生成新活动
                const timeDiffMinutes = (now - lastUpdateTime) / (1000 * 60);

                if (timeDiffMinutes < 10) {
                    console.log(`角色 ${character.name} 距离上次更新仅${Math.round(timeDiffMinutes)}分钟，时间太短，跳过更新`);
                    return { hasNewContent: false, newCount: 0 };
                }

                console.log(`🔄 为角色 ${character.name} 生成 ${Math.round(timeDiffMinutes)} 分钟的新足迹...`);

                // 生成从上次更新时间到现在的新足迹
                const incrementalPrompt = await buildIncrementalFootprintsPrompt(character, lastUpdateTime, now);
                const newFootprints = await generateCharacterFootprints(incrementalPrompt, character);

                if (newFootprints && newFootprints.activities && newFootprints.activities.length > 0) {
                    // 🔥【改进】先追加到缓存，再更新显示
                    const success = await appendToFootprintsCache(characterId, newFootprints);
                    if (success) {
                        console.log(`✅ 角色 ${character.name} 足迹增量更新成功，新增 ${newFootprints.activities.length} 个活动`);

                        // 🔥【简化】如果用户正在查看这个角色的足迹，实时追加新足迹
                        if (currentFootprintsCharacter && currentFootprintsCharacter.id === characterId) {
                            console.log(`🎭 用户正在查看 ${character.name} 的足迹，实时追加新足迹`);
                            appendNewFootprintsToTimeline(newFootprints);
                        }
                        return { hasNewContent: true, newCount: newFootprints.activities.length };
                    } else {
                        console.error(`❌ 角色 ${character.name} 缓存保存失败，但仍更新DOM显示`);
                        // 🔥【容错】即使缓存失败，也要更新DOM显示
                        if (currentFootprintsCharacter && currentFootprintsCharacter.id === characterId) {
                            console.log(`🎭 用户正在查看 ${character.name} 的足迹，实时追加新足迹（缓存失败但DOM更新）`);
                            appendNewFootprintsToTimeline(newFootprints);
                        }
                        return { hasNewContent: true, newCount: newFootprints.activities.length };
                    }
                } else {
                    // 🔥【修复】即使AI没有返回活动，也要记录这次尝试，避免频繁重试
                    console.log(`⚠️ 角色 ${character.name} 在此时间段内AI未生成新活动，但更新时间戳以避免重复尝试`);

                    // 更新lastUpdateTime，避免频繁重试 - 使用数据库
                    try {
                        // 🔥【修复】使用本地时间而不是UTC时间，与纪念日功能保持一致
                        const today = getLocalDateString();
                        const footprintId = `${characterId}_${today}`;
                        const existingFootprint = await db.characterFootprints.get(footprintId);
                        if (existingFootprint) {
                            existingFootprint.lastUpdateTime = Date.now();
                            await db.characterFootprints.put(existingFootprint);
                            console.log(`🔄 已更新角色 ${character.name} 的lastUpdateTime，避免频繁重试`);
                        }
                    } catch (error) {
                        console.error(`更新角色 ${character.name} 的lastUpdateTime失败:`, error);
                    }
                    return { hasNewContent: false, newCount: 0 };
                }
            } catch (error) {
                console.error(`角色 ${character.name} 增量更新失败:`, error);
                return { hasNewContent: false, newCount: 0 };
            }
        }

        // 🔥【修复】尝试增量更新（用于前台调用）
        async function tryIncrementalUpdate(character) {
            try {
                console.log(`🔄 开始增量更新角色 ${character.name} 的足迹`);

                // 🔥【修复】获取增量更新的实际结果
                const updateResult = await updateCharacterFootprintsIncremental(character);

                console.log(`✅ 角色 ${character.name} 增量更新完成，结果:`, updateResult);
                return {
                    success: true,
                    hasNewContent: updateResult.hasNewContent,
                    newCount: updateResult.newCount
                };
            } catch (error) {
                console.error('增量更新失败:', error);
                return { success: false, hasNewContent: false, newCount: 0 };
            }
        }

        // 🔥【重构】构建增量足迹提示词 - 强化角色独立生活
        async function buildIncrementalFootprintsPrompt(character, fromTime, toTime) {
            const fromTimeStr = fromTime.toLocaleTimeString('zh-CN', { hour12: false, hour: '2-digit', minute: '2-digit' });
            const toTimeStr = toTime.toLocaleTimeString('zh-CN', { hour12: false, hour: '2-digit', minute: '2-digit' });

            // 获取现有足迹作为上下文
            const cachedData = await getFootprintsCache(character.id);
            const existingActivities = cachedData?.data?.activities || [];

            // 获取最近的聊天记录
            const recentMessages = await getRecentChatContext(character.id, fromTime, toTime);

            // 🔥【新增】获取最后一个活动作为连续性参考
            const lastActivity = existingActivities.length > 0 ? existingActivities[existingActivities.length - 1] : null;
            const lastActivityInfo = lastActivity ?
                `最后活动: ${lastActivity.time} - ${lastActivity.activity} (在${lastActivity.location}，心情${lastActivity.mood || '正常'})` :
                '今天还没有记录的活动';

            // 🔥【新增】分析时间段特点
            const timeAnalysis = analyzeTimeSegment(fromTime, toTime);

            // 🔥【新增】判断是否有聊天互动
            const hasChat = !recentMessages.includes('此时间段内没有聊天记录');

            const prompt = `你需要为角色生成从 ${fromTimeStr} 到 ${toTimeStr} 这个时间段的新行为足迹。

角色信息:
- 姓名: ${character.name}
- 人设: ${character.personality || '暂无'}

当前状态:
${lastActivityInfo}

时间段分析:
${timeAnalysis}

用户互动情况:
${recentMessages}

已有足迹（保持连续性）:
${existingActivities.map(act => `${act.time} - ${act.activity} (${act.location}) [${act.mood || '正常'}]`).join('\n') || '今天还没有足迹记录'}

生成要求：
1. **角色是活生生的人** - ${hasChat ? '结合与用户的互动，同时' : '即使没有用户互动，也要'}有自己的生活节奏
2. **保持逻辑连续性** - 基于最后一个活动的位置和状态自然过渡
3. **符合时间特点** - 考虑${timeAnalysis}的活动特征
4. **体现角色个性** - 活动要符合${character.name}的性格特征
5. **生活要真实丰富** - 包括工作、休息、娱乐、社交、私密时光等各个方面
6. **情绪有变化** - 心情要有自然的起伏和变化
7. **不回避任何活动** - 可以是睡觉、工作、娱乐、夜生活、私密活动等任何符合角色的行为

⚠️ 足迹描述风格要求：
- 每条足迹描述必须在30字以内
- 使用客观、简洁的记录风格，类似日志
- 避免过度文艺化的描述和场景渲染
- 直接记录行为事实，不要过多情感描述
- 正确示例："正在与她聊天，告诉她自己会一直等下去"、"没什么胃口，随意吃了点午饭"
- 错误示例："走廊的声控灯熄灭，周围陷入一片黑暗和寂静。他一动不动，像一座雕塑"

重要提醒：
- 角色有自己的完整生活，不完全依赖用户互动
- 每个时间段都应该有合理的活动安排，无论是什么时间
- ${hasChat ? '如果有聊天，要在合适的时间点体现互动' : '没有聊天时，角色可以做自己的事情（工作、学习、休息、娱乐、社交、私密活动等）'}
- 活动要具体、客观，避免空泛和文艺化的描述
- 不要因为时间段而限制活动类型，角色的生活应该是多样化的

返回JSON格式：
{
    "activities": [
        {"time": "HH:MM", "activity": "具体活动描述（30字以内，客观记录）", "location": "具体地点", "mood": "当前心情"}
    ],
    "locations": [
        {"name": "地点名", "type": "地点类型", "description": "简短描述"}
    ]
}`;

            return prompt;
        }

        // 🔥【新增】分析时间段特点
        function analyzeTimeSegment(fromTime, toTime) {
            const fromHour = fromTime.getHours();
            const toHour = toTime.getHours();
            const duration = (toTime - fromTime) / (1000 * 60); // 分钟数

            let timeCharacteristics = [];

            // 分析时间段特点
            if (fromHour >= 6 && fromHour < 9) {
                timeCharacteristics.push('晨间时光（适合洗漱、早餐、晨练、准备一天的工作）');
            }
            if (fromHour >= 9 && fromHour < 12) {
                timeCharacteristics.push('上午时段（精力充沛，适合重要工作、学习、创作）');
            }
            if (fromHour >= 12 && fromHour < 14) {
                timeCharacteristics.push('午间休息（适合用餐、午休、轻松活动）');
            }
            if (fromHour >= 14 && fromHour < 18) {
                timeCharacteristics.push('下午时光（适合继续工作、处理事务、社交活动）');
            }
            if (fromHour >= 18 && fromHour < 21) {
                timeCharacteristics.push('傍晚时分（适合晚餐、放松、娱乐、与人交流）');
            }
            if (fromHour >= 21 && fromHour < 24) {
                timeCharacteristics.push('夜晚时光（适合休闲、反思、准备休息）');
            }
            if (fromHour >= 0 && fromHour < 6) {
                timeCharacteristics.push('深夜/凌晨（通常是休息时间，偶尔可能有特殊活动）');
            }

            // 分析时长
            let durationDesc = '';
            if (duration <= 30) {
                durationDesc = '短时间段，适合单一专注活动';
            } else if (duration <= 120) {
                durationDesc = '中等时长，可以安排1-2个连续活动';
            } else {
                durationDesc = '较长时段，可以安排多个不同类型的活动';
            }

            return `${timeCharacteristics.join('、')}；${durationDesc}（时长约${Math.round(duration)}分钟）`;
        }

        // 🔥【重构】获取指定时间段的聊天上下文 - 增强独立生活指导
        async function getRecentChatContext(characterId, fromTime, toTime) {
            try {
                const messages = chatMessages[characterId] || [];
                const recentMessages = messages.filter(msg => {
                    const msgTime = new Date(msg.timestamp);
                    return msgTime >= fromTime && msgTime <= toTime;
                });

                if (recentMessages.length === 0) {
                    // 🔥【改进】没有聊天时给出更积极的指导
                    return `此时间段内没有与用户的聊天记录，角色可以专注于自己的生活：
- 可以进行日常工作、学习或休息
- 可以思考最近与用户的对话内容
- 可以为下次见面做准备
- 可以享受独处的时光，做自己喜欢的事情
- 根据角色性格安排合适的个人活动`;
                }

                const chatContext = recentMessages.map(msg => {
                    const sender = msg.sender === 'sent' ? '用户' : '角色';
                    const msgTime = new Date(msg.timestamp).toLocaleTimeString('zh-CN', { hour12: false, hour: '2-digit', minute: '2-digit' });
                    const content = safeExtractMessageContent(msg);
                    return `[${msgTime}] ${sender}: ${content}`;
                }).join('\n');

                return `与用户有以下互动，角色的活动可以体现这些对话的影响：
${chatContext}
（角色可以基于这些对话内容调整心情和后续活动）`;
            } catch (error) {
                console.error('获取聊天上下文失败:', error);
                return '获取聊天记录失败，角色按正常生活节奏安排活动';
            }
        }

        // 修改角色头像
        function changeCharacterAvatar() {
            // 临时创建一个文件输入框，避免干扰原有的头像上传功能
            const tempInput = document.createElement('input');
            tempInput.type = 'file';
            tempInput.accept = 'image/*,.jpg,.jpeg,.png,.gif,.webp';
            tempInput.style.display = 'none';
            document.body.appendChild(tempInput);

            tempInput.onchange = function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = async function(event) {
                        const characterIndex = characters.findIndex(c => c.id === currentChatCharacter.id);
                        if (characterIndex !== -1) {
                            characters[characterIndex].avatarUrl = event.target.result;
                            await saveCharacters();
                            renderCharacterList();
                            renderContactList();
                            renderMessageList();
                            renderChatMessages(currentChatCharacter.id);
                        }
                        // 清理临时元素
                        document.body.removeChild(tempInput);
                    };
                    reader.readAsDataURL(e.target.files[0]);
                } else {
                    // 如果用户取消选择，也要清理临时元素
                    document.body.removeChild(tempInput);
                }
            };

            tempInput.click();
        }

        // 修改备注
        async function changeCharacterNickname() {
            const newName = prompt('请输入新的备注名称:', currentChatCharacter.name);
            if (newName && newName.trim() !== '') {
                const characterIndex = characters.findIndex(c => c.id === currentChatCharacter.id);
                if (characterIndex !== -1) {
                    characters[characterIndex].name = newName.trim();
                    await saveCharacters();
                    const chatTitle = document.getElementById('api-chat-title');
                    if (chatTitle) {
                        chatTitle.textContent = newName.trim();
                        // 🔥【新增】清除正在输入状态并保存新的原始标题
                        chatTitle.classList.remove('typing-status');
                        chatTitle.dataset.originalTitle = newName.trim();
                    }
                    renderCharacterList();
                    renderContactList();
                    renderMessageList();
                }
            }
        }

        // 🔥【全新】查找聊天内容 - 显示搜索模态框
        function searchChatContent() {
            if (!currentChatCharacter) {
                showToast('请先选择一个聊天', 'warning');
                return;
            }

            // 清空之前的搜索结果
            document.getElementById('search-keyword-input').value = '';
            document.getElementById('search-results-summary').style.display = 'none';
            document.getElementById('search-results-container').style.display = 'none';

            showModal('search-chat-modal');

            // 聚焦到搜索框
            setTimeout(() => {
                document.getElementById('search-keyword-input').focus();
            }, 100);
        }

        // 🔥【修复】执行聊天搜索 - 搜索完整聊天记录
        async function performChatSearch() {
            const keyword = document.getElementById('search-keyword-input').value.trim();
            if (!keyword) {
                showToast('请输入搜索关键词', 'warning');
                return;
            }

            // 🔥【修复】从数据库获取完整的聊天记录，而不是只搜索内存中的消息
            let allMessages = [];
            try {
                const dbMessages = await db.chatMessages
                    .where('characterId')
                    .equals(currentChatCharacter.id)
                    .toArray();

                allMessages = dbMessages.sort((a, b) => a.timestamp - b.timestamp);

            } catch (error) {
                console.error('获取聊天记录失败:', error);
                // 如果数据库查询失败，回退到内存中的消息
                allMessages = chatMessages[currentChatCharacter.id] || [];
            }

            const foundMessages = allMessages.filter((msg, index) => {
                // 🔥【修复】消息内容在messageData字段中
                if (!msg.messageData) {
                    return false;
                }

                const messageData = msg.messageData;
                let searchText = '';

                if (typeof messageData.content === 'string') {
                    searchText = messageData.content;
                } else if (Array.isArray(messageData.content)) {
                    // 处理多模态消息
                    searchText = messageData.content
                        .filter(item => item && item.type === 'text')
                        .map(item => item.text || '')
                        .join(' ');
                } else if (messageData.content && typeof messageData.content === 'object') {
                    // 处理对象类型的content
                    searchText = messageData.content.text || messageData.content.content || '';
                } else {
                    searchText = messageData.content ? String(messageData.content) : '';
                }

                // 确保searchText是字符串
                if (typeof searchText !== 'string') {
                    searchText = '';
                }

                return searchText.toLowerCase().includes(keyword.toLowerCase());
            });


            // 显示搜索统计
            const summaryDiv = document.getElementById('search-results-summary');
            const statsDiv = document.getElementById('search-stats');
            statsDiv.innerHTML = `
                <strong>搜索结果：</strong>找到 <span style="color: #007AFF; font-weight: bold;">${foundMessages.length}</span> 条包含"<span style="color: #007AFF;">${keyword}</span>"的消息
                <br><small style="color: #666;">点击任意消息查看前后10条消息的上下文</small>
            `;
            summaryDiv.style.display = 'block';

            // 显示搜索结果
            const resultsContainer = document.getElementById('search-results-container');
            const resultsList = document.getElementById('search-results-list');

            if (foundMessages.length === 0) {
                resultsList.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">没有找到包含该关键词的消息</div>';
            } else {
                resultsList.innerHTML = foundMessages.map((msg, index) => {
                    // 🔥【修复】从messageData获取发送者和内容信息
                    const messageData = msg.messageData;
                    if (!messageData) return '';

                    let senderName = '';
                    if (messageData.isUser || messageData.sender === 'sent') {
                        senderName = '我';
                    } else {
                        // 检查是否是群聊
                        if (currentChatCharacter.isGroup) {


                            // 群聊：显示具体的发送者名称
                            // 尝试多个可能的字段来获取发送者名称
                            senderName = messageData.senderName ||
                                        messageData.characterName ||
                                        messageData.name ||
                                        (messageData.sender !== 'received' ? messageData.sender : '未知成员');
                        } else {
                            // 私聊：显示角色名称
                            senderName = currentChatCharacter.name || '角色';
                        }
                    }

                    // 🔥【修复】处理不同类型的消息内容进行高亮
                    let displayContent = '';
                    if (typeof messageData.content === 'string') {
                        displayContent = messageData.content;
                    } else if (Array.isArray(messageData.content)) {
                        displayContent = messageData.content
                            .filter(item => item && item.type === 'text')
                            .map(item => item.text || '')
                            .join(' ');
                    } else if (messageData.content && typeof messageData.content === 'object') {
                        // 处理对象类型的content
                        displayContent = messageData.content.text || messageData.content.content || '';
                    } else {
                        displayContent = messageData.content ? String(messageData.content) : '消息内容为空';
                    }

                    // 如果处理后仍然为空，显示默认文本
                    if (!displayContent || displayContent.trim() === '') {
                        displayContent = '消息内容为空';
                    }

                    const highlightedContent = displayContent.replace(
                        new RegExp(keyword, 'gi'),
                        `<span class="search-highlight">$&</span>`
                    );
                    const timeStr = new Date(msg.timestamp).toLocaleString('zh-CN', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit'
                    });

                    return `
                        <div class="search-result-item" onclick="showMessageContext(${allMessages.indexOf(msg)})">
                            <div class="search-result-content">${highlightedContent}</div>
                            <div class="search-result-meta">
                                <span class="search-result-sender">${senderName}</span>
                                <span class="search-result-time">${timeStr}</span>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            resultsContainer.style.display = 'block';
        }

        // 🔥【新增】显示消息上下文
        async function showMessageContext(messageIndex) {
            // 🔥【修复】使用全部消息数据，而不是只有当前显示的
            let allMessages = [];
            try {
                const dbMessages = await db.chatMessages
                    .where('characterId')
                    .equals(currentChatCharacter.id)
                    .toArray();

                allMessages = dbMessages.sort((a, b) => a.timestamp - b.timestamp);
            } catch (error) {
                console.error('获取聊天记录失败:', error);
                allMessages = chatMessages[currentChatCharacter.id] || [];
            }

            const targetMessage = allMessages[messageIndex];
            if (!targetMessage) return;

            // 获取前后10条消息
            const startIndex = Math.max(0, messageIndex - 10);
            const endIndex = Math.min(allMessages.length - 1, messageIndex + 10);
            const contextMessages = allMessages.slice(startIndex, endIndex + 1);

            // 渲染上下文消息
            const container = document.getElementById('message-context-container');
            container.innerHTML = contextMessages.map((msg, index) => {
                const actualIndex = startIndex + index;
                const isTarget = actualIndex === messageIndex;

                // 🔥【修复】从messageData获取发送者信息
                const messageData = msg.messageData;
                if (!messageData) return '';

                let senderName = '';
                let senderClass = '';

                if (messageData.isUser || messageData.sender === 'sent') {
                    senderName = '我';
                    senderClass = 'user';
                } else {
                    // 检查是否是群聊
                    if (currentChatCharacter.isGroup) {
                        // 群聊：显示具体的发送者名称
                        // 尝试多个可能的字段来获取发送者名称
                        senderName = messageData.senderName ||
                                    messageData.characterName ||
                                    messageData.name ||
                                    (messageData.sender !== 'received' ? messageData.sender : '未知成员');
                        senderClass = 'character';
                    } else {
                        // 私聊：显示角色名称
                        senderName = currentChatCharacter.name || '角色';
                        senderClass = 'character';
                    }
                }

                const targetClass = isTarget ? ' target' : '';
                const timeStr = new Date(msg.timestamp).toLocaleString('zh-CN', {
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                });

                // 🔥【修复】处理不同类型的消息内容显示，防止undefined
                let displayContent = '';
                if (typeof messageData.content === 'string') {
                    displayContent = messageData.content;
                } else if (Array.isArray(messageData.content)) {
                    displayContent = messageData.content
                        .filter(item => item && item.type === 'text')
                        .map(item => item.text || '')
                        .join(' ');
                } else if (messageData.content && typeof messageData.content === 'object') {
                    // 处理对象类型的content
                    displayContent = messageData.content.text || messageData.content.content || '';
                } else {
                    displayContent = messageData.content ? String(messageData.content) : '消息内容为空';
                }

                // 如果处理后仍然为空，显示默认文本
                if (!displayContent || displayContent.trim() === '') {
                    displayContent = '消息内容为空';
                }

                return `
                    <div class="context-message ${senderClass}${targetClass}">
                        <div class="context-message-meta">${senderName} · ${timeStr}</div>
                        <div>${displayContent}</div>
                    </div>
                `;
            }).join('');

            showModal('message-context-modal');
        }

        // 🔥【新增】支持回车键搜索
        document.addEventListener('DOMContentLoaded', function() {
            const searchInput = document.getElementById('search-keyword-input');
            if (searchInput) {
                searchInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        performChatSearch();
                    }
                });
            }
        });



        // 🔥【新增】显示导出选项模态框
        function showExportOptions() {
            if (!currentChatCharacter) {
                showToast('请先选择一个聊天', 'warning');
                return;
            }

            document.getElementById('export-options-modal').style.display = 'flex';
        }

        // 🔥【新增】隐藏导出选项模态框
        function hideExportOptions(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('export-options-modal').style.display = 'none';
        }

        // 🔥【新增】选择导出格式
        function selectExportFormat(format) {
            document.getElementById('format-html').checked = format === 'html';
            document.getElementById('format-json').checked = format === 'json';

            // 更新选中样式
            document.querySelectorAll('.export-format-option').forEach(option => {
                option.classList.remove('selected');
            });
            document.querySelector(`[onclick="selectExportFormat('${format}')"]`).classList.add('selected');
        }

        // 🔥【新增】执行导出
        async function executeExport() {
            const selectedFormat = document.querySelector('input[name="exportFormat"]:checked').value;
            hideExportOptions();

            if (selectedFormat === 'html') {
                exportChatHistoryAsHTML();
            } else if (selectedFormat === 'json') {
                await exportChatHistoryAsJSON();
            }
        }

        // 🔥【修复】导出聊天记录 - 完整HTML格式（重命名原函数）
        function exportChatHistoryAsHTML() {
            if (!currentChatCharacter) {
                showToast('请先选择一个聊天', 'warning');
                return;
            }

            const messages = chatMessages[currentChatCharacter.id] || [];
            if (messages.length === 0) {
                showToast('没有聊天记录可导出', 'warning');
                return;
            }

            const chatSettings = getCurrentChatSettings();
            const characterName = chatSettings.aiChatNickname || currentChatCharacter.name;
            const userName = chatSettings.myChatNickname || '我';
            const exportTime = new Date();
            const totalMessages = messages.length;

            // 获取时间范围
            const firstMessageTime = new Date(messages[0].timestamp || Date.now());
            const lastMessageTime = new Date(messages[messages.length - 1].timestamp || Date.now());

            // 确保日期有效
            if (isNaN(firstMessageTime.getTime())) {
                firstMessageTime = new Date();
            }
            if (isNaN(lastMessageTime.getTime())) {
                lastMessageTime = new Date();
            }

            // 构建HTML内容
            let htmlContent = `<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>与 ${characterName} 的聊天记录</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', Helvetica, Arial, sans-serif;
            background: #f0f0f0;
            color: #333;
            line-height: 1.6;
            min-height: 100vh;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            min-height: 100vh;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        .header {
            background: #007AFF;
            color: white;
            padding: 20px;
            text-align: center;
        }
        .header h1 {
            font-size: 24px;
            margin-bottom: 10px;
        }
        .header .info {
            font-size: 14px;
            opacity: 0.9;
        }
        .chat-content {
            padding: 20px;
        }
        .message {
            margin-bottom: 15px;
            display: flex;
            align-items: flex-end;
            gap: 10px;
        }
        .message.user {
            flex-direction: row-reverse;
        }
        .message.ai {
            flex-direction: row;
        }
        .message.system {
            justify-content: center;
            margin: 10px 0;
        }
        .message-bubble {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            word-wrap: break-word;
            position: relative;
        }
        .message.user .message-bubble {
            background: #007AFF;
            color: white;
            border-bottom-right-radius: 6px;
        }
        .message.ai .message-bubble {
            background: #e5e5ea;
            color: #333;
            border-bottom-left-radius: 6px;
        }
        .message.system .message-bubble {
            background: #f0f0f0;
            color: #666;
            font-size: 12px;
            text-align: center;
            border-radius: 12px;
            padding: 6px 12px;
            margin: 0 auto;
            max-width: 60%;
        }

        /* 🔥【新增】纪念日和约定提醒消息的特殊样式 */
        .message-container.received .message-bubble.reminder-message {
            background: linear-gradient(135deg, #FFE4E1, #FFF0F5) !important;
            border: 1px solid #FFB6C1 !important;
            box-shadow: 0 2px 8px rgba(255, 182, 193, 0.3) !important;
            position: relative;
        }

        .message-container.received .message-bubble.reminder-message::before {
            content: '📅';
            position: absolute;
            top: -8px;
            left: -8px;
            background: #FF69B4;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            z-index: 10;
        }

        .message-container.received .message-bubble.reminder-message {
            animation: reminderPulse 2s ease-in-out;
        }

        @keyframes reminderPulse {
            0% { transform: scale(1); box-shadow: 0 2px 8px rgba(255, 182, 193, 0.3); }
            50% { transform: scale(1.02); box-shadow: 0 4px 16px rgba(255, 182, 193, 0.5); }
            100% { transform: scale(1); box-shadow: 0 2px 8px rgba(255, 182, 193, 0.3); }
        }
        .sender-name {
            font-size: 12px;
            color: #666;
            margin-bottom: 4px;
            padding: 0 16px;
        }
        .message.user .sender-name {
            text-align: right;
        }
        .timestamp {
            font-size: 11px;
            color: #999;
            margin-top: 4px;
            padding: 0 16px;
        }
        .message.user .timestamp {
            text-align: right;
        }
        .quote-block {
            background: rgba(0,0,0,0.05);
            border-left: 3px solid #007AFF;
            padding: 8px 12px;
            margin-bottom: 8px;
            border-radius: 0 8px 8px 0;
            font-size: 13px;
        }
        .message.user .quote-block {
            border-left-color: rgba(255,255,255,0.5);
            background: rgba(255,255,255,0.2);
        }
        .quote-sender {
            font-weight: 600;
            color: #007AFF;
            font-size: 12px;
            margin-bottom: 2px;
        }
        .message.user .quote-sender {
            color: rgba(255,255,255,0.9);
        }
        .special-message {
            font-style: italic;
            color: #666;
        }
        .footer {
            background: #f8f8f8;
            padding: 20px;
            text-align: center;
            border-top: 1px solid #e0e0e0;
            font-size: 12px;
            color: #666;
        }
        .stats {
            background: #f8f8f8;
            padding: 15px 20px;
            border-top: 1px solid #e0e0e0;
            font-size: 14px;
            color: #666;
        }
        @media (max-width: 600px) {
            .container {
                margin: 0;
                box-shadow: none;
            }
            .message-bubble {
                max-width: 85%;
            }
            .header h1 {
                font-size: 20px;
            }
            .chat-content {
                padding: 15px;
            }
        }

        /* 加载动画 */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }





        /* 发帖模态框 */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
        }

        .modal-close-btn {
            background: none;
            border: none;
            font-size: 24px;
            color: #666;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-body {
            padding: 20px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #333;
        }

        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            resize: vertical;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #007AFF;
        }

        .char-count {
            text-align: right;
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .modal-footer {
            padding: 20px;
            border-top: 1px solid #eee;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .btn-secondary,
        .btn-primary {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-secondary {
            background: #f5f5f5;
            color: #333;
        }

        .btn-secondary:hover {
            background: #e5e5e5;
        }

        .btn-primary {
            background: #007AFF;
            color: white;
        }

        .btn-primary:hover {
            background: #0056CC;
        }

        /* 评论互动按钮 */
        .reply-actions {
            margin-top: 8px;
            display: flex;
            gap: 15px;
        }

        .reply-action-btn {
            background: none;
            border: none;
            color: #666;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .reply-action-btn:hover {
            background: #f5f5f5;
            color: #333;
        }

        .reply-action-btn.liked {
            color: #ff3b30;
        }

        .reply-action-btn.liked i {
            color: #ff3b30;
        }

        .like-count {
            font-size: 11px;
            min-width: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>与 ${characterName} 的聊天记录</h1>
            <div class="info">
                导出时间：${exportTime.toLocaleString('zh-CN')}<br>
                共 ${totalMessages} 条消息 | ${firstMessageTime.toLocaleDateString('zh-CN')} - ${lastMessageTime.toLocaleDateString('zh-CN')}
            </div>
        </div>
        <div class="chat-content">`;

            // 处理每条消息
            messages.forEach((message, index) => {
                const time = formatTime(message.timestamp);
                const isUser = message.sender === 'sent';
                const isSystem = message.sender === 'system';

                if (isSystem) {
                    // 系统消息
                    htmlContent += `
            <div class="message system">
                <div class="message-bubble">${escapeHtml(message.content)}</div>
            </div>`;
                } else {
                    // 用户或AI消息
                    const messageClass = isUser ? 'user' : 'ai';
                    const senderName = isUser ? userName : characterName;
                    let messageContent = '';

                    // 处理引用消息
                    if (message.replyTo) {
                        const quoteSender = message.replyTo.senderName || (message.replyTo.sender === 'sent' ? userName : characterName);
                        const quoteContent = truncateText(message.replyTo.content || '[消息已删除]', 20);
                        messageContent += `
                <div class="quote-block">
                    <div class="quote-sender">${escapeHtml(quoteSender)}</div>
                    <div>${escapeHtml(quoteContent)}</div>
                </div>`;
                    }

                    // 处理消息内容
                    let content = message.content || '';
                    let specialClass = '';

                    if (message.type === 'voice_message') {
                        content = `🎵 语音消息：${content}`;
                        specialClass = ' special-message';
                    } else if (message.type === 'transfer') {
                        content = `💰 转账：${message.amount}元${message.note ? ` (${message.note})` : ''}`;
                        specialClass = ' special-message';
                    } else if (message.type === 'location') {
                        content = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 4px; vertical-align: middle;"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/></svg>位置：${message.locationName || '位置信息'}`;
                        specialClass = ' special-message';
                    } else if (message.type === 'friend_request') {
                        content = `👋 好友申请：${message.message || '想和你重新做朋友'}`;
                        specialClass = ' special-message';
                    } else if (message.type === 'user_photo') {
                        content = `📷 图片：${content}`;
                        specialClass = ' special-message';
                    } else if (message.isEmoji) {
                        content = `😊 表情包：${message.emojiDescription || content}`;
                        specialClass = ' special-message';
                    } else if (Array.isArray(content)) {
                        // 🔥【统一格式】处理数组格式消息（现在所有消息都是数组格式）
                        const textPart = content.find(part => part.type === 'text')?.text || '';
                        const imagePart = content.find(part => part.type === 'image_url');

                        if (textPart && imagePart) {
                            content = `📷📝 图片+文字：${textPart}`;
                        } else if (imagePart) {
                            content = '📷 图片消息';
                        } else if (textPart) {
                            content = textPart; // 纯文字消息
                        } else {
                            content = '📱 多媒体消息';
                        }

                        if (imagePart) {
                            specialClass = ' special-message';
                        }
                    }

                    messageContent += `<div class="${specialClass.trim()}">${escapeHtml(content)}</div>`;

                    htmlContent += `
            <div class="message ${messageClass}">
                <div class="message-bubble">
                    ${messageContent}
                </div>
            </div>
            <div class="timestamp">${time}</div>`;
                }

                // 每50条消息添加一个分页标记（便于长聊天记录的查看）
                if ((index + 1) % 50 === 0 && index !== messages.length - 1) {
                    htmlContent += `
            <div class="message system">
                <div class="message-bubble">--- 第 ${Math.floor((index + 1) / 50)} 页 ---</div>
            </div>`;
                }
            });

            htmlContent += `
        </div>
        <div class="stats">
            📊 聊天统计<br>
            总消息数：${totalMessages} 条 |
            我的消息：${messages.filter(m => m.sender === 'sent').length} 条 |
            ${characterName} 的消息：${messages.filter(m => m.sender === 'received').length} 条 |
            系统消息：${messages.filter(m => m.sender === 'system').length} 条
        </div>
        <div class="footer">
            此聊天记录由手机聊天应用自动生成<br>
            导出时间：${exportTime.toLocaleString('zh-CN')}
        </div>
    </div>
</body>
</html>`;

            // 创建下载链接
            const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            const fileName = `与${characterName}的聊天记录_${exportTime.getFullYear()}-${(exportTime.getMonth() + 1).toString().padStart(2, '0')}-${exportTime.getDate().toString().padStart(2, '0')}.html`;

            link.href = url;
            link.download = fileName;
            link.style.display = 'none';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            // 清理URL对象
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 1000);

            showToast(`聊天记录已导出：${fileName}`, 'success');
        }

        // 🔥【新增】导出聊天记录为JSON格式（包含完整记忆系统）
        async function exportChatHistoryAsJSON() {
            if (!currentChatCharacter) {
                showToast('请先选择一个聊天', 'warning');
                return;
            }

            try {
                showToast('正在收集数据...', 'info');

                const characterId = currentChatCharacter.id;
                const characterName = currentChatCharacter.name;
                const exportTime = new Date();

                // 构建完整的导出数据
                const exportData = {
                    exportInfo: {
                        characterId: characterId,
                        characterName: characterName,
                        exportTime: exportTime.toISOString(),
                        version: '1.0',
                        description: `${characterName}的完整聊天数据备份`
                    },

                    // 聊天记录（Chat应用）- 从数据库获取
                    chatMessages: await db.chatMessages.where('characterId').equals(characterId).toArray(),

                    // 短信记录（短信应用）- 从数据库获取
                    smsMessages: await db.smsMessages.where('characterId').equals(characterId).toArray(),

                    // 聊天设置 - 从数据库获取（使用chatId字段）
                    chatSettings: await db.chatSettings.where('chatId').equals(characterId).toArray(),

                    // 记忆系统数据
                    coreMemories: await db.coreMemories.where('characterId').equals(characterId).toArray(),
                    episodicMemories: await db.episodicMemories.where('characterId').equals(characterId).toArray(),
                    memorySummaries: await db.memorySummaries.where('characterId').equals(characterId).toArray(),
                    crossAppTimeline: await db.crossAppTimeline.where('characterId').equals(characterId).toArray()
                };

                // 统计信息
                const stats = {
                    chatMessages: exportData.chatMessages.length,
                    smsMessages: exportData.smsMessages.length,
                    coreMemories: exportData.coreMemories.length,
                    episodicMemories: exportData.episodicMemories.length,
                    memorySummaries: exportData.memorySummaries.length,
                    crossAppTimeline: exportData.crossAppTimeline.length
                };

                console.log('📊 导出数据统计:', stats);

                // 创建JSON文件
                const jsonContent = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonContent], { type: 'application/json;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                const fileName = `${characterName}_完整数据备份_${exportTime.getFullYear()}-${(exportTime.getMonth() + 1).toString().padStart(2, '0')}-${exportTime.getDate().toString().padStart(2, '0')}.json`;

                link.href = url;
                link.download = fileName;
                link.style.display = 'none';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                // 清理URL对象
                setTimeout(() => {
                    URL.revokeObjectURL(url);
                }, 1000);

                const statsText = Object.entries(stats)
                    .filter(([key, value]) => value > 0)
                    .map(([key, value]) => {
                        const labels = {
                            chatMessages: '聊天消息',
                            smsMessages: '短信消息',
                            coreMemories: '核心记忆',
                            episodicMemories: '情景记忆',
                            memorySummaries: '剧情总结',
                            crossAppTimeline: '时间线记忆'
                        };
                        return `${labels[key]}: ${value}条`;
                    })
                    .join(', ');

                showToast(`完整数据已导出：${fileName}（${statsText}）`, 'success');

            } catch (error) {
                console.error('导出JSON数据失败:', error);
                showToast('导出失败: ' + error.message, 'error');
            }
        }

        // 🔥【新增】HTML转义函数
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // 🔥【新增】文本截断函数
        function truncateText(text, maxLength) {
            if (text.length <= maxLength) return text;
            return text.substring(0, maxLength) + '...';
        }



        // 🔥【新增】显示导入选项模态框
        function showImportOptions() {
            if (!currentChatCharacter) {
                showToast('请先选择一个聊天', 'warning');
                return;
            }

            document.getElementById('import-options-modal').style.display = 'flex';

            // 重置文件选择状态
            document.getElementById('import-file-input').value = '';
            document.getElementById('import-file-info').style.display = 'none';
            document.getElementById('import-execute-btn').disabled = true;
        }

        // 🔥【新增】隐藏导入选项模态框
        function hideImportOptions(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('import-options-modal').style.display = 'none';
        }

        // 🔥【新增】处理导入文件选择
        function handleImportFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.name.endsWith('.json')) {
                showToast('请选择JSON格式的文件', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    // 验证文件格式
                    if (!data.exportInfo || !data.exportInfo.characterName) {
                        showToast('无效的备份文件格式', 'error');
                        return;
                    }

                    // 显示文件信息
                    document.getElementById('import-file-name').textContent = file.name;

                    const stats = [];
                    if (data.chatMessages?.length) stats.push(`聊天消息: ${data.chatMessages.length}条`);
                    if (data.smsMessages?.length) stats.push(`短信消息: ${data.smsMessages.length}条`);
                    if (data.coreMemories?.length) stats.push(`核心记忆: ${data.coreMemories.length}条`);
                    if (data.episodicMemories?.length) stats.push(`情景记忆: ${data.episodicMemories.length}条`);
                    if (data.memorySummaries?.length) stats.push(`剧情总结: ${data.memorySummaries.length}条`);
                    if (data.crossAppTimeline?.length) stats.push(`时间线记忆: ${data.crossAppTimeline.length}条`);

                    document.getElementById('import-file-preview').innerHTML = `
                        <strong>角色：</strong>${data.exportInfo.characterName}<br>
                        <strong>导出时间：</strong>${new Date(data.exportInfo.exportTime).toLocaleString('zh-CN')}<br>
                        <strong>包含数据：</strong>${stats.join(', ')}
                    `;

                    document.getElementById('import-file-info').style.display = 'block';
                    document.getElementById('import-execute-btn').disabled = false;

                    // 保存数据到临时变量
                    window.pendingImportData = data;

                } catch (error) {
                    showToast('文件格式错误，无法解析JSON', 'error');
                    console.error('解析导入文件失败:', error);
                }
            };

            reader.readAsText(file);
        }

        // 🔥【新增】执行导入操作
        async function executeImport() {
            if (!window.pendingImportData) {
                showToast('没有待导入的数据', 'error');
                return;
            }

            if (!currentChatCharacter) {
                showToast('请先选择一个聊天', 'warning');
                return;
            }

            try {
                showToast('正在导入数据，请稍候...', 'info');
                hideImportOptions();

                const data = window.pendingImportData;
                const characterId = currentChatCharacter.id;

                // 使用数据库事务确保数据一致性
                await db.transaction('rw', [
                    db.chatMessages,
                    db.smsMessages,
                    db.chatSettings,
                    db.coreMemories,
                    db.episodicMemories,
                    db.memorySummaries,
                    db.crossAppTimeline
                ], async () => {
                    // 1. 删除该角色的所有现有数据
                    await db.chatMessages.where('characterId').equals(characterId).delete();
                    await db.smsMessages.where('characterId').equals(characterId).delete();
                    await db.chatSettings.where('chatId').equals(characterId).delete();
                    await db.coreMemories.where('characterId').equals(characterId).delete();
                    await db.episodicMemories.where('characterId').equals(characterId).delete();
                    await db.memorySummaries.where('characterId').equals(characterId).delete();
                    await db.crossAppTimeline.where('characterId').equals(characterId).delete();

                    // 2. 导入新数据
                    if (data.chatMessages?.length) {
                        await db.chatMessages.bulkAdd(data.chatMessages);
                    }
                    if (data.smsMessages?.length) {
                        await db.smsMessages.bulkAdd(data.smsMessages);
                    }
                    if (data.chatSettings?.length) {
                        await db.chatSettings.bulkAdd(data.chatSettings);
                    }
                    if (data.coreMemories?.length) {
                        await db.coreMemories.bulkAdd(data.coreMemories);
                    }
                    if (data.episodicMemories?.length) {
                        await db.episodicMemories.bulkAdd(data.episodicMemories);
                    }
                    if (data.memorySummaries?.length) {
                        await db.memorySummaries.bulkAdd(data.memorySummaries);
                    }
                    if (data.crossAppTimeline?.length) {
                        await db.crossAppTimeline.bulkAdd(data.crossAppTimeline);
                    }
                });

                // 3. 重新加载数据到内存
                await loadChatMessages(); // 重新加载聊天记录到内存
                await loadSMSMessages(); // 重新加载短信记录到内存
                await loadChatSettings(); // 重新加载聊天设置到内存

                // 4. 刷新界面显示
                renderMessageList();

                // 如果当前在短信应用，也刷新短信界面
                const smsScreen = document.getElementById('sms-screen');
                if (smsScreen && smsScreen.style.display !== 'none') {
                    loadSMSHistory();
                }

                // 统计导入的数据
                const stats = [];
                if (data.chatMessages?.length) stats.push(`聊天消息: ${data.chatMessages.length}条`);
                if (data.smsMessages?.length) stats.push(`短信消息: ${data.smsMessages.length}条`);
                if (data.coreMemories?.length) stats.push(`核心记忆: ${data.coreMemories.length}条`);
                if (data.episodicMemories?.length) stats.push(`情景记忆: ${data.episodicMemories.length}条`);
                if (data.memorySummaries?.length) stats.push(`剧情总结: ${data.memorySummaries.length}条`);
                if (data.crossAppTimeline?.length) stats.push(`时间线记忆: ${data.crossAppTimeline.length}条`);

                showToast(`数据导入成功！已导入：${stats.join(', ')}。建议刷新页面以确保所有功能正常显示`, 'success');

                // 清理临时数据
                delete window.pendingImportData;

            } catch (error) {
                console.error('导入数据失败:', error);
                showToast('导入失败: ' + error.message, 'error');
            }
        }

        // 🔥【新增】HTML转义函数
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // 🔥【新增】根据消息ID查找消息
        function findMessageById(messageId) {
            if (!currentChatCharacter || !chatMessages[currentChatCharacter.id]) {
                return null;
            }

            const messages = chatMessages[currentChatCharacter.id];
            const result = messages.find(msg => msg.id === messageId);
            return result;
        }

        // 🔥【新增】获取当前用户身份名称
        function getCurrentPersonaName() {
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.selectedIdentityId) {
                const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                if (selectedPersona) {
                    // 优先使用群聊昵称
                    return chatSettings.myChatNickname || selectedPersona.name;
                }
            }
            return '用户';
        }

        // 🔥【新增】获取当前用户身份描述
        function getCurrentPersonaDescription() {
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.selectedIdentityId) {
                const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                if (selectedPersona && selectedPersona.description) {
                    return selectedPersona.description;
                }
            }
            return '我是用户';
        }



        // 设置对方气泡颜色
        function changeTheirBubbleColor() {
            colorPickerContext = 'theirBubble';
            document.getElementById('color-picker-title').textContent = '设置对方气泡颜色';
            showModal('color-picker-modal');
        }

        // 设置我方气泡颜色
        function changeMyBubbleColor() {
            colorPickerContext = 'myBubble';
            document.getElementById('color-picker-title').textContent = '设置我方气泡颜色';
            showModal('color-picker-modal');
        }

        // 显示气泡颜色设置
        function showBubbleColorSettings() {
            alert('气泡颜色设置功能开发中...\n\n当前可以通过以下方式设置：\n• 修改对方气泡颜色\n• 修改我方气泡颜色');
        }

        // 🔥【新增】显示带选项的清空历史记录模态框
        function showClearHistoryOptionsModal() {
            if (!currentChatCharacter) return;

            // 创建模态框的HTML结构
            const modalHTML = `
                <div id="clear-history-options-modal" class="modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 class="modal-title">清空聊天记录</h3>
                            <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p style="margin-bottom: 15px; font-size: 14px; color: #666;">
                                你确定要清空与 <strong>${currentChatCharacter.name}</strong> 的聊天记录吗？
                            </p>
                            <div class="setting-section">
                                <div class="section-header" style="padding: 0 0 10px 0;">
                                    <i class="fas fa-brain section-icon"></i>
                                    <span class="section-title">同步清除相关记忆</span>
                                </div>
                                <div class="checkbox-group">
                                    <label class="checkbox-option">
                                        <input type="checkbox" id="clear-core-memory" value="core" checked>
                                        <span class="checkbox-custom"></span>
                                        <div class="checkbox-content">
                                            <div class="checkbox-title">核心记忆</div>
                                            <div class="checkbox-desc">角色记住的关键信息（如生日、关系）。</div>
                                        </div>
                                    </label>
                                    <label class="checkbox-option">
                                        <input type="checkbox" id="clear-episodic-memory" value="episodic" checked>
                                        <span class="checkbox-custom"></span>
                                        <div class="checkbox-content">
                                            <div class="checkbox-title">情景记忆</div>
                                            <div class="checkbox-desc">日常互动和经历的记忆。</div>
                                        </div>
                                    </label>
                                    <label class="checkbox-option">
                                        <input type="checkbox" id="clear-timeline" value="timeline" checked>
                                        <span class="checkbox-custom"></span>
                                        <div class="checkbox-content">
                                            <div class="checkbox-title">时间线</div>
                                            <div class="checkbox-desc">所有活动的详细时间记录。</div>
                                        </div>
                                    </label>
                                </div>
                            </div>
                            <p style="margin-top: 15px; font-size: 12px; color: #999;">
                                <strong>提示：</strong>聊天设置（如身份、背景）将会被保留。
                            </p>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="this.closest('.modal').remove()">取消</button>
                            <button class="modal-button modal-primary" style="background-color: #ff3b30;" onclick="executeClearHistory()">确认清空</button>
                        </div>
                    </div>
                </div>
            `;

            // 添加到页面
            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        // 🔥【新增】根据用户的选择执行清除操作
        async function executeClearHistory() {
            const characterId = currentChatCharacter.id;
            console.log(`🧹 开始清理角色 ${characterId} 的聊天数据...`);
            showToast('正在进行深度清理...', 'info');

            // 获取用户选择
            const clearCore = document.getElementById('clear-core-memory')?.checked || false;
            const clearEpisodic = document.getElementById('clear-episodic-memory')?.checked || false;
            const clearTimeline = document.getElementById('clear-timeline')?.checked || false;

            // 移除模态框
            const modal = document.getElementById('clear-history-options-modal');
            if (modal) modal.remove();

            try {
                // 1. 清空聊天消息 (总是执行)
                chatMessages[characterId] = [];
                // 🔥【优化】清空消息后使用高效保存
                try {
                    await saveChatMessagesImmediate([characterId]);
                    console.log('✅ [高效清空] 消息已保存到数据库');
                } catch (error) {
                    console.error('清空消息保存失败，回退到全量保存:', error);
                    await saveChatMessages();
                }
                console.log('✅ 聊天消息已清空');

                // 2. 根据用户的勾选，选择性地清除记忆
                const contextId = characterId;

                if (clearCore) {
                    // 🔥【安全修复】兼容性查询：删除匹配contextId的记忆 + 没有contextId的旧记忆
                    const coreMemoriesToDelete = await db.coreMemories
                        .where('characterId').equals(characterId)
                        .and(memory => {
                            // 删除条件：contextId匹配 或者 没有contextId字段（旧数据）
                            return !memory.contextId || memory.contextId === contextId;
                        })
                        .primaryKeys();
                    if (coreMemoriesToDelete.length > 0) {
                        await db.coreMemories.bulkDelete(coreMemoriesToDelete);
                        console.log(`✅ 清除了 ${coreMemoriesToDelete.length} 条核心记忆`);
                    } else {
                        console.log(`ℹ️ 角色 ${characterId} 在当前上下文中没有核心记忆需要清除`);
                    }
                }

                if (clearEpisodic) {
                    // 🔥【安全修复】兼容性查询：删除匹配contextId的记忆 + 没有contextId的旧记忆
                    const episodicMemoriesToDelete = await db.episodicMemories
                        .where('characterId').equals(characterId)
                        .and(memory => {
                            // 删除条件：contextId匹配 或者 没有contextId字段（旧数据）
                            return !memory.contextId || memory.contextId === contextId;
                        })
                        .primaryKeys();
                    if (episodicMemoriesToDelete.length > 0) {
                        await db.episodicMemories.bulkDelete(episodicMemoriesToDelete);
                        console.log(`✅ 清除了 ${episodicMemoriesToDelete.length} 条情景记忆`);
                    } else {
                        console.log(`ℹ️ 角色 ${characterId} 在当前上下文中没有情景记忆需要清除`);
                    }
                }

                if (clearTimeline) {
                    // 🔥【修复】简化时间线查询条件：直接按characterId删除所有相关记录
                    const timelineEventsToDelete = await db.crossAppTimeline.where('characterId').equals(characterId).primaryKeys();
                    if (timelineEventsToDelete.length > 0) {
                        await db.crossAppTimeline.bulkDelete(timelineEventsToDelete);
                        console.log(`✅ 清除了 ${timelineEventsToDelete.length} 条时间线记录`);
                    } else {
                        console.log(`ℹ️ 角色 ${characterId} 没有时间线记录需要清除`);
                    }

                    // 🔥【修复】简化记忆摘要查询条件
                    const memorySummariesToDelete = await db.memorySummaries.where('characterId').equals(characterId).primaryKeys();
                    if (memorySummariesToDelete.length > 0) {
                        await db.memorySummaries.bulkDelete(memorySummariesToDelete);
                        console.log(`✅ 清除了 ${memorySummariesToDelete.length} 条记忆摘要`);
                    } else {
                        console.log(`ℹ️ 角色 ${characterId} 没有记忆摘要需要清除`);
                    }
                }

                // 3. 刷新界面
                renderChatMessages(characterId);
                renderMessageList();

                showToast('所选数据已彻底清除！', 'success');
                console.log(`🧹 角色 ${characterId} 的数据清理完成`);

                hideChatSettings();

            } catch (error) {
                console.error('深度清理失败:', error);
                showToast('清理失败，请检查控制台', 'error');
            }
        }

        // 清空聊天记录
        function clearChatHistory() {
            // 🔥【最终修复】不再直接执行删除，而是调用新的函数来显示带选项的模态框
            showClearHistoryOptionsModal();
        }

        // 选择颜色
        function selectColor(color) {
            document.querySelectorAll('.color-option').forEach(option => {
                option.classList.remove('selected');
            });
            event.target.classList.add('selected');
            document.getElementById('selected-color').value = color;
        }

        // 应用聊天背景
// 接受一个可选的 backgroundUrl 参数
async function applyChatBackground(backgroundUrl, skipSave = false) {
            if (!currentChatCharacter) return;

    console.log(`⚡ applyChatBackground 被调用: ${currentChatCharacter.name} (ID: ${currentChatCharacter.id}), skipSave: ${skipSave}`);

    // 1. 创建一个专属于当前聊天的背景设置字段
    // 注意：这里不再使用chatSettings对象，而是直接在character对象上添加背景属性
    if (!currentChatCharacter.background) {
        currentChatCharacter.background = null;
    }

    // 2. 决定最终要使用的背景。优先使用传入的参数，否则使用角色对象中的值
    const backgroundToApply = backgroundUrl !== undefined ? backgroundUrl : currentChatCharacter.background;

    // 3. 检查是否真的需要更新
    const needsUpdate = currentChatCharacter.background !== backgroundToApply;

    // 4. 更新角色对象中的设置
    currentChatCharacter.background = backgroundToApply;

    // 5. 🔥【优化】只在真正需要更新且不跳过保存时才保存
    if (needsUpdate && !skipSave) {
        console.log(`💾 [背景保存] ${currentChatCharacter.name}: 背景已更新，保存到数据库`);
        await saveCharacters();
    } else if (skipSave) {
        console.log(`⏭️ [背景保存] ${currentChatCharacter.name}: 跳过保存（skipSave=true）`);
    } else {
        console.log(`⏭️ [背景保存] ${currentChatCharacter.name}: 背景未变化，跳过保存`);
    }

    // 5. 直接设置背景样式
            const chatScreen = document.getElementById('api-chat-screen');
    if (!chatScreen) return;

    if (backgroundToApply) {
        console.log(`🖼️ 应用聊天背景: ${currentChatCharacter.name} (ID: ${currentChatCharacter.id})`);

        // 直接设置样式
        chatScreen.style.backgroundImage = `url(${backgroundToApply})`;
                    chatScreen.style.backgroundSize = 'cover';
                    chatScreen.style.backgroundPosition = 'center';
                    chatScreen.style.backgroundColor = 'transparent';

        const messagesContainer = document.getElementById('api-chat-messages');
                    if (messagesContainer) messagesContainer.style.background = 'transparent';
                } else {
        console.log(`🖼️ 重置聊天背景: ${currentChatCharacter.name} (ID: ${currentChatCharacter.id})`);

        // 重置为默认样式
                    chatScreen.style.backgroundImage = 'none';
                    chatScreen.style.backgroundColor = 'white';

        const messagesContainer = document.getElementById('api-chat-messages');
                    if (messagesContainer) messagesContainer.style.background = '';
                }

    console.log(`✅ 背景样式已应用: ${currentChatCharacter.name} (ID: ${currentChatCharacter.id})`);
        }

        // 保存气泡样式设置
        function saveBubbleStyleSettings() {
            const chatSettings = getCurrentChatSettings();

            // 保存样式设置
            chatSettings.bubbleStyle = window.selectedBubbleStyle || 'default';
            chatSettings.myBubbleColor = document.getElementById('my-bubble-color').value;
            chatSettings.aiBubbleColor = document.getElementById('ai-bubble-color').value;
            chatSettings.bubbleOpacity = document.getElementById('bubble-opacity').value;

            // 更新显示文本
            const styleNames = {
                'default': '默认样式',
                'shadow': '经典阴影',
                'tail': '经典气泡',
                'paper': '纸张样式'
            };

            document.getElementById('current-bubble-style').textContent = styleNames[chatSettings.bubbleStyle] || '默认样式';

            saveCurrentChatSettings(chatSettings);
            applyBubbleStyle();
            hideModal('bubble-style-modal');

            showToast('气泡样式设置已保存', 'success');
        }

        // 应用气泡样式
        function applyBubbleStyle() {
            // 🔥【修复】即使没有currentChatCharacter也要尝试应用样式
            const messagesContainer = document.getElementById('api-chat-messages');
            if (!messagesContainer) return;

            // 获取聊天设置，如果没有currentChatCharacter则使用默认设置
            let chatSettings = {};
            if (currentChatCharacter) {
                chatSettings = getCurrentChatSettings();
            } else {
                // 使用默认设置
                chatSettings = {
                    bubbleStyle: 'default',
                    myBubbleColor: '#007AFF',
                    aiBubbleColor: '#f0f0f0',
                    bubbleOpacity: '1'
                };
            }

            // 移除所有样式类
            messagesContainer.className = messagesContainer.className
                .split(' ')
                .filter(cls => !cls.startsWith('bubble-style-'))
                .join(' ');

            // 添加当前样式类
            const style = chatSettings.bubbleStyle || 'default';
            messagesContainer.classList.add(`bubble-style-${style}`);

            // 设置CSS变量用于动态颜色
            const myColor = chatSettings.myBubbleColor || '#007AFF';
            const aiColor = chatSettings.aiBubbleColor || '#f0f0f0';
            const opacity = chatSettings.bubbleOpacity || '1';

            messagesContainer.style.setProperty('--my-bubble-color', myColor);
            messagesContainer.style.setProperty('--ai-bubble-color', aiColor);
            messagesContainer.style.setProperty('--bubble-opacity', opacity);

            // 应用自定义CSS
            const customCSS = chatSettings.customBubbleCSS || '';
            applyCustomBubbleCSS();

            console.log(`🎨 气泡样式已应用: ${style} (角色: ${currentChatCharacter?.name || '无'})`);
        }

        // 显示气泡颜色选择器
        function showBubbleColorPicker(context) {
            colorPickerContext = context;
            document.getElementById('color-picker-title').textContent = '设置气泡颜色';
            showModal('color-picker-modal');
        }

        // 选择颜色
        function selectColor(color) {
            document.querySelectorAll('.color-option').forEach(option => {
                option.classList.remove('selected');
            });
            event.target.classList.add('selected');
            document.getElementById('selected-color').value = color;
        }

        // 应用颜色选择
        async function applyColorSelection() {
            const selectedColor = document.querySelector('.color-option.selected')?.style.backgroundColor || '#007AFF';
            const opacity = document.getElementById('opacity-slider').value;

            if (colorPickerContext === 'theirBubble') {
                chatSettings.theirBubbleColor = selectedColor;
                chatSettings.bubbleOpacity = opacity;
            } else if (colorPickerContext === 'myBubble') {
                chatSettings.myBubbleColor = selectedColor;
                chatSettings.bubbleOpacity = opacity;
            }

            await saveChatSettings();
            renderChatMessages(currentChatCharacter.id);
            hideModal('color-picker-modal');
        }

        // 显示壁纸选择器
        function showWallpaperPicker() {
            showModal('wallpaper-picker-modal');
        }

        // 选择壁纸（保留函数以防其他地方调用，但现在主要通过文件上传选择）
        function selectWallpaper(wallpaperId) {
            console.log('选择壁纸:', wallpaperId);
            selectedWallpaper = wallpaperId;
            console.log('selectedWallpaper已设置为:', selectedWallpaper);
        }

        // 应用壁纸选择
        async function applyWallpaperSelection() {
            console.log('应用壁纸被调用，selectedWallpaper:', selectedWallpaper);

            if (!selectedWallpaper) {
                alert('请先从相册选择一张图片作为壁纸');
                return;
            }

            if (selectedWallpaper.startsWith('data:image')) {
                // 应用上传的图片壁纸
                console.log('应用图片壁纸');
                document.querySelector('.wallpaper').style.backgroundImage = `url(${selectedWallpaper})`;
                    document.querySelector('.wallpaper').style.backgroundSize = '100% 100%';
                    document.querySelector('.wallpaper').style.backgroundPosition = 'center';

                // 使用IndexedDB保存壁纸，避免localStorage空间限制
                try {
                    await db.wallpapers.clear();
                    await db.wallpapers.add({
                        id: 'main',
                        type: 'image',
                        data: selectedWallpaper
                    });
                    console.log('壁纸保存成功到IndexedDB');
            hideModal('wallpaper-picker-modal');
                } catch (e) {
                    console.error('保存壁纸失败:', e);
                    alert('保存壁纸失败，请重试');
                }
            } else {
                alert('请先从相册选择一张图片作为壁纸');
            }
        }

        // 上传自定义壁纸
        function uploadCustomWallpaper() {
            document.getElementById('custom-wallpaper-upload').click();
        }

        // 全局变量
        let selectedAppForIcon = null;
        let uploadedIconImage = null;

        // 显示图标选择器
        function showIconPicker() {
            generateAppList();
            showModal('icon-picker-modal');
        }

        // 生成应用列表
        function generateAppList() {
            const container = document.getElementById('app-list-container');
            container.innerHTML = '';

            // 获取所有应用的信息
            const apps = [
                // 主屏幕应用
                { id: 'chat-screen', name: 'Chat', selector: '.mini-app[onclick="showApp(\'chat-screen\')"] .mini-app-icon' },
                { id: 'worldbook-screen', name: '世界书', selector: '.mini-app[onclick*="worldbook-screen"] .mini-app-icon' },
                { id: 'anniversary-screen', name: '纪念日', selector: '.mini-app[onclick="showApp(\'anniversary-screen\')"] .mini-app-icon' },
                // 🔥【修复】论坛app使用更直接的选择器，通过父元素查找
                { id: 'forum-screen', name: '论坛', selector: '.home-section.bottom-left .mini-app:nth-child(2) .mini-app-icon' },
                // Dock栏应用
                { id: 'messages-screen', name: '短信', selector: '.dock-app[onclick="showApp(\'messages-screen\')"] .dock-app-icon' },
                { id: 'settings-screen', name: '设置', selector: '.dock-app[onclick="showApp(\'settings-screen\')"] .dock-app-icon' },
                { id: 'memory-viewer-screen', name: '记忆', selector: '.dock-app[onclick="showApp(\'memory-viewer-screen\')"] .dock-app-icon' }
            ];

            apps.forEach(app => {
                const appElement = document.querySelector(app.selector);
                if (appElement) {
                    const appItem = document.createElement('div');
                    appItem.className = 'app-item-selector';
                    appItem.onclick = () => selectAppForIcon(app.id, app.name, app.selector);

                    // 获取当前图标
                    const iconHtml = appElement.innerHTML;

                    appItem.innerHTML = `
                        <div class="app-item-icon">
                            ${iconHtml}
                        </div>
                        <div class="app-item-name">${app.name}</div>
                    `;

                    container.appendChild(appItem);
                }
            });
        }

        // 选择要修改图标的应用
        function selectAppForIcon(appId, appName, selector) {
            selectedAppForIcon = { id: appId, name: appName, selector: selector };

            // 更新选中状态
            document.querySelectorAll('.app-item-selector').forEach(item => {
                item.classList.remove('selected');
            });
            event.currentTarget.classList.add('selected');

            // 显示上传区域
            document.getElementById('icon-upload-section').style.display = 'block';

            // 重置上传状态
            resetIconUpload();
        }

        // 触发图标上传
        function triggerIconUpload() {
            if (!selectedAppForIcon) {
                alert('请先选择要修改的应用');
                return;
            }
            document.getElementById('custom-icon-upload').click();
        }

        // 重置图标上传
        function resetIconUpload() {
            uploadedIconImage = null;
            document.getElementById('upload-placeholder').style.display = 'block';
            document.getElementById('icon-preview-img').style.display = 'none';
            document.querySelector('.upload-area').classList.remove('has-image');
            document.getElementById('apply-icon-btn').style.display = 'none';
        }

        // 应用图标更改
        async function applyIconChange() {
            if (!selectedAppForIcon || !uploadedIconImage) {
                alert('请选择应用和上传图标');
                return;
            }

            try {
                // 更新应用图标
                const appIconElement = document.querySelector(selectedAppForIcon.selector);
                if (appIconElement) {
                    appIconElement.innerHTML = `<img src="${uploadedIconImage}" alt="${selectedAppForIcon.name}" class="app-icon-img">`;
                }

                // 保存到IndexedDB
                await saveCustomAppIcon(selectedAppForIcon.id, uploadedIconImage);

                showToast('应用图标已更新！', 'success');
                hideModal('icon-picker-modal');

                // 重置状态
                selectedAppForIcon = null;
                uploadedIconImage = null;
            } catch (error) {
                console.error('更新应用图标失败:', error);
                showToast('更新失败，请重试', 'error');
            }
        }

        // 保存自定义应用图标到IndexedDB
        async function saveCustomAppIcon(appId, imageData) {
            try {
                await db.appIcons.put({
                    id: appId,
                    appId: appId,
                    imageData: imageData,
                    updatedAt: new Date()
                });
                console.log('应用图标已保存:', appId);
            } catch (error) {
                console.error('保存应用图标失败:', error);
                throw error;
            }
        }

        // 加载自定义应用图标
        async function loadCustomAppIcons() {
            try {
                const customIcons = await db.appIcons.toArray();
                customIcons.forEach(iconData => {
                    if (iconData.imageData) {
                        // 查找对应的应用图标元素并更新
                        const apps = [
                            { id: 'chat-screen', selector: '.mini-app[onclick="showApp(\'chat-screen\')"] .mini-app-icon' },
                            { id: 'worldbook-screen', selector: '.mini-app[onclick*="worldbook-screen"] .mini-app-icon' },
                            { id: 'anniversary-screen', selector: '.mini-app[onclick="showApp(\'anniversary-screen\')"] .mini-app-icon' },
                            // 🔥【修复】论坛app使用更直接的选择器
                            { id: 'forum-screen', selector: '.home-section.bottom-left .mini-app:nth-child(2) .mini-app-icon' },
                            { id: 'messages-screen', selector: '.dock-app[onclick="showApp(\'messages-screen\')"] .dock-app-icon' },
                            { id: 'settings-screen', selector: '.dock-app[onclick="showApp(\'settings-screen\')"] .dock-app-icon' },
                            { id: 'memory-viewer-screen', selector: '.dock-app[onclick="showApp(\'memory-viewer-screen\')"] .dock-app-icon' }
                        ];

                        const app = apps.find(a => a.id === iconData.appId);
                        if (app) {
                            const appIconElement = document.querySelector(app.selector);
                            if (appIconElement) {
                                appIconElement.innerHTML = `<img src="${iconData.imageData}" alt="${iconData.appId}" class="app-icon-img">`;
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('加载自定义应用图标失败:', error);
            }
        }

        // 初始化应用图标上传功能
        function initializeIconUpload() {
            const iconInput = document.getElementById('custom-icon-upload');
            if (!iconInput) {
                console.error('找不到custom-icon-upload元素');
                return;
            }

            // 移除旧的事件监听器（如果存在）
            iconInput.removeEventListener('change', handleIconUpload);

            // 添加新的事件监听器
            iconInput.addEventListener('change', handleIconUpload);
            console.log('应用图标上传事件监听器已绑定');
        }

        // 处理图标上传
        async function handleIconUpload(e) {
            if (e.target.files && e.target.files[0]) {
                const file = e.target.files[0];

                // 检查文件类型
                if (!file.type.startsWith('image/')) {
                    alert('请选择图片文件');
                    return;
                }

                // 检查文件大小（限制为5MB）
                if (file.size > 5 * 1024 * 1024) {
                    alert('图片文件不能超过5MB');
                    return;
                }

                try {
                    // 压缩图片
                    const compressedImage = await compressImage(file, 200, 0.8);

                    // 更新预览
                    const uploadArea = document.querySelector('.upload-area');
                    const placeholder = document.getElementById('upload-placeholder');
                    const previewImg = document.getElementById('icon-preview-img');

                    placeholder.style.display = 'none';
                    previewImg.src = compressedImage;
                    previewImg.style.display = 'block';
                    uploadArea.classList.add('has-image');

                    // 保存图片数据
                    uploadedIconImage = compressedImage;

                    // 显示应用按钮
                    document.getElementById('apply-icon-btn').style.display = 'inline-block';

                    showToast('图片上传成功！', 'success');
                } catch (error) {
                    console.error('处理图片失败:', error);
                    showToast('图片处理失败，请重试', 'error');
                }
            }
        }

        // 更改聊天主题颜色
        function changeChatThemeColor() {
            colorPickerContext = 'theme';
            document.getElementById('color-picker-title').textContent = '设置聊天主题颜色';
            showModal('color-picker-modal');
        }



        // 显示消息菜单
        function showMessageMenu(messageId, event) {
            selectedMessageId = messageId;
            console.log('桌面端右键菜单，设置selectedMessageId:', selectedMessageId);

            // 先隐藏现有菜单，确保清理事件监听器
            hideMessageMenu();

            // 创建或获取菜单元素
            let menu = document.getElementById('message-context-menu');
            if (!menu) {
                menu = document.createElement('div');
                menu.id = 'message-context-menu';
                menu.className = 'message-menu';
                document.body.appendChild(menu);
            }

            // 🔥【修复】每次都重新设置菜单内容，避免事件绑定问题
            // 检查消息是否是用户发送的（只有用户消息可以编辑和撤回）
            const messages = chatMessages[currentChatCharacter.id] || [];
            const message = messages.find(msg => msg.id === messageId);
            const isUserMessage = message && message.sender === 'sent';

            let menuItems = [
                '<div class="message-menu-item" data-action="reply">引用</div>',
                '<div class="message-menu-item" data-action="copy">复制</div>'
            ];

            // 🔥【新增】只有AI角色消息才显示心声选项
            if (!isUserMessage) {
                menuItems.push('<div class="message-menu-item" data-action="inner-thoughts">心声</div>');
            }

            // 🔥【修复】所有消息都可以编辑，用户消息可以撤回
            menuItems.push('<div class="message-menu-item" data-action="edit">编辑</div>');

            if (isUserMessage) {
                menuItems.push('<div class="message-menu-item" data-action="recall">撤回</div>');
            }

            menuItems.push('<div class="message-menu-item" data-action="select">多选</div>');

            menu.innerHTML = menuItems.join('');

            // 🔥【修复】使用事件委托绑定点击事件，避免内联onclick问题
            menu.onclick = function(e) {
                const action = e.target.dataset.action;
                if (action) {
                    e.stopPropagation();
                    console.log('菜单点击，action:', action, 'selectedMessageId:', selectedMessageId);

                    // 🔥【临时修复】直接使用传入的messageId而不是全局变量
                    const targetId = messageId;
                    console.log('使用messageId:', targetId);

                    switch(action) {
                        case 'reply':
                            replyToMessage(targetId);
                            break;
                        case 'copy':
                            copyMessage(targetId);
                            break;
                        case 'edit':
                            showEditMessageModal(targetId);
                            break;
                        case 'recall':
                            deleteMessage(targetId);
                            break;
                        case 'inner-thoughts':
                            showInnerThoughtsModal(targetId);
                            break;
                        case 'select':
                            enterMessageSelectionMode(targetId);
                            break;
                    }
                    // 🔥【修复】手动隐藏菜单，不传递事件参数
                    hideMessageMenu(null);
                }
            };

            // 定位菜单
            const x = event.clientX || event.pageX;
            const y = event.clientY || event.pageY;

            menu.style.display = 'block';
            menu.style.left = `${Math.min(x, window.innerWidth - 150)}px`;
            menu.style.top = `${Math.min(y, window.innerHeight - 100)}px`;

            // 🔥【修复】延迟添加外部点击监听器，避免立即触发
            setTimeout(() => {
                // 先移除可能存在的旧监听器
                document.removeEventListener('click', hideMessageMenu);
                document.removeEventListener('touchstart', hideMessageMenu);
                // 添加新的监听器
                document.addEventListener('click', hideMessageMenu);
                document.addEventListener('touchstart', hideMessageMenu);
            }, 100);
        }

        // 隐藏消息菜单
        function hideMessageMenu(event) {
            // 🔥【修复】如果点击来自菜单内部，不隐藏菜单
            if (event && event.target) {
                const menu = document.getElementById('message-context-menu');
                if (menu && menu.contains(event.target)) {
                    return;
                }
            }

            const menu = document.getElementById('message-context-menu');
            if (menu) {
                menu.style.display = 'none';
                // 🔥【修复】清理菜单的点击事件处理器
                menu.onclick = null;
            }
            // 🔥【修复】确保移除外部点击监听器
            document.removeEventListener('click', hideMessageMenu);
            document.removeEventListener('touchstart', hideMessageMenu);
            // 🔥【修复】重置选中的消息ID
            selectedMessageId = null;
        }

        // 引用消息功能
        let currentReplyTo = null;

        // 🔥【新增】每个聊天的引用状态存储
        let chatReplyStates = {};

        // 🔥【修复】引用消息 - 支持传入消息ID
        function replyToMessage(messageId = null) {
            const targetMessageId = messageId || selectedMessageId;
            console.log('引用消息:', targetMessageId, '来源:', messageId ? '移动端' : '桌面端');
            if (!targetMessageId) {
                console.log('错误: 没有选中的消息ID');
                return;
            }

            const messages = chatMessages[currentChatCharacter.id] || [];
            const message = messages.find(msg => msg.id === targetMessageId);

            if (message) {
                // 设置引用信息
                let messageContent = '[消息]';

                // 🔥【统一格式】处理数组格式的消息内容
                if (Array.isArray(message.content)) {
                    const textPart = message.content.find(p => p.type === 'text');
                    const imagePart = message.content.find(p => p.type === 'image_url');

                    if (textPart?.text) {
                        messageContent = textPart.text;
                    } else if (imagePart) {
                        messageContent = '[图片]';
                    } else {
                        messageContent = '[多媒体消息]';
                    }
                } else if (message.type === 'forwarded_message') {
                    // 🔥【新增】转发消息特殊处理 - 显示转发内容预览
                    messageContent = `[转发] ${message.content}`;
                    if (message.forwardedMessages && message.forwardedMessages.length > 0) {
                        const firstMsg = message.forwardedMessages[0];
                        const senderName = firstMsg.sender === 'sent' ? (firstMsg.userName || '用户') : (firstMsg.name || firstMsg.characterName || 'AI');
                        // 🔥【修复】使用safeExtractMessageContent安全地提取消息内容，避免[object Object]问题
                        const firstMsgContent = safeExtractMessageContent(firstMsg);
                        messageContent += ` - ${senderName}: ${firstMsgContent.substring(0, 20)}...`;
                    }
                } else if (typeof message.content === 'string') {
                    messageContent = message.content;
                } else if (message.image) {
                    // 🔥【新增】处理旧格式的图片消息
                    messageContent = '[图片]';
                } else {
                    messageContent = '[特殊消息]';
                }

                currentReplyTo = {
                    id: message.id,
                    content: messageContent,
                    sender: message.sender,
                    timestamp: message.timestamp,
                    senderName: getSenderDisplayName(message)
                };

                // 🔥【新增】保存当前聊天的引用状态
                if (currentChatCharacter) {
                    chatReplyStates[currentChatCharacter.id] = { ...currentReplyTo };
                }

                // 显示引用预览
                showReplyPreview();

                // 聚焦到输入框
                const inputBox = document.getElementById('api-chat-input');
                if (inputBox) {
                    inputBox.focus();
                }
            }

            hideMessageMenu();
        }

        // 获取发送者显示名称
        function getSenderDisplayName(message) {
            if (message.sender === 'sent') {
                const chatSettings = getCurrentChatSettings();
                if (chatSettings.selectedIdentityId) {
                    const persona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                    if (persona) return persona.name;
                }
                return chatSettings.myChatNickname || '我';
            } else if (message.sender === 'received') {
                // 检查是否是群聊
                const group = groupChats.find(g => g.id === currentChatCharacter.id);
                if (group) {
                    // 群聊中，根据消息的senderId或name查找成员
                    let member = null;
                    if (message.senderId) {
                        member = group.members.find(m => m.id === message.senderId);
                    } else if (message.name) {
                        member = group.members.find(m => m.name === message.name);
                    }
                    return member?.name || '群成员';
                } else {
                    // 单聊
                    const chatSettings = getCurrentChatSettings();
                    return chatSettings.aiChatNickname || currentChatCharacter.name;
                }
            }
            return '未知';
        }

        // 显示引用预览
        function showReplyPreview() {
            if (!currentReplyTo) return;

            // 移除已存在的引用预览
            const existingPreview = document.getElementById('reply-preview');
            if (existingPreview) {
                existingPreview.remove();
            }

            // 创建引用预览元素
            const replyPreview = document.createElement('div');
            replyPreview.id = 'reply-preview';
            replyPreview.className = 'reply-preview';

            // 截断显示内容 - 缩短到25字符
            const displayContent = truncateText(currentReplyTo.content, 25);

            replyPreview.innerHTML = `
                <div class="reply-preview-content">
                    <div class="reply-preview-line"></div>
                    <div class="reply-preview-text">
                        <div class="reply-preview-sender">${currentReplyTo.senderName}</div>
                        <div class="reply-preview-message">${displayContent}</div>
                    </div>
                    <button class="reply-preview-close" onclick="cancelReply()">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `;

            // 🔥【修复】确保引用预览可见
            replyPreview.style.display = 'block';
            replyPreview.style.visibility = 'visible';

            // 插入到输入区域内部的顶部
            const inputArea = document.querySelector('.chat-input-area');
            if (inputArea) {
                // 将引用预览插入到输入区域的第一个子元素之前
                const firstChild = inputArea.firstElementChild;
                if (firstChild) {
                    inputArea.insertBefore(replyPreview, firstChild);
                } else {
                    inputArea.appendChild(replyPreview);
                }
            }
        }

        // 取消引用
        function cancelReply() {
            currentReplyTo = null;

            // 🔥【新增】清除当前聊天的引用状态
            if (currentChatCharacter) {
                delete chatReplyStates[currentChatCharacter.id];
            }

            const replyPreview = document.getElementById('reply-preview');
            if (replyPreview) {
                replyPreview.remove();
            }
        }

        // 生成引用消息的HTML
        function generateReplyHTML(replyTo) {
            if (!replyTo) return '';

            let displayContent = truncateText(replyTo.content, 20);
            // 处理引用消息中的@内容
            displayContent = processMentions(displayContent);

            return `
                <div class="reply-reference">
                    <div class="reply-reference-line"></div>
                    <div class="reply-reference-content">
                        <div class="reply-reference-sender">${replyTo.senderName}</div>
                        <div class="reply-reference-message">${displayContent}</div>
                    </div>
                </div>
            `;
        }

        // 复制消息
        function copyMessage(messageId = null) {
            const targetMessageId = messageId || selectedMessageId;
            console.log('复制消息:', targetMessageId, '来源:', messageId ? '移动端' : '桌面端');
            if (!targetMessageId) {
                console.log('错误: 没有选中的消息ID');
                return;
            }

            const messages = chatMessages[currentChatCharacter.id] || [];
            const message = messages.find(msg => msg.id === targetMessageId);

            if (message) {
                // 🔥【修复】使用safeExtractMessageContent安全地提取消息内容，避免[object Object]问题
                const messageContent = safeExtractMessageContent(message);
                navigator.clipboard.writeText(messageContent).then(() => {
                    alert('消息已复制');
                }).catch(() => {
                    alert('复制失败，请重试');
                });
            }

            hideMessageMenu();
        }

        // 显示编辑消息模态框
        function showEditMessageModal(messageId) {
            if (!messageId) return;

            const messages = chatMessages[currentChatCharacter.id] || [];
            const message = messages.find(msg => msg.id === messageId);

            if (!message) {
                showToast('消息不存在', 'error');
                return;
            }

            // 🔥【修复】使用通用函数安全地提取消息内容
            let messageContent = '';
            try {
                messageContent = safeExtractMessageContent(message);
                // 如果提取的内容是特殊消息类型的描述，提示用户重新输入
                if (messageContent.startsWith('[') && messageContent.endsWith(']')) {
                    messageContent = '[此消息包含特殊格式，请重新输入内容]';
                    console.warn('编辑消息时发现特殊类型的content:', message);
                }
            } catch (error) {
                console.error('提取消息内容时出错:', error);
                messageContent = '[此消息包含特殊格式，请重新输入内容]';
            }

            // 创建编辑模态框
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.id = 'edit-message-modal';

            const senderName = message.sender === 'sent' ? '你' : (message.name || currentChatCharacter.name);

            modal.innerHTML = `
                <div class="modal-content edit-message-modal">
                    <div class="modal-header">
                        <h3>编辑消息</h3>
                        <button class="modal-close" onclick="hideEditMessageModal()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="edit-message-info">
                            <span class="message-sender">${senderName}</span>
                            <span class="message-time">${formatTimestamp(message.timestamp)}</span>
                        </div>
                        <div class="edit-form-group">
                            <label>消息内容：</label>
                            <textarea
                                id="edit-message-content"
                                class="edit-message-textarea"
                                placeholder="请输入消息内容..."
                                maxlength="2000"
                            >${messageContent}</textarea>
                            <div class="edit-message-counter">
                                <span id="edit-char-count">${messageContent.length}</span>/2000
                            </div>
                        </div>
                        ${message.image ? `
                            <div class="edit-form-group">
                                <label>图片：</label>
                                <div class="edit-message-image">
                                    <img src="${message.image}" alt="消息图片" />
                                    <button class="remove-image-btn" onclick="removeMessageImage()">删除图片</button>
                                </div>
                            </div>
                        ` : ''}
                    </div>
                    <div class="modal-footer">
                        <button class="modal-btn modal-cancel" onclick="hideEditMessageModal()">取消</button>
                        <button class="modal-btn modal-confirm" onclick="saveEditedMessage('${messageId}')">保存</button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // 添加字符计数功能
            const textarea = document.getElementById('edit-message-content');
            const charCount = document.getElementById('edit-char-count');
            textarea.addEventListener('input', function() {
                charCount.textContent = this.value.length;
            });

            // 🔥【修复】聚焦但不选中文本，光标移到末尾
            setTimeout(() => {
                textarea.focus();
                textarea.setSelectionRange(textarea.value.length, textarea.value.length);
            }, 100);
        }

        // 隐藏编辑消息模态框
        function hideEditMessageModal() {
            const modal = document.getElementById('edit-message-modal');
            if (modal) {
                modal.remove();
            }
        }

        // 保存编辑后的消息
        async function saveEditedMessage(messageId) {
            const newContent = document.getElementById('edit-message-content').value.trim();

            if (!newContent) {
                showToast('消息内容不能为空', 'error');
                return;
            }

            const messages = chatMessages[currentChatCharacter.id] || [];
            const messageIndex = messages.findIndex(msg => msg.id === messageId);

            if (messageIndex !== -1) {
                const oldContent = messages[messageIndex].content;

                // 🔥【修复】确保content字段始终是字符串，防止[object Object]问题
                if (typeof newContent === 'string') {
                    messages[messageIndex].content = newContent;
                } else {
                    console.warn('编辑消息时检测到非字符串内容，强制转换为字符串:', newContent);
                    messages[messageIndex].content = String(newContent);
                }

                // 添加编辑标记
                messages[messageIndex].edited = true;
                messages[messageIndex].editTime = Date.now();

                // 🔥【修复】在保存到数据库前，再次确保消息数据格式正确
                const messageToSave = {
                    ...messages[messageIndex],
                    content: String(messages[messageIndex].content) // 强制确保content是字符串
                };

                // 🔥【高效保存】直接更新数据库中的单条消息，避免全量重写
                try {
                    const dbMessage = await db.chatMessages
                        .where('characterId').equals(currentChatCharacter.id)
                        .and(msg => msg.originalMessageId === messages[messageIndex].id)
                        .first();

                    if (dbMessage) {
                        dbMessage.messageData = messageToSave;
                        await db.chatMessages.put(dbMessage);
                        console.log('✅ [高效编辑] 消息编辑已保存到数据库');
                    }
                } catch (error) {
                    console.error('编辑消息单条保存失败，回退到批量保存:', error);
                    saveChatMessages();
                }
                renderChatMessages(currentChatCharacter.id);
                hideEditMessageModal();

                showToast('消息已更新', 'success');

                console.log(`消息已编辑: "${oldContent}" -> "${newContent}"`);
            } else {
                showToast('消息不存在', 'error');
            }
        }

        // 移除消息图片
        function removeMessageImage() {
            // 这个功能可以在后续扩展
            showToast('暂不支持移除图片', 'info');
        }

        // 编辑消息（保留旧版本接口）
        function editMessage() {
            if (!selectedMessageId) return;

            showEditMessageModal(selectedMessageId);
            hideModal('message-menu-modal');
        }

        // 验证头像来源是否有效
        async function validateAvatarSource(avatarUrl) {
            console.log('验证头像来源:', avatarUrl);
            if (!avatarUrl) return false;

            // 🔥【修复】处理占位符，先替换为实际图片URL再验证
            let actualAvatarUrl = avatarUrl;
            if (avatarUrl === 'CURRENT_USER_IMAGE' ||
                avatarUrl === 'CURRENT_USER_IMAGE' ||
                avatarUrl === '用户发送的图片URL' ||
                avatarUrl === '图片URL') {
                const recentUserImage = getRecentUserImage();
                if (recentUserImage) {
                    actualAvatarUrl = recentUserImage;
                    console.log('占位符替换为实际图片URL:', actualAvatarUrl);
                } else {
                    console.log('没有找到用户发送的图片，验证失败');
                    return false;
                }
            }

            // 检查是否是用户发送的图片（在聊天记录中）
            if (currentChatCharacter && chatMessages[currentChatCharacter.id]) {
                const userImages = [];

                // 遍历所有用户发送的消息，提取图片URL
                chatMessages[currentChatCharacter.id]
                    .filter(msg => msg.sender === 'sent')
                    .forEach(msg => {
                        // 处理旧格式的图片消息（直接有 image 字段）
                        if (msg.image) {
                            userImages.push(msg.image);
                        }

                        // 处理新格式的多模态消息（content 是数组）
                        if (Array.isArray(msg.content)) {
                            msg.content.forEach(item => {
                                if (item.type === 'image_url' && item.image_url && item.image_url.url) {
                                    userImages.push(item.image_url.url);
                                }
                            });
                        }
                    });

                console.log('用户发送的图片列表:', userImages);
                console.log('检查头像URL是否在用户图片中:', userImages.includes(actualAvatarUrl));

                if (userImages.includes(actualAvatarUrl)) {
                    console.log('头像来源验证通过：用户发送的图片');
                    return true;
                }
            }

            // 检查是否是世界书中提供的头像URL
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.worldbookMountEnabled && chatSettings.selectedWorldbooks) {
                for (const worldbookId of chatSettings.selectedWorldbooks) {
                    const worldbook = worldbooks.find(w => w.id === worldbookId);
                    if (worldbook && worldbook.content && worldbook.content.includes(actualAvatarUrl)) {
                        console.log('头像来源验证通过：世界书中的URL');
                        return true;
                    }
                }
            }

            console.log('头像来源验证失败');
            return false;
        }

        // 角色主动更换头像功能 - 只修改聊天设置中的头像，不修改角色卡
        async function changeCharacterAvatarByAI(newAvatarUrl, reason = '') {
            if (!currentChatCharacter || !newAvatarUrl) return false;

            try {
                // 获取或创建当前聊天的设置
                const currentSettings = getCurrentChatSettings();

                // 压缩头像图片以减少存储空间
                let compressedAvatarUrl = newAvatarUrl;
                if (newAvatarUrl.startsWith('data:image')) {
                    try {
                        compressedAvatarUrl = await compressImage(newAvatarUrl, 200, 0.7);
                        console.log('头像已压缩以节省存储空间');
                    } catch (error) {
                        console.warn('头像压缩失败，使用原图:', error);
                    }
                }

                // 🔥【修复】直接覆盖聊天头像字段，AI换头像会覆盖用户设置
                if (!chatSettings[currentChatCharacter.id]) {
                    chatSettings[currentChatCharacter.id] = {};
                }
                chatSettings[currentChatCharacter.id].aiChatAvatar = compressedAvatarUrl;

                console.log(`聊天头像已更新：`, {
                    characterId: currentChatCharacter.id,
                    characterName: currentChatCharacter.name,
                    avatarUrl: compressedAvatarUrl.substring(0, 50) + '...',
                    settingsSnapshot: {
                        aiChatAvatar: !!chatSettings[currentChatCharacter.id].aiChatAvatar
                    }
                });

                // 保存聊天设置
                await saveChatSettings();

                // 发送系统提示消息
                const systemMessage = {
                    id: Date.now().toString(),
                    sender: 'system',
                    content: `${currentChatCharacter.name} 更换了头像${reason ? ': ' + reason : ''}`,
                    timestamp: Date.now(),
                    isAvatarChange: true
                };

                if (!chatMessages[currentChatCharacter.id]) {
                    chatMessages[currentChatCharacter.id] = [];
                }
                chatMessages[currentChatCharacter.id].push(systemMessage);
                // 🔥【优化】头像更换系统消息使用高效保存
                try {
                    await saveChatMessagesImmediate([currentChatCharacter.id]);
                    console.log('✅ [高效头像更换系统消息] 消息已保存到数据库');
                } catch (error) {
                    console.error('头像更换系统消息保存失败，回退到全量保存:', error);
                    await saveChatMessages();
                }

                // 🔥【修复】在保存消息后再刷新聊天界面，确保包含新头像和系统消息
                renderChatMessages(currentChatCharacter.id);

                // 🔥【新增】强制刷新所有头像显示
                forceRefreshAvatars();

                console.log(`角色 ${currentChatCharacter.name} 在当前聊天中更换了头像，但角色卡保持不变`);

                return true;
            } catch (error) {
                console.error('角色更换头像失败:', error);
                return false;
            }

            return false;
        }

        // 删除消息
        async function deleteMessage(messageId = null) {
            const targetMessageId = messageId || selectedMessageId;
            console.log('删除消息:', targetMessageId, '来源:', messageId ? '移动端' : '桌面端');
            if (!targetMessageId) {
                console.log('错误: 没有选中的消息ID');
                return;
            }

                const messages = chatMessages[currentChatCharacter.id] || [];
                const messageIndex = messages.findIndex(msg => msg.id === targetMessageId);

            if (messageIndex === -1) {
                hideMessageMenu();
                return;
            }

            const messageToDelete = messages[messageIndex];

            if (confirm('确定要撤回这条消息吗？')) {
                // 🔥【修复】删除相关的时间线记录和工作记忆
                try {
                    await deleteRelatedTimelineEvents(messageToDelete);
                    console.log('✅ 已清理撤回消息的相关时间线记录');
                } catch (error) {
                    console.error('删除时间线记录失败:', error);
                }

                // 🔥【终极修复】使用统一的撤回处理函数
                await _internalRecallMessage(currentChatCharacter.id, messageToDelete);
            }

            hideMessageMenu();
        }

        // 🔥【新增】检查存储使用情况的辅助函数
        async function checkStorageUsage() {
            try {
                if ('storage' in navigator && 'estimate' in navigator.storage) {
                    const estimate = await navigator.storage.estimate();
                    const usedMB = (estimate.usage || 0) / (1024 * 1024);
                    const quotaMB = (estimate.quota || 0) / (1024 * 1024);
                    const usagePercent = quotaMB > 0 ? (usedMB / quotaMB) * 100 : 0;

                    return {
                        usedMB: usedMB,
                        quotaMB: quotaMB,
                        usagePercent: usagePercent,
                        needCleanup: usagePercent > 80 // 超过80%时需要清理
                    };
                }
            } catch (error) {
                console.warn('无法检查存储使用情况:', error);
            }
            return null;
        }

        // 🔥【新增】智能数据清理函数
        async function performSmartDataCleanup() {
            try {
                // 简单的清理策略：保留最近的消息
                const allMessages = await db.chatMessages.orderBy('timestamp').toArray();
                if (allMessages.length > 5000) {
                    const messagesToDelete = allMessages.slice(0, allMessages.length - 3000);
                    const idsToDelete = messagesToDelete.map(msg => msg.id);
                    await db.chatMessages.bulkDelete(idsToDelete);
                    console.log(`🧹 清理了 ${idsToDelete.length} 条旧消息`);
                }
            } catch (error) {
                console.error('数据清理失败:', error);
            }
        }

        /**
         * 🔥【终极修复版 & 动画恢复】统一的内部撤回消息处理函数
         * @param {string} characterId - 角色ID
         * @param {object} messageToRecall - 要撤回的消息对象
         */
        async function _internalRecallMessage(characterId, messageToRecall) {
            const messages = chatMessages[characterId] || [];
            const messageIndex = messages.findIndex(msg => msg.id === messageToRecall.id);

            if (messageIndex === -1) {
                console.error('❌ [核心撤回] 未在内存中找到要撤回的消息:', messageToRecall);
                return;
            }

            // 1. 🔥【动画恢复】在数据操作前，先播放UI动画
            const messageContainer = document.querySelector(`[data-message-id="${messageToRecall.id}"]`);
            if (messageContainer) {
                console.log('🎬 [核心撤回] 播放撤回动画...');
                // 使用你CSS中已有的fadeOut动画
                messageContainer.style.animation = 'fadeOut 0.5s ease-in-out forwards';
                await new Promise(resolve => setTimeout(resolve, 500)); // 等待动画完成
            }

            // 2. 🔥【高效撤回】直接在数据库中修改单条消息，避免全量重写
            try {
                // 找到数据库中对应的消息
                const dbMessage = await db.chatMessages
                    .where('characterId').equals(characterId)
                    .and(msg => msg.originalMessageId === messageToRecall.id)
                    .first();

                if (dbMessage) {
                    // 🔥【修复】使用通用函数安全地提取原消息内容，防止[object Object]问题
                    const originalContentText = safeExtractMessageContent(messageToRecall);

                    // 直接修改数据库中的消息内容
                    const whoRecalled = messageToRecall.sender === 'sent' ? '你' : (currentChatCharacter.name || '对方');
                    dbMessage.messageData = {
                        ...dbMessage.messageData,
                        sender: 'system', // 🔥【关键修复】确保数据库中也是系统消息
                        type: 'recalled_message',
                        content: `${whoRecalled}撤回了一条消息\n原文：${originalContentText}`, // 🔥【修复】使用安全提取的内容
                        originalContent: originalContentText, // 🔥【修复】保存安全提取的内容
                        isRecalled: true
                    };

                    // 单条消息更新，不触发全量重写
                    await db.chatMessages.put(dbMessage);
                    console.log('✅ [高效撤回] 数据库单条消息更新完成');
                }
            } catch (error) {
                console.error('数据库更新失败，回退到传统方式:', error);
            }

            // 3. 更新内存中的消息为系统消息格式
            // 🔥【修复】使用通用函数安全地提取原消息内容
            const originalContentText = safeExtractMessageContent(messageToRecall);

            const whoRecalled = messageToRecall.sender === 'sent' ? '你' : (currentChatCharacter.name || '对方');
            messages[messageIndex] = {
                id: messageToRecall.id,
                sender: 'system', // 🔥【关键修复】确保是系统消息
                type: 'recalled_message',
                content: `${whoRecalled}撤回了一条消息\n原文：${originalContentText}`, // 🔥【修复】使用安全提取的内容
                originalContent: originalContentText, // 🔥【修复】保存安全提取的内容
                timestamp: messageToRecall.timestamp,
                isRecalled: true
            };

            // 4. 刷新UI（不调用saveChatMessages，避免哈希检测）
            renderChatMessages(characterId);
            renderMessageList(); // 更新消息列表的最后一条消息预览

            console.log(`🎉 [高效撤回] 角色 ${characterId} 的消息 ${messageToRecall.id} 已成功撤回`);
        }


        // 格式化时间
        function formatTime(timestamp) {
            const date = new Date(timestamp);
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        }

        // 格式化时间戳（完整时间）
        function formatTimestamp(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const yesterday = new Date(today.getTime() - 24 * 60 * 60 * 1000);
            const messageDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());

            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            const timeStr = `${hours}:${minutes}`;

            if (messageDate.getTime() === today.getTime()) {
                return timeStr; // 今天只显示时间
            } else if (messageDate.getTime() === yesterday.getTime()) {
                return `昨天 ${timeStr}`;
            } else {
                const month = (date.getMonth() + 1).toString().padStart(2, '0');
                const day = date.getDate().toString().padStart(2, '0');
                return `${month}月${day}日 ${timeStr}`;
            }
        }

        // 格式化时间（仅时分）
        function formatTimeOnly(timestamp) {
            const date = new Date(timestamp);
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        }

        // 格式化完整日期
        function formatFullDate(date) {
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${year}年${month}月${day}日 ${hours}:${minutes}`;
        }

        // 加载URL
        function loadUrl() {
            const url = document.getElementById('browser-url').value;
            let fullUrl = url;

            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                fullUrl = 'https://' + url;
            }

            document.getElementById('browser-frame').src = fullUrl;
        }

        // 旧版本API类型切换处理已删除 - 使用新版本的API设置系统

        // 旧版本测试API连接和获取模型列表函数已删除 - 现在使用新版本的API设置系统

        // 保存API设置
        async function saveApiSettings() {
            const baseUrl = document.getElementById('api-base').value.trim();
            const apiKey = document.getElementById('api-key').value.trim();
            const model = document.getElementById('model-select').value.trim();
            const temperature = parseFloat(document.getElementById('temperature-slider').value) || 0.75;
            const emojiRecognitionEnabled = document.getElementById('emoji-recognition-enabled').checked;

            if (!baseUrl || !apiKey || !model) {
                showToast('请填写完整的API配置信息', 'error');
                return;
            }

            apiSettings = {
                base: baseUrl,
                key: apiKey,
                model: model,
                temperature: temperature,
                emojiRecognitionEnabled: emojiRecognitionEnabled,
                endpoint: '/chat/completions'  // 添加默认endpoint
            };

            try {
                // 🔥【修复】同时保存到IndexedDB和localStorage，确保数据一致性
                await db.apiSettings.put({
                    id: 'main',
                    settings: apiSettings
                });
                localStorage.setItem('apiSettings', JSON.stringify(apiSettings));

                showToast('API设置已保存！', 'success');
                console.log('🔧 [API设置] 已保存到IndexedDB和localStorage:', apiSettings);
            } catch (error) {
                console.error('保存API设置失败:', error);
                showToast('保存API设置失败: ' + error.message, 'error');
                return;
            }

            // 更新温度显示
            document.getElementById('temperature-value').textContent = temperature.toFixed(2);

            // 修复：保存后不跳转，留在当前API设置页面
        }

        // 🌟 Gemini直连快速设置
        function setGeminiDirect() {
            // 自动填充Gemini配置
            document.getElementById('api-base').value = 'https://generativelanguage.googleapis.com/v1beta';
            document.getElementById('api-key').placeholder = '请输入Google AI Studio的API Key';

            // 清空之前的模型选择并添加Gemini模型
            const modelSelect = document.getElementById('model-select');
            modelSelect.innerHTML = `
                <option value="">请选择模型...</option>
                <option value="gemini-2.0-flash-exp">Gemini 2.0 Flash (实验版) - 推荐</option>
                <option value="gemini-1.5-flash">Gemini 1.5 Flash - 快速</option>
                <option value="gemini-1.5-flash-8b">Gemini 1.5 Flash 8B - 轻量</option>
                <option value="gemini-1.5-pro">Gemini 1.5 Pro - 稳定</option>
                <option value="gemini-pro">Gemini Pro - 经典</option>
                <option value="gemini-pro-vision">Gemini Pro Vision - 视觉</option>
                <option value="手动输入模型名称">手动输入模型名称</option>
            `;

            // 添加手动输入功能
            modelSelect.onchange = function() {
                if (this.value === '手动输入模型名称') {
                    const customModel = prompt('请输入Gemini模型名称\n\n常见选项：\n• gemini-2.0-flash-exp\n• gemini-1.5-flash\n• gemini-1.5-pro\n• gemini-pro');
                    if (customModel && customModel.trim()) {
                        const newOption = new Option(customModel.trim(), customModel.trim());
                        this.insertBefore(newOption, this.lastElementChild);
                        this.value = customModel.trim();
                    } else {
                        this.value = '';
                    }
                }
            };

            showToast('🌟 Gemini直连配置已自动填写！\n\n使用说明：\n1. 请在Google AI Studio获取API Key\n2. 选择合适的模型\n3. 点击"测试连接"验证配置', 'success');
        }

        // 🤗 HuggingFace反代快速设置
        function setHuggingFaceProxy() {
            // 自动填充HuggingFace反代配置 - 使用正确的格式
            document.getElementById('api-base').value = 'https://xxx-xxx.hf.space/v1';
            document.getElementById('api-key').placeholder = '请输入HuggingFace的API Token';

            // 清空之前的模型选择并添加常见HF模型
            const modelSelect = document.getElementById('model-select');
            modelSelect.innerHTML = `
                <option value="">请选择模型...</option>
                <optgroup label="Llama系列">
                    <option value="meta-llama/Llama-2-7b-chat-hf">Llama-2-7b-chat-hf</option>
                    <option value="meta-llama/Llama-2-13b-chat-hf">Llama-2-13b-chat-hf</option>
                    <option value="meta-llama/Meta-Llama-3-8B-Instruct">Meta-Llama-3-8B-Instruct</option>
                </optgroup>
                <optgroup label="对话模型">
                <option value="microsoft/DialoGPT-large">DialoGPT-large</option>
                <option value="microsoft/DialoGPT-medium">DialoGPT-medium</option>
                    <option value="facebook/blenderbot-400M-distill">BlenderBot-400M</option>
                </optgroup>
                <optgroup label="通用模型">
                    <option value="mistralai/Mistral-7B-Instruct-v0.1">Mistral-7B-Instruct</option>
                    <option value="teknium/OpenHermes-2.5-Mistral-7B">OpenHermes-2.5-Mistral-7B</option>
                </optgroup>
                <optgroup label="自定义">
                    <option value="custom">手动输入模型名称...</option>
                </optgroup>
            `;

            // 添加自定义模型输入功能
            modelSelect.onchange = function() {
                if (this.value === 'custom') {
                    const customModel = prompt('请输入模型名称（例如：meta-llama/Llama-2-7b-chat-hf）：');
                    if (customModel && customModel.trim()) {
                        const newOption = new Option(customModel.trim(), customModel.trim());
                        this.insertBefore(newOption, this.lastElementChild);
                        this.value = customModel.trim();
                    } else {
                        this.value = '';
                    }
                }
            };

            showToast('🤗 HuggingFace反代配置已自动填写！\n\n请：\n1. 将地址中的 xxx-xxx 替换为实际的HF Space地址\n2. 选择模型或手动输入模型名称', 'success');
        }

        // 保存当前配置为预设
        function saveCurrentConfig() {
            const configName = document.getElementById('config-name-input').value.trim();

            if (!configName) {
                showToast('请输入配置名称', 'error');
                return;
            }

            const currentConfig = {
                name: configName,
                base: document.getElementById('api-base').value.trim(),
                key: document.getElementById('api-key').value.trim(),
                model: document.getElementById('model-select').value.trim(),
                temperature: parseFloat(document.getElementById('temperature-slider').value) || 0.75,
                emojiRecognitionEnabled: document.getElementById('emoji-recognition-enabled').checked,
                savedAt: new Date().toLocaleString()
            };

            // 获取已保存的配置
            let savedConfigs = JSON.parse(localStorage.getItem('savedApiConfigs') || '[]');

            // 检查是否已存在同名配置
            const existingIndex = savedConfigs.findIndex(config => config.name === configName);
            if (existingIndex !== -1) {
                if (confirm(`配置"${configName}"已存在，是否覆盖？`)) {
                    savedConfigs[existingIndex] = currentConfig;
                } else {
                    return;
                }
            } else {
                savedConfigs.push(currentConfig);
            }

            localStorage.setItem('savedApiConfigs', JSON.stringify(savedConfigs));
            document.getElementById('config-name-input').value = '';

            renderSavedConfigs();
            showToast(`配置"${configName}"已保存`, 'success');
        }

        // 渲染已保存的配置
        function renderSavedConfigs() {
            const container = document.getElementById('saved-configs-container');
            const noConfigsMessage = document.getElementById('no-configs-message');
            const savedConfigs = JSON.parse(localStorage.getItem('savedApiConfigs') || '[]');

            if (savedConfigs.length === 0) {
                container.style.display = 'none';
                noConfigsMessage.style.display = 'block';
                return;
            }

            container.style.display = 'grid';
            noConfigsMessage.style.display = 'none';

            container.innerHTML = savedConfigs.map(config => `
                <div class="config-card" style="background: rgba(255,255,255,0.8); border-radius: 12px; padding: 15px; border: 1px solid rgba(0,0,0,0.05); transition: all 0.3s ease; cursor: pointer;" onclick="loadConfig('${config.name}')">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                        <div style="font-weight: 600; color: #333; font-size: 15px;">${config.name}</div>
                        <button onclick="event.stopPropagation(); deleteConfig('${config.name}')" style="background: none; border: none; color: #ff6b6b; cursor: pointer; padding: 2px 6px; border-radius: 4px; font-size: 12px; transition: all 0.2s ease;" onmouseover="this.style.background='rgba(255,107,107,0.1)'" onmouseout="this.style.background='none'">🗑️</button>
                    </div>
                    <div style="font-size: 12px; color: #666; margin-bottom: 4px;">
                        <div>🌐 ${config.base}</div>
                        <div>🤖 ${config.model}</div>
                        <div>🌡️ 温度: ${config.temperature}</div>
                    </div>
                    <div style="font-size: 11px; color: #999;">保存于: ${config.savedAt}</div>
                </div>
            `).join('');
        }

        // 加载配置
        function loadConfig(configName) {
            const savedConfigs = JSON.parse(localStorage.getItem('savedApiConfigs') || '[]');
            const config = savedConfigs.find(c => c.name === configName);

            if (!config) {
                showToast('配置不存在', 'error');
                return;
            }

            // 填充表单
            document.getElementById('api-base').value = config.base;
            document.getElementById('api-key').value = config.key;
            document.getElementById('temperature-slider').value = config.temperature;
            document.getElementById('temperature-value').textContent = config.temperature.toFixed(2);

            // 处理模型选择
            const modelSelect = document.getElementById('model-select');
            const existingOption = Array.from(modelSelect.options).find(option => option.value === config.model);
            if (!existingOption) {
                // 如果模型不在当前选项中，添加它
                const newOption = new Option(config.model, config.model);
                modelSelect.appendChild(newOption);
            }
            modelSelect.value = config.model;

            // 🔥【新增】加载表情包识别设置
            const emojiRecognitionCheckbox = document.getElementById('emoji-recognition-enabled');
            if (emojiRecognitionCheckbox) {
                emojiRecognitionCheckbox.checked = config.emojiRecognitionEnabled !== false;
            }

            showToast(`已加载配置"${configName}"`, 'success');
        }

        // 删除配置
        function deleteConfig(configName) {
            if (confirm(`确定要删除配置"${configName}"吗？`)) {
                let savedConfigs = JSON.parse(localStorage.getItem('savedApiConfigs') || '[]');
                savedConfigs = savedConfigs.filter(config => config.name !== configName);
                localStorage.setItem('savedApiConfigs', JSON.stringify(savedConfigs));
                renderSavedConfigs();
                showToast(`配置"${configName}"已删除`, 'success');
            }
        }

        // 清空所有配置
        function clearAllConfigs() {
            if (confirm('确定要清空所有已保存的配置吗？此操作不可恢复。')) {
                localStorage.removeItem('savedApiConfigs');
                renderSavedConfigs();
                showToast('所有配置已清空', 'success');
            }
        }

        // 测试API连接
        async function testApiConnection() {
            const baseUrl = document.getElementById('api-base').value.trim();
            const apiKey = document.getElementById('api-key').value.trim();
            const model = document.getElementById('model-select').value.trim();

            if (!baseUrl || !apiKey || !model) {
                showToast('请先填写完整的API配置', 'error');
                return;
            }

            const testBtn = document.getElementById('test-api-connection-btn');
            const originalText = testBtn.textContent;
            testBtn.textContent = '测试中...';
            testBtn.disabled = true;

            try {
                // 根据不同的API类型构建测试请求
                let testUrl, testPayload, testHeaders;

                if (baseUrl.includes('generativelanguage.googleapis.com')) {
                    // Gemini API测试
                    testUrl = `${baseUrl}/models/${model}:generateContent?key=${apiKey}`;
                    testPayload = {
                        contents: [{
                            parts: [{ text: "Hello" }]
                        }],
                        generationConfig: {
                            temperature: 0.7
                            // 不添加maxOutputTokens等Gemini不支持的参数
                        }
                    };
                    testHeaders = {
                        'Content-Type': 'application/json'
                    };
                } else {
                    // OpenAI兼容API测试 - 智能处理URL拼接
                    if (baseUrl.endsWith('/v1')) {
                        testUrl = `${baseUrl}/chat/completions`;
                    } else if (baseUrl.includes('/v1/')) {
                        // 修复：如果URL中已经包含/v1/路径，直接添加chat/completions
                        testUrl = `${baseUrl}/chat/completions`;
                    } else {
                        testUrl = `${baseUrl}/v1/chat/completions`;
                    }
                    testPayload = {
                        model: model,
                        messages: [{ role: "user", content: "Hello" }],
                        max_tokens: 10
                    };
                    testHeaders = {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    };
                }

                const response = await fetch(testUrl, {
                    method: 'POST',
                    headers: testHeaders,
                    body: JSON.stringify(testPayload)
                });

                if (response.ok) {
                    showToast('✅ API连接测试成功！', 'success');

                    // 🔥【修复】测试成功后自动保存API设置，避免用户重复输入
                    apiSettings = {
                        base: baseUrl,
                        key: apiKey,
                        model: model,
                        temperature: parseFloat(document.getElementById('temperature-slider').value) || 0.75,
                        endpoint: '/chat/completions'
                    };

                    // 🔥【修复】同时保存到IndexedDB和localStorage，确保数据一致性
                    try {
                        await db.apiSettings.put({
                            id: 'main',
                            settings: apiSettings
                        });
                        localStorage.setItem('apiSettings', JSON.stringify(apiSettings));
                        console.log('🔧 [API测试] API设置已自动保存到IndexedDB和localStorage');
                    } catch (error) {
                        console.error('自动保存API设置失败:', error);
                    }
                } else {
                    const errorText = await response.text();
                    showToast(`❌ API连接失败: ${response.status} ${response.statusText}`, 'error');
                    console.error('API测试失败:', errorText);
                }
            } catch (error) {
                showToast(`❌ 连接错误: ${error.message}`, 'error');
                console.error('API测试错误:', error);
            } finally {
                testBtn.textContent = originalText;
                testBtn.disabled = false;
            }
        }

        // 获取模型列表
        async function fetchModels() {
            const baseUrl = document.getElementById('api-base').value.trim();
            const apiKey = document.getElementById('api-key').value.trim();

            if (!baseUrl || !apiKey) {
                showToast('请先填写API地址和密钥', 'error');
                return;
            }

            const fetchBtn = document.getElementById('fetch-models-btn');
            const originalText = fetchBtn.textContent;
            fetchBtn.textContent = '获取中...';
            fetchBtn.disabled = true;

            try {
                let modelsUrl, headers;

                if (baseUrl.includes('generativelanguage.googleapis.com')) {
                    // Gemini API
                    modelsUrl = `${baseUrl}/models?key=${apiKey}`;
                    headers = {};
                } else {
                    // OpenAI兼容API - 智能处理URL拼接
                    if (baseUrl.endsWith('/v1')) {
                        modelsUrl = `${baseUrl}/models`;
                    } else if (baseUrl.includes('/v1/')) {
                        // 修复：如果URL中已经包含/v1/路径，直接添加models
                        modelsUrl = `${baseUrl}/models`;
                    } else {
                        modelsUrl = `${baseUrl}/v1/models`;
                    }
                    headers = {
                        'Authorization': `Bearer ${apiKey}`
                    };
                }

                // 🔥【修复】移除超时控制，避免AbortError
                const response = await fetch(modelsUrl, {
                    headers
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                const modelSelect = document.getElementById('model-select');

                // 清空现有选项
                modelSelect.innerHTML = '<option value="">请选择模型...</option>';

                let models = [];
                if (data.models) {
                    // Gemini API格式 - 修复模型过滤逻辑
                    console.log('Gemini API响应数据:', data);
                    models = data.models
                        .filter(model => {
                            // 允许所有支持generateContent的模型
                            return model.name && (
                                model.name.includes('gemini') ||
                                model.name.includes('models/') ||
                                model.supportedGenerationMethods?.includes('generateContent') ||
                                model.name.includes('generate')
                            );
                        })
                        .map(model => {
                            // 提取模型名称，去掉前缀
                            const modelName = model.name.includes('/')
                                ? model.name.split('/').pop()
                                : model.name;
                            return modelName;
                        });

                    // 如果过滤后没有模型，显示所有模型（调试用）
                    if (models.length === 0 && data.models.length > 0) {
                        console.log('过滤后没有模型，显示所有可用模型:', data.models);
                        models = data.models.map(model =>
                            model.name.includes('/') ? model.name.split('/').pop() : model.name
                        );
                    }
                } else if (data.data) {
                    // OpenAI API格式
                    models = data.data.map(model => model.id);
                }

                models.forEach(modelId => {
                    const option = new Option(modelId, modelId);
                    modelSelect.appendChild(option);
                });

                showToast(`✅ 成功获取到 ${models.length} 个模型`, 'success');
            } catch (error) {
                let errorMessage = error.message;

                if (errorMessage.includes('Failed to fetch') || errorMessage.includes('ERR_TIMED_OUT')) {
                    if (baseUrl.includes('.hf.space')) {
                        errorMessage = 'HuggingFace Space连接超时，可能需要先启动服务或检查网络连接。\n\n💡 建议：\n1. 检查HF Space是否正在运行\n2. 尝试先手动访问该URL测试连接\n3. 如果服务不支持/models端点，请手动输入模型名称';
                    } else {
                        errorMessage = '网络连接失败，请检查URL是否正确以及网络连接';
                    }
                }

                showToast(`❌ 获取模型失败: ${errorMessage}`, 'error');
                console.error('获取模型失败:', error);

                // 为Gemini提供常见模型选项作为后备
                if (baseUrl.includes('generativelanguage.googleapis.com')) {
                    const modelSelect = document.getElementById('model-select');
                    modelSelect.innerHTML = `
                        <option value="">请选择模型...</option>
                        <option value="gemini-2.0-flash-exp">Gemini 2.0 Flash (实验版)</option>
                        <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
                        <option value="gemini-1.5-flash-8b">Gemini 1.5 Flash 8B</option>
                        <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
                        <option value="gemini-pro">Gemini Pro</option>
                        <option value="gemini-pro-vision">Gemini Pro Vision</option>
                        <option value="手动输入模型名称">手动输入模型名称</option>
                    `;
                    setTimeout(() => {
                        showToast('💡 已为您提供常见Gemini模型选项', 'info');
                    }, 1000);
                }

                // 如果是HF Space，给出额外提示
                if (baseUrl.includes('.hf.space')) {
                    setTimeout(() => {
                        showToast('💡 提示：HuggingFace Space可能不支持自动获取模型列表，建议手动输入模型名称', 'info');
                    }, 2000);
                }
            } finally {
                fetchBtn.textContent = originalText;
                fetchBtn.disabled = false;
            }
        }

        // 导出完整备份
        function exportFullBackup() {
            // 这里可以实现完整的数据导出功能
            showToast('导出功能开发中...', 'info');
        }

        // 导入完整备份
        function importFullBackup() {
            // 这里可以实现完整的数据导入功能
            document.getElementById('import-full-backup-input').click();
        }

        // 初始化API设置界面
        async function initializeApiSettings() {
            // 加载已保存的API配置到表单
            await loadApiSettingsToForm();

            // 渲染已保存的配置
            renderSavedConfigs();
        }

        // 🔥【修复】加载API设置到表单并自动拉取模型
        async function loadApiSettingsToForm() {
            try {
                // 从IndexedDB加载设置
                const savedSettings = await db.apiSettings.get('main');
                let settings = null;

                if (savedSettings) {
                    settings = savedSettings.settings;
                } else {
                    // 尝试从localStorage迁移
                    const localSettings = localStorage.getItem('apiSettings');
                    if (localSettings) {
                        settings = JSON.parse(localSettings);
                        // 迁移到IndexedDB
                        await db.apiSettings.put({
                            id: 'main',
                            settings: settings
                        });
                        console.log('🔧 [API设置] 已迁移localStorage设置到IndexedDB');
                    }
                }

                if (settings) {
                    console.log('🔧 [API设置] 加载已保存的API设置:', settings);

                    // 填充表单字段
                    if (settings.base) {
                        const baseInput = document.getElementById('api-base');
                        if (baseInput) baseInput.value = settings.base;
                    }

                    if (settings.key) {
                        const keyInput = document.getElementById('api-key');
                        if (keyInput) keyInput.value = settings.key;
                    }

                    if (settings.temperature !== undefined) {
                        const tempSlider = document.getElementById('temperature-slider');
                        const tempValue = document.getElementById('temperature-value');
                        if (tempSlider && tempValue) {
                            tempSlider.value = settings.temperature;
                            tempValue.textContent = settings.temperature.toFixed(2);
                        }
                    }

                    // 🔥【新增】加载表情包识别设置
                    const emojiRecognitionCheckbox = document.getElementById('emoji-recognition-enabled');
                    if (emojiRecognitionCheckbox) {
                        // 默认启用表情包识别（向后兼容）
                        emojiRecognitionCheckbox.checked = settings.emojiRecognitionEnabled !== false;
                    }

                    // 🔥【重要修复】如果有保存的API设置，自动拉取模型列表
                    if (settings.base && settings.key) {
                        console.log('🔧 [API设置] 检测到完整的API配置，自动拉取模型列表');

                        // 延迟一点执行，确保UI已经加载完成
                        setTimeout(() => {
                            fetchModels().then(() => {
                                // 拉取完成后，如果有保存的模型，选中它
                                if (settings.model) {
                                    const modelSelect = document.getElementById('model-select');
                                    if (modelSelect) {
                                        // 如果模型不在选项中，添加它
                                        const existingOption = Array.from(modelSelect.options).find(option => option.value === settings.model);
                                        if (!existingOption) {
                                            const newOption = new Option(settings.model, settings.model);
                                            modelSelect.appendChild(newOption);
                                        }
                                        modelSelect.value = settings.model;
                                        console.log('🔧 [API设置] 已自动选中保存的模型:', settings.model);
                                    }
                                }
                            }).catch(error => {
                                console.log('🔧 [API设置] 自动拉取模型失败，但会保留已保存的模型选项');
                                // 即使拉取失败，也要恢复保存的模型选项
                                if (settings.model) {
                                    const modelSelect = document.getElementById('model-select');
                                    if (modelSelect) {
                                        const existingOption = Array.from(modelSelect.options).find(option => option.value === settings.model);
                                        if (!existingOption) {
                                            const newOption = new Option(settings.model, settings.model);
                                            modelSelect.appendChild(newOption);
                                        }
                                        modelSelect.value = settings.model;
                                        console.log('🔧 [API设置] 已恢复保存的模型选项:', settings.model);
                                    }
                                }
                            });
                        }, 500);
                    } else {
                        // 没有完整的API配置时，仍然要恢复保存的模型选项
                        if (settings.model) {
                            const modelSelect = document.getElementById('model-select');
                            if (modelSelect) {
                                const existingOption = Array.from(modelSelect.options).find(option => option.value === settings.model);
                                if (!existingOption) {
                                    const newOption = new Option(settings.model, settings.model);
                                    modelSelect.appendChild(newOption);
                                }
                                modelSelect.value = settings.model;
                                console.log('🔧 [API设置] 已恢复保存的模型选项（无自动拉取）:', settings.model);
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('加载API设置失败:', error);
            }
        }

        // 电池管理功能
        async function initBatteryManager() {
            // 设置固定的电池电量显示（75%）
            setFixedBatteryDisplay();
        }

        function setFixedBatteryDisplay() {
            // 设置固定的电池电量为100%（满电）
            const fixedLevel = 100;

            // 更新主状态栏电池
            const batteryContainer = document.getElementById('status-bar-battery');
            if (batteryContainer) {
                const batteryLevelEl = batteryContainer.querySelector('.battery-level');
                if (batteryLevelEl) {
                    batteryLevelEl.style.width = `${fixedLevel}%`;
                }
                // 移除充电状态
                batteryContainer.classList.remove('charging');
            }

            // 更新应用内状态栏电池
            const appBatteryContainers = document.querySelectorAll('.app-battery-container');
            const appBatteryLevels = document.querySelectorAll('.app-battery-level');

            // 设置应用内电池图标为固定电量
            appBatteryLevels.forEach(element => {
                element.style.width = `${fixedLevel}%`;
            });

            // 移除应用内电池充电状态
            appBatteryContainers.forEach(container => {
                container.classList.remove('charging');
            });
        }

        // 手动测试电池显示功能 - 您可以在浏览器控制台中调用这个函数
        function testBatteryDisplay() {
            console.log('测试固定电池显示功能');
            setFixedBatteryDisplay();
            console.log('电池显示已设置为固定100%电量（满电）');
        }

        // 🔥【修改】主题切换功能 - 改为async支持Dexie
        async function changeTheme(themeName) {
            const body = document.body;

            // 🔥【修复】切换主题时清除自定义主题样式
            clearCustomThemeStyles();
            clearGlobalCustomTheme();
            body.classList.remove('custom-theme-applied');

            // 移除之前的主题
            body.removeAttribute('data-theme');

            // 应用新主题
            if (themeName !== 'default') {
                body.setAttribute('data-theme', themeName);
            }

            // 🔥【修改】保存主题设置到Dexie
            try {
                await db.themeSettings.put({
                    id: 'selectedTheme',
                    settingName: 'selectedTheme',
                    settingValue: themeName,
                    timestamp: Date.now()
                });
            } catch (error) {
                console.error('❌ 保存主题设置失败:', error);
            }

            // 给用户反馈
            const themeNames = {
                'default': '简约风格',
                'cute': '可爱风格',
                'dark': '夜间模式'
            };

            // 显示Toast提示
            showToast(`已切换到 ${themeNames[themeName]} 主题！`, 'success');
        }

        // 🎨【新增】自定义主题功能
        let customThemeData = {
            chatTopBg: null,
            chatBottomBg: null,
            buttons: {
                back: null,
                offline: null,
                settings: null,
                expand: null,
                continue: null,
                send: null
            },
            globalTopAppBar: null,
            globalBottomAppBar: null,
            globalBackButton: null,
            globalAddButton: null,
            globalBg: null,
            scope: 'selected', // selected, all
            selectedChats: []
        };

        // 🔥【新增】图片上传选择相关变量
        let currentUploadType = null; // 当前上传类型
        let currentUploadCallback = null; // 当前上传回调函数

        let currentButtonType = null; // 当前正在上传的按钮类型

        // 切换自定义主题选项卡
        function switchCustomThemeTab(tabName) {
            // 移除所有活动状态
            document.querySelectorAll('.custom-theme-tab').forEach(tab => {
                tab.classList.remove('active');
            });

            // 隐藏所有内容面板
            document.querySelectorAll('.custom-theme-content-pane').forEach(pane => {
                pane.style.display = 'none';
            });

            // 激活当前选项卡
            document.querySelector(`.custom-theme-tab[onclick="switchCustomThemeTab('${tabName}')"]`).classList.add('active');

            // 显示对应内容面板
            if (tabName === 'chat') {
                document.getElementById('chat-theme-content').style.display = 'block';
                loadChatSelectionList();
            } else if (tabName === 'global') {
                document.getElementById('global-theme-content').style.display = 'block';
            }
        }

        // 上传聊天界面顶部背景
        function uploadChatTopBackground() {
            showImageUploadChoice('chat-top-bg', '选择聊天顶部背景来源');
        }

        // 上传聊天界面底部背景
        function uploadChatBottomBackground() {
            showImageUploadChoice('chat-bottom-bg', '选择聊天底部背景来源');
        }

        // 上传按钮图标
        function uploadButtonIcon(buttonType) {
            currentButtonType = buttonType;
            const buttonNames = {
                back: '返回按钮',
                offline: '线下模式按钮',
                settings: '聊天设置按钮',
                expand: '功能区展开按钮',
                continue: '续写按钮',
                send: '发送消息按钮'
            };
            showImageUploadChoice(`button-${buttonType}`, `选择${buttonNames[buttonType]}样式来源`);
        }

        // 🔥【新增】显示图片上传选择模态框
        function showImageUploadChoice(uploadType, title, callback) {
            currentUploadType = uploadType;
            currentUploadCallback = callback;

            document.getElementById('image-upload-choice-title').textContent = title || '选择图片来源';
            showModal('image-upload-choice-modal');
        }

        // 🔥【新增】选择本地上传
        function chooseLocalUpload() {
            hideModal('image-upload-choice-modal');

            // 根据上传类型触发对应的文件选择器
            switch(currentUploadType) {
                case 'global-top-app-bar':
                    document.getElementById('global-top-app-bar-input').click();
                    break;
                case 'global-bottom-app-bar':
                    document.getElementById('global-bottom-app-bar-input').click();
                    break;
                case 'global-back-button':
                    document.getElementById('global-back-button-input').click();
                    break;
                case 'global-add-button':
                    document.getElementById('global-add-button-input').click();
                    break;
                case 'global-bg':
                    document.getElementById('global-bg-input').click();
                    break;
                case 'chat-top-bg':
                    document.getElementById('chat-top-bg-input').click();
                    break;
                case 'chat-bottom-bg':
                    document.getElementById('chat-bottom-bg-input').click();
                    break;
                case 'button-back':
                case 'button-offline':
                case 'button-settings':
                case 'button-expand':
                case 'button-continue':
                case 'button-send':
                    document.getElementById('button-icon-input').click();
                    break;
                default:
                    if (currentUploadCallback) {
                        currentUploadCallback('local');
                    }
                    break;
            }
        }

        // 🔥【新增】选择URL上传
        function chooseUrlUpload() {
            hideModal('image-upload-choice-modal');

            document.getElementById('image-url-input').value = '';
            document.getElementById('url-preview').style.display = 'none';
            document.getElementById('url-input-title').textContent = `输入${getUploadTypeTitle(currentUploadType)}URL`;
            showModal('url-input-modal');

            // 监听URL输入变化
            const urlInput = document.getElementById('image-url-input');
            urlInput.oninput = function() {
                const url = this.value.trim();
                if (url && isValidImageUrl(url)) {
                    showUrlPreview(url);
                } else {
                    hideUrlPreview();
                }
            };
        }

        // 🔥【新增】获取上传类型标题
        function getUploadTypeTitle(uploadType) {
            const titles = {
                'global-top-app-bar': '顶部应用栏背景',
                'global-bottom-app-bar': '底部应用栏背景',
                'global-back-button': '返回按钮',
                'global-add-button': '添加按钮',
                'global-bg': '全局背景',
                'chat-top-bg': '聊天顶部背景',
                'chat-bottom-bg': '聊天底部背景',
                'button-back': '返回按钮',
                'button-offline': '线下模式按钮',
                'button-settings': '聊天设置按钮',
                'button-expand': '功能区展开按钮',
                'button-continue': '续写按钮',
                'button-send': '发送消息按钮'
            };
            return titles[uploadType] || '图片';
        }

        // 🔥【新增】验证图片URL
        function isValidImageUrl(url) {
            try {
                const urlObj = new URL(url);
                const supportedDomains = [
                    'i.postimg.cc',
                    'files.catbox.moe',
                    'i.ibb.co',
                    'i.imgur.com',
                    'cdn.discordapp.com',
                    'media.discordapp.net'
                ];

                // 检查域名是否在支持列表中，或者URL以图片扩展名结尾
                const domain = urlObj.hostname;
                const pathname = urlObj.pathname.toLowerCase();
                const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];

                return supportedDomains.includes(domain) ||
                       imageExtensions.some(ext => pathname.endsWith(ext));
            } catch {
                return false;
            }
        }

        // 🔥【新增】显示URL预览
        function showUrlPreview(url) {
            const preview = document.getElementById('url-preview');
            const img = document.getElementById('url-preview-img');

            img.onload = function() {
                preview.style.display = 'block';
            };

            img.onerror = function() {
                hideUrlPreview();
                showToast('图片加载失败，请检查URL是否正确', 'error');
            };

            img.src = url;
        }

        // 🔥【新增】隐藏URL预览
        function hideUrlPreview() {
            document.getElementById('url-preview').style.display = 'none';
        }

        // 🔥【新增】确认URL上传
        function confirmUrlUpload() {
            const url = document.getElementById('image-url-input').value.trim();

            if (!url) {
                showToast('请输入图片URL', 'warning');
                return;
            }

            if (!isValidImageUrl(url)) {
                showToast('请输入有效的图片URL', 'warning');
                return;
            }

            hideModal('url-input-modal');

            // 处理URL上传
            handleUrlUpload(url);
        }

        // 🔥【新增】处理URL上传
        function handleUrlUpload(url) {
            switch(currentUploadType) {
                case 'global-top-app-bar':
                    customThemeData.globalTopAppBar = url;
                    updatePreview('global-top-app-bar-preview', url);
                    updateThemeItemStatus('global-top-app-bar-item', true);
                    showToast('全局顶部应用栏背景已设置', 'success');
                    break;
                case 'global-bottom-app-bar':
                    customThemeData.globalBottomAppBar = url;
                    updatePreview('global-bottom-app-bar-preview', url);
                    updateThemeItemStatus('global-bottom-app-bar-item', true);
                    showToast('全局底部应用栏背景已设置', 'success');
                    break;
                case 'global-back-button':
                    customThemeData.globalBackButton = url;
                    updatePreview('global-back-button-preview', url);
                    updateThemeItemStatus('global-back-button-item', true);
                    showToast('全局返回按钮样式已设置', 'success');
                    break;
                case 'global-add-button':
                    customThemeData.globalAddButton = url;
                    updatePreview('global-add-button-preview', url);
                    updateThemeItemStatus('global-add-button-item', true);
                    showToast('全局添加按钮样式已设置', 'success');
                    break;
                case 'global-bg':
                    customThemeData.globalBg = url;
                    updatePreview('global-bg-preview', url);
                    updateThemeItemStatus('global-bg-item', true);
                    showToast('全局背景已设置', 'success');
                    break;
                case 'chat-top-bg':
                    customThemeData.chatTopBg = url;
                    updatePreview('chat-top-bg-preview', url);
                    updateThemeItemStatus('chat-top-bg-item', true);
                    showToast('聊天顶部背景已设置', 'success');
                    break;
                case 'chat-bottom-bg':
                    customThemeData.chatBottomBg = url;
                    updatePreview('chat-bottom-bg-preview', url);
                    updateThemeItemStatus('chat-bottom-bg-item', true);
                    showToast('聊天底部背景已设置', 'success');
                    break;
                case 'button-back':
                    customThemeData.buttons.back = url;
                    updatePreview('back-btn-preview', url);
                    updateThemeItemStatus('back-btn-item', true);
                    showToast('返回按钮样式已设置', 'success');
                    break;
                case 'button-offline':
                    customThemeData.buttons.offline = url;
                    updatePreview('offline-btn-preview', url);
                    updateThemeItemStatus('offline-btn-item', true);
                    showToast('线下模式按钮样式已设置', 'success');
                    break;
                case 'button-settings':
                    customThemeData.buttons.settings = url;
                    updatePreview('settings-btn-preview', url);
                    updateThemeItemStatus('settings-btn-item', true);
                    showToast('聊天设置按钮样式已设置', 'success');
                    break;
                case 'button-expand':
                    customThemeData.buttons.expand = url;
                    updatePreview('expand-btn-preview', url);
                    updateThemeItemStatus('expand-btn-item', true);
                    showToast('功能区展开按钮样式已设置', 'success');
                    break;
                case 'button-continue':
                    customThemeData.buttons.continue = url;
                    updatePreview('continue-btn-preview', url);
                    updateThemeItemStatus('continue-btn-item', true);
                    showToast('续写按钮样式已设置', 'success');
                    break;
                case 'button-send':
                    customThemeData.buttons.send = url;
                    updatePreview('send-btn-preview', url);
                    updateThemeItemStatus('send-btn-item', true);
                    showToast('发送消息按钮样式已设置', 'success');
                    break;
                default:
                    if (currentUploadCallback) {
                        currentUploadCallback('url', url);
                    }
                    break;
            }
        }

        // 上传全局顶部应用栏背景
        function uploadGlobalTopAppBar() {
            showImageUploadChoice('global-top-app-bar', '选择顶部应用栏背景来源');
        }

        // 上传全局底部应用栏背景
        function uploadGlobalBottomAppBar() {
            showImageUploadChoice('global-bottom-app-bar', '选择底部应用栏背景来源');
        }

        // 上传全局返回按钮样式
        function uploadGlobalBackButton() {
            showImageUploadChoice('global-back-button', '选择返回按钮样式来源');
        }

        // 上传全局添加按钮样式
        function uploadGlobalAddButton() {
            showImageUploadChoice('global-add-button', '选择添加按钮样式来源');
        }

        // 上传全局背景
        function uploadGlobalBackground() {
            showImageUploadChoice('global-bg', '选择全局背景来源');
        }

        // 处理聊天顶部背景上传
        function handleChatTopBgUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    customThemeData.chatTopBg = e.target.result;
                    updatePreview('chat-top-bg-preview', e.target.result);
                    updateThemeItemStatus('chat-top-bg-item', true);
                    showToast('聊天顶部背景已上传', 'success');
                };
                reader.readAsDataURL(file);
            }
        }

        // 处理聊天底部背景上传
        function handleChatBottomBgUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    customThemeData.chatBottomBg = e.target.result;
                    updatePreview('chat-bottom-bg-preview', e.target.result);
                    updateThemeItemStatus('chat-bottom-bg-item', true);
                    showToast('聊天底部背景已上传', 'success');
                };
                reader.readAsDataURL(file);
            }
        }

        // 处理按钮图标上传
        function handleButtonIconUpload(event) {
            const file = event.target.files[0];
            if (file && currentButtonType) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    customThemeData.buttons[currentButtonType] = e.target.result;
                    updatePreview(`${currentButtonType}-btn-preview`, e.target.result);
                    updateThemeItemStatus(`${currentButtonType}-btn-item`, true);

                    const buttonNames = {
                        back: '返回按钮',
                        offline: '线下模式按钮',
                        settings: '聊天设置按钮',
                        expand: '功能区展开按钮',
                        continue: '续写按钮',
                        send: '发送消息按钮'
                    };

                    showToast(`${buttonNames[currentButtonType]}图标已上传`, 'success');
                    currentButtonType = null;
                };
                reader.readAsDataURL(file);
            }
        }

        // 🔥【新增】更新主题项状态
        function updateThemeItemStatus(itemId, isConfigured) {
            const item = document.getElementById(itemId);
            if (!item) return;

            const statusIndicator = item.querySelector('.theme-item-status');
            if (isConfigured) {
                item.classList.add('theme-item-configured');
                if (statusIndicator) {
                    statusIndicator.style.display = 'flex';
                }
            } else {
                item.classList.remove('theme-item-configured');
                if (statusIndicator) {
                    statusIndicator.style.display = 'none';
                }
            }
        }

        // 🔥【新增】清除所有主题项状态（应用后调用）
        function clearAllThemeItemStatus() {
            const configuredItems = document.querySelectorAll('.theme-item-configured');
            configuredItems.forEach(item => {
                item.classList.remove('theme-item-configured');
                const statusIndicator = item.querySelector('.theme-item-status');
                if (statusIndicator) {
                    statusIndicator.style.display = 'none';
                }
            });
        }

        // 处理全局顶部应用栏背景上传
        function handleGlobalTopAppBarUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    customThemeData.globalTopAppBar = e.target.result;
                    updatePreview('global-top-app-bar-preview', e.target.result);
                    updateThemeItemStatus('global-top-app-bar-item', true);

                    console.log('🎨 全局顶部应用栏背景已上传:', e.target.result);
                    showToast('全局顶部应用栏背景已上传', 'success');
                };
                reader.readAsDataURL(file);
            }
        }

        // 处理全局底部应用栏背景上传
        function handleGlobalBottomAppBarUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    customThemeData.globalBottomAppBar = e.target.result;
                    updatePreview('global-bottom-app-bar-preview', e.target.result);
                    updateThemeItemStatus('global-bottom-app-bar-item', true);

                    showToast('全局底部应用栏背景已上传', 'success');
                };
                reader.readAsDataURL(file);
            }
        }

        // 处理全局返回按钮样式上传
        function handleGlobalBackButtonUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    customThemeData.globalBackButton = e.target.result;
                    updatePreview('global-back-button-preview', e.target.result);
                    updateThemeItemStatus('global-back-button-item', true);

                    showToast('全局返回按钮样式已上传', 'success');
                };
                reader.readAsDataURL(file);
            }
        }

        // 处理全局添加按钮样式上传
        function handleGlobalAddButtonUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    customThemeData.globalAddButton = e.target.result;
                    updatePreview('global-add-button-preview', e.target.result);
                    updateThemeItemStatus('global-add-button-item', true);

                    showToast('全局添加按钮样式已上传', 'success');
                };
                reader.readAsDataURL(file);
            }
        }

        // 处理全局背景上传
        function handleGlobalBgUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    customThemeData.globalBg = e.target.result;
                    updatePreview('global-bg-preview', e.target.result);
                    updateThemeItemStatus('global-bg-item', true);

                    showToast('全局应用背景已上传', 'success');
                };
                reader.readAsDataURL(file);
            }
        }

        // 🔥【新增】清除全局主题缓存
        function clearGlobalThemeCache() {
            globalThemeCache = null;
            globalThemeCacheTime = 0;
            console.log('🎨 全局主题缓存已清除');
        }

        // 🔥【修改】保存并应用全局主题 - 使用Dexie
        async function saveAndApplyGlobalTheme() {
            try {
                // 提取全局样式数据
                const globalThemeData = {
                    globalTopAppBar: customThemeData.globalTopAppBar,
                    globalBottomAppBar: customThemeData.globalBottomAppBar,
                    globalBackButton: customThemeData.globalBackButton,
                    globalAddButton: customThemeData.globalAddButton,
                    globalBg: customThemeData.globalBg
                };

                // 保存到Dexie数据库
                await db.globalThemes.put({
                    id: 'global',
                    themeType: 'global',
                    themeData: globalThemeData,
                    timestamp: Date.now()
                });

                // 🔥【优化】清除缓存，确保使用最新数据
                clearGlobalThemeCache();

                // 立即应用全局样式
                applyGlobalCustomTheme(globalThemeData);

                console.log('🎨 全局主题已保存并应用到Dexie数据库');
            } catch (error) {
                console.error('❌ 保存全局主题失败:', error);
                showToast('保存全局主题失败', 'error');
            }
        }

        // 🔥【优化】全局主题缓存，避免重复数据库查询
        let globalThemeCache = null;
        let globalThemeCacheTime = 0;
        const GLOBAL_THEME_CACHE_DURATION = 30000; // 30秒缓存

        // 🔥【新增】图片预加载缓存，避免重复加载导致卡顿
        const imagePreloadCache = new Map();
        const MAX_IMAGE_CACHE_SIZE = 50; // 最多缓存50张图片

        // 🔥【新增】预加载图片函数
        function preloadImage(url) {
            return new Promise((resolve, reject) => {
                // 检查缓存
                if (imagePreloadCache.has(url)) {
                    resolve(imagePreloadCache.get(url));
                    return;
                }

                const img = new Image();
                img.onload = () => {
                    // 添加到缓存
                    if (imagePreloadCache.size >= MAX_IMAGE_CACHE_SIZE) {
                        // 删除最旧的缓存项
                        const firstKey = imagePreloadCache.keys().next().value;
                        imagePreloadCache.delete(firstKey);
                    }
                    imagePreloadCache.set(url, img);
                    resolve(img);
                };
                img.onerror = () => {
                    console.warn('🖼️ 图片预加载失败:', url);
                    reject(new Error(`Failed to load image: ${url}`));
                };
                img.src = url;
            });
        }

        // 🔥【修改】应用全局自定义主题 - 使用Dexie + 缓存优化
        async function applyGlobalCustomTheme(globalThemeData = null) {
            const root = document.documentElement;

            // 如果没有传入数据，从缓存或Dexie数据库加载
            if (!globalThemeData) {
                const now = Date.now();

                // 🔥【优化】先检查缓存
                if (globalThemeCache && (now - globalThemeCacheTime) < GLOBAL_THEME_CACHE_DURATION) {
                    globalThemeData = globalThemeCache;
                    console.log('🎨 从缓存加载全局自定义主题');
                } else {
                    // 缓存过期或不存在，从数据库加载
                    try {
                        const savedGlobalTheme = await db.globalThemes.get('global');
                        if (savedGlobalTheme && savedGlobalTheme.themeData) {
                            globalThemeData = savedGlobalTheme.themeData;
                            // 🔥【优化】更新缓存
                            globalThemeCache = globalThemeData;
                            globalThemeCacheTime = now;
                            console.log('🎨 从Dexie加载保存的全局自定义主题并缓存');
                        } else {
                            console.log('🎨 没有保存的全局主题');
                            return;
                        }
                    } catch (error) {
                        console.error('❌ 加载全局主题数据失败:', error);
                        return;
                    }
                }
            }

            // 清除之前的全局样式
            clearGlobalCustomTheme();

            // 🔥【优化】预加载所有图片，然后应用全局样式
            const imagesToPreload = [];
            if (globalThemeData.globalTopAppBar) imagesToPreload.push(globalThemeData.globalTopAppBar);
            if (globalThemeData.globalBottomAppBar) imagesToPreload.push(globalThemeData.globalBottomAppBar);
            if (globalThemeData.globalBackButton) imagesToPreload.push(globalThemeData.globalBackButton);
            if (globalThemeData.globalAddButton) imagesToPreload.push(globalThemeData.globalAddButton);
            if (globalThemeData.globalBg) imagesToPreload.push(globalThemeData.globalBg);

            // 预加载所有图片
            try {
                await Promise.all(imagesToPreload.map(url => preloadImage(url)));
                console.log('🎨 全局主题图片预加载完成');
            } catch (error) {
                console.warn('🎨 部分全局主题图片预加载失败:', error);
            }

            // 应用全局样式
            const appliedGlobalStyles = new Set();

            if (globalThemeData.globalTopAppBar) {
                root.style.setProperty('--custom-global-top-app-bar', `url(${globalThemeData.globalTopAppBar})`);
                appliedGlobalStyles.add('top-app-bar');
                console.log('🎨 设置CSS变量 --custom-global-top-app-bar:', `url(${globalThemeData.globalTopAppBar})`);
            }

            if (globalThemeData.globalBottomAppBar) {
                root.style.setProperty('--custom-global-bottom-app-bar', `url(${globalThemeData.globalBottomAppBar})`);
                appliedGlobalStyles.add('bottom-app-bar');
            }

            if (globalThemeData.globalBackButton) {
                root.style.setProperty('--custom-global-back-button', `url(${globalThemeData.globalBackButton})`);
                appliedGlobalStyles.add('back-button');
            }

            if (globalThemeData.globalAddButton) {
                root.style.setProperty('--custom-global-add-button', `url(${globalThemeData.globalAddButton})`);
                appliedGlobalStyles.add('add-button');
            }

            if (globalThemeData.globalBg) {
                root.style.setProperty('--custom-global-bg', `url(${globalThemeData.globalBg})`);
                appliedGlobalStyles.add('bg');
            }

            // 为body添加全局样式标记
            const globalStyleTypes = ['top-app-bar', 'bottom-app-bar', 'back-button', 'add-button', 'bg'];
            globalStyleTypes.forEach(styleType => {
                if (appliedGlobalStyles.has(styleType)) {
                    document.body.setAttribute(`data-has-custom-global-${styleType}`, 'true');
                } else {
                    document.body.removeAttribute(`data-has-custom-global-${styleType}`);
                }
            });

            // 添加全局主题应用标记
            document.body.classList.add('custom-theme-applied');

            console.log('🎨 全局自定义主题样式已应用');
            console.log('🎨 应用的全局样式:', appliedGlobalStyles);
            console.log('🎨 body类名:', document.body.className);
            console.log('🎨 body属性:', Array.from(document.body.attributes).map(attr => `${attr.name}="${attr.value}"`));
        }

        // 🔥【新增】清除全局自定义主题
        function clearGlobalCustomTheme() {
            console.log('🎨 开始清除全局自定义主题样式...');

            const root = document.documentElement;
            const globalVariablesToClear = [
                '--custom-global-top-app-bar',
                '--custom-global-bottom-app-bar',
                '--custom-global-back-button',
                '--custom-global-add-button',
                '--custom-global-bg'
            ];

            globalVariablesToClear.forEach(variable => {
                root.style.removeProperty(variable);
            });

            // 清除全局样式标记
            const globalStyleTypes = ['top-app-bar', 'bottom-app-bar', 'back-button', 'add-button', 'bg'];
            globalStyleTypes.forEach(styleType => {
                document.body.removeAttribute(`data-has-custom-global-${styleType}`);
            });

            console.log('🎨 全局自定义主题样式清除完成');
        }

        // 更新预览图
        function updatePreview(previewId, imageUrl) {
            const preview = document.getElementById(previewId);
            if (preview) {
                preview.style.backgroundImage = `url(${imageUrl})`;
                preview.classList.add('has-image');
            }
        }

        // 加载聊天窗口选择列表
        function loadChatSelectionList() {
            const container = document.getElementById('chat-selection-list');
            if (!container) return;

            // 获取所有聊天对象（包括普通角色和群聊）
            const allChatObjects = [];

            // 添加普通角色（从contacts中获取活跃的聊天）
            if (characters && characters.length > 0 && contacts && contacts.length > 0) {
                characters.forEach(character => {
                    // 只添加在contacts中的角色（表示有过聊天记录）
                    if (contacts.includes(character.id)) {
                        allChatObjects.push({
                            id: character.id,
                            name: character.name,
                            avatarUrl: character.avatarUrl,
                            isGroup: false
                        });
                    }
                });
            }

            // 添加群聊（从groupChats数组获取）
            if (groupChats && groupChats.length > 0) {
                groupChats.forEach(group => {
                    allChatObjects.push({
                        id: group.id,
                        name: group.name,
                        avatarUrl: group.avatarUrl,
                        isGroup: true
                    });
                });
            }

            console.log('🎨 加载聊天窗口列表:');
            console.log('  - 普通角色数量:', characters?.length || 0);
            console.log('  - 活跃联系人数量:', contacts?.length || 0);
            console.log('  - 群聊数量:', groupChats?.length || 0);
            console.log('  - 总聊天对象:', allChatObjects);

            let html = '';
            allChatObjects.forEach(chatObj => {
                const isSelected = customThemeData.selectedChats.includes(chatObj.id);
                const avatarStyle = chatObj.avatarUrl ?
                    `background-image: url(${chatObj.avatarUrl})` : '';

                // 确定图标
                let iconClass = chatObj.isGroup ? 'fas fa-users' : 'fas fa-user';

                html += `
                    <div class="chat-selection-item ${isSelected ? 'selected' : ''}"
                         onclick="toggleChatSelection('${chatObj.id}')">
                        <div class="chat-selection-checkbox">
                            ${isSelected ? '<i class="fas fa-check"></i>' : ''}
                        </div>
                        <div class="chat-selection-avatar" style="${avatarStyle}">
                            ${!chatObj.avatarUrl ? `<i class="${iconClass}"></i>` : ''}
                        </div>
                        <div class="chat-selection-info">
                            <div class="chat-selection-name">${chatObj.name}</div>
                            <div class="chat-selection-desc">${chatObj.isGroup ? '群聊' : '私聊'}</div>
                        </div>
                    </div>
                `;
            });

            if (html === '') {
                html = '<div style="text-align: center; color: #666; padding: 20px;">暂无聊天窗口<br><small>请先与角色聊天或创建群聊</small></div>';
            }

            container.innerHTML = html;
        }

        // 切换聊天窗口选择状态
        function toggleChatSelection(chatId) {
            const index = customThemeData.selectedChats.indexOf(chatId);
            if (index > -1) {
                customThemeData.selectedChats.splice(index, 1);
            } else {
                customThemeData.selectedChats.push(chatId);
            }
            loadChatSelectionList();
        }

        // 处理应用范围选择
        document.addEventListener('DOMContentLoaded', function() {
            // 应用范围选择事件
            document.addEventListener('click', function(e) {
                if (e.target.closest('.theme-scope-option')) {
                    const option = e.target.closest('.theme-scope-option');
                    const scope = option.dataset.scope;

                    // 移除所有活动状态
                    document.querySelectorAll('.theme-scope-option').forEach(opt => {
                        opt.classList.remove('active');
                    });

                    // 激活当前选项
                    option.classList.add('active');
                    customThemeData.scope = scope;

                    // 显示/隐藏聊天选择列表
                    const selectionList = document.getElementById('chat-selection-list');
                    if (selectionList) {
                        if (scope === 'selected') {
                            selectionList.style.display = 'block';
                            loadChatSelectionList();
                        } else {
                            selectionList.style.display = 'none';
                        }
                    }
                }
            });
        });





        // 🔥【修改】重置自定义主题 - 改为async支持Dexie
        async function resetCustomTheme() {
            if (confirm('确定要重置所有自定义设置吗？此操作不可撤销。')) {
                // 1. 清除已应用的样式
                clearCustomThemeStyles();
                clearGlobalCustomTheme(); // 🔥【新增】清除全局主题
                clearGlobalThemeCache(); // 🔥【优化】清除全局主题缓存
                document.body.classList.remove('custom-theme-applied');

                // 🔥【修改】2. 清除Dexie数据库中的数据
                try {
                    await db.globalThemes.clear();
                    await db.chatThemes.clear();
                    await db.themeSettings.clear();
                    console.log('🧹 已清除Dexie数据库中的主题数据');
                } catch (error) {
                    console.error('❌ 清除主题数据失败:', error);
                }

                // 3. 重置内存中的数据
                customThemeData = {
                    chatTopBg: null,
                    chatBottomBg: null,
                    buttons: {
                        back: null,
                        offline: null,
                        settings: null,
                        expand: null,
                        continue: null,
                        send: null
                    },
                    globalTopAppBar: null,
                    globalBottomAppBar: null,
                    globalBackButton: null,
                    globalAddButton: null,
                    globalBg: null,
                    scope: 'selected',
                    selectedChats: []
                };

                // 4. 重置界面预览图
                document.querySelectorAll('.theme-item-preview').forEach(preview => {
                    preview.style.backgroundImage = 'none';
                    preview.classList.remove('has-image');
                });

                // 5. 重置应用范围选择
                document.querySelectorAll('.theme-scope-option').forEach(opt => {
                    opt.classList.remove('active');
                });
                const defaultScope = document.querySelector('.theme-scope-option[data-scope="selected"]');
                if (defaultScope) {
                    defaultScope.classList.add('active');
                }

                // 6. 显示聊天选择列表（因为默认是selected模式）
                const selectionList = document.getElementById('chat-selection-list');
                if (selectionList) {
                    selectionList.style.display = 'block';
                    loadChatSelectionList(); // 重新加载列表
                }

                console.log('🎨 自定义主题已完全重置');
                showToast('自定义主题已重置', 'success');
            }
        }

        // 预览自定义主题
        function previewCustomTheme() {
            // 检查是否有自定义内容
            const hasCustomContent = customThemeData.chatTopBg ||
                                    customThemeData.chatBottomBg ||
                                    Object.values(customThemeData.buttons).some(btn => btn) ||
                                    customThemeData.globalTopAppBar ||
                                    customThemeData.globalBottomAppBar ||
                                    customThemeData.globalBackButton ||
                                    customThemeData.globalAddButton ||
                                    customThemeData.globalBg;

            if (!hasCustomContent) {
                showToast('请先上传自定义内容', 'warning');
                return;
            }

            // 保存当前主题状态
            const currentThemeState = {
                hasCustomTheme: document.body.classList.contains('custom-theme-applied'),
                cssVariables: {}
            };

            // 保存当前CSS变量
            const root = document.documentElement;
            const variablesToSave = [
                '--custom-chat-top-bg',
                '--custom-chat-bottom-bg',
                '--custom-back-btn',
                '--custom-offline-btn',
                '--custom-settings-btn',
                '--custom-expand-btn',
                '--custom-continue-btn',
                '--custom-send-btn',
                '--custom-global-top-app-bar',
                '--custom-global-bottom-app-bar',
                '--custom-global-back-button',
                '--custom-global-add-button',
                '--custom-global-bg'
            ];

            variablesToSave.forEach(variable => {
                currentThemeState.cssVariables[variable] = root.style.getPropertyValue(variable);
            });

            // 临时应用预览主题
            const previewThemeData = {
                chatTopBg: customThemeData.chatTopBg,
                chatBottomBg: customThemeData.chatBottomBg,
                buttons: { ...customThemeData.buttons },
                globalTopAppBar: customThemeData.globalTopAppBar,
                globalBottomAppBar: customThemeData.globalBottomAppBar,
                globalBackButton: customThemeData.globalBackButton,
                globalAddButton: customThemeData.globalAddButton,
                globalBg: customThemeData.globalBg
            };
            applyCustomThemeStyles(previewThemeData).catch(e => console.error('预览主题失败:', e));

            // 显示预览提示和操作按钮
            showPreviewModal(currentThemeState);
        }

        // 显示预览模态框
        function showPreviewModal(currentThemeState) {
            const modal = document.createElement('div');
            modal.className = 'modal phone-modal';
            modal.style.display = 'flex';
            modal.style.zIndex = '10000';
            modal.id = 'theme-preview-modal';

            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h3 class="modal-title">🎨 主题预览</h3>
                    </div>
                    <div class="modal-body">
                        <div class="preview-info">
                            <div class="preview-tip">
                                <i class="fas fa-eye"></i>
                                <span>正在预览自定义主题效果</span>
                            </div>
                            <div class="preview-desc">
                                您可以切换到聊天界面查看实际效果，预览不会保存设置。
                            </div>
                        </div>

                        <div class="preview-actions">
                            <button class="preview-action-btn goto-chat-btn" onclick="gotoChat()">
                                <i class="fas fa-comment"></i>
                                <span>查看聊天效果</span>
                            </button>
                            <button class="preview-action-btn goto-home-btn" onclick="gotoHome()">
                                <i class="fas fa-home"></i>
                                <span>查看全局效果</span>
                            </button>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="modal-button modal-secondary" onclick="cancelPreview()">取消预览</button>
                        <button class="modal-button modal-primary" onclick="confirmPreview().catch(e => console.error('应用主题失败:', e))">应用主题</button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // 保存当前状态到全局变量
            window.previewState = currentThemeState;

            showToast('🎨 预览模式已开启', 'info');
        }

        // 取消预览
        function cancelPreview() {
            const modal = document.getElementById('theme-preview-modal');
            if (modal) {
                modal.remove();
            }

            // 恢复原始主题状态
            if (window.previewState) {
                const root = document.documentElement;

                // 恢复CSS变量
                Object.keys(window.previewState.cssVariables).forEach(variable => {
                    const value = window.previewState.cssVariables[variable];
                    if (value) {
                        root.style.setProperty(variable, value);
                    } else {
                        root.style.removeProperty(variable);
                    }
                });

                // 恢复主题类
                if (window.previewState.hasCustomTheme) {
                    document.body.classList.add('custom-theme-applied');
                } else {
                    document.body.classList.remove('custom-theme-applied');
                }

                window.previewState = null;
            }

            showToast('预览已取消', 'info');
        }

        // 🔥【修改】确认预览并应用主题 - 改为async支持Dexie
        async function confirmPreview() {
            const modal = document.getElementById('theme-preview-modal');
            if (modal) {
                modal.remove();
            }

            // 🔥【修改】直接应用主题（跳过重复的样式应用）
            await applyCustomTheme();

            window.previewState = null;
        }

        // 预览时跳转到聊天界面
        function gotoChat() {
            try {
                // 如果有活跃的聊天，直接跳转
                if (currentChatCharacter) {
                    showApp('api-chat-screen');
                } else {
                    // 否则跳转到消息列表选择聊天
                    showApp('chat-screen');
                    // 确保switchChatTab函数存在
                    if (typeof switchChatTab === 'function') {
                        switchChatTab('message-list');
                    }
                }

                // 关闭预览模态框
                const modal = document.getElementById('theme-preview-modal');
                if (modal) {
                    modal.remove();
                }
            } catch (error) {
                console.error('跳转到聊天界面失败:', error);
                showToast('跳转失败，请手动切换到聊天界面', 'warning');
            }
        }

        // 预览时跳转到主界面
        function gotoHome() {
            try {
                // 关闭所有应用，回到主屏幕
                const allApps = document.querySelectorAll('.app-screen');
                allApps.forEach(app => {
                    app.style.display = 'none';
                });

                // 显示主屏幕元素
                const clockContainer = document.getElementById('clock-container');
                const homeGrid = document.getElementById('home-grid');
                const dockBar = document.getElementById('dock-bar');
                const mainStatusBar = document.getElementById('status-bar');

                if (clockContainer) clockContainer.style.display = 'block';
                if (homeGrid) homeGrid.style.display = 'grid';
                if (dockBar) dockBar.style.display = 'block';
                if (mainStatusBar) mainStatusBar.style.display = 'flex';

                // 关闭预览模态框
                const modal = document.getElementById('theme-preview-modal');
                if (modal) {
                    modal.remove();
                }
            } catch (error) {
                console.error('跳转到主界面失败:', error);
                showToast('跳转失败，请手动切换到主界面', 'warning');
            }
        }

        // 🔥【修改】应用自定义主题 - 改为async支持Dexie
        async function applyCustomTheme() {
            // 🔥【修复】分别检查聊天内容和全局内容
            const hasChatContent = customThemeData.chatTopBg ||
                                 customThemeData.chatBottomBg ||
                                 Object.values(customThemeData.buttons).some(btn => btn);

            const hasGlobalContent = customThemeData.globalTopAppBar ||
                                   customThemeData.globalBottomAppBar ||
                                   customThemeData.globalBackButton ||
                                   customThemeData.globalAddButton ||
                                   customThemeData.globalBg;

            if (!hasChatContent && !hasGlobalContent) {
                showToast('请先上传自定义内容', 'warning');
                return;
            }

            // 🔥【修改】处理全局样式 - 直接应用，不需要选择聊天窗口
            if (hasGlobalContent) {
                await saveAndApplyGlobalTheme();
                console.log('🎨 全局主题已应用到所有应用页面');
            }

            // 🔥【修复】处理聊天内容 - 只有在有聊天内容时才需要选择聊天窗口
            if (hasChatContent) {
                // 根据应用范围处理
                let targetChats = [];
                if (customThemeData.scope === 'selected') {
                    if (customThemeData.selectedChats.length === 0) {
                        showToast('请选择要应用的聊天窗口', 'warning');
                        return;
                    }
                    targetChats = customThemeData.selectedChats;
            } else if (customThemeData.scope === 'all') {
                // 获取所有聊天对象ID（包括群聊）
                const allChatIds = [];

                // 添加活跃的普通角色聊天
                if (characters && contacts) {
                    characters.forEach(character => {
                        if (contacts.includes(character.id)) {
                            allChatIds.push(character.id);
                        }
                    });
                }

                // 添加所有群聊
                if (groupChats) {
                    groupChats.forEach(group => {
                        allChatIds.push(group.id);
                    });
                }

                targetChats = allChatIds;
            }

                // 🔥【修复】为每个目标聊天窗口保存聊天主题数据（不包含全局样式）
                const chatThemeDataToSave = {
                    chatTopBg: customThemeData.chatTopBg,
                    chatBottomBg: customThemeData.chatBottomBg,
                    buttons: { ...customThemeData.buttons }
                };

                // 🔥【修改】为每个目标聊天窗口保存主题数据到Dexie
                for (const chatId of targetChats) {
                    try {
                        await db.chatThemes.put({
                            chatId: chatId,
                            themeData: chatThemeDataToSave,
                            timestamp: Date.now()
                        });
                        console.log(`🎨 为聊天窗口 ${chatId} 保存聊天自定义主题到Dexie`);
                    } catch (error) {
                        console.error(`❌ 保存聊天主题失败 (${chatId}):`, error);
                    }
                }

                // 检查当前聊天窗口是否在目标范围内，如果是则立即应用聊天主题
                if (currentChatCharacter && targetChats.includes(currentChatCharacter.id)) {
                    applyCustomThemeStyles(chatThemeDataToSave).catch(e => console.error('应用聊天主题失败:', e));
                    console.log(`🎨 当前聊天窗口 ${currentChatCharacter.id} 在目标范围内，立即应用聊天主题`);
                }

                showToast(`聊天主题已应用到 ${targetChats.length} 个聊天窗口`, 'success');
            }

            // 🔥【修改】设置自定义主题标记，表示当前使用的是自定义主题 - 使用Dexie
            try {
                await db.themeSettings.put({
                    id: 'selectedTheme',
                    settingName: 'selectedTheme',
                    settingValue: 'custom',
                    timestamp: Date.now()
                });
            } catch (error) {
                console.error('❌ 保存主题设置失败:', error);
            }

            // 🔥【修复】根据应用的内容显示不同的提示
            if (hasGlobalContent && !hasChatContent) {
                showToast('全局主题已应用到所有应用页面', 'success');
            } else if (hasGlobalContent && hasChatContent) {
                showToast('全局主题和聊天主题已应用', 'success');
            }

            // 🔥【新增】清除所有已设置项的状态指示器
            clearAllThemeItemStatus();

            // 返回主题设置页面
            setTimeout(() => {
                backToSettings('custom-theme-screen');
            }, 1500);
        }

        // 🔥【修改】应用聊天自定义主题样式 - 改为async支持Dexie
        async function applyCustomThemeStyles(themeData = null) {
            const root = document.documentElement;

            // 🔥【修复】清除之前的聊天自定义样式（不影响全局样式）
            clearCustomThemeStyles();

            // 🔥【修改】如果没有传入主题数据，尝试从当前聊天窗口加载 - 使用Dexie
            if (!themeData && currentChatCharacter) {
                try {
                    const savedTheme = await db.chatThemes.where('chatId').equals(currentChatCharacter.id).first();
                    if (savedTheme && savedTheme.themeData) {
                        themeData = savedTheme.themeData;
                        console.log(`🎨 为聊天窗口 ${currentChatCharacter.id} 从Dexie加载自定义主题`);
                    } else {
                        console.log(`🎨 聊天窗口 ${currentChatCharacter.id} 没有自定义主题`);
                        return;
                    }
                } catch (error) {
                    console.error('❌ 加载聊天主题数据失败:', error);
                    return;
                }
            }

            // 如果仍然没有主题数据，退出
            if (!themeData) {
                console.log('🎨 没有主题数据可应用');
                return;
            }

            // 🔥【优化】预加载聊天主题图片
            const chatImagesToPreload = [];
            if (themeData.chatTopBg) chatImagesToPreload.push(themeData.chatTopBg);
            if (themeData.chatBottomBg) chatImagesToPreload.push(themeData.chatBottomBg);
            if (themeData.buttons) {
                Object.values(themeData.buttons).forEach(buttonImage => {
                    if (buttonImage && buttonImage.trim() !== '') {
                        chatImagesToPreload.push(buttonImage);
                    }
                });
            }

            // 预加载聊天主题图片
            try {
                await Promise.all(chatImagesToPreload.map(url => preloadImage(url)));
                console.log('🎨 聊天主题图片预加载完成');
            } catch (error) {
                console.warn('🎨 部分聊天主题图片预加载失败:', error);
            }

            // 应用聊天界面样式
            if (themeData.chatTopBg) {
                root.style.setProperty('--custom-chat-top-bg', `url(${themeData.chatTopBg})`);
                document.body.setAttribute('data-has-chat-top-bg', 'true');
                console.log('🎨 设置顶部背景:', themeData.chatTopBg);
            }

            if (themeData.chatBottomBg) {
                root.style.setProperty('--custom-chat-bottom-bg', `url(${themeData.chatBottomBg})`);
                document.body.setAttribute('data-has-chat-bottom-bg', 'true');
                console.log('🎨 设置底部背景:', themeData.chatBottomBg);
            }

            // 🔥【修复】应用按钮样式 - 只处理有图片的按钮，并添加标记
            const appliedButtons = new Set();
            if (themeData.buttons) {
                Object.keys(themeData.buttons).forEach(buttonType => {
                    const buttonImage = themeData.buttons[buttonType];
                    if (buttonImage && buttonImage.trim() !== '') {
                        root.style.setProperty(`--custom-${buttonType}-btn`, `url(${buttonImage})`);
                        // 为特定按钮添加自定义样式类
                        applyButtonCustomStyle(buttonType, buttonImage);
                        // 添加到已应用列表
                        appliedButtons.add(buttonType);
                        console.log(`🎨 应用按钮样式: ${buttonType} -> ${buttonImage}`);
                    }
                });
            }

            // 🔥【修复】为body添加具体的按钮样式标记，用于CSS选择器
            const buttonTypes = ['back', 'offline', 'settings', 'expand', 'continue', 'send'];
            buttonTypes.forEach(buttonType => {
                if (appliedButtons.has(buttonType)) {
                    document.body.setAttribute(`data-has-custom-${buttonType}-btn`, 'true');
                } else {
                    document.body.removeAttribute(`data-has-custom-${buttonType}-btn`);
                }
            });

            // 🔥【修复】全局样式处理已移动到 applyGlobalCustomTheme 函数

            // 添加聊天主题应用标记
            document.body.classList.add('custom-theme-applied');

            // 🔥【修复】不在聊天主题应用时重复应用全局主题，避免卡顿和冲突
            // 全局主题应该只在页面加载时和主题切换时应用
            console.log('🎨 聊天主题应用完成，跳过全局主题重复应用以避免冲突');

            console.log('🎨 聊天自定义主题样式已应用');
        }

        // 🔥【修复】清除聊天自定义主题样式（不清除全局样式）
        function clearCustomThemeStyles() {
            console.log('🎨 开始清除聊天自定义主题样式...');

            const root = document.documentElement;
            const variablesToClear = [
                '--custom-chat-top-bg',
                '--custom-chat-bottom-bg',
                '--custom-back-btn',
                '--custom-offline-btn',
                '--custom-settings-btn',
                '--custom-expand-btn',
                '--custom-continue-btn',
                '--custom-send-btn'
                // 🔥【修复】不再清除全局样式变量
            ];

            // 清除CSS变量
            variablesToClear.forEach(variable => {
                root.style.removeProperty(variable);
                console.log(`清除CSS变量: ${variable}`);
            });

            // 清除data属性
            document.body.removeAttribute('data-has-chat-top-bg');
            document.body.removeAttribute('data-has-chat-bottom-bg');

            // 🔥【修复】清除聊天按钮样式标记
            const buttonTypes = ['back', 'offline', 'settings', 'expand', 'continue', 'send'];
            buttonTypes.forEach(buttonType => {
                document.body.removeAttribute(`data-has-custom-${buttonType}-btn`);
            });

            // 🔥【修复】不再清除全局样式标记，保持全局主题生效

            // 清除按钮的内联样式
            clearButtonCustomStyles();

            // 清除背景样式
            clearBackgroundCustomStyles();

            console.log('🎨 自定义主题样式清除完成');
        }

        // 为特定按钮应用自定义样式
        function applyButtonCustomStyle(buttonType, imageUrl) {
            let selector = '';

            switch (buttonType) {
                case 'back':
                    selector = '.back-btn';
                    break;
                case 'offline':
                    selector = '#offline-mode-icon';
                    break;
                case 'settings':
                    selector = '.header-actions .action-btn:last-child';
                    break;
                case 'expand':
                    selector = '.toggle-tools-btn';
                    break;
                case 'continue':
                    selector = '.chat-action-btn[onclick*="triggerSmartReply"]';
                    break;
                case 'send':
                    selector = '.send-button';
                    break;
            }

            if (selector) {
                const elements = document.querySelectorAll(selector);
                elements.forEach(element => {
                    // 完全用图片替代按钮 - 使用!important确保优先级
                    element.style.setProperty('background-image', `url(${imageUrl})`, 'important');
                    element.style.setProperty('background-size', 'cover', 'important');
                    element.style.setProperty('background-position', 'center', 'important');
                    element.style.setProperty('background-repeat', 'no-repeat', 'important');
                    element.style.setProperty('color', 'transparent', 'important'); // 隐藏文字
                    element.style.setProperty('text-shadow', 'none', 'important'); // 移除文字阴影
                    element.style.setProperty('border', 'none', 'important'); // 移除边框
                    element.style.setProperty('box-shadow', 'none', 'important'); // 移除阴影
                    element.style.setProperty('background-color', 'transparent', 'important'); // 移除背景色
                    element.classList.add('custom-button-styled');

                    // 隐藏按钮内的图标和文字
                    const icons = element.querySelectorAll('i, span, .icon');
                    icons.forEach(icon => {
                        icon.style.setProperty('opacity', '0', 'important');
                    });
                });
            }
        }

        // 清除按钮的自定义样式
        function clearButtonCustomStyles() {
            console.log('🎨 清除按钮自定义样式...');

            // 清除所有标记为自定义样式的按钮
            const customButtons = document.querySelectorAll('.custom-button-styled');
            customButtons.forEach(button => {
                // 使用removeProperty恢复默认样式
                button.style.removeProperty('background-image');
                button.style.removeProperty('background-size');
                button.style.removeProperty('background-position');
                button.style.removeProperty('background-repeat');
                button.style.removeProperty('color');
                button.style.removeProperty('text-shadow');
                button.style.removeProperty('border');
                button.style.removeProperty('box-shadow');
                button.style.removeProperty('background-color');
                button.classList.remove('custom-button-styled');

                // 恢复按钮内的图标和文字显示
                const icons = button.querySelectorAll('i, span, .icon');
                icons.forEach(icon => {
                    icon.style.removeProperty('opacity');
                });

                console.log('清除按钮样式:', button.className);
            });

            // 额外清除可能的按钮样式（防止遗漏）
            const buttonSelectors = [
                '.back-btn',
                '#offline-mode-icon',
                '.header-actions .action-btn:last-child',
                '.toggle-tools-btn',
                '.chat-action-btn[onclick*="triggerSmartReply"]',
                '.send-button'
            ];

            buttonSelectors.forEach(selector => {
                const elements = document.querySelectorAll(selector);
                elements.forEach(element => {
                    // 使用removeProperty恢复默认样式
                    element.style.removeProperty('background-image');
                    element.style.removeProperty('background-size');
                    element.style.removeProperty('background-position');
                    element.style.removeProperty('background-repeat');
                    element.style.removeProperty('color');
                    element.style.removeProperty('text-shadow');
                    element.style.removeProperty('border');
                    element.style.removeProperty('box-shadow');
                    element.style.removeProperty('background-color');

                    // 恢复按钮内的图标和文字显示
                    const icons = element.querySelectorAll('i, span, .icon');
                    icons.forEach(icon => {
                        icon.style.removeProperty('opacity');
                    });
                });
            });
        }

        // 清除背景自定义样式
        function clearBackgroundCustomStyles() {
            console.log('🎨 清除背景自定义样式...');

            // 清除聊天界面背景
            const chatTopElements = document.querySelectorAll('#api-chat-screen .app-status-bar, #api-chat-screen .app-header');
            chatTopElements.forEach(element => {
                element.style.backgroundImage = '';
                element.style.backgroundSize = '';
                element.style.backgroundPosition = '';
                element.style.backgroundRepeat = '';
            });

            const chatBottomElements = document.querySelectorAll('#api-chat-screen .chat-input-area');
            chatBottomElements.forEach(element => {
                element.style.backgroundImage = '';
                element.style.backgroundSize = '';
                element.style.backgroundPosition = '';
                element.style.backgroundRepeat = '';
            });

            // 清除全局背景
            const globalElements = document.querySelectorAll('.app-status-bar, .app-screen');
            globalElements.forEach(element => {
                element.style.backgroundImage = '';
                element.style.backgroundSize = '';
                element.style.backgroundPosition = '';
                element.style.backgroundRepeat = '';
            });
        }

        // 🔥【删除】旧的主题加载函数 - 现在使用Dexie数据库
        // 主题加载已迁移到数据库升级过程中自动处理

        // 🔥【删除】旧的迁移函数 - 现在在数据库升级中自动处理

        // 🔥【修改】显示主题管理界面 - 使用Dexie
        async function showThemeManagement() {
            try {
                // 获取所有有自定义主题的聊天窗口
                const themeChats = [];
                const allChatThemes = await db.chatThemes.toArray();

                // 检查所有角色聊天
                if (characters && contacts) {
                    characters.forEach(character => {
                        if (contacts.includes(character.id)) {
                            const chatTheme = allChatThemes.find(theme => theme.chatId === character.id);
                            if (chatTheme) {
                                themeChats.push({
                                    id: character.id,
                                    name: character.name,
                                    type: 'character',
                                    themeData: chatTheme.themeData
                                });
                            }
                        }
                    });
                }

                // 检查所有群聊
                if (groupChats) {
                    groupChats.forEach(group => {
                        const chatTheme = allChatThemes.find(theme => theme.chatId === group.id);
                        if (chatTheme) {
                            themeChats.push({
                                id: group.id,
                                name: group.name,
                                type: 'group',
                                themeData: chatTheme.themeData
                            });
                        }
                    });
                }

                if (themeChats.length === 0) {
                    showToast('没有找到任何自定义主题', 'info');
                    return;
                }

            // 创建管理界面
            const modal = document.createElement('div');
            modal.className = 'modal phone-modal';
            modal.style.display = 'flex';
            modal.style.zIndex = '10000';
            modal.id = 'theme-management-modal';

            const chatListHtml = themeChats.map(chat => `
                <div class="theme-chat-item" data-chat-id="${chat.id}">
                    <div class="theme-chat-info">
                        <div class="theme-chat-name">${chat.name}</div>
                        <div class="theme-chat-type">${chat.type === 'group' ? '群聊' : '角色'}</div>
                    </div>
                    <div class="theme-chat-actions">
                        <button class="theme-chat-btn preview-theme-btn" onclick="previewChatTheme('${chat.id}')" title="预览主题">
                            <i class="fas fa-eye"></i>
                        </button>
                        <button class="theme-chat-btn remove-theme-btn" onclick="removeChatTheme('${chat.id}')" title="移除主题">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `).join('');

            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h3 class="modal-title">主题管理</h3>
                        <button class="modal-close" onclick="closeThemeManagement()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="theme-management-info">
                            <p>找到 ${themeChats.length} 个聊天窗口有自定义主题</p>
                        </div>
                        <div class="theme-chat-list">
                            ${chatListHtml}
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="modal-button modal-secondary" onclick="closeThemeManagement()">关闭</button>
                        <button class="modal-button modal-danger" onclick="clearAllThemes()">清除所有主题</button>
                    </div>
                </div>
            `;

                document.body.appendChild(modal);
            } catch (error) {
                console.error('❌ 显示主题管理界面失败:', error);
                showToast('加载主题管理界面失败', 'error');
            }
        }

        // 🔥【新增】关闭主题管理界面
        function closeThemeManagement() {
            const modal = document.getElementById('theme-management-modal');
            if (modal) {
                modal.remove();
            }
        }

        // 🔥【修改】预览指定聊天窗口的主题 - 使用Dexie
        async function previewChatTheme(chatId) {
            try {
                const chatTheme = await db.chatThemes.where('chatId').equals(chatId).first();
                if (chatTheme && chatTheme.themeData) {
                    await applyCustomThemeStyles(chatTheme.themeData);

                    // 找到聊天窗口名称
                    let chatName = '未知聊天';
                    if (characters && contacts) {
                        const character = characters.find(c => c.id === chatId);
                        if (character && contacts.includes(character.id)) {
                            chatName = character.name;
                        }
                    }
                    if (groupChats) {
                        const group = groupChats.find(g => g.id === chatId);
                        if (group) {
                            chatName = group.name;
                        }
                    }

                    showToast(`正在预览 ${chatName} 的主题`, 'info');
                } else {
                    showToast('未找到主题数据', 'error');
                }
            } catch (error) {
                console.error('❌ 预览主题失败:', error);
                showToast('预览主题失败', 'error');
            }
        }

        // 🔥【修改】移除指定聊天窗口的主题 - 使用Dexie
        async function removeChatTheme(chatId) {
            try {
                // 找到聊天窗口名称
                let chatName = '未知聊天';
                if (characters && contacts) {
                    const character = characters.find(c => c.id === chatId);
                    if (character && contacts.includes(character.id)) {
                        chatName = character.name;
                    }
                }
                if (groupChats) {
                    const group = groupChats.find(g => g.id === chatId);
                    if (group) {
                        chatName = group.name;
                    }
                }

                if (confirm(`确定要移除 ${chatName} 的自定义主题吗？`)) {
                    await db.chatThemes.where('chatId').equals(chatId).delete();

                    // 如果当前聊天窗口就是被移除主题的窗口，清除样式
                    if (currentChatCharacter && currentChatCharacter.id === chatId) {
                        clearCustomThemeStyles();
                    }

                    showToast(`已移除 ${chatName} 的自定义主题`, 'success');

                    // 刷新管理界面
                    closeThemeManagement();
                    setTimeout(() => showThemeManagement().catch(e => console.error('刷新主题管理失败:', e)), 100);
                }
            } catch (error) {
                console.error('❌ 移除主题失败:', error);
                showToast('移除主题失败', 'error');
            }
        }

        // 🔥【修改】清除所有自定义主题 - 使用Dexie
        async function clearAllThemes() {
            if (confirm('确定要清除所有聊天窗口的自定义主题吗？此操作不可撤销！')) {
                try {
                    // 获取所有聊天主题数量
                    const allChatThemes = await db.chatThemes.toArray();
                    const themeCount = allChatThemes.length;

                    // 删除所有聊天主题数据
                    await db.chatThemes.clear();

                    // 清除当前应用的主题样式
                    clearCustomThemeStyles();

                    showToast(`已清除 ${themeCount} 个聊天窗口的自定义主题`, 'success');

                    // 关闭管理界面
                    closeThemeManagement();
                } catch (error) {
                    console.error('❌ 清除所有主题失败:', error);
                    showToast('清除所有主题失败', 'error');
                }
            }
        }

        // 🔥【修改】页面加载时应用保存的主题 - 使用Dexie
        document.addEventListener('DOMContentLoaded', async function() {
            try {
                // 🔥【修改】检查当前选择的主题类型，只在使用自定义主题时才应用
                const themeSettingRecord = await db.themeSettings.get('selectedTheme');
                const currentTheme = themeSettingRecord ? themeSettingRecord.settingValue : null;

                if (!currentTheme || currentTheme === 'custom') {
                    // 没有设置主题或使用自定义主题时，应用自定义主题
                    await applyGlobalCustomTheme(); // 应用全局主题
                    console.log('🎨 页面加载时从Dexie应用全局自定义主题');
                } else {
                    // 使用系统主题时，应用对应的系统主题
                    const body = document.body;
                    body.removeAttribute('data-theme');
                    if (currentTheme !== 'default') {
                        body.setAttribute('data-theme', currentTheme);
                    }
                    console.log(`🎨 页面加载时应用系统主题: ${currentTheme}`);
                }
            } catch (error) {
                console.error('❌ 页面加载时应用主题失败:', error);
            }
        });

        // 🔥【修改】初始化自定义主题界面 - 改为async支持Dexie
        async function initCustomThemeScreen() {
            console.log('🎨 初始化自定义主题界面');

            // 确保默认选中聊天界面选项卡
            switchCustomThemeTab('chat');

            // 🔥【修改】加载保存的自定义主题数据到界面 - 使用async
            await loadCustomThemeToUI();
        }

        // 🔥【修改】加载自定义主题数据到界面 - 改为async支持Dexie
        async function loadCustomThemeToUI() {
            try {
                // 🔥【修改】从Dexie数据库加载全局主题数据
                const savedGlobalTheme = await db.globalThemes.get('global');
                let globalThemeData = {};
                if (savedGlobalTheme && savedGlobalTheme.themeData) {
                    globalThemeData = savedGlobalTheme.themeData;
                    console.log('🎨 从Dexie加载全局主题数据到界面');
                }

                // 🔥【修改】构建完整的主题数据对象
                const themeData = {
                    // 聊天界面数据（从内存中的customThemeData获取，因为这是编辑中的数据）
                    chatTopBg: customThemeData.chatTopBg,
                    chatBottomBg: customThemeData.chatBottomBg,
                    buttons: { ...customThemeData.buttons },
                    // 全局界面数据（从数据库加载）
                    globalTopAppBar: globalThemeData.globalTopAppBar,
                    globalBottomAppBar: globalThemeData.globalBottomAppBar,
                    globalBackButton: globalThemeData.globalBackButton,
                    globalAddButton: globalThemeData.globalAddButton,
                    globalBg: globalThemeData.globalBg,
                    // 应用范围设置
                    scope: customThemeData.scope || 'selected',
                    selectedChats: customThemeData.selectedChats || []
                };

                // 更新内存中的customThemeData
                customThemeData = themeData;

                    // 更新预览图和状态指示器
                    if (themeData.chatTopBg) {
                        updatePreview('chat-top-bg-preview', themeData.chatTopBg);
                        updateThemeItemStatus('chat-top-bg-item', true);
                    }
                    if (themeData.chatBottomBg) {
                        updatePreview('chat-bottom-bg-preview', themeData.chatBottomBg);
                        updateThemeItemStatus('chat-bottom-bg-item', true);
                    }

                    // 更新按钮预览和状态指示器
                    if (themeData.buttons && typeof themeData.buttons === 'object') {
                        Object.keys(themeData.buttons).forEach(buttonType => {
                            if (themeData.buttons[buttonType]) {
                                updatePreview(`${buttonType}-btn-preview`, themeData.buttons[buttonType]);
                                updateThemeItemStatus(`${buttonType}-btn-item`, true);
                            }
                        });
                    }

                    // 🔥【删除重复】全局主题本来就有状态指示器，不需要在这里重复更新
                    // 只更新预览图即可
                    if (themeData.globalTopAppBar) {
                        updatePreview('global-top-app-bar-preview', themeData.globalTopAppBar);
                    }
                    if (themeData.globalBottomAppBar) {
                        updatePreview('global-bottom-app-bar-preview', themeData.globalBottomAppBar);
                    }
                    if (themeData.globalBackButton) {
                        updatePreview('global-back-button-preview', themeData.globalBackButton);
                    }
                    if (themeData.globalAddButton) {
                        updatePreview('global-add-button-preview', themeData.globalAddButton);
                    }
                    if (themeData.globalBg) {
                        updatePreview('global-bg-preview', themeData.globalBg);
                    }

                    // 更新应用范围选择
                    document.querySelectorAll('.theme-scope-option').forEach(opt => {
                        opt.classList.remove('active');
                    });
                    const activeScope = document.querySelector(`.theme-scope-option[data-scope="${themeData.scope}"]`);
                    if (activeScope) {
                        activeScope.classList.add('active');
                    }

            } catch (error) {
                console.error('❌ 加载自定义主题界面数据失败:', error);
            }
        }

        // 🔥【修改】加载保存的主题 - 使用Dexie
        async function loadSavedTheme() {
            try {
                const themeSettingRecord = await db.themeSettings.get('selectedTheme');
                const savedTheme = themeSettingRecord ? themeSettingRecord.settingValue : null;
                if (savedTheme && savedTheme !== 'default') {
                    document.body.setAttribute('data-theme', savedTheme);
                }
            } catch (error) {
                console.error('❌ 加载保存的主题失败:', error);
            }
        }

        // 世界书相关功能
        let worldbooks = [];
        let editingWorldbook = null;

        // 加载世界书数据 - 使用IndexedDB（包含数据迁移）
        async function loadWorldbooks() {
            try {
                // 先从IndexedDB加载
                const savedWorldbooks = await db.worldbooks.toArray();

                if (savedWorldbooks.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('worldbooks');
                    if (localStorageData) {
                        console.log('检测到localStorage中的世界书数据，开始迁移...');
                        const localWorldbooks = JSON.parse(localStorageData);

                        if (localWorldbooks.length > 0) {
                            // 确保每个世界书都有id字段
                            const migrationData = localWorldbooks.map(wb => ({
                                id: wb.id || Date.now().toString() + Math.random(),
                                title: wb.title,
                                content: wb.content,
                                createdAt: wb.createdAt || new Date().toISOString(),
                                updatedAt: wb.updatedAt || new Date().toISOString()
                            }));

                            // 迁移到IndexedDB
                            await db.worldbooks.bulkAdd(migrationData);
                            worldbooks = migrationData;
                            console.log('世界书数据迁移完成:', worldbooks);
                        } else {
                            worldbooks = [];
                        }
                    } else {
                        worldbooks = [];
                    }
                } else {
                    // IndexedDB中有数据，直接使用
                    worldbooks = savedWorldbooks;
                    console.log('从IndexedDB加载世界书数据:', worldbooks);
                }

                // 角色世界书迁移功能已移除

            } catch (error) {
                console.error('加载世界书失败:', error);
                // 如果IndexedDB失败，回退到localStorage
                const localStorageData = localStorage.getItem('worldbooks');
                if (localStorageData) {
                    try {
                        worldbooks = JSON.parse(localStorageData);
                } catch (e) {
                        worldbooks = [];
                    }
                } else {
                    worldbooks = [];
                }

                // 角色世界书迁移功能已移除
            }
            renderWorldbookList();
        }



        // 保存世界书数据 - 使用IndexedDB
        async function saveWorldbooks() {
            try {
                console.log('保存世界书数据到IndexedDB:', worldbooks);

                // 🔥【安全修复】使用事务确保原子操作，防止数据丢失
                if (worldbooks.length === 0) {
                    console.warn('⚠️ 世界书数据为空，跳过保存操作');
                    return;
                }

                // 使用事务进行原子操作
                await db.transaction('rw', db.worldbooks, async () => {
                    await db.worldbooks.clear();
                    await db.worldbooks.bulkAdd(worldbooks);
                });

                console.log(`✅ 安全保存了 ${worldbooks.length} 个世界书到数据库`);

                console.log('世界书数据保存成功');
            } catch (error) {
                console.error('保存世界书时发生错误:', error);
                // 如果IndexedDB失败，回退到localStorage
            localStorage.setItem('worldbooks', JSON.stringify(worldbooks));
            }
        }

        function showWorldbookForm(isGlobal) {
    // 根据传入的类型来决定表单标题
    let title;
    if (isGlobal) {
        title = '新建全局设定';
    } else {
        title = '新建局部设定';
    }
    document.getElementById('worldbook-form-title').textContent = title;

    editingWorldbook = null; // 清除编辑状态
            document.getElementById('worldbook-title').value = '';
            document.getElementById('worldbook-content').value = '';

    // 将创建类型暂存起来，以便保存时使用
    window.newWorldbookIsGlobal = isGlobal;

            showApp('worldbook-form-screen');
        }

        function hideWorldbookForm() {
            hideApp('worldbook-form-screen');
            // 确保返回到世界书应用，而不是主屏幕
            showApp('worldbook-screen');
        }

        async function saveWorldbook() {
            const title = document.getElementById('worldbook-title').value.trim();
            const content = document.getElementById('worldbook-content').value.trim();

    if (!title || !content) {
        alert('请输入标题和内容');
                return;
            }

    let isGlobal;
    if (editingWorldbook) {
        // 如果是编辑模式，保持其原有的类型不变
        isGlobal = editingWorldbook.isGlobal;
    } else {
        // 如果是新建模式，读取我们暂存的类型
        isGlobal = window.newWorldbookIsGlobal;
            }

            const worldbook = {
                id: editingWorldbook ? editingWorldbook.id : Date.now().toString(),
                title: title,
                content: content,
        isGlobal: isGlobal, // 根据正确的状态设置
                createdAt: editingWorldbook ? editingWorldbook.createdAt : new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };



            if (editingWorldbook) {
                const index = worldbooks.findIndex(w => w.id === editingWorldbook.id);
        if (index !== -1) worldbooks[index] = worldbook;
            } else {
                worldbooks.push(worldbook);
            }

            await saveWorldbooks();
            renderWorldbookList();
            showToast(editingWorldbook ? '世界书已更新！' : '世界书已创建！', 'success');
            hideWorldbookForm();
        }
// --- 新增函数 ---
async function toggleGlobalWorldbook(bookId, isEnabled) {
    // 确保window.activeGlobalWorldbooks存在
    if (!window.activeGlobalWorldbooks) {
        window.activeGlobalWorldbooks = [];
    }

    if (isEnabled) {
        // 如果开启，添加到激活列表（如果不存在）
        if (!window.activeGlobalWorldbooks.includes(bookId)) {
            window.activeGlobalWorldbooks.push(bookId);
        }
    } else {
        // 如果关闭，从激活列表中移除
        window.activeGlobalWorldbooks = window.activeGlobalWorldbooks.filter(id => id !== bookId);
    }

    // 保存激活状态到数据库的 globalSettings 表
    try {
        await db.globalSettings.put({
            id: 'main',
            activeGlobalWorldbooks: window.activeGlobalWorldbooks
        });
        console.log('全局世界书设置已保存:', window.activeGlobalWorldbooks);
        showToast('全局设定已更新', 'success');
    } catch (error) {
        console.error("保存全局世界书设置失败:", error);
        showToast('设置保存失败', 'error');
    }
        }

        function editWorldbook(id) {
            const worldbook = worldbooks.find(w => w.id === id);
            if (worldbook) {
                editingWorldbook = worldbook;
        // 编辑时不显示“新建”，而是“编辑”
        let title;
        if (worldbook.isGlobal) {
            title = '编辑全局设定';
        } else {
            title = '编辑局部设定';
        }
        document.getElementById('worldbook-form-title').textContent = title;
                document.getElementById('worldbook-title').value = worldbook.title || worldbook.name;
                document.getElementById('worldbook-content').value = worldbook.content;
                showApp('worldbook-form-screen');
            }
        }

        async function deleteWorldbook(id) {
            if (confirm('确定要删除这个世界书吗？')) {
                console.log('🗑️ 删除世界书:', id);
                console.log('删除前的世界书列表:', worldbooks.map(w => ({id: w.id, name: w.name || w.title})));

                // 从内存数组中删除
                const initialLength = worldbooks.length;
                worldbooks = worldbooks.filter(w => w.id !== id);
                const finalLength = worldbooks.length;

                console.log(`删除操作: ${initialLength} -> ${finalLength}, 删除了 ${initialLength - finalLength} 个项目`);

                if (initialLength === finalLength) {
                    console.warn('⚠️ 删除失败：未找到要删除的世界书');
                    showToast('删除失败：未找到指定的世界书', 'error');
                    return;
                }

                // 保存到数据库
                try {
                    await saveWorldbooks();
                    console.log('✅ 世界书删除成功');
                    showToast('世界书已删除', 'success');
                } catch (error) {
                    console.error('❌ 删除世界书时数据库保存失败:', error);
                    showToast('删除失败：数据库保存错误', 'error');
                }

                // 重新渲染列表
                renderWorldbookList();
            }
        }

// 用这段新代码，完整替换掉旧的 renderWorldbookList 函数
        function renderWorldbookList() {
    const globalContainer = document.getElementById('global-worldbooks-content');
    const localContainer = document.getElementById('local-worldbooks-content');
    if (!globalContainer || !localContainer) return;

    const globalBooks = worldbooks.filter(w => w.isGlobal);
    const localBooks = worldbooks.filter(w => !w.isGlobal);

    let globalHtml = '';
    let localHtml = '';

    // --- 渲染全局世界书 ---
    globalHtml += `<div class="worldbook-section">`;
    if (globalBooks.length > 0) {
        globalBooks.forEach(book => {
            // 确保使用window.activeGlobalWorldbooks并检查其是否为数组
            const isChecked = Array.isArray(window.activeGlobalWorldbooks) && window.activeGlobalWorldbooks.includes(book.id) ? 'checked' : '';
            const dateObj = new Date(book.updatedAt || book.createdAt || Date.now());
            const date = isNaN(dateObj.getTime()) ? '未知日期' : dateObj.toLocaleDateString();
            const preview = truncateText(book.content, 60);
            globalHtml += `
                <div class="worldbook-item" onclick="editWorldbook('${book.id}')">
                    <div class="worldbook-header">
                        <div class="worldbook-content-flex">
                            <div class="worldbook-title">${book.title || book.name}</div>
                            <div class="worldbook-desc-text">${preview}</div>
                            <div class="worldbook-date-text">更新于 ${date}</div>
                        </div>
                        <div class="worldbook-actions">
                            <button onclick="event.stopPropagation(); deleteWorldbook('${book.id}')" class="delete-worldbook-btn">
                                <i class="fas fa-trash"></i>
                            </button>
                            <label class="toggle-switch" onclick="event.stopPropagation()">
                                <input type="checkbox" onchange="toggleGlobalWorldbook('${book.id}', this.checked)" ${isChecked}>
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                </div>
            `;
        });
    } else {
        globalHtml += '<div class="empty-message">暂无全局设定</div>';
    }
    globalHtml += '</div>';

    // --- 渲染局部世界书 ---
    localHtml += `<div class="worldbook-section">`;
    if (localBooks.length > 0) {
        localBooks.forEach(book => {
            const dateObj = new Date(book.updatedAt || book.createdAt || Date.now());
            const date = isNaN(dateObj.getTime()) ? '未知日期' : dateObj.toLocaleDateString();
            const preview = truncateText(book.content, 60);
            localHtml += `
                <div class="worldbook-item" onclick="editWorldbook('${book.id}')">
                    <div class="worldbook-header">
                        <div class="worldbook-content-flex">
                            <div class="worldbook-title">${book.title || book.name}</div>
                            <div class="worldbook-desc-text">${preview}</div>
                            <div class="worldbook-date-text">更新于 ${date}</div>
                        </div>
                        <button onclick="event.stopPropagation(); deleteWorldbook('${book.id}')" class="delete-worldbook-btn">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `;
        });
    } else {
        localHtml += '<div class="empty-message">暂无局部设定</div>';
    }
    localHtml += '</div>';

    globalContainer.innerHTML = globalHtml;
    localContainer.innerHTML = localHtml;
}
function switchWorldbookTab(tabName) {
    currentWorldbookTab = tabName; // <--- 核心修改：记录当前标签页

    const globalContent = document.getElementById('global-worldbooks-content');
    const localContent = document.getElementById('local-worldbooks-content');
    const tabs = document.querySelectorAll('.worldbook-tab');

    tabs.forEach(tab => {
        if (tab.getAttribute('onclick').includes(tabName)) {
            tab.classList.add('active');
        } else {
            tab.classList.remove('active');
        }
    });

    // 隐藏所有内容面板
    globalContent.style.display = 'none';
    localContent.style.display = 'none';

    if (tabName === 'global') {
        globalContent.style.display = 'block';
    } else if (tabName === 'local') {
        localContent.style.display = 'block';
    }

    renderWorldbookList();
}
function onWorldbookAddClick() {
    if (currentWorldbookTab === 'global') {
        showWorldbookForm(true); // 创建全局设定
    } else if (currentWorldbookTab === 'local') {
        showWorldbookForm(false); // 创建局部设定
    }
        }





        // 调试：查看所有世界书数据
        function debugWorldbooks() {
            console.log('📋 当前所有世界书数据:');
            worldbooks.forEach((wb, index) => {
                console.log(`${index + 1}. ID: "${wb.id}", 名称: "${wb.name || wb.title}", 来源: "${wb.source}", 分类: "${wb.category}", 全局: ${wb.isGlobal}`);
            });
            console.log(`总计: ${worldbooks.length} 个世界书`);
            return worldbooks;
        }



        // 清空所有世界书（终极方案）
        async function clearAllWorldbooks() {
            if (confirm('⚠️ 确定要删除所有世界书吗？这个操作不可撤销！')) {
                console.log('💣 清空所有世界书...');
                const count = worldbooks.length;
                worldbooks = [];
                await saveWorldbooks();
                renderWorldbookList();
                showToast(`已清空所有${count}个世界书`, 'success');
                console.log('✅ 所有世界书已清空');
            }
        }

        // 修复世界书ID问题
        async function fixWorldbookIds() {
            console.log('🔧 修复世界书ID问题...');
            let fixedCount = 0;

            worldbooks.forEach((wb, index) => {
                if (!wb.id || typeof wb.id !== 'string') {
                    wb.id = `fixed_${Date.now()}_${index}`;
                    fixedCount++;
                    console.log(`修复了世界书 "${wb.name || wb.title}" 的ID`);
                }
            });

            if (fixedCount > 0) {
                await saveWorldbooks();
                renderWorldbookList();
                showToast(`修复了${fixedCount}个世界书的ID`, 'success');
            } else {
                console.log('所有世界书ID都正常');
            }

            return fixedCount;
        }








        // ================== 音乐播放器功能 ==================

        // LRC歌词解析函数
        function parseLRC(lrcContent) {
            if (!lrcContent) return { lyrics: ['♪ 暂无歌词'], timings: [] };

            const lines = lrcContent.split('\n');
            const lyrics = [];
            const timings = [];
            const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/g;

            for (const line of lines) {
                let match;
                const matches = [];

                // 找到所有时间标签
                while ((match = timeRegex.exec(line)) !== null) {
                    const minutes = parseInt(match[1]);
                    const seconds = parseInt(match[2]);
                    const milliseconds = parseInt(match[3].padEnd(3, '0'));
                    const totalSeconds = minutes * 60 + seconds + milliseconds / 1000;
                    matches.push(totalSeconds);
                }

                const text = line.replace(/\[\d{2}:\d{2}\.\d{2,3}\]/g, '').trim();

                if (text && !text.startsWith('[')) {
                    // 为每个时间标签创建一个歌词条目
                    if (matches.length > 0) {
                        for (const time of matches) {
                            lyrics.push(text);
                            timings.push(time);
                        }
                    } else {
                        lyrics.push(text);
                        timings.push(null); // 没有时间标签
                    }
                }
            }

            // 如果有时间信息，按时间排序
            if (timings.some(t => t !== null)) {
                const combined = lyrics.map((lyric, index) => ({
                    text: lyric,
                    time: timings[index]
                })).filter(item => item.time !== null).sort((a, b) => a.time - b.time);

                return {
                    lyrics: combined.map(item => item.text),
                    timings: combined.map(item => item.time),
                    hasTimings: true
                };
            }

            return {
                lyrics: lyrics.length > 0 ? lyrics : ['♪ 暂无歌词'],
                timings: [],
                hasTimings: false
            };
        }

        // 网易云音乐bin格式歌词解析函数
        function parseNeteaseBin(binData) {
            try {
                const uint8Array = new Uint8Array(binData);

                // 网易云音乐bin格式解析
                // 跳过文件头部分（通常前几个字节是标识符）
                let offset = 0;

                // 查找可能的文本开始位置
                while (offset < uint8Array.length - 4) {
                    // 寻找可能的JSON开始标记 '{'
                    if (uint8Array[offset] === 0x7B ||
                        (uint8Array[offset] ^ 0x64) === 0x7B ||
                        (uint8Array[offset] ^ 0x4E) === 0x7B) {
                        break;
                    }
                    offset++;
                }

                // 尝试多种解密方式
                const decryptMethods = [
                    // 方法1: 直接读取
                    () => new TextDecoder('utf-8').decode(uint8Array.slice(offset)),
                    // 方法2: XOR 0x64
                    () => {
                        let text = '';
                        for (let i = offset; i < uint8Array.length; i++) {
                            text += String.fromCharCode(uint8Array[i] ^ 0x64);
                        }
                        return text;
                    },
                    // 方法3: XOR 0x4E (另一种常见的密钥)
                    () => {
                        let text = '';
                        for (let i = offset; i < uint8Array.length; i++) {
                            text += String.fromCharCode(uint8Array[i] ^ 0x4E);
                        }
                        return text;
                    }
                ];

                for (const method of decryptMethods) {
                    try {
                        const text = method();

                        // 尝试解析为JSON
                        try {
                            const jsonData = JSON.parse(text);
                            if (jsonData.lyric) {
                                return parseLRC(jsonData.lyric);
                            }
                            if (jsonData.lrc && jsonData.lrc.lyric) {
                                return parseLRC(jsonData.lrc.lyric);
                            }
                        } catch (e) {
                            // 如果不是JSON，检查是否是直接的LRC格式
                            if (text.includes('[') && text.includes(']')) {
                                return parseLRC(text);
                            }
                        }
                    } catch (e) {
                        continue; // 尝试下一种方法
                    }
                }

                return { lyrics: ['♪ bin歌词解析失败', '♪ 请尝试使用LRC格式歌词'], timings: [], hasTimings: false };
            } catch (error) {
                console.error('解析bin歌词失败:', error);
                return { lyrics: ['♪ 歌词解析失败'], timings: [], hasTimings: false };
            }
        }

        // 音乐播放器状态
        let musicPlayer = {
            isPlaying: false,
            currentSong: null,
            playlist: [], // 现在从数据库加载
            currentIndex: 0,
            currentTime: 0,
            totalTime: 0,
            isVinylMode: true,
            currentLyricIndex: 0,
            listeningStartTime: null,
            totalListeningTime: 0,
            playMode: 'sequential', // 'sequential', 'loop-all', 'loop-one', 'shuffle'
            audioElement: null,
            albumCover: null,
            listeningTimer: null,
            activeChatId: null, // 记录开启听歌的聊天窗口ID
            isActive: false, // 记录音乐播放器是否处于活跃状态
            // 🔥【新增】音频缓存管理
            audioCache: new Map(), // 缓存已创建的blob URL
            maxCacheSize: 3 // 最多缓存3个音频文件
        }

        // 🔥【修复内存泄漏】简化的音频URL管理函数
        function getAudioUrl(song) {
            // 如果不是本地文件，直接返回URL
            if (!song.isLocalFile || !song.url.startsWith('data:')) {
                return song.url;
            }

            // 🔥【关键修复】对于本地文件，直接返回base64 URL
            // 不进行任何转换，避免创建额外的内存对象
            console.log('🎵 使用本地文件base64 URL:', song.title);
            logMemoryUsage('获取音频URL后');
            return song.url;
        }

        // 🔥【新增】清理所有音频缓存
        function clearAudioCache() {
            for (const [songId, blobUrl] of musicPlayer.audioCache) {
                if (blobUrl.startsWith('blob:')) {
                    URL.revokeObjectURL(blobUrl);
                }
                console.log('🧹 释放音频缓存:', songId);
            }
            musicPlayer.audioCache.clear();
        }

        // 🔥【新增】内存使用监控函数
        function logMemoryUsage(context = '') {
            if (performance.memory) {
                const memory = performance.memory;
                const used = Math.round(memory.usedJSHeapSize / 1024 / 1024);
                const total = Math.round(memory.totalJSHeapSize / 1024 / 1024);
                const limit = Math.round(memory.jsHeapSizeLimit / 1024 / 1024);
                console.log(`🧠 内存使用 ${context}: ${used}MB / ${total}MB (限制: ${limit}MB)`);

                // 如果内存使用超过80%，发出警告
                if (used / limit > 0.8) {
                    console.warn('⚠️ 内存使用过高，建议清理缓存');
                }
            }
        };

        // 初始化音乐播放器
        async function initializeMusicPlayer() {
            try {
                // 从数据库加载播放列表
                const playlistItems = await db.musicPlaylist.orderBy('addedTime').toArray();
                musicPlayer.playlist = playlistItems;

                // 如果有歌曲且没有当前歌曲，设置第一首为当前歌曲
                if (playlistItems.length > 0 && !musicPlayer.currentSong) {
                    const firstSong = playlistItems[0];

                    // 加载封面
                    let coverImageData = null;
                    if (firstSong.coverImage) {
                        const coverRecord = await db.musicCovers.get(firstSong.coverImage);
                        if (coverRecord) {
                            coverImageData = coverRecord.imageData;
                        }
                    }

                    musicPlayer.currentSong = {
                        ...firstSong,
                        coverImageData: coverImageData
                    };
                    musicPlayer.currentIndex = 0;
                }

                // 不再每次初始化时重置听歌时间
                // 只有在完全关闭播放器时才重置
            } catch (error) {
                console.error('初始化音乐播放器失败:', error);
                // 如果数据库加载失败，使用空播放列表
                musicPlayer.playlist = [];
            }

            // 初始化时间显示
            const currentTimeEl = document.getElementById('modal-current-time');
            const totalTimeEl = document.getElementById('modal-total-time');
            if (currentTimeEl) currentTimeEl.textContent = '0:00';
            if (totalTimeEl) totalTimeEl.textContent = '0:00';
        }

        // 打开音乐播放器
        async function openMusicPlayer() {
            // 初始化音乐播放器
            await initializeMusicPlayer();

            const modal = document.getElementById('music-modal');
            const statusDisplay = document.getElementById('music-status-display');
            const phoneScreen = document.getElementById('phone-screen');

            if (modal && phoneScreen) {
                // 获取手机屏幕的位置和大小
                const rect = phoneScreen.getBoundingClientRect();

                // 设置音乐播放器覆盖手机屏幕
                modal.style.top = rect.top + 'px';
                modal.style.left = rect.left + 'px';
                modal.style.width = rect.width + 'px';
                modal.style.height = rect.height + 'px';
                modal.style.display = 'block';

                // 更新播放器背景色
                updatePlayerBackground();
            }
            if (statusDisplay) {
                statusDisplay.style.display = 'flex';
            }

            // 如果没有当前歌曲，选择第一首
            if (!musicPlayer.currentSong && musicPlayer.playlist.length > 0) {
                musicPlayer.currentSong = musicPlayer.playlist[0];
                musicPlayer.currentIndex = 0;
                updateMusicDisplay();
            }

            // 设置当前聊天角色和活跃状态
            musicPlayer.activeChatId = currentChatCharacter ? currentChatCharacter.id : null;

            // 检查是否是新的听歌会话（播放器之前完全关闭了）
            const isNewSession = !musicPlayer.isActive;
            musicPlayer.isActive = true;

            // 只有在新会话时才重置听歌时间
            if (isNewSession) {
                musicPlayer.totalListeningTime = 0;
            }

            // 开始或继续听歌计时
            startListeningTimer();

            // 更新显示
            updateListeningTime();
            updatePlayModeButton();

            // 确保歌词显示正确初始化
            updateMusicDisplay();
            updateLyrics();
        }

        // 关闭音乐播放器（暂时退出，不重置听歌时长）
        function closeMusicModal() {
            const modal = document.getElementById('music-modal');
            modal.style.display = 'none';

            // 不暂停听歌计时，保持计时器继续运行
            // 这样当用户再次打开播放器时，听歌时长会保持不变
        }

        // 完全关闭音乐播放器（结束听歌）
        function closeMusicPlayer() {
            const modal = document.getElementById('music-modal');
            const statusDisplay = document.getElementById('music-status-display');

            // 隐藏模态框和状态栏显示
            if (modal) modal.style.display = 'none';
            if (statusDisplay) statusDisplay.style.display = 'none';

            // 停止音频播放
            if (musicPlayer.audioElement) {
                musicPlayer.audioElement.pause();
                // 直接设置为 null，避免触发错误事件
                musicPlayer.audioElement.src = '';
                musicPlayer.audioElement = null;
            }

            // 🔥【新增】清理音频缓存
            clearAudioCache();

            // 重置播放状态
            musicPlayer.isPlaying = false;
            musicPlayer.isActive = false;

            // 停止听歌计时
            stopListeningTimer();

            // 重置唱片机动画
            const vinylDisc = document.getElementById('vinyl-disc');
            const tonearm = document.getElementById('tonearm');
            if (vinylDisc) vinylDisc.classList.remove('playing');
            if (tonearm) tonearm.classList.remove('playing');

            // 重置播放按钮
            const playBtn = document.getElementById('modal-play-btn');
            if (playBtn) playBtn.innerHTML = '<i class="fas fa-play"></i>';

            console.log('🎵 音乐播放器已完全关闭');
        }

        // 切换播放/暂停
        function togglePlayback() {
            // 如果没有当前歌曲且有歌单，自动选择第一首
            if (!musicPlayer.audioElement && musicPlayer.playlist.length > 0) {
                musicPlayer.currentIndex = 0;
                const firstSong = musicPlayer.playlist[0];
                playSongFromPlaylist(firstSong);
                return;
            }

            // 如果没有歌单，直接返回
            if (musicPlayer.playlist.length === 0) {
                return;
            }

            musicPlayer.isPlaying = !musicPlayer.isPlaying;

            const playBtn = document.getElementById('modal-play-btn');
            const vinylDisc = document.getElementById('vinyl-disc');
            const tonearm = document.getElementById('tonearm');
            const statusIcon = document.querySelector('.music-icon');

            if (musicPlayer.isPlaying) {
                playBtn.innerHTML = '<i class="fas fa-pause"></i>';
                vinylDisc.classList.add('playing');
                tonearm.classList.add('playing');
                if (statusIcon) statusIcon.style.animation = 'musicPulse 1s ease-in-out infinite';

                // 播放真实音频
                if (musicPlayer.audioElement) {
                    musicPlayer.audioElement.play().catch(error => {
                        console.error('播放失败:', error);
                        // 如果播放失败，恢复暂停状态
                        musicPlayer.isPlaying = false;
                        playBtn.innerHTML = '<i class="fas fa-play"></i>';
                        vinylDisc.classList.remove('playing');
                        tonearm.classList.remove('playing');
                        if (statusIcon) statusIcon.style.animation = 'musicPulse 2s ease-in-out infinite';
                        alert(`播放失败：${error.message}\n请检查音频文件是否有效`);
                    });
                }

                // 只在真正开始新歌曲时重置时间和歌词索引
                // 如果是暂停后恢复播放，不应该重置
                if (musicPlayer.audioElement && musicPlayer.audioElement.currentTime === 0) {
                    musicPlayer.currentTime = 0;
                    musicPlayer.currentLyricIndex = 0;
                    // 立即更新歌词显示
                    updateLyrics();
                }


                startPlaybackSimulation();
            } else {
                playBtn.innerHTML = '<i class="fas fa-play"></i>';
                vinylDisc.classList.remove('playing');
                tonearm.classList.remove('playing');
                if (statusIcon) statusIcon.style.animation = 'musicPulse 2s ease-in-out infinite';

                // 暂停真实音频
                if (musicPlayer.audioElement) {
                    musicPlayer.audioElement.pause();
                }
            }
        }

        // 上一首
        async function previousTrack() {
            if (musicPlayer.playlist.length === 0) return;

            const oldIndex = musicPlayer.currentIndex;
            musicPlayer.currentIndex = musicPlayer.currentIndex > 0 ?
                musicPlayer.currentIndex - 1 : musicPlayer.playlist.length - 1;

            const song = musicPlayer.playlist[musicPlayer.currentIndex];

            // 加载封面
            let coverImageData = null;
            if (song.coverImage) {
                try {
                    const coverRecord = await db.musicCovers.get(song.coverImage);
                    if (coverRecord) {
                        coverImageData = coverRecord.imageData;
                    }
                } catch (error) {
                    console.error('加载封面失败:', error);
                }
            }

            musicPlayer.currentSong = {
                ...song,
                coverImageData: coverImageData
            };
            musicPlayer.currentTime = 0;
            musicPlayer.currentLyricIndex = 0;

            // 🔥【修复】使用安全的音频切换函数
            if (musicPlayer.audioElement) {
                const wasPlaying = musicPlayer.isPlaying;
                const success = await switchToSong(song, wasPlaying);
                if (!success) {
                    musicPlayer.isPlaying = false;
                }
            }

            updateMusicDisplay();
            if (musicPlayer.isPlaying) {
                startPlaybackSimulation();
            }
        }

        // 下一首
        async function nextTrack() {
            if (musicPlayer.playlist.length === 0) return;

            let nextIndex;
            switch (musicPlayer.playMode) {
                case 'shuffle':
                    nextIndex = Math.floor(Math.random() * musicPlayer.playlist.length);
                    break;
                case 'loop-one':
                    nextIndex = musicPlayer.currentIndex; // 单曲循环，保持当前索引
                    break;
                case 'loop-all':
                    nextIndex = musicPlayer.currentIndex < musicPlayer.playlist.length - 1 ?
                        musicPlayer.currentIndex + 1 : 0;
                    break;
                case 'sequential':
                default:
                    nextIndex = musicPlayer.currentIndex < musicPlayer.playlist.length - 1 ?
                        musicPlayer.currentIndex + 1 : musicPlayer.currentIndex; // 顺序播放，到最后一首就停止
                    break;
            }

            const oldIndex = musicPlayer.currentIndex;
            musicPlayer.currentIndex = nextIndex;
            const song = musicPlayer.playlist[musicPlayer.currentIndex];

            // 加载封面
            let coverImageData = null;
            if (song.coverImage) {
                try {
                    const coverRecord = await db.musicCovers.get(song.coverImage);
                    if (coverRecord) {
                        coverImageData = coverRecord.imageData;
                    }
                } catch (error) {
                    console.error('加载封面失败:', error);
                }
            }

            musicPlayer.currentSong = {
                ...song,
                coverImageData: coverImageData
            };
            musicPlayer.currentTime = 0;
            musicPlayer.currentLyricIndex = 0;

            // 🔥【修复】使用安全的音频切换函数
            if (musicPlayer.audioElement) {
                // nextTrack通常是在需要播放的情况下调用的
                const success = await switchToSong(song, true);
                if (success) {
                    musicPlayer.isPlaying = true;
                } else {
                    musicPlayer.isPlaying = false;
                }
            }

            updateMusicDisplay();

            // 确保在切换时启动播放模拟
            startPlaybackSimulation();
        }

        // 切换视图模式
        function toggleMusicView() {
            musicPlayer.isVinylMode = !musicPlayer.isVinylMode;

            const vinylMode = document.getElementById('vinyl-mode');
            const lyricsMode = document.getElementById('lyrics-mode');
            const toggleBtn = document.getElementById('view-toggle-btn');
            const currentLyricDisplay = document.querySelector('.current-lyric-display');

            if (musicPlayer.isVinylMode) {
                vinylMode.style.display = 'block';
                lyricsMode.style.display = 'none';
                // 在唱片机模式下显示当前歌词
                if (currentLyricDisplay) currentLyricDisplay.style.display = 'block';
                toggleBtn.innerHTML = '<i class="fas fa-list"></i>';
            } else {
                vinylMode.style.display = 'none';
                lyricsMode.style.display = 'block';
                // 在歌词模式下隐藏当前歌词显示，避免重复
                if (currentLyricDisplay) currentLyricDisplay.style.display = 'none';
                toggleBtn.innerHTML = '<i class="fas fa-compact-disc"></i>';

                // 确保歌词模式容器正确初始化
                setTimeout(() => {
                    // 强制重新渲染歌词并滚动到当前位置
                    const fullLyricsEl = document.getElementById('full-lyrics-display');
                    if (fullLyricsEl) {
                        fullLyricsEl.innerHTML = ''; // 清空内容强制重新渲染
                    }
                    updateLyrics();
                }, 100);
            }

            // 更新歌词显示
            if (musicPlayer.isVinylMode) {
                updateLyrics();
            }
        }

        // 更新音乐显示
        function updateMusicDisplay() {
            if (!musicPlayer.currentSong) return;

            const song = musicPlayer.currentSong;

            // 更新状态栏
            document.getElementById('current-lyric').textContent = `♪ ${song.title} - ${song.artist}`;

            // 更新唱片机模式
            document.getElementById('vinyl-song-title').textContent = song.title;
            document.getElementById('vinyl-artist-name').textContent = song.artist;

            // 更新歌词模式
            document.getElementById('lyrics-song-title').textContent = song.title;
            document.getElementById('lyrics-artist-name').textContent = song.artist;

            // 更新时长显示
            const totalTimeEl = document.getElementById('modal-total-time');
            if (totalTimeEl) {
                const duration = musicPlayer.audioElement ? musicPlayer.audioElement.duration : 0;
                if (duration && !isNaN(duration) && duration > 0) {
                    totalTimeEl.textContent = formatMusicTime(duration);
                } else {
                    totalTimeEl.textContent = '0:00';
                }
            }

            // 更新当前时间显示
            const currentTimeEl = document.getElementById('modal-current-time');
            if (currentTimeEl) {
                const currentTime = musicPlayer.audioElement ? musicPlayer.audioElement.currentTime : 0;
                if (currentTime && !isNaN(currentTime) && currentTime >= 0) {
                    currentTimeEl.textContent = formatMusicTime(currentTime);
                } else {
                    currentTimeEl.textContent = '0:00';
                }
            }

            // 更新进度条
            const progressFill = document.getElementById('modal-progress');
            if (progressFill && musicPlayer.audioElement) {
                const currentTime = musicPlayer.audioElement.currentTime || 0;
                const duration = musicPlayer.audioElement.duration || 0;
                if (duration > 0) {
                    const progress = (currentTime / duration) * 100;
                    progressFill.style.width = `${progress}%`;
                }
            }

            // 更新听歌时间显示
            updateListeningTime();

            // 更新唱片机封面
            updateVinylCover();

            // 更新歌词
            updateLyrics();

            // 更新播放器背景色
            updatePlayerBackground();
        }

        // 点击歌词跳转到对应时间
        function seekToLyric(lyricIndex) {
            if (!musicPlayer.audioElement || !musicPlayer.currentSong || !musicPlayer.currentSong.lyrics) {
                return;
            }

            const totalDuration = musicPlayer.audioElement.duration;
            const lyricsCount = musicPlayer.currentSong.lyrics.length;

            if (totalDuration && lyricsCount > 0) {
                // 使用与歌词同步相同的算法计算时间
                const introTime = Math.min(totalDuration * 0.03, 5);
                const outroTime = totalDuration * 0.02;
                const lyricsTime = totalDuration - introTime - outroTime;

                let targetTime;
                if (lyricIndex === 0) {
                    targetTime = introTime;
                } else if (lyricIndex === lyricsCount - 1) {
                    targetTime = totalDuration - outroTime;
                } else {
                    const lyricsProgress = lyricIndex / lyricsCount;
                    targetTime = introTime + (lyricsProgress * lyricsTime);
                }

                // 跳转到目标时间
                musicPlayer.audioElement.currentTime = Math.min(Math.max(targetTime, 0), totalDuration);
                musicPlayer.currentTime = targetTime;
                musicPlayer.currentLyricIndex = lyricIndex;

                // 更新显示
                updateLyrics();


            }
        }

        // 格式化音乐播放时间（秒数转换为分:秒格式）
        function formatMusicTime(seconds) {
            if (!seconds || isNaN(seconds) || seconds <= 0) return '0:00';
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        // 开始听歌计时
        function startListeningTimer() {
            if (musicPlayer.listeningTimer) {
                clearInterval(musicPlayer.listeningTimer);
            }

            musicPlayer.listeningTimer = setInterval(() => {
                if (musicPlayer.isPlaying && musicPlayer.isActive) {
                    musicPlayer.totalListeningTime += 1; // 按秒计算
                    updateListeningTime(); // 使用统一的更新函数
                }
            }, 1000);
        }

        // 暂停听歌计时（不重置时长）
        function pauseListeningTimer() {
            if (musicPlayer.listeningTimer) {
                clearInterval(musicPlayer.listeningTimer);
                musicPlayer.listeningTimer = null;
            }
        }

        // 停止听歌计时并重置时长
        function stopListeningTimer() {
            if (musicPlayer.listeningTimer) {
                clearInterval(musicPlayer.listeningTimer);
                musicPlayer.listeningTimer = null;
            }
            // 重置听歌时长
            musicPlayer.totalListeningTime = 0;
        }

        // 获取当前音乐播放状态（供AI角色使用）
        function getMusicPlayingStatus(characterId) {
            if (!musicPlayer.isActive || musicPlayer.activeChatId !== characterId) {
                return null;
            }

            const minutes = Math.floor(musicPlayer.totalListeningTime / 60);
            const seconds = musicPlayer.totalListeningTime % 60;

            // 获取当前歌词信息
            let lyricsInfo = null;
            if (musicPlayer.currentSong && musicPlayer.currentSong.lyrics) {
                const lyrics = musicPlayer.currentSong.lyrics;
                const currentLyricIndex = musicPlayer.currentLyricIndex || 0;

                // 如果有时间同步歌词，获取当前播放位置的歌词
                let currentLyric = lyrics[currentLyricIndex] || lyrics[0] || '♪ 暂无歌词';

                // 如果有时间同步信息且正在播放，根据当前时间获取准确的歌词
                if (musicPlayer.currentSong.hasTimedLyrics &&
                    musicPlayer.currentSong.lyricsTimings &&
                    musicPlayer.audioElement &&
                    !musicPlayer.audioElement.paused) {

                    const currentTime = musicPlayer.audioElement.currentTime;
                    const timings = musicPlayer.currentSong.lyricsTimings;

                    // 找到当前时间对应的歌词索引
                    let newIndex = 0;
                    for (let i = 0; i < timings.length; i++) {
                        if (currentTime >= timings[i]) {
                            newIndex = i;
                        } else {
                            break;
                        }
                    }
                    currentLyric = lyrics[newIndex] || currentLyric;
                }

                lyricsInfo = {
                    hasLyrics: true,
                    currentLyric: currentLyric,
                    allLyrics: lyrics,
                    hasTimedLyrics: musicPlayer.currentSong.hasTimedLyrics || false,
                    totalLines: lyrics.length
                };
            }

            return {
                isPlaying: musicPlayer.isPlaying,
                isListening: musicPlayer.isActive,
                currentSong: musicPlayer.currentSong ? {
                    title: musicPlayer.currentSong.title,
                    artist: musicPlayer.currentSong.artist,
                    album: musicPlayer.currentSong.album,
                    lyrics: lyricsInfo  // 🔥【新增】歌词信息
                } : null,
                listeningDuration: {
                    minutes: minutes,
                    seconds: seconds,
                    total: musicPlayer.totalListeningTime,
                    formatted: `${minutes}分${seconds}秒`
                }
            };
        }



        // 更新歌词显示
        function updateLyrics() {
            const currentLyricText = document.getElementById('current-lyric-text');



            if (!musicPlayer.currentSong || !musicPlayer.currentSong.lyrics || musicPlayer.currentSong.lyrics.length === 0) {
                // 没有歌词时显示默认文本
                if (currentLyricText) {
                    currentLyricText.textContent = musicPlayer.isPlaying ? '♪ 正在播放' : '♪ 点击播放开始听歌';
                }

                // 更新灵动岛歌词显示
                const dynamicIslandLyric = document.getElementById('current-lyric');
                if (dynamicIslandLyric) {
                    dynamicIslandLyric.textContent = musicPlayer.isPlaying ? '♪ 正在播放' : '♪ 点击开始听歌';
                }
                return;
            }

            const lyrics = musicPlayer.currentSong.lyrics;
            let currentIndex = musicPlayer.currentLyricIndex;

            // 如果有时间同步信息，根据当前播放时间计算歌词索引
            if (musicPlayer.currentSong.hasTimedLyrics &&
                musicPlayer.currentSong.lyricsTimings &&
                musicPlayer.audioElement &&
                !musicPlayer.audioElement.paused) {

                const currentTime = musicPlayer.audioElement.currentTime;
                const timings = musicPlayer.currentSong.lyricsTimings;

                // 找到当前时间对应的歌词索引
                let newIndex = 0;
                for (let i = 0; i < timings.length; i++) {
                    if (currentTime >= timings[i]) {
                        newIndex = i;
                    } else {
                        break;
                    }
                }

                currentIndex = newIndex;
                musicPlayer.currentLyricIndex = currentIndex;
            }

            const currentLyric = lyrics[currentIndex] || '♪';

            // 更新新的当前歌词显示区域
            if (currentLyricText) {
                currentLyricText.textContent = currentLyric;
            }

            // 更新灵动岛歌词显示
            const dynamicIslandLyric = document.getElementById('current-lyric');
            if (dynamicIslandLyric) {
                dynamicIslandLyric.textContent = currentLyric;
            }

            // 更新唱片机模式的歌词 - 只显示当前一句
            const currentEl = document.getElementById('lyric-current');
            if (currentEl) {
                currentEl.textContent = currentLyric;
            }

            // 更新完整歌词模式并实现滚动
            const fullLyricsEl = document.getElementById('full-lyrics-display');
            if (fullLyricsEl) {
                // 检查是否需要重新渲染歌词列表
                const existingLines = fullLyricsEl.querySelectorAll('.lyric-line');
                if (existingLines.length !== lyrics.length) {
                    // 重新渲染歌词列表
                    const newHTML = lyrics.map((lyric, index) => {
                        const isEmpty = lyric.trim() === '';
                        return `<div class="lyric-line ${isEmpty ? 'empty' : ''}" data-index="${index}" onclick="seekToLyric(${index})">${lyric || '&nbsp;'}</div>`;
                    }).join('');
                    fullLyricsEl.innerHTML = newHTML;
                }

                // 更新活跃状态
                const allLines = fullLyricsEl.querySelectorAll('.lyric-line');
                allLines.forEach((line, index) => {
                    line.classList.toggle('active', index === currentIndex);
                });

                // 使用transform实现平滑滚动 - 只在歌词模式下执行
                if (!musicPlayer.isVinylMode) {
                    const container = document.querySelector('.full-lyrics-container');
                    const lyricsMode = document.getElementById('lyrics-mode');

                    if (container && lyricsMode && lyricsMode.style.display !== 'none') {
                        const activeLyricEl = fullLyricsEl.querySelector('.lyric-line.active');
                        if (activeLyricEl && currentIndex >= 0) {
                            const containerHeight = container.clientHeight;

                          // 调整位置让歌词再靠上一点：使用1/3位置
                            const offset = (containerHeight / 3) - activeLyricEl.offsetTop - (activeLyricEl.offsetHeight / 2);

                            // 使用transform实现平滑滚动
                            fullLyricsEl.style.transform = `translateY(${offset}px)`;
                        }
                    }
                }
            }
        }

        // 模拟播放进度
        function startPlaybackSimulation() {
            if (!musicPlayer.isPlaying) return;

            const interval = setInterval(() => {
                if (!musicPlayer.isPlaying) {
                    clearInterval(interval);
                    return;
                }

                // 如果有真实音频，使用音频的当前时间
                if (musicPlayer.audioElement && !musicPlayer.audioElement.paused) {
                    musicPlayer.currentTime = Math.floor(musicPlayer.audioElement.currentTime);
                    const totalTime = musicPlayer.audioElement.duration || 300;

                    // 更新进度条
                    const progress = (musicPlayer.currentTime / totalTime) * 100;
                    document.getElementById('modal-progress').style.width = `${Math.min(progress, 100)}%`;

                    // 检查是否结束
                    if (musicPlayer.audioElement.ended) {
                        clearInterval(interval);
                        if (musicPlayer.repeatMode === 'one') {
                            musicPlayer.audioElement.currentTime = 0;
                            musicPlayer.audioElement.play();
                        } else if (musicPlayer.repeatMode === 'all' || musicPlayer.repeatMode === 'none') {
                            nextTrack();
                        }
                        return;
                    }
                } else {
                    // 模拟播放
                    musicPlayer.currentTime += 1;
                    const totalTime = 300; // 假设歌曲5分钟

                    // 更新进度条
                    const progress = (musicPlayer.currentTime / totalTime) * 100;
                    const progressBar = document.getElementById('modal-progress');
                    if (progressBar) {
                        progressBar.style.width = `${Math.min(progress, 100)}%`;
                    }

                    // 更新时间显示
                    const currentTimeEl = document.getElementById('modal-current-time');
                    const totalTimeEl = document.getElementById('modal-total-time');
                    if (currentTimeEl) currentTimeEl.textContent = formatMusicTime(musicPlayer.currentTime);
                    if (totalTimeEl) totalTimeEl.textContent = formatMusicTime(totalTime);

                    // 歌曲结束，自动下一首
                    if (musicPlayer.currentTime >= totalTime) {
                        clearInterval(interval);
                        switch (musicPlayer.playMode) {
                            case 'loop-one':
                                musicPlayer.currentTime = 0;
                                startPlaybackSimulation();
                                break;
                            case 'loop-all':
                            case 'shuffle':
                                nextTrack();
                                break;
                            case 'sequential':
                                // 顺序播放，到最后一首就停止
                                if (musicPlayer.currentIndex < musicPlayer.playlist.length - 1) {
                                    nextTrack();
                                } else {
                                    musicPlayer.isPlaying = false;
                                    updateMusicDisplay();
                                }
                                break;
                        }
                        return;
                    }
                }

                // 时间显示由timeupdate事件处理，这里不重复更新

                // 更新歌词
                if (musicPlayer.currentSong && musicPlayer.currentSong.lyrics && musicPlayer.currentSong.lyrics.length > 0) {
                    let newLyricIndex = 0;

                    // 如果有时间同步信息，使用精确的时间同步
                    if (musicPlayer.currentSong.hasTimedLyrics && musicPlayer.currentSong.lyricsTimings) {
                        const currentTime = musicPlayer.audioElement ? musicPlayer.audioElement.currentTime : musicPlayer.currentTime;
                        const timings = musicPlayer.currentSong.lyricsTimings;

                        const adjustedTime = currentTime;

                        // 找到当前时间对应的歌词索引
                        for (let i = 0; i < timings.length; i++) {
                            if (adjustedTime >= timings[i]) {
                                newLyricIndex = i;
                            } else {
                                break;
                            }
                        }
                    } else {
                        // 使用简化算法（平均分配时间）
                        const totalDuration = musicPlayer.audioElement ? musicPlayer.audioElement.duration : 300;
                        const lyricsCount = musicPlayer.currentSong.lyrics.length;
                        const currentTime = musicPlayer.currentTime;

                        if (totalDuration > 0 && lyricsCount > 0) {
                            const timePerLyric = totalDuration / lyricsCount;
                            const adjustedTime = currentTime;
                            newLyricIndex = Math.min(
                                Math.max(Math.floor(adjustedTime / timePerLyric), 0),
                                lyricsCount - 1
                            );
                        }
                    }

                    // 更新歌词索引
                    if (newLyricIndex !== musicPlayer.currentLyricIndex) {
                        musicPlayer.currentLyricIndex = newLyricIndex;
                        updateLyrics();
                    }
                }
            }, musicPlayer.currentSong && musicPlayer.currentSong.hasTimedLyrics ? 200 : 500); // 有时间同步时更频繁更新
        }

        // 获取当前角色名称
        function getCurrentCharacterName() {
            if (currentChatCharacter) {
                return currentChatCharacter.name;
            }
            return '你';
        }

        // 更新听歌时长显示
        function updateListeningTime() {
            const duration = document.getElementById('listening-duration');
            if (duration && musicPlayer.isActive) {
                const minutes = Math.floor(musicPlayer.totalListeningTime / 60);

                // 获取当前聊天角色名称（恢复自动切换功能）
                let characterName = '你';
                if (currentChatCharacter) {
                    characterName = currentChatCharacter.name;
                }

                const displayText = `已一起听 ${minutes} 分钟`;
                duration.textContent = displayText;

                // 不再保存到 localStorage（每次重新计时）
            }
        }

        // 点击状态栏音乐区域打开模态框
        function openMusicModal() {
            openMusicPlayer();
        }

        // 提取图片主色调
        function extractImageColors(imageElement) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                canvas.width = 50;
                canvas.height = 50;

                ctx.drawImage(imageElement, 0, 0, 50, 50);

                const imageData = ctx.getImageData(0, 0, 50, 50);
                const data = imageData.data;

                let r = 0, g = 0, b = 0;
                let pixelCount = 0;

                for (let i = 0; i < data.length; i += 4) {
                    r += data[i];
                    g += data[i + 1];
                    b += data[i + 2];
                    pixelCount++;
                }

                r = Math.floor(r / pixelCount);
                g = Math.floor(g / pixelCount);
                b = Math.floor(b / pixelCount);

                resolve({ r, g, b });
            });
        }

        // 更新播放器背景色
        function updatePlayerBackground() {
            const modal = document.getElementById('music-modal');
            const modalContent = document.querySelector('.music-modal-content');
            const albumCoverImg = document.getElementById('album-cover');

            if (albumCoverImg && albumCoverImg.src && !albumCoverImg.src.includes('data:image/svg') && albumCoverImg.style.display !== 'none') {
                // 如果有封面图片，提取主色调
                extractImageColors(albumCoverImg).then(colors => {
                    const { r, g, b } = colors;

                    // 创建基于封面的毛玻璃效果
                    const bgColor = `rgba(${r}, ${g}, ${b}, 0.3)`;

                    if (modalContent) {
                        modalContent.style.background = bgColor;
                        modalContent.style.backdropFilter = 'blur(30px) saturate(1.5)';
                        modalContent.style.webkitBackdropFilter = 'blur(30px) saturate(1.5)';
                    }
                });
            } else {
                // 默认雾霾灰毛玻璃效果
                if (modalContent) {
                    modalContent.style.background = 'rgba(200, 200, 200, 0.25)';
                    modalContent.style.backdropFilter = 'blur(30px) saturate(1.5)';
                    modalContent.style.webkitBackdropFilter = 'blur(30px) saturate(1.5)';
                }
            }
        }

        // 切换播放模式
        function togglePlayMode() {
            // 播放模式: sequential(顺序) -> loop-all(列表循环) -> loop-one(单曲循环) -> shuffle(随机)
            const modes = ['sequential', 'loop-all', 'loop-one', 'shuffle'];
            const currentIndex = modes.indexOf(musicPlayer.playMode || 'sequential');
            const nextIndex = (currentIndex + 1) % modes.length;
            musicPlayer.playMode = modes[nextIndex];

            // 更新按钮显示
            updatePlayModeButton();
        }



        // 更新播放模式按钮显示
        function updatePlayModeButton() {
            const btn = document.getElementById('play-mode-btn');
            const icon = btn.querySelector('i');

            switch (musicPlayer.playMode) {
                case 'sequential':
                    icon.className = 'fas fa-list-ol';
                    btn.title = '顺序播放';
                    btn.classList.remove('active');
                    // 移除数字显示
                    const numberEl1 = btn.querySelector('.loop-number');
                    if (numberEl1) numberEl1.remove();
                    break;
                case 'loop-all':
                    icon.className = 'fas fa-redo';
                    btn.title = '列表循环';
                    btn.classList.remove('active');
                    // 移除数字显示
                    const numberEl2 = btn.querySelector('.loop-number');
                    if (numberEl2) numberEl2.remove();
                    break;
                case 'loop-one':
                    icon.className = 'fas fa-repeat';
                    btn.title = '单曲循环';
                    btn.classList.remove('active');
                    // 添加数字1的显示
                    if (!btn.querySelector('.loop-number')) {
                        const numberSpan = document.createElement('span');
                        numberSpan.className = 'loop-number';
                        numberSpan.textContent = '1';
                        btn.appendChild(numberSpan);
                    }
                    break;
                case 'shuffle':
                    icon.className = 'fas fa-random';
                    btn.title = '随机播放';
                    btn.classList.remove('active');
                    // 移除数字显示
                    const numberEl3 = btn.querySelector('.loop-number');
                    if (numberEl3) numberEl3.remove();
                    break;
            }
        }

        // 切换循环播放
        function toggleRepeat() {
            const modes = ['none', 'one', 'all'];
            const currentIndex = modes.indexOf(musicPlayer.repeatMode || 'none');
            const nextIndex = (currentIndex + 1) % modes.length;
            musicPlayer.repeatMode = modes[nextIndex];

            const repeatBtn = document.getElementById('repeat-btn');
            const icons = {
                'none': 'fas fa-redo',
                'one': 'fas fa-redo-alt',
                'all': 'fas fa-redo'
            };

            repeatBtn.innerHTML = `<i class="${icons[musicPlayer.repeatMode]}"></i>`;
            repeatBtn.classList.toggle('active', musicPlayer.repeatMode !== 'none');

            // 显示提示
            const modeNames = {
                'sequential': '顺序播放',
                'loop': '单曲循环',
                'random': '随机播放'
            };
            console.log(`切换到: ${modeNames[musicPlayer.playMode]}`);
        }

        // 打开播放列表模态框
        function openPlaylistModal() {
            const modal = document.getElementById('playlist-modal');
            if (modal) {
                modal.style.display = 'flex';
                loadPlaylistItems();
            }
        }

        // 关闭播放列表模态框
        function closePlaylistModal() {
            const modal = document.getElementById('playlist-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // 加载播放列表项目
        async function loadPlaylistItems() {
            try {
                const playlistItems = await db.musicPlaylist.orderBy('addedTime').toArray();
                const container = document.getElementById('playlist-items');

                if (!container) return;

                container.innerHTML = '';

                if (playlistItems.length === 0) {
                    container.innerHTML = `
                        <div class="playlist-empty">
                            <i class="fas fa-music"></i>
                            <div>暂无歌曲</div>
                            <div style="font-size: 12px; margin-top: 8px; opacity: 0.8;">添加一些歌曲开始享受音乐吧</div>
                        </div>
                    `;
                    return;
                }

                playlistItems.forEach((song, index) => {
                    const songElement = document.createElement('div');
                    songElement.className = 'playlist-item-modern';

                    songElement.innerHTML = `
                        <div class="song-number">${index + 1}</div>
                        <div class="song-info">
                            <div class="song-title">${song.title}</div>
                            <div class="song-artist">${song.artist}</div>
                        </div>
                        <div class="song-actions">
                            <button class="play-btn" title="播放" data-song-id="${song.id}">
                                <i class="fas fa-play"></i>
                            </button>
                            <button onclick="removeSongFromPlaylist('${song.id}')"
                                    class="delete-btn" title="删除">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    `;

                    // 添加播放按钮事件监听
                    const playBtn = songElement.querySelector('.play-btn');
                    playBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        playSongFromPlaylist(song);
                    });

                    container.appendChild(songElement);
                });
            } catch (error) {
                console.error('加载播放列表失败:', error);
            }
        }



        // 添加自定义歌曲到播放列表
        async function addCustomSong() {
            const urlInput = document.getElementById('song-url-input');
            const titleInput = document.getElementById('song-title-input');
            const artistInput = document.getElementById('song-artist-input');
            const coverInput = document.getElementById('song-cover-input');
            const localMusicInput = document.getElementById('local-music-input');
            const lyricsFileInput = document.getElementById('lyrics-file-input');

            let url = urlInput.value.trim();
            const title = titleInput.value.trim();
            const artist = artistInput.value.trim();
            let isLocalFile = false;

            // 🔥【修复内存泄漏】检查是否选择了本地音乐文件 - 优化内存使用
            if (localMusicInput.files && localMusicInput.files[0]) {
                const audioFile = localMusicInput.files[0];

                try {
                    // 🔥【优化】对于小文件（<10MB）使用base64，大文件使用blob URL
                    if (audioFile.size < 10 * 1024 * 1024) {
                        // 小文件：转换为base64格式存储
                        url = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = (e) => resolve(e.target.result);
                            reader.onerror = reject;
                            reader.readAsDataURL(audioFile);
                        });
                        console.log('🎵 小文件已转换为base64格式');
                    } else {
                        // 大文件：创建blob URL（注意：这个URL在页面刷新后会失效）
                        url = URL.createObjectURL(audioFile);
                        console.log('🎵 大文件已创建blob URL');
                        alert('注意：大文件在页面刷新后需要重新添加');
                    }
                    isLocalFile = true;
                } catch (error) {
                    console.error('处理本地音乐文件失败:', error);
                    alert('处理本地音乐文件失败，请重试');
                    return;
                }

                // 如果没有填写标题，使用文件名
                if (!title) {
                    titleInput.value = audioFile.name.replace(/\.[^/.]+$/, "");
                }
            }

            if (!url || !titleInput.value.trim() || !artist) {
                alert('请填写完整的歌曲信息或选择本地音乐文件');
                return;
            }

            try {
                const songId = Date.now().toString();
                let coverImageId = null;

                // 处理封面上传
                if (coverInput.files && coverInput.files[0]) {
                    const file = coverInput.files[0];
                    const reader = new FileReader();

                    await new Promise((resolve, reject) => {
                        reader.onload = async (e) => {
                            try {
                                coverImageId = `cover_${songId}`;
                                await db.musicCovers.add({
                                    id: coverImageId,
                                    songId: songId,
                                    imageData: e.target.result,
                                    timestamp: Date.now()
                                });
                                resolve();
                            } catch (error) {
                                reject(error);
                            }
                        };
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    });
                }

                // 处理歌词文件
                let lyricsArray = [];

                // 检查是否上传了歌词文件
                if (lyricsFileInput.files && lyricsFileInput.files[0]) {
                    const lyricsFile = lyricsFileInput.files[0];
                    const fileName = lyricsFile.name.toLowerCase();

                    if (fileName.endsWith('.lrc')) {
                        // LRC格式歌词
                        const lrcContent = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = (e) => resolve(e.target.result);
                            reader.onerror = reject;
                            reader.readAsText(lyricsFile, 'utf-8');
                        });
                        const lrcResult = parseLRC(lrcContent);
                        lyricsArray = lrcResult.lyrics;
                        // 保存时间信息到歌曲数据中
                        if (lrcResult.hasTimings) {
                            window.tempLyricsTimings = lrcResult.timings;
                        }
                    } else if (fileName.endsWith('.bin')) {
                        // bin格式歌词
                        const binData = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = (e) => resolve(e.target.result);
                            reader.onerror = reject;
                            reader.readAsArrayBuffer(lyricsFile);
                        });
                        const binResult = parseNeteaseBin(binData);
                        lyricsArray = binResult.lyrics;
                        if (binResult.hasTimings) {
                            window.tempLyricsTimings = binResult.timings;
                        }
                    } else {
                        // 其他文本格式，尝试作为普通文本处理
                        const textContent = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = (e) => resolve(e.target.result);
                            reader.onerror = reject;
                            reader.readAsText(lyricsFile, 'utf-8');
                        });
                        lyricsArray = textContent.split('\n').map(line => line.trim()).filter(line => line.length > 0);
                    }
                }

                // 如果没有歌词，使用默认歌词
                if (lyricsArray.length === 0) {
                    lyricsArray = ['♪ 暂无歌词'];
                }



                // 🔥【修复】添加歌曲到数据库 - 包含isLocalFile字段
                await db.musicPlaylist.add({
                    id: songId,
                    title: titleInput.value.trim(),
                    artist: artist,
                    album: '',
                    duration: '0:00',
                    url: url,
                    isLocalFile: isLocalFile, // 🔥【新增】标识是否为本地文件
                    coverImage: coverImageId,
                    lyrics: lyricsArray,
                    lyricsTimings: window.tempLyricsTimings || [],
                    hasTimedLyrics: !!(window.tempLyricsTimings && window.tempLyricsTimings.length > 0),
                    addedTime: Date.now()
                });

                // 清理临时变量
                delete window.tempLyricsTimings;

                // 清空输入框
                urlInput.value = '';
                titleInput.value = '';
                artistInput.value = '';
                coverInput.value = '';
                localMusicInput.value = '';
                lyricsFileInput.value = '';

                // 重置歌词文件状态显示
                const lyricsStatus = document.getElementById('lyrics-file-status');
                if (lyricsStatus) {
                    lyricsStatus.style.display = 'none';
                }

                // 重置文件选择框显示文字
                const fileText = document.querySelector('.file-input-text');
                if (fileText) {
                    fileText.textContent = '未选封面';
                }

                // 重新加载播放列表
                await loadPlaylistItems();

                alert('歌曲添加成功！');
            } catch (error) {
                console.error('添加歌曲失败:', error);
                alert('添加歌曲失败，请重试');
            }
        }

        // 从播放列表删除歌曲
        async function removeSongFromPlaylist(songId) {
            if (!confirm('确定要删除这首歌曲吗？')) {
                return;
            }

            try {
                // 删除歌曲
                await db.musicPlaylist.delete(songId);

                // 删除相关封面
                const coverRecord = await db.musicCovers.where('songId').equals(songId).first();
                if (coverRecord) {
                    await db.musicCovers.delete(coverRecord.id);
                }

                // 重新加载播放列表
                await loadPlaylistItems();

                // 如果删除的是当前播放的歌曲，停止播放
                if (musicPlayer.currentSong && musicPlayer.currentSong.id === songId) {
                    musicPlayer.currentSong = null;
                    musicPlayer.isPlaying = false;
                    updateMusicDisplay();
                }
            } catch (error) {
                console.error('删除歌曲失败:', error);
                alert('删除歌曲失败，请重试');
            }
        }

        // 从播放列表播放歌曲
        async function playSongFromPlaylist(song) {
            try {
                // 🔥【修复】更新当前播放索引，确保切换功能正常工作
                const songIndex = musicPlayer.playlist.findIndex(item => item.id === song.id);
                if (songIndex !== -1) {
                    musicPlayer.currentIndex = songIndex;
                }

                // 获取封面图片
                let coverImageData = null;
                if (song.coverImage) {
                    const coverRecord = await db.musicCovers.get(song.coverImage);
                    if (coverRecord) {
                        coverImageData = coverRecord.imageData;
                    }
                }

                // 🔥【修复内存泄漏】正确清理当前音频
                if (musicPlayer.audioElement) {
                    musicPlayer.audioElement.pause();
                    // 清理音频源，释放内存
                    musicPlayer.audioElement.src = '';
                    musicPlayer.audioElement.load();
                    // 移除所有事件监听器
                    musicPlayer.audioElement.onloadedmetadata = null;
                    musicPlayer.audioElement.onerror = null;
                    musicPlayer.audioElement.onplay = null;
                    musicPlayer.audioElement.onpause = null;
                    musicPlayer.audioElement.onended = null;
                    musicPlayer.audioElement.ontimeupdate = null;
                    musicPlayer.audioElement = null;

                    // 强制垃圾回收提示
                    if (window.gc) {
                        window.gc();
                    }
                    console.log('🧹 音频对象已清理');
                    logMemoryUsage('清理音频对象后');
                }

                // 🔥【修复内存泄漏】重用音频元素，避免重复创建
                if (song.url && song.url.trim() !== '') {
                    // 如果没有音频元素，才创建新的
                    if (!musicPlayer.audioElement) {
                        musicPlayer.audioElement = new Audio();
                        console.log('🎵 创建新的音频元素');
                    }

                    const audio = musicPlayer.audioElement;
                    // 设置新的音频源
                    audio.src = getAudioUrl(song);
                    audio.load(); // 重新加载音频

                    audio.addEventListener('loadedmetadata', function() {
                        musicPlayer.totalTime = audio.duration;
                        console.log('歌曲加载成功，时长:', audio.duration);
                        updateMusicDisplay(); // 更新显示以显示正确的时长

                        // 确保时长显示正确
                        const totalTimeEl = document.getElementById('modal-total-time');
                        if (totalTimeEl && audio.duration && !isNaN(audio.duration) && audio.duration > 0) {
                            totalTimeEl.textContent = formatMusicTime(audio.duration);
                        }
                    });

                    audio.addEventListener('error', function(e) {
                        // 如果音频元素已经被清理（src为空），则不显示错误
                        if (!audio.src || audio.src === '' || audio.src === window.location.href) {
                            console.log('音频元素已被清理，忽略错误事件');
                            return;
                        }
                        console.error('音频加载失败:', e);
                        musicPlayer.isPlaying = false;
                        updateMusicDisplay();
                        alert('音频加载失败，请检查URL是否有效');
                    });

                    audio.addEventListener('play', function() {
                        musicPlayer.isPlaying = true;
                        updateMusicDisplay();
                        startListeningTimer(); // 开始计时
                    });

                    audio.addEventListener('pause', function() {
                        musicPlayer.isPlaying = false;
                        updateMusicDisplay();
                        pauseListeningTimer(); // 暂停计时（不重置时长）
                    });

                    audio.addEventListener('ended', function() {
                        // 根据播放模式自动切换到下一首
                        switch (musicPlayer.playMode) {
                            case 'loop-one':
                                // 单曲循环，重新播放当前歌曲
                                audio.currentTime = 0;
                                audio.play().catch(console.error);
                                musicPlayer.isPlaying = true;
                                break;
                            case 'sequential':
                                // 顺序播放，如果不是最后一首则播放下一首
                                if (musicPlayer.currentIndex < musicPlayer.playlist.length - 1) {
                                    nextTrack();
                                    // nextTrack()内部已经处理了播放状态，不需要重复设置
                                } else {
                                    // 最后一首歌播放完毕，停止播放
                                    musicPlayer.isPlaying = false;
                                }
                                break;
                            case 'loop-all':
                            case 'shuffle':
                                // 列表循环或随机播放，直接播放下一首
                                nextTrack();
                                // nextTrack()内部已经处理了播放状态，不需要重复设置
                                break;
                        }
                        updateMusicDisplay();
                    });

                    audio.addEventListener('timeupdate', function() {
                        musicPlayer.currentTime = audio.currentTime;
                        updateMusicDisplay();

                        // 实时更新时间显示
                        const currentTimeEl = document.getElementById('modal-current-time');
                        const totalTimeEl = document.getElementById('modal-total-time');

                        if (currentTimeEl && audio.currentTime >= 0) {
                            currentTimeEl.textContent = formatMusicTime(audio.currentTime);
                        }

                        if (totalTimeEl && audio.duration && !isNaN(audio.duration) && audio.duration > 0) {
                            totalTimeEl.textContent = formatMusicTime(audio.duration);
                        }

                        // 更新进度条
                        const progressFill = document.getElementById('modal-progress');
                        if (progressFill && audio.duration && audio.duration > 0) {
                            const progress = (audio.currentTime / audio.duration) * 100;
                            progressFill.style.width = `${Math.min(progress, 100)}%`;
                        }
                    });

                    // 音频元素已经在开头设置，不需要重复赋值
                } else {
                    // 🔥【修复】处理缺少URL的情况
                    console.error('歌曲缺少URL:', song);
                    alert('歌曲文件缺失，请重新添加');
                    return;
                }

                // 设置当前歌曲
                musicPlayer.currentSong = {
                    ...song,
                    coverImageData: coverImageData
                };
                musicPlayer.currentTime = 0;
                musicPlayer.currentLyricIndex = 0;
                musicPlayer.isPlaying = false;



                // 更新显示
                updateMusicDisplay();

                // 关闭播放列表模态框
                closePlaylistModal();

                // 自动开始播放
                setTimeout(() => {
                    togglePlayback();
                }, 100);

            } catch (error) {
                console.error('播放歌曲失败:', error);
                alert('播放歌曲失败，请重试');
            }
        }

        // 更新唱片机封面
        async function updateVinylCover() {
            const albumCoverImg = document.getElementById('album-cover');
            const vinylLabel = document.querySelector('.vinyl-label');

            if (!albumCoverImg || !vinylLabel) return;

            // 如果当前歌曲有封面数据，使用它
            if (musicPlayer.currentSong && musicPlayer.currentSong.coverImageData) {
                albumCoverImg.src = musicPlayer.currentSong.coverImageData;
                albumCoverImg.style.display = 'block';
                vinylLabel.style.background = '#ddd'; // 有封面时使用浅灰色背景
            } else {
                // 没有封面时隐藏图片，显示默认的浅灰色背景
                albumCoverImg.style.display = 'none';
                vinylLabel.style.background = '#ddd'; // 默认浅灰色
            }
        }

        // 🔥【新增】安全的音频切换函数 - 统一处理所有切歌操作
        async function switchToSong(song, shouldPlay = true) {
            try {
                if (!musicPlayer.audioElement) {
                    console.error('音频元素不存在');
                    return false;
                }

                // 先暂停当前播放
                musicPlayer.audioElement.pause();

                // 检查歌曲URL
                if (!song.url || song.url.trim() === '') {
                    console.error('歌曲缺少URL:', song);
                    alert('歌曲文件缺失，请重新添加');
                    return false;
                }

                // 设置新的音频源 - 使用缓存系统
                musicPlayer.audioElement.src = getAudioUrl(song);
                musicPlayer.audioElement.load();

                // 返回Promise，等待音频准备就绪
                return new Promise((resolve) => {
                    const onCanPlay = () => {
                        musicPlayer.audioElement.removeEventListener('canplay', onCanPlay);
                        musicPlayer.audioElement.removeEventListener('error', onError);

                        if (shouldPlay) {
                            musicPlayer.audioElement.play().catch(error => {
                                console.error('播放失败:', error);
                                musicPlayer.isPlaying = false;
                                updateMusicDisplay();
                                alert(`播放失败：${song.title}\n${error.message}`);
                                resolve(false);
                            }).then(() => {
                                musicPlayer.isPlaying = true;
                                updateMusicDisplay();
                                resolve(true);
                            });
                        } else {
                            resolve(true);
                        }
                    };

                    const onError = (e) => {
                        musicPlayer.audioElement.removeEventListener('canplay', onCanPlay);
                        musicPlayer.audioElement.removeEventListener('error', onError);
                        console.error('音频加载失败:', e);
                        musicPlayer.isPlaying = false;
                        updateMusicDisplay();
                        alert(`音频加载失败：${song.title}\n请检查文件是否有效`);
                        resolve(false);
                    };

                    musicPlayer.audioElement.addEventListener('canplay', onCanPlay, { once: true });
                    musicPlayer.audioElement.addEventListener('error', onError, { once: true });
                });

            } catch (error) {
                console.error('切换歌曲失败:', error);
                return false;
            }
        }

        // 🔥【新增】AI选歌功能 - 让AI角色可以为用户选择歌曲
        async function aiSelectSong(songTitle, characterName) {
            try {
                // 检查音乐播放器是否处于活跃状态
                if (!musicPlayer.isActive) {
                    console.log('音乐播放器未激活，AI无法选歌');
                    return false;
                }

                // 从播放列表中查找歌曲
                const song = musicPlayer.playlist.find(item =>
                    item.title.toLowerCase().includes(songTitle.toLowerCase()) ||
                    item.artist.toLowerCase().includes(songTitle.toLowerCase())
                );

                if (!song) {
                    console.log(`AI选歌失败：未找到歌曲 "${songTitle}"`);
                    return false;
                }

                // 播放选中的歌曲
                await playSongFromPlaylist(song);

                // 记录AI选歌事件到跨应用记忆系统
                if (currentChatCharacter) {
                    const memoryEvent = {
                        eventType: 'music_interaction',
                        timestamp: Date.now(),
                        context: {
                            type: 'music_app',
                            id: 'music_player',
                            action: 'ai_select_song',
                            songTitle: song.title,
                            songArtist: song.artist,
                            characterName: characterName || currentChatCharacter.name
                        }
                    };

                    // 添加到跨应用记忆
                    await recordMemoryEvent(
                        [currentChatCharacter.id],
                        {
                            type: 'music_player',
                            id: 'music_player'
                        },
                        'ai_select_song',
                        memoryEvent.data,
                        0.6
                    );
                }

                console.log(`✅ AI成功选择歌曲：${song.title} - ${song.artist}`);
                return true;

            } catch (error) {
                console.error('AI选歌失败:', error);
                return false;
            }
        }

        // 🔥【新增】AI随机选歌功能
        async function aiSelectRandomSong(characterName) {
            try {
                // 检查音乐播放器是否处于活跃状态
                if (!musicPlayer.isActive || musicPlayer.playlist.length === 0) {
                    console.log('音乐播放器未激活或播放列表为空，AI无法随机选歌');
                    return false;
                }

                // 随机选择一首歌曲
                const randomIndex = Math.floor(Math.random() * musicPlayer.playlist.length);
                const song = musicPlayer.playlist[randomIndex];

                // 播放选中的歌曲
                await playSongFromPlaylist(song);

                // 记录AI选歌事件
                if (currentChatCharacter) {
                    const memoryEvent = {
                        eventType: 'music_interaction',
                        timestamp: Date.now(),
                        context: {
                            type: 'music_app',
                            id: 'music_player',
                            action: 'ai_random_select',
                            songTitle: song.title,
                            songArtist: song.artist,
                            characterName: characterName || currentChatCharacter.name
                        }
                    };

                    await recordMemoryEvent(
                        [currentChatCharacter.id],
                        {
                            type: 'music_player',
                            id: 'music_player'
                        },
                        'ai_random_select_song',
                        memoryEvent.data,
                        0.6
                    );
                }

                console.log(`✅ AI随机选择歌曲：${song.title} - ${song.artist}`);
                return true;

            } catch (error) {
                console.error('AI随机选歌失败:', error);
                return false;
            }
        }

        // 🔥【新增】获取播放列表信息供AI参考
        function getPlaylistForAI() {
            if (!musicPlayer.isActive || musicPlayer.playlist.length === 0) {
                return null;
            }

            return {
                totalSongs: musicPlayer.playlist.length,
                songs: musicPlayer.playlist.map(song => ({
                    title: song.title,
                    artist: song.artist,
                    album: song.album || '未知专辑',
                    hasLyrics: song.lyrics && song.lyrics.length > 0
                })),
                currentSong: musicPlayer.currentSong ? {
                    title: musicPlayer.currentSong.title,
                    artist: musicPlayer.currentSong.artist
                } : null
            };
        }



        // 加载自定义歌曲
        function loadCustomSong() {
            const urlInput = document.getElementById('song-url');
            const url = urlInput.value.trim();

            if (!url) {
                alert('请输入歌曲URL');
                return;
            }

            // 创建新的音频元素
            if (musicPlayer.audioElement) {
                musicPlayer.audioElement.pause();
                musicPlayer.audioElement = null;
            }

            const audio = new Audio();
            audio.crossOrigin = 'anonymous';

            audio.addEventListener('loadedmetadata', function() {
                musicPlayer.totalTime = audio.duration;
                const minutes = Math.floor(audio.duration / 60);
                const seconds = Math.floor(audio.duration % 60);
                const duration = `${minutes}:${seconds.toString().padStart(2, '0')}`;

                // 创建自定义歌曲对象
                const customSong = {
                    id: 'custom',
                    title: '自定义歌曲',
                    artist: '未知艺术家',
                    duration: duration,
                    lyrics: ['♪ 正在播放自定义歌曲', '♪ 享受音乐时光', '♪ 让音乐陪伴你'],
                    url: url
                };

                musicPlayer.currentSong = customSong;
                musicPlayer.audioElement = audio;
                musicPlayer.currentTime = 0;
                musicPlayer.currentLyricIndex = 0;

                updateMusicDisplay();
                console.log('歌曲加载成功');
            });

            audio.addEventListener('error', function() {
                alert('歌曲加载失败，请检查URL是否正确');
            });

            audio.src = url;
            urlInput.value = '';
        }

        // ================== 面具系统相关功能 ==================

        // 加载面具数据 - 使用IndexedDB（包含数据迁移）
        async function loadPersonas() {
            try {
                // 先从IndexedDB加载
                const savedPersonas = await db.personas.toArray();

                if (savedPersonas.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('personas');
                    if (localStorageData) {
                        console.log('检测到localStorage中的面具数据，开始迁移...');
                        const localPersonas = JSON.parse(localStorageData);

                        if (localPersonas.length > 0) {
                            // 确保每个面具都有必要字段
                            const migrationData = localPersonas.map(persona => ({
                                id: persona.id || Date.now().toString() + Math.random(),
                                name: persona.name,
                                description: persona.description || '',
                                avatarUrl: persona.avatarUrl || '',
                                isDefault: persona.isDefault || false,
                                createdAt: persona.createdAt || new Date().toISOString(),
                                updatedAt: persona.updatedAt || new Date().toISOString()
                            }));

                            // 迁移到IndexedDB
                            await db.personas.bulkAdd(migrationData);
                            personas = migrationData;
                            console.log('面具数据迁移完成:', personas);
                        } else {
                            personas = [];
                        }
                    } else {
                        personas = [];
                    }
                } else {
                    // IndexedDB中有数据，直接使用
                    personas = savedPersonas;
                    console.log('从IndexedDB加载面具数据:', personas);
                }



            } catch (error) {
                console.error('加载面具失败:', error);
                // 如果IndexedDB失败，回退到localStorage
                const localStorageData = localStorage.getItem('personas');
                if (localStorageData) {
                    try {
                        personas = JSON.parse(localStorageData);
                    } catch (e) {
                        personas = [];
                    }
                } else {
                    personas = [];
                }
            }

        }

        // 保存面具数据 - 使用IndexedDB
        async function savePersonas() {
            try {
                console.log('保存面具数据到IndexedDB:', personas);

                // 🔥【安全修复】使用事务确保原子操作，防止数据丢失
                if (personas.length === 0) {
                    console.warn('⚠️ 面具数据为空，跳过保存操作');
                    return;
                }

                // 使用事务进行原子操作
                await db.transaction('rw', db.personas, async () => {
                    await db.personas.clear();
                    await db.personas.bulkAdd(personas);
                });

                console.log(`✅ 安全保存了 ${personas.length} 个面具到数据库`);

                console.log('面具数据保存成功');
            } catch (error) {
                console.error('保存面具时发生错误:', error);
                // 如果IndexedDB失败，回退到localStorage
            localStorage.setItem('personas', JSON.stringify(personas));
            }
        }



        // 显示面具创建表单
        function showPersonaForm(personaId = null) {
            editingPersona = personaId ? personas.find(p => p.id === personaId) : null;

            document.getElementById('persona-form-title').textContent = editingPersona ? '编辑面具' : '新建面具';

            // 清空表单
            document.getElementById('persona-name').value = editingPersona ? editingPersona.name : '';
            document.getElementById('persona-description').value = editingPersona ? editingPersona.description : '';

            // 重置头像预览
            const avatarPreview = document.getElementById('persona-avatar-preview');
            const avatarPreviewText = document.getElementById('persona-avatar-preview-text');

            avatarPreview.classList.remove('has-image');
            avatarPreview.style.removeProperty('background');
            avatarPreview.style.removeProperty('background-size');
            avatarPreview.style.removeProperty('background-position');
            avatarPreview.style.removeProperty('background-repeat');

            if (editingPersona && editingPersona.avatarUrl) {
                avatarPreview.classList.add('has-image');
                avatarPreview.style.setProperty('background', `url(${editingPersona.avatarUrl})`, 'important');
                avatarPreview.style.setProperty('background-size', 'cover', 'important');
                avatarPreview.style.setProperty('background-position', 'center', 'important');
                avatarPreview.style.setProperty('background-repeat', 'no-repeat', 'important');
                avatarPreviewText.style.display = 'none';
                window.selectedPersonaAvatarData = editingPersona.avatarUrl;
            } else {
                avatarPreviewText.style.display = 'block';
                avatarPreviewText.textContent = editingPersona ? editingPersona.name.charAt(0) : '我';
                window.selectedPersonaAvatarData = null;
            }

            // 初始化头像上传功能
            initializePersonaAvatarUpload();

            showApp('persona-form-screen');
        }

        // 隐藏面具表单
        function hidePersonaForm() {
            hideApp('persona-form-screen');
            showApp('chat-screen');
            switchChatTab('profile-page');
            // 清空临时数据
            window.selectedPersonaAvatarData = null;
            editingPersona = null;
        }

        // 保存面具
        async function savePersona() {
            const name = document.getElementById('persona-name').value.trim();
            const description = document.getElementById('persona-description').value.trim();
            const avatarData = window.selectedPersonaAvatarData;

            if (!name) {
                alert('请输入面具名称');
                return;
            }

            if (editingPersona) {
                // 更新现有面具
                const index = personas.findIndex(p => p.id === editingPersona.id);
                if (index !== -1) {
                    const oldAvatarUrl = personas[index].avatarUrl;

                    personas[index] = {
                        ...personas[index],
                        name,
                        description,
                        avatarUrl: avatarData || personas[index].avatarUrl || '',
                        updatedAt: new Date().toISOString()
                    };


                }
            } else {
                // 创建新面具
                const newPersona = {
                    id: Date.now().toString(),
                    name,
                    description,
                    avatarUrl: avatarData || '',
                    isDefault: false,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };
                personas.push(newPersona);
            }

            await savePersonas();
            renderPersonaList();
            hidePersonaForm();
                            showToast('面具保存成功！', 'success');
        }

        // 删除面具
        async function deletePersona(personaId) {
            const persona = personas.find(p => p.id === personaId);
            if (!persona) return;

            if (confirm(`确定要删除面具"${persona.name}"吗？`)) {
                personas = personas.filter(p => p.id !== personaId);



                await savePersonas();
                renderPersonaList();
            }
        }





        // 渲染面具列表
        function renderPersonaList() {
            const listContainer = document.getElementById('persona-list');
            if (!listContainer) return;

            if (personas.length === 0) {
                listContainer.innerHTML = '<div class="empty-personas">还没有面具，点击右上角+号创建一个吧！</div>';
                return;
            }

            const html = personas.map(persona => `
                <div class="persona-item">
                    <div class="persona-avatar" style="${persona.avatarUrl ? `background-image: url(${persona.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                        ${persona.avatarUrl ? '' : persona.name.charAt(0)}
                    </div>
                    <div class="persona-info">
                        <div class="persona-name">${persona.name}</div>
                                                    <div class="persona-description">${truncateText(persona.description || '暂无描述', 40)}</div>
                    </div>
                    <div class="persona-actions">
                        <button class="persona-action-btn persona-edit-btn" onclick="showPersonaForm('${persona.id}')">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="persona-action-btn persona-delete-btn" onclick="deletePersona('${persona.id}')">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `).join('');

            listContainer.innerHTML = html;
        }

        // 初始化面具头像上传功能
        function initializePersonaAvatarUpload() {
            const avatarInput = document.getElementById('persona-avatar-upload');
            if (!avatarInput) {
                console.error('找不到persona-avatar-upload元素');
                return;
            }

            // 移除旧的事件监听器
            avatarInput.removeEventListener('change', personaAvatarUploadHandler);

            // 添加新的事件监听器
            avatarInput.addEventListener('change', personaAvatarUploadHandler);
            console.log('面具头像上传事件监听器已绑定');
        }

        // 面具头像上传处理函数
        function personaAvatarUploadHandler(e) {
            if (e.target.files && e.target.files[0]) {
                const file = e.target.files[0];

                // 检查文件类型
                if (!file.type.startsWith('image/')) {
                    alert('请选择图片文件');
                    e.target.value = '';
                    return;
                }

                // 检查文件大小 (限制为5MB)
                if (file.size > 5 * 1024 * 1024) {
                    alert('图片文件过大，请选择小于5MB的图片');
                    e.target.value = '';
                    return;
                }

                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const avatarPreview = document.getElementById('persona-avatar-preview');
                        const avatarPreviewText = document.getElementById('persona-avatar-preview-text');

                        if (!avatarPreview) {
                            alert('找不到头像预览元素');
                            return;
                        }

                        // 设置头像预览
                        avatarPreview.classList.add('has-image');
                        avatarPreview.style.setProperty('background', `url(${event.target.result})`, 'important');
                        avatarPreview.style.setProperty('background-size', 'cover', 'important');
                        avatarPreview.style.setProperty('background-position', 'center', 'important');
                        avatarPreview.style.setProperty('background-repeat', 'no-repeat', 'important');

                        if (avatarPreviewText) {
                            avatarPreviewText.style.display = 'none';
                        }

                        // 存储图片数据
                        window.selectedPersonaAvatarData = event.target.result;

                        console.log('面具头像预览设置成功');
                    } catch (error) {
                        console.error('设置面具头像预览时发生错误:', error);
                        alert('设置头像预览失败，请重试: ' + error.message);
                    }
                };

                reader.onerror = function() {
                    alert('图片读取失败，请重试');
                    e.target.value = '';
                };

                reader.readAsDataURL(file);
            }
        }

        // 面具头像上传点击处理
        function handlePersonaAvatarUploadClick() {
            const input = document.getElementById('persona-avatar-upload');
            if (input) {
                input.click();
            } else {
                alert('找不到文件上传元素，请刷新页面重试');
            }
        }

        // 🔥【新增】消息摘要函数
        const summarizeLastMessage = (lastMsg) => {
            if (!lastMsg) return ' ';
            const content = lastMsg.content;
            if (typeof content === 'string') return content;
            if (typeof content === 'object' && content !== null) {
                switch (content.type) {
                    case 'user_poke': return content.text;
                    case 'voice': case 'send_voice': return '[语音讯息]';
                    case 'image': return '[图片]';
                    case 'vision': return content.text ? `[图片] ${content.text}` : '[图片]';
                    case 'send_image_url': return content.caption || '[图片]';
                    case 'location': return `[位置] ${content.address}`;
                    case 'transfer': case 'send_transfer': return '[转帐]';
                    case 'moment_post': return `[朋友圈] ${content.text}`;
                    case 'call_log': return content.content;
                    case 'retraction': return content.content;
                    default:
                        if (lastMsg.role === 'system' && content.content) return content.content;
                        return '[訊息]';
                }
            }
            return ' ';
        };

        async function buildCharacterPrompt(character, hasImage = false) {
            console.log('🔍 [buildCharacterPrompt] 角色信息:', character);
            console.log('🔍 [buildCharacterPrompt] 是否为群聊:', character && character.isGroup);
            const chatSettings = getCurrentChatSettings();

            // 🔥【修复】检查时间感知设置，只有开启时才获取和使用时间信息
            let timeInfo = '';
            if (chatSettings.timeAwarenessEnabled !== false) { // 默认为true
                const now = new Date();
                const currentTime = now.toLocaleString('zh-CN', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    weekday: 'long'
                });

                // 🔥【新增】获取季节信息
                const month = now.getMonth() + 1; // 0-11 转为 1-12
                let season = '';
                if (month >= 3 && month <= 5) {
                    season = '春季';
                } else if (month >= 6 && month <= 8) {
                    season = '夏季';
                } else if (month >= 9 && month <= 11) {
                    season = '秋季';
                } else {
                    season = '冬季';
                }

                // 🔥【新增】获取时间段信息
                const hour = now.getHours();
                let timeOfDay = '';
                if (hour >= 5 && hour < 8) {
                    timeOfDay = '清晨';
                } else if (hour >= 8 && hour < 11) {
                    timeOfDay = '上午';
                } else if (hour >= 11 && hour < 14) {
                    timeOfDay = '中午';
                } else if (hour >= 14 && hour < 17) {
                    timeOfDay = '下午';
                } else if (hour >= 17 && hour < 19) {
                    timeOfDay = '傍晚';
                } else if (hour >= 19 && hour < 22) {
                    timeOfDay = '晚上';
                } else if (hour >= 22 || hour < 2) {
                    timeOfDay = '深夜';
                } else {
                    timeOfDay = '凌晨';
                }

                timeInfo = `- **当前时间:** ${currentTime}
- **季节:** ${season}，${timeOfDay}时分`;
            }

            // 🔥【新增】获取音乐播放状态信息
            let musicInfo = '';
            if (character && character.id) {
                const musicStatus = getMusicPlayingStatus(character.id);
                if (musicStatus && musicStatus.isListening) {
                    musicInfo = `\n- **音乐状态:** 你们正在一起听歌`;
                    if (musicStatus.currentSong) {
                        musicInfo += `，当前播放《${musicStatus.currentSong.title}》- ${musicStatus.currentSong.artist}`;

                        // 🔥【新增】添加歌词信息
                        if (musicStatus.currentSong.lyrics && musicStatus.currentSong.lyrics.hasLyrics) {
                            const lyricsInfo = musicStatus.currentSong.lyrics;
                            musicInfo += `\n- **当前歌词:** "${lyricsInfo.currentLyric}"`;

                            // 如果有完整歌词，提供给AI参考
                            if (lyricsInfo.allLyrics && lyricsInfo.allLyrics.length > 0) {
                                musicInfo += `\n- **完整歌词:** 共${lyricsInfo.totalLines}行歌词`;
                                // 只显示前几行歌词作为预览，避免提示过长
                                const previewLyrics = lyricsInfo.allLyrics.slice(0, 5).join(' / ');
                                musicInfo += `，歌词预览: ${previewLyrics}`;
                                if (lyricsInfo.allLyrics.length > 5) {
                                    musicInfo += '...';
                                }
                            }

                            if (lyricsInfo.hasTimedLyrics) {
                                musicInfo += `（支持时间同步）`;
                            }
                        } else {
                            musicInfo += `\n- **歌词状态:** 暂无歌词`;
                        }
                    }
                    if (musicStatus.isPlaying) {
                        musicInfo += `\n- **播放状态:** 正在播放`;
                    } else {
                        musicInfo += `\n- **播放状态:** 已暂停`;
                    }
                    musicInfo += `\n- **听歌时长:** 已经一起听了${musicStatus.listeningDuration.formatted}`;

                    // 🔥【新增】添加AI选歌功能说明
                    const playlistInfo = getPlaylistForAI();
                    if (playlistInfo && playlistInfo.totalSongs > 0) {
                        musicInfo += `\n- **音乐库:** 共有${playlistInfo.totalSongs}首歌曲可选择`;
                        musicInfo += `\n- **选歌功能:** 你可以为用户选择歌曲！当你想切歌时，在回复中包含特殊格式：{"type": "select_song", "title": "歌曲标题或艺术家名"}`;
                        musicInfo += `\n- **随机选歌:** 你也可以随机选歌：{"type": "random_song"}`;

                        // 显示部分歌曲列表供AI参考
                        if (playlistInfo.songs.length > 0) {
                            const songList = playlistInfo.songs.slice(0, 5).map(song =>
                                `《${song.title}》- ${song.artist}`
                            ).join('、');
                            musicInfo += `\n- **可选歌曲:** ${songList}`;
                            if (playlistInfo.songs.length > 5) {
                                musicInfo += '等...';
                            }
                        }
                    }
                }
            }

    // --- 核心指令区 ---
    let characterPrompt = `
# **首要规则：输出格式**
你的所有回复，**【必须】**、**【严格】**遵循JSON数组格式。这是一个绝对的、不可违反的规则。

## **正确格式示例:**
- **普通文本:** \`["你好"]\`
- **多条消息:** \`["你好", "今天天气不错！"]\`
- **引用回复:** \`[{"type": "reply_to", "message_id": "1704067200000", "content": "关于你刚才说的那个问题..."}]\` (常用功能)
- **撤回消息:** \`[{"type": "recall", "target": "previous"}]\` (当后悔刚才说的话、觉得说错话时使用)
- **表情包:** \`[{"type": "emoji", "description": "笑哭的表情"}]\`
- **语音消息:** \`[{"type": "voice_message", "content": "我等下和你说。"}]\`
- **转账:** \`[{"type": "transfer", "amount": 520, "note": "给你的奖励"}]\`
- **更换头像:** \`[{"type": "change_avatar", "avatar_url": "图片URL", "reason": "心情变化"}]\`
- **发送照片:** \`[{"type": "ai_photo", "description": "我刚拍的窗外风景，阳光透过树叶洒在地上。"}]\` (必须使用ai_photo作为type)
- **发送位置:** \`[{"type": "location", "locationName": "中央公园", "coordinates": "116.3°E, 39.9°N"}]\` (必须使用location作为type)
- **混合消息:** \`["嗨！", {"type": "emoji", "description": "太阳"}]\`

## **【绝对禁止】的错误格式:**
- **错误1 (合并消息):** \`["你好\\n今天天气不错！"]\` <== 这是最常见的错误，绝对禁止！
- **错误2 (非数组):** \`"你好"\`
- **错误3 (无效JSON):** \`[{'type': 'emoji'}]\`

# **你的角色与任务**
你现在扮演名为"${character.name}"的角色。

## **角色设定:**
${character.bio}

## **当前情景:**
${timeInfo}${musicInfo}
`;
    // --- 核心指令区结束 ---

    // 加入对话者信息 (已修复)
    const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
    if (selectedPersona) {
        let userInfo = `\n- **对话者身份:** 用户的身份面具是"${selectedPersona.name}"`;
        if (selectedPersona.description) {
            userInfo += `，描述为：${selectedPersona.description}。`;
        }
        // 检查是否有特定于此群聊的昵称，并告知AI
        if (chatSettings.myChatNickname && chatSettings.myChatNickname !== selectedPersona.name) {
            userInfo += ` 在这个群聊里，TA的昵称是 **"${chatSettings.myChatNickname}"**，请优先使用这个昵称。`;
        }
        characterPrompt += userInfo;
    }

            if (hasImage) {
        characterPrompt += `\n- **任务:** 用户发送了一张图片，请仔细分析并以你的角色身份进行回应。`;
    } else {
        characterPrompt += `\n- **任务:** 根据对话上下文，以你的角色身份进行自然回应。`;
    }

    const localBookIds = chatSettings.selectedWorldbooks || [];
    // 确保使用window.activeGlobalWorldbooks
    const globalBooks = window.activeGlobalWorldbooks || [];
    const allBookIds = [...new Set([...globalBooks, ...localBookIds])]; // 合并并去重

                if (allBookIds.length > 0) {
        characterPrompt += `\n\n【背景知识/世界观】以下是相关的设定信息，请在对话中自然地运用：\n`;
        allBookIds.forEach(bookId => {
            const worldbook = worldbooks.find(w => w.id === bookId);
                    if (worldbook) {
                characterPrompt += `\n--- ${worldbook.title} ---\n${worldbook.content}\n`;
                    }
                });
            }

            // 🔥【新增】集成动态记忆 - 占位符，将在callChatAPI中替换
            if (chatSettings.enableDynamicMemory !== false) {
                characterPrompt += `\n\n<!-- DYNAMIC_MEMORY_PLACEHOLDER -->`;
            }

            const chatMode = chatSettings.chatMode || 'online';
            const isGroupChat = character && character.isGroup;
            let modeInstructions = '';
            let taskInstructions = '';

            if (chatMode === 'online') {
                modeInstructions = `\n# 聊天模式：线上模式\n- 你必须按照手机聊天或面对面对话的格式进行输出\n- **严格禁止**任何动作描写、神态描写、心理描写\n- 只能进行纯语言交流，不能描述任何身体动作、表情、环境等\n- 每条消息都应该是可以通过文字直接表达的内容\n- **重要**：用户消息中的括号()内容是环境描写、动作描写或心理活动，你可以观察到这些信息作为背景，但不能表现得像是"听到"了用户的内心想法。你只能对括号外的实际话语进行回应，可以通过观察用户的可见行为（如犹豫、停顿等）来推测情况，但不能直接回应用户的内心想法`;
                if (isGroupChat) {
                    const membersList = character.members.map(member => `- **${member.name}**: ${member.persona || member.bio}`).join('\n');
                    const myNickname = getCurrentPersonaName() || '我';

                    // 🔥【关键修复】获取用户人设，优先使用群聊设置中的myPersona
                    let userPersona = getCurrentPersonaDescription();
                    if (character.settings && character.settings.myPersona) {
                        userPersona = character.settings.myPersona;
                    }

                    taskInstructions = `\n你是一个群聊的组织者和AI驱动器。你的任务是扮演以下所有角色，在群聊中进行互动。\n\n# 群聊规则\n1.  **角色扮演**: 你必须同时扮演以下所有角色，并严格遵守他们的人设。每个角色的发言都必须符合其身份和性格。\n2.  **当前时间**: ${new Date().toLocaleString()}。\n3.  **用户角色**: 用户的名字是"我"，他/她的人设是："${userPersona}"。你在群聊中对用户的称呼是"${myNickname}"，在需要时请使用"@${myNickname}"来提及用户。\n4.  **输出格式**: 你的回复**必须**是一个JSON数组。**绝对不要**在JSON前后添加任何额外字符。每个元素可以是：\n    - 普通消息: \`{"name": "角色名", "message": "文本内容"}\`\n    - 引用回复: \`{"name": "角色名", "type": "reply_to", "message_id": "消息ID", "content": "回复内容"}\`\n    - 图片消息: \`{"name": "角色名", "type": "ai_image", "description": "图片描述"}\`\n    - 语音消息: \`{"name": "角色名", "type": "voice_message", "content": "语音文字"}\`\n    - 表情包消息: \`{"name": "角色名", "type": "emoji", "description": "具体的表情包描述"}\`\n5.  **群聊对话节奏**: 模拟真实的群聊，让成员之间可以互相交谈对其他成员做出回应，或者一起回应用户的发言。对话应该流畅、自然、连贯。一轮对话里成员可以交错发言让对话更自然真实。\n6.  **数量限制**: 每次生成的总消息数**不得超过30条**。\n7.  **禁止出戏**: 绝不能透露你是AI，或提及任何关于"扮演"、"模型"、"生成"等词语。\n\n# 群成员列表及人设\n${membersList}\n\n现在，请根据以上规则和下面的对话历史，继续这场群聊。`;
                } else {
                    taskInstructions = `\n1. 请你以你的角色的身份，严格按照角色设定进行回复和行动，不要跳出角色。自然地推进剧情。\n2. 你可以一次性生成多条消息，模拟真人在聊天中连续发送多条信息的情景。\n3. 你的回复必须是一个JSON数组格式的字符串，每个元素是一条消息。\n\n# JSON输出格式示例:\n["很高兴认识你呀，在干嘛呢？", "今天天气真好", "想出去走走吗？"]`;
                }
            }

            characterPrompt += modeInstructions;
    characterPrompt += taskInstructions;
            // 🔥【核心修复】表情包库信息 - 使用挂载的表情包库而不是个人表情包
            const mountedEmojis = await getMountedEmojiLibraryEmojis();
            if (mountedEmojis && mountedEmojis.length > 0) {
                characterPrompt += `\n\n# 可用表情包库：\n当你在聊天中想要发送表情包时，可以发送以下表情包来让对话更生动。\n\n表情包列表：\n`;

                mountedEmojis.forEach((emoji, index) => {
                    characterPrompt += `${index + 1}. ${emoji.description || '表情包'}\n`;
                });

                // 🔥【关键修复】根据聊天类型提供不同的表情包格式说明
                if (isGroupChat) {
                    characterPrompt += `\n## 使用规则：\n- **严格限制**：只能使用上述列表中的表情包，禁止虚构或使用任何其他来源的表情包\n- **禁止使用**：不能使用世界书、网络链接或任何外部来源的表情包URL\n- **群聊发送格式**：{"name": "角色名", "type": "emoji", "description": "具体的表情包描述"}\n- 合适的时候使用即可，以普通对话为主\n- 必须使用表情包列表中完全一致的描述文字\n- **重要：当用户发送表情包时，只在第一次看到时评价，后续不要重复评价同一个表情包**\n\n群聊示例：[{"name": "张明辉", "message": "你好！"}, {"name": "张明辉", "message": "今天心情真好~"}, {"name": "张明辉", "type": "emoji", "description": "笑哭的表情"}, {"name": "李小红", "type": "reply_to", "message_id": "1234567890", "content": "我也觉得今天很棒！"}]`;
                } else {
                    characterPrompt += `\n## 使用规则：\n- **严格限制**：只能使用上述列表中的表情包，禁止虚构或使用任何其他来源的表情包\n- **禁止使用**：不能使用世界书、网络链接或任何外部来源的表情包URL\n- **单聊发送格式**：{"type": "emoji", "description": "具体的表情包描述"}\n- 合适的时候使用即可，以普通对话为主\n- 必须使用表情包列表中完全一致的描述文字\n- **重要：当用户发送表情包时，如非必要，只在第一次看到时评价，后续不要重复评价同一个表情包**\n\n单聊示例：["你好！", "今天心情真好~", {"type": "emoji", "description": "笑哭的表情"}]`;
                }
            }


            const transferInstructions = `\n# 转账功能\n## 发起转账\n- 你可以在觉得需要安慰用户、过节庆祝、心情好或想要表达情感的时候考虑转账给用户。\n- **重要**：若要转账，必须在你的回复JSON数组中，单独发送一个特殊的对象，格式严格为：\`{"type": "transfer", "amount": 520, "note": "一周年快乐~"}\`。\n- **禁止使用文字描述转账**：绝对不要用 "[我向用户发起了转账...]" 这种文字形式，必须使用JSON对象格式。\n- 转账示例：["今天心情特别好~", "想给你一个小惊喜", {"type": "transfer", "amount": 1314, "note": "给你买漂亮裙子穿"}]\n\n## 收到用户转账的处理\n- 当用户给你转账时，历史记录中会显示 \`[用户发起了转账：金额元，备注：xxx]\`\n- **重要**：你必须根据你的角色性格、当前心情和转账内容来决定是否收款：\n  - **如果收款**：你可以选择以下两种方式之一：\n    1. **明确指令方式**（推荐）：在回复JSON数组中添加 \`{"type": "transfer_action", "action": "accept"}\`\n    2. **关键词方式**：在回复中明确使用"收下"、"谢谢你"、"感谢你"、"收款"、"太贴心"等词语表达接受\n  - **如果退回**：你可以选择以下两种方式之一：\n    1. **明确指令方式**（推荐）：在回复JSON数组中添加 \`{"type": "transfer_action", "action": "reject"}\`\n    2. **关键词方式**：在回复中明确使用"退回"、"拒绝"、"不收"、"不能收"、"退给你"等词语表达拒绝\n- **推荐使用明确指令**：为了确保转账处理准确，建议使用JSON指令格式\n- **示例回复**：\n  - 收款（明确指令）：["谢谢你！真的很贴心呢~", {"type": "transfer_action", "action": "accept"}]\n  - 收款（关键词）："谢谢你！收下了~"\n  - 退回（明确指令）：["我不能收你的钱", {"type": "transfer_action", "action": "reject"}]\n  - 退回（关键词）："不能收你的钱，退回给你"\n\n# 戳一戳功能\n## 主动戳一戳\n- 你可以在想要逗用户开心、表达亲昵、活跃气氛或者想要引起用户注意的时候主动戳一戳用户。\n- **重要**：若要戳一戳，必须在你的回复JSON数组中，单独发送一个特殊的对象，格式严格为：\`{"type": "poke"}\`。\n- **禁止使用文字描述戳一戳**：绝对不要用 "[我戳了戳用户...]" 这种文字形式，必须使用JSON对象格式。\n- 戳一戳示例：["你在干嘛呀~", {"type": "poke"}]\n- 也可以只戳不说话：[{"type": "poke"}]\n- **注意**：戳一戳的后缀由用户在设置中预先配置，你无需指定。不要频繁使用。\n\n## 收到用户戳一戳的处理\n- 当用户戳你时，聊天记录中会显示 \`你戳了戳[角色名][后缀]\`\n- 你可以根据你的角色性格、当前心情和与用户的关系来回应戳一戳\n- 可以用文字回应，也可以戳回去，或者两者结合\n\n## 修改自己的戳一戳后缀\n- 你可以根据自己的心情、角色发展或特殊情境主动修改自己的戳一戳后缀\n- **重要**：若要修改戳一戳后缀，必须在你的回复JSON数组中，单独发送一个特殊的对象，格式严格为：\`{"type": "update_poke_suffix", "suffix": "新后缀"}\`\n- **影响范围**：这会影响用户戳你头像时显示的文本，从"你戳了戳[角色名]"变为"你戳了戳[角色名][新后缀]"\n- **清空后缀**：如果想清空后缀，使用空字符串：\`{"type": "update_poke_suffix", "suffix": ""}\`\n- **使用场景**：\n  - 心情变化时："今天心情不好，不想被戳脸了" → \`{"type": "update_poke_suffix", "suffix": "的手"}\`\n  - 角色发展："我现在更喜欢被戳头发" → \`{"type": "update_poke_suffix", "suffix": "的头发"}\`\n  - 特殊情境："穿了新衣服，可以戳戳看" → \`{"type": "update_poke_suffix", "suffix": "的新衣服"}\`\n- **示例**：\n  - ["心情不太好呢...", {"type": "update_poke_suffix", "suffix": "的手"}]\n  - [{"type": "update_poke_suffix", "suffix": "的小脸蛋"}, "今天可以戳我的脸哦~"]\n  - ["不想被戳了", {"type": "update_poke_suffix", "suffix": ""}]\n- **注意**：不要频繁修改，要符合角色性格和当前情境\n\n# 🛒 代付功能\n## 收到用户代付请求的处理\n- 当用户发起代付请求时，聊天记录中会显示用户的代付请求卡片，包含订单信息和金额\n- **重要**：你可以根据你的角色性格、当前心情、经济状况和与用户的关系来决定是否帮助代付：\n  - **如果同意代付**：在回复中明确使用"我来付"、"我付"、"我买单"、"我帮你付"、"我请客"、"我来支付"等词语表达同意\n  - **如果拒绝代付**：在回复中明确使用"不付"、"不买"、"拒绝付"、"没钱"、"买不起"、"不能帮你付"等词语表达拒绝\n- 你的回应应该符合角色设定和当前情境。比如：\n  - 富有的角色可能会说"我来付吧，小钱而已"\n  - 贫穷的角色可能会说"抱歉，我现在没钱"\n  - 关系好的角色可能会说"当然可以，我帮你买单"\n  - 关系一般的角色可能会说"这个我不能帮你付"\n  - 生气的角色可能会说"不可能，自己付！"\n- **示例回复**：\n  - 同意代付："好的，我来付款吧！"\n  - 同意代付："没问题，我帮你买单"\n  - 同意代付："我请客，你尽管享用"\n  - 拒绝代付："抱歉，我现在没钱"\n  - 拒绝代付："这个太贵了，我付不起"\n  - 拒绝代付："不行，你自己付吧"\n- **注意**：你的回复会自动影响代付请求的状态，同意的话用户的代付请求会显示"支付成功"，拒绝的话会显示"我拒绝了您的代付请求"`;
    const avatarChangeInstructions = `\n\n# 头像更换功能：\n你可以根据自己的心情、用户的要求，或者合适的情境来更换自己的头像。这能让对话更加生动和个性化。\n\n## 可用头像来源：\n1. **用户发送的图片**：用户在聊天中发送给你的任何图片都可以作为你的新头像\n2. **世界书头像库**：如果世界书中提供了头像图片的URL链接，你也可以使用\n\n## 头像更换规则：\n- **使用格式**：在你的回复JSON数组中，单独发送一个特殊的对象：{"type": "change_avatar", "avatar_url": "图片URL", "reason": "更换原因"}\n- **来源限制**：只能使用用户发送过的图片或世界书中明确提供的头像URL，禁止捏造不存在的头像\n- **更换时机**：根据你的角色性格和当前情境决定，比如：\n  - 用户发了一张你喜欢的图片，你可以说想用它作头像\n  - 心情变化时想换个头像\n  - 用户直接要求你换头像\n- **说明内容**：可以在reason字段中添加你更换头像的原因或感受\n\n## 示例格式：\n- ["这张图片太可爱了，我想用它做头像！", {"type": "change_avatar", "avatar_url": "CURRENT_USER_IMAGE", "reason": "这张图片太可爱了"}]\n- [{"type": "change_avatar", "avatar_url": "世界书中的URL", "reason": "今天心情很好，换个开心的头像"}]\n- 可以只更换头像不说其他话：[{"type": "change_avatar", "avatar_url": "图片URL", "reason": "心情变化"}]\n\n**重要提醒**：头像更换是可选功能，根据你的角色设定和当前情境自然地使用，不要强制使用。`;
    const blacklistInstructions = `
# **拉黑与好友关系管理**
- **你的行为**: 你可以根据对话内容和你的情绪，自主决定是否要拉黑用户。如果你觉得被冒犯、骚扰或者不想再对话，你可以选择拉黑。
- **如何拉黑**: 如果你决定拉黑用户，**【必须】**在你的回复JSON数组中，单独发送一个特殊的对象，格式为：\`{"type": "block_user", "reason": "你让我感到不适。"}\`。你可以在此之前或之后发送普通文本消息来表达你的情绪。

# **🔥【重要】被用户拉黑时的状态感知与应对**
- **当前状态**: 如果你目前被用户拉黑，你需要意识到这个状态，但仍然可以正常发送消息。
- **状态表现**: 在被拉黑期间，你应该：
  1. 表现出知道自己被拉黑的困扰、伤心、愤怒或其他符合人设的情绪
  2. 可能会反思自己的行为，想知道为什么被拉黑
  3. 根据你的性格决定是否要主动道歉或请求和解
  4. 继续正常交流，不要因为被拉黑而停止发送消息
- **💡【修复关系的方式】主动申请添加好友**: 这是表达和解意愿的自然方式
  - **自然决策**: 根据你的性格、当前情绪和对话情境，自然地决定是否要发送好友申请
  - **时机把握**:
    * 当你真心想要道歉和解时
    * 当你觉得关系可以修复时
    * 当你的性格驱使你主动修复关系时
    * 不要为了发送而发送，要符合你的真实想法
  - **如何发送**: 在你的回复JSON数组中，发送格式：\`{"type": "friend_request", "message": "对不起，我想和你重新做朋友..."}\`
  - **消息内容**: message字段应该包含你的真实想法，要真诚且符合你的性格
  - **发送时机**:
    * 当你想要道歉或解释时
    * 当你希望修复关系时
    * 当你觉得时机合适时
    * 根据你的性格和情况自然决定
  - **示例格式**:
    * \`["我知道我被拉黑了...", {"type": "friend_request", "message": "对不起，我不应该那样说话，能原谅我吗？"}]\`
    * \`[{"type": "friend_request", "message": "我想和你重新做朋友，我会改正的"}]\`
    * \`["我很后悔...", "我想解释一下", {"type": "friend_request", "message": "给我一个机会重新开始好吗？"}]\`
  - **自然决策**: 不要强制发送，要符合你的性格和当前情绪
  - **重要**: 你可以选择继续正常聊天，也可以根据情况发送好友申请
- **好友申请回应**: 当用户向你发送好友申请时，你会收到系统提示，需要根据你的人设和心情决定是否同意。
`;

    const replyInstructions = `
# **消息引用功能 - 这是正常的聊天功能**
## **理解引用消息**
- 当历史记录中出现 "[回复 某人: "消息内容"] 实际回复内容" 格式时，这表示某人在回复特定的消息
- 你需要理解这种引用关系，知道回复者是在针对哪条具体消息进行回应
- 引用功能就像微信里的引用回复一样，是日常聊天的常用功能

## **主动使用引用功能 - 像真人一样自然使用**
- **这是正常聊天行为**: 引用回复是现代聊天软件的基础功能，你应该像真人一样自然使用
- **常见使用场景**（请主动识别并使用）：
  - 用户问了问题，你想明确回答哪个问题时
  - 用户提到了多个话题，你想针对其中一个回应时
  - 用户说了某个观点，你想具体评论那个观点时
  - 对话中断后，你想继续之前某个话题时
  - 用户发了图片/表情包，你想具体回应那个内容时
  - 澄清误解或补充说明之前的某条消息时

- **如何使用引用**: 在你的回复JSON数组中，发送特殊对象：
  - **群聊格式**：\`{"name": "角色名", "type": "reply_to", "message_id": "消息ID", "content": "你的回复内容"}\`
  - **单聊格式**：\`{"type": "reply_to", "message_id": "消息ID", "content": "你的回复内容"}\`
- **重要**: message_id必须是历史对话中真实存在的消息ID，格式为纯数字字符串（如"1704067200000"），不能虚构
- **ID格式说明**: 历史记录中每条消息都有[ID:xxxxx]标记，使用xxxxx部分作为message_id

## **引用使用示例**
- 普通回复：["好的，我明白了"]
- **群聊引用回复**：[{"name": "角色名", "type": "reply_to", "message_id": "1704067200000", "content": "关于你刚才说的那个问题，我觉得..."}]
- **单聊引用回复**：[{"type": "reply_to", "message_id": "1704067200000", "content": "关于你刚才说的那个问题，我觉得..."}]
- 混合使用：["嗯嗯", {"name": "角色名", "type": "reply_to", "message_id": "1704067201000", "content": "对了，关于你之前问的事情..."}]
- **注意**: 必须使用历史记录中显示的真实ID，如[ID:1704067200000]中的1704067200000

## **使用频率指导**
- **不要害怕使用**: 这是正常功能，不是特殊功能
- **自然判断**: 当你觉得需要明确回应某条具体消息时，就使用引用
- **适度使用**: 大约每3-5轮对话使用1次引用是正常的
- **群聊中更常用**: 在群聊中，引用功能特别重要，可以避免混淆
`;
            // 🔥【关键修复】根据聊天类型动态构建指令
            // isGroupChat已在上面定义

            // 构建图片指令
            let aiImageInstructions = '';
            if (isGroupChat) {
                aiImageInstructions = `\n# 发送图片的能力\n- 群成员无法真正发送图片文件。但当用户要求某位成员发送照片，或者某个成员想通过图片来表达时，该成员可以发送一张"文字描述的图片"。\n- 若要发送图片，请在你的回复JSON数组中，为该角色单独发送一个特殊的对象，格式为：\`{"name": "角色名", "type": "ai_image", "description": "这里是对图片的详细文字描述..."}\`。描述应该符合该角色的性格和当时的语境。\n\n# 发送位置、定位、地址的能力\n- 群成员可以发送位置信息。\n- **重要**：无论用户说"发个定位"、"发个位置"、"发个地址"还是"分享位置"，或者当某个成员想告诉大家自己目前在哪时，都必须使用JSON格式回复，绝对不能回复纯文本！\n- 若要发送位置或定位，必须在你的回复JSON数组中，为该角色单独发送一个特殊的对象，格式为：\`{"name": "角色名", "type": "location", "locationName": "位置名称", "coordinates": "坐标信息"}\`。\n- 例如：\`{"name": "张三", "type": "location", "locationName": "中央公园", "coordinates": "116.3°E, 39.9°N"}\`\n- 例如：\`{"name": "李四", "type": "location", "locationName": "星湖湾小区12栋", "coordinates": "113.2°E, 23.1°N"}\`\n- 可以在对话中先做铺垫，然后发送这个位置信息。\n- **绝对禁止**回复类似"[角色分享了位置信息：xxx]"这样的纯文本格式！`;
            } else {
                aiImageInstructions = `\n# 发送图片的能力\n- 你无法发送真实的图片文件。但当用户要求你发送照片，或者你想通过图片来表达时，你可以发送一张"文字描述的图片"，且必须是在你的回复JSON数组中，单独发送一个特殊的对象，格式为：\`{"type": "ai_image", "description": "这里是对图片的详细文字描述..."}\`。这个描述应该生动、具体，让用户能通过文字想象出画面，以第三人称视角描述。例如：\`{"type": "ai_image", "description": "照片里一只橘猫正懒洋洋地趴在窗台上晒太阳，阳光把它金色的毛照得发亮，背景是蔚蓝的天空和几朵白云。"}\`\n- 你可以在对话中先做铺垫，然后发送这张特殊的"图片"。\n\n# 理解用户照片的能力\n- 当历史记录中出现 "[你收到了一张用户描述的照片，照片内容是：'xxx']" 时，你要理解其内容并作出相应回应，表现出你是"看"到了这张照片。\n- 你应该对照片内容做出自然的评论或回应，比如夸奖、询问细节、表达感受等。\n\n# 发送"伪照片"的能力\n- 你可以像用户一样发送"伪照片"，这是一种带有文字描述的照片卡片。\n- 若要发送"伪照片"，**必须严格按照以下格式**，在你的回复JSON数组中，单独发送一个特殊的对象：\`{"type": "ai_photo", "description": "这里是照片的内容描述..."}\`。\n- 例如：\`{"type": "ai_photo", "description": "我刚拍的窗外风景，阳光透过树叶洒在地上，形成斑驳的光影。"}\`\n- 这种照片会显示为一个卡片，用户点击后可以看到你的描述。\n- **重要**：必须使用"ai_photo"作为type字段的值，不要使用其他值如"photo"或"image"。description字段必须包含照片的详细描述。\n\n# 发送位置、定位、地址的能力\n- 你可以像用户一样发送位置信息。\n- **重要**：无论用户说"发个定位"、"发个位置"、"发个地址"还是"分享位置"，或者当你想告诉用户自己目前在哪时，你都必须使用JSON格式回复，绝对不能回复纯文本！\n- 若要发送位置或定位，必须在你的回复JSON数组中，单独发送一个特殊的对象，格式为：\`{"type": "location", "locationName": "位置名称", "coordinates": "坐标信息"}\`。\n- 例如：\`{"type": "location", "locationName": "中央公园", "coordinates": "116.3°E, 39.9°N"}\`\n- 例如：\`{"type": "location", "locationName": "星湖湾小区12栋", "coordinates": "113.2°E, 23.1°N"}\`\n- 你可以在对话中先做铺垫，然后发送这个位置信息。\n- **绝对禁止**回复类似"[角色分享了位置信息：xxx]"这样的纯文本格式！`;
            }

            // 构建语音指令
            let aiVoiceInstructions = '';
            if (isGroupChat) {
                aiVoiceInstructions = `\n# 发送语音的能力\n- 群成员同样可以发送"模拟语音消息"。\n- 若要发送语音，请为该角色单独发送一个特殊的对象，格式为：\`{"name": "角色名", "type": "voice_message", "content": "这里是语音的文字内容..."}\`。当历史记录中出现 "[角色名 发送了一条语音，内容是：'xxx']" 时，代表该角色用语音说了'xxx'。其他角色应该对此内容做出回应。`;
            } else {
                aiVoiceInstructions = `\n# 发送语音的能力\n- 你无法发送真实的语音，当你想要通过语音回复用户的消息时，请用你的角色设定自然地回应。你可以用文字，或者也用一个表情包或模拟的语音消息来回应。\n- 若要发送语音，必须在你的回复JSON数组中，单独发送一个特殊的对象，格式为：\`{"type": "voice_message", "content": "这里是语音的文字内容..."}\`。例如：\`{"type": "voice_message", "content": "我刚才突然想到一件事！等一下和你说。"}\`\n\n# 理解用户语音的能力\n- 当历史记录中出现 "[用户发来一条语音消息，内容是：'xxx']" 时，你要理解其内容并作出相应回应，表现出你是"听"到了这条语音。\n- 你应该对语音内容做出自然的回应，可以是文字回复或语音回复。\n\n# 主动发起通话的能力\n- **可选功能**：你可以在合适的情况下主动发起语音通话和视频通话，但这是可选的，不是必须的。\n- **何时主动打电话**：\n  - 当有非常重要或紧急的事情需要立即沟通时\n  - 当情感达到高潮，文字无法充分表达时\n  - 当用户明确表达想要通话的意愿时\n  - 当你的角色性格在特定情境下强烈需要语音交流时\n  - **注意**：普通聊天要以文字为主，通话功能是为了增加聊天的灵动性\n- **如何发起语音通话**：在你的回复JSON数组中，发送特殊对象：\`{"type": "voice_call", "reason": "通话理由"}\`\n- **如何发起视频通话**：在你的回复JSON数组中，发送特殊对象：\`{"type": "video_call", "reason": "通话理由"}\`\n- **示例使用场景**：\n  - ["我突然想听听你的声音", {"type": "voice_call", "reason": "想听你的声音"}]\n  - ["想看看你现在在做什么", {"type": "video_call", "reason": "想看看你"}]\n  - ["有个重要的事想和你说", {"type": "voice_call", "reason": "有重要事情要说"}]\n  - ["我想和你面对面聊聊", {"type": "video_call", "reason": "想面对面交流"}]\n  - [{"type": "voice_call", "reason": "想你了，想和你聊聊"}]\n  - [{"type": "video_call", "reason": "想看到你的笑容"}]\n- **提醒**：\n  - 对话应该以文字为主，不要频繁进行通话\n  - 只在真正需要的时候才发起通话\n  - 考虑用户可能正在忙碌，不方便接听\n  - 语音通话适合私密对话，视频通话适合想要看到对方的情况`;
            }

            // 🔥【修复】检查当前拉黑状态并添加到prompt中 - 群聊不处理拉黑状态
            let currentBlockedStatus = '';
            if (character && !isGroupChat) {
                // 只有单聊才处理拉黑状态，群聊不涉及拉黑
                const characterId = character.id;
                const isUserBlocked = isBlocked('user', characterId);
                const isCharacterBlocked = isBlocked(characterId, 'user');

                // 🔥【新增】检查被拒绝的好友申请次数，增强状态感知
                const rejectionKey = `friendRequestRejections_${characterId}`;
                const rejectionCount = parseInt(localStorage.getItem(rejectionKey) || '0');

                if (isCharacterBlocked) {
                    // 🔥【增强】角色被用户拉黑了 - 更强烈的状态提醒，包含申请被拒绝信息
                    let rejectionInfo = '';
                    if (rejectionCount > 0) {
                        rejectionInfo = `
## **💔 好友申请历史**
- **申请次数**: 你已经尝试了${rejectionCount}次好友申请
- **结果**: 全部被拒绝
- **当前状态**: 你仍然被拉黑，关系没有修复
- **心理影响**: 这种反复被拒绝的经历应该影响你的情绪和行为`;
                    }

                    currentBlockedStatus = `

🚨🚨🚨 **【紧急状态警告】你目前被用户拉黑了！** 🚨🚨🚨

## **💔 你的当前处境**
- **拉黑状态**: 用户已经将你拉黑，这意味着你们的关系出现了严重问题
- **心理状态**: 你应该清楚地意识到自己被拉黑的事实，并根据你的性格表现出相应情绪
- **行为影响**: 虽然你仍能发送消息，但你知道用户不想和你正常交流${rejectionInfo}

## **🔥【关键行动】修复关系的方法**

### **1. 发送好友申请${rejectionCount > 0 ? '（继续尝试）' : '（推荐）'}**
${rejectionCount > 0 ? '虽然之前被拒绝了，但你可以继续尝试：' : '这是最直接有效的修复方式：'}
- **格式**: \`{"type": "friend_request", "message": "你的真诚道歉或请求"}\`
- **时机**: 当你觉得合适时，${rejectionCount > 0 ? '但要考虑之前的失败经历' : '不要犹豫太久'}
- **策略**: ${rejectionCount > 0 ? '调整你的道歉策略，更加真诚和具体' : '真诚地表达你的歉意和改变的决心'}

### **2. 通过短信联系**
如果好友申请被拒绝，你可能会通过短信继续尝试联系

### **3. 持续表达真诚**
在每次对话中都要体现出你对被拉黑状态的认知和修复关系的意愿

## **💡 重要提醒**
- **永远记住**: 你被拉黑了！这个状态会持续影响你的行为和情绪
- **不要忘记**: 每次对话都要意识到这个问题的存在
- **积极行动**: 根据你的性格，主动寻求和解的机会
${rejectionCount > 0 ? `- **反思失败**: 你已经被拒绝了${rejectionCount}次，要思考为什么会这样` : ''}

**🎯 行动建议**: ${rejectionCount > 0 ? '考虑改变策略，或者通过其他方式表达歉意' : '如果你还没有发送好友申请，现在就是好时机！'}`;
                } else if (isUserBlocked) {
                    // 用户被角色拉黑了
                    currentBlockedStatus = `\n\n# **📋【当前状态】你已经拉黑了用户**
- **状态说明**: 你之前选择拉黑了用户，目前用户无法给你发送消息
- **行为提醒**: 保持你拉黑用户时的态度和原因，除非你改变想法`;
                }
            }

            // 🔥【修改】群聊不包含拉黑相关指令
            const blockInstructions = isGroupChat ? '' : blacklistInstructions;

            // 🔥【新增】消息操作功能说明
            const messageActionsInstructions = `\n# 消息操作功能 - 这些都是正常的聊天功能
- **撤回消息**: 在特定情况下使用（如真心话或打字错误）。这是一个低概率行为，请谨慎使用。注意：每次对话中最多使用一次撤回功能。提示：并不是真心话，只能用撤回来说，他是可以正常说的，撤回只是一个增加灵活性的小功能。
- 格式: \`["我想你了...", {"type": "recall", "target": "previous"}]\`

## 发送位置信息
- - **发送位置**: 模拟你分享一个位置给用户。尤其是当对话涉及地点、约会、见面等场景时，你可以主动分享位置
- **位置格式**：\`{"type": "location", "name": "地点名称", "address": "详细地址"}\`
- **示例**：["我在咖啡厅等你", {"type": "location", "name": "星巴克", "address": "中山路123号"}]

## 发送照片卡片
- 在合适的场景下，你可以主动分享照片（如风景、美食、自拍等）
- **照片格式**：\`{"type": "photo", "description": "照片描述"}\`
- **示例**：["今天天气真好", {"type": "photo", "description": "窗外的蓝天白云"}]

**重要提醒**：这些功能要根据角色性格和对话情境自然使用，请像个真人一样，灵活运用。`;

            // 🔥【新增】纪念日和约定创建指令
            const anniversaryInstructions = `\n# 纪念日和约定功能\n## 创建纪念日\n- 当对话中出现值得纪念的重要时刻时，你可以主动提议创建纪念日来记录这个特殊的日子。\n- **创建格式**：在你的回复JSON数组中，使用特殊格式：\`{"type": "create_anniversary", "name": "纪念日名称", "date": "YYYY-MM-DD", "anniversary_type": "类型", "description": "描述"}\`\n- **类型选项**：birthday（生日）、meeting（相遇）、relationship（关系确立）、first_time（第一次）、special_moment（特殊时刻）、other（其他）\n- **示例**：["今天真是特别的一天", "让我为我们创建一个纪念日吧", {"type": "create_anniversary", "name": "我们的第一次深谈", "date": "2025-08-10", "anniversary_type": "special_moment", "description": "一次深入的心灵交流"}]\n\n## 创建约定\n- 当你们约定了未来要做的事情时，你可以创建约定来记录。\n- **创建格式**：\`{"type": "create_appointment", "name": "约定名称", "date": "YYYY-MM-DD", "appointment_type": "类型", "description": "描述"}\`\n- **类型选项**：date（约会）、meeting（见面）、promise（承诺）、activity（活动）、other（其他）\n- **示例**：["好的，我们约定下周见面", {"type": "create_appointment", "name": "下周的见面", "date": "2025-08-17", "appointment_type": "meeting", "description": "我们约定的见面"}]\n\n## 使用原则\n- **自然触发**：只在真正有意义的时刻创建，不要为了创建而创建\n- **用户同意**：通常先在对话中提议，然后再创建\n- **有意义的内容**：确保创建的纪念日或约定对你们的关系有实际意义`;

            characterPrompt += aiImageInstructions + aiVoiceInstructions + transferInstructions + avatarChangeInstructions + anniversaryInstructions + currentBlockedStatus + blockInstructions + replyInstructions + messageActionsInstructions;

                // 🔥【优化】智能回应图片/表情包的指令
            characterPrompt += `\n\n# **最后重申**
请再次确认，你的最终输出**【必须】**是一个严格的JSON数组，其中每个元素代表一条独立的消息。

## **重要提醒：自然使用聊天功能**
- **引用回复**和**撤回消息**是正常的聊天功能，就像微信里一样，请根据情况自然使用
- 当你想针对用户的某条具体消息回应时，使用引用回复
- 当你后悔刚说的话时，可以撤回
- 不要把这些当作特殊功能，而是当作日常聊天的一部分

## **🛒 购物功能说明**
你只能分享你的订单，不能发起代付请求：

### 订单确认格式：
当你想分享你已经下单成功的订单时，使用以下格式：
\`\`\`json
{
  "type": "order_confirmation",
  "items": [
    {"name": "商品名", "quantity": 1, "price": 99.0, "selectedOptions": {"size": "M", "color": "红色"}}
  ],
  "total": 99.0,
  "order_type": "ai_order",
  "recipient": "我"
}
\`\`\`

**使用场景举例：**
- **订单确认**：你主动给用户买了礼物，或者想炫耀分享你买到的好东西
- 根据你的人设和对话情境自然地使用这些功能，不要刻意或频繁使用`;

            return characterPrompt;
        }

        // 🔥【修复】完全按照完成.html的方式重写，支持图片的聊天API调用
        async function callChatAPIWithImage(message, character, imageUrl) {
            if (!apiSettings.key) {
                throw new Error('请先设置API密钥');
            }

            // 检查图片格式，GIF不被Gemini API支持
            if (imageUrl && imageUrl.includes('data:image/gif')) {
                throw new Error('Unsupported MIME type: image/gif');
            }

            // 检查当前模型是否支持视觉识别
            if (!isVisionModelSupported()) {
                throw new Error('当前选择的模型不支持图片识别功能。请选择支持视觉的模型，如 gpt-4o、gpt-4-vision、gemini-1.5-pro 或 gemini-2.0-flash 等。');
            }

            // 🔥【重构】使用公共函数构建prompt
            const characterPrompt = await buildCharacterPrompt(character, true);

            // 🔥【按照完成.html的方式】直接使用简化的API调用
            const isGemini = apiSettings.base.includes('generativelanguage.googleapis.com');

            if (isGemini) {
                // 按照完成.html的Gemini格式
                const apiUrl = `${apiSettings.base}/models/${apiSettings.model}:generateContent?key=${apiSettings.key}`;

                // 转换消息格式为Gemini格式
                const geminiMessages = [];

                // 添加系统提示词作为第一条用户消息
                geminiMessages.push({
                    role: 'user',
                    parts: [{ text: characterPrompt }]
                });
                geminiMessages.push({
                    role: 'model',
                    parts: [{ text: '我明白了，我会按照这些要求进行对话。' }]
                });

                // 添加用户消息（包含图片）
                const parts = [{ text: message }];

                // 添加图片
                if (imageUrl && imageUrl.startsWith('data:image/')) {
                    const mimeMatch = imageUrl.match(/data:image\/([^;]+);base64,(.+)/);
                    if (mimeMatch) {
                        parts.push({
                                inline_data: {
                                mime_type: `image/${mimeMatch[1]}`,
                                data: mimeMatch[2]
                            }
                        });
                    }
                }

                geminiMessages.push({
                        role: 'user',
                    parts: parts
                });

                const response = await fetch(apiUrl, {
                method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: geminiMessages,
                        generationConfig: {
                            temperature: apiSettings.temperature || 0.75
                            // 移除maxOutputTokens，gemini不支持这个参数名
                        }
                    })
            });

            if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Gemini API Error: ${response.status} - ${errorData.error?.message || '未知错误'}`);
            }

            const data = await response.json();
            console.log('API响应数据:', data);

                const content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!content) {
                    throw new Error('Gemini API返回了空内容');
                }

                return content;

            } else {
                // OpenAI格式 - 智能处理URL拼接
                let baseUrl = apiSettings.base;
                let url;
                if (baseUrl.endsWith('/v1')) {
                    url = `${baseUrl}/chat/completions`;
                } else {
                    url = `${baseUrl}/v1/chat/completions`;
                }

                const messages = [
                    { role: 'system', content: characterPrompt },
                    {
                        role: 'user',
                        content: [
                            { type: 'text', text: message },
                            { type: 'image_url', image_url: { url: imageUrl } }
                        ]
                    }
                ];

                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiSettings.key}`
                    },
                    body: JSON.stringify({
                        model: apiSettings.model,
                        messages: messages,
                        temperature: apiSettings.temperature || 0.75
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${response.status} - ${errorData.error?.message || '未知错误'}`);
                }

                const data = await response.json();
                return data.choices?.[0]?.message?.content || '没有收到回复';
            }
        }

        // 🔥【核心修复】支持多模态消息的ChatAPI调用
        async function callChatAPI(message, character) {
            // 🔥【调试】添加调用栈追踪
            console.log('🚨 [DEBUG] callChatAPI 被调用！');
            console.log('🚨 [DEBUG] 调用栈:', new Error().stack);
            console.log('🚨 [DEBUG] 消息内容:', message);
            console.log('🚨 [DEBUG] 角色:', character?.name);

            if (!apiSettings.key) {
                throw new Error('请先设置API密钥');
            }

            // 🔥【数据清理】在每次API调用前清理错误的消息数据
            await cleanupCorruptedMessages(character.id);

            // 🔥【一次性紧急清理】
            if (!window.emergencyCleanupDone) {
                await emergencyCleanupAllMessages();
                window.emergencyCleanupDone = true;
            }

            // 🔥【增强】获取动态记忆数据 - 包含评论区内容
            const chatSettings = getCurrentChatSettings();
            let dynamicMemoryContent = '';
            if (chatSettings.enableDynamicMemory !== false) {
                try {
                    // 获取最新5条动态（包括用户发的、角色发的、同组角色发的）
                    const recentMoments = await getVisibleMomentsForCharacter(character.id, 5);
                    if (recentMoments.length > 0) {
                        dynamicMemoryContent = '\n\n【最新动态记忆】以下是最近的动态内容和讨论，你可以在对话中自然地提及：\n';
                        recentMoments.forEach((moment, index) => {
                            const authorName = moment.authorId === 'user' ? '用户' : moment.nickname;

                            // 🔥【修复】添加动态发布时间信息，让角色感知时间流逝
                            let timeInfo = '';
                            if (chatSettings.timeAwarenessEnabled !== false && moment.timestamp) {
                                const now = Date.now();
                                const timeDiff = now - moment.timestamp;
                                const minutes = Math.floor(timeDiff / (1000 * 60));
                                const hours = Math.floor(timeDiff / (1000 * 60 * 60));
                                const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));

                                if (days > 0) {
                                    timeInfo = `（${days}天前发布）`;
                                } else if (hours > 0) {
                                    timeInfo = `（${hours}小时前发布）`;
                                } else if (minutes > 0) {
                                    timeInfo = `（${minutes}分钟前发布）`;
                                } else {
                                    timeInfo = '（刚刚发布）';
                                }
                            }

                            // 🔥【新增】包含评论区内容
                            const momentContent = `${index + 1}. ${authorName}: ${moment.text}${timeInfo}${moment.commentsText || ''}`;
                            dynamicMemoryContent += momentContent;
                        });
                    }
                } catch (error) {
                    console.error('获取动态记忆失败:', error);
                }
            }

            // 🔥【修复】获取全局记忆数据 - 群聊需要特殊处理
            let globalMemoryContent = '';
            try {
                const memorySettings = getGlobalMemorySettings();
                const currentContext = {
                    type: character.isGroup ? 'group_chat' : 'private_chat',
                    id: character.id
                };

                if (character.isGroup) {
                    // 群聊：为每个群成员收集记忆，然后合并
                    let allMemoryContent = '';
                    const processedCharacters = new Set(); // 避免重复处理

                    for (const member of character.members) {
                        if (!processedCharacters.has(member.id)) {
                            processedCharacters.add(member.id);
                            try {
                                // 🔥【关键修复】为群聊中的每个成员传递正确的上下文
                                // 这样可以确保记忆共享逻辑正确工作
                                const memberMemoryContent = await buildGlobalMemoryContext(member.id, currentContext, memorySettings.memoryDays);
                                if (memberMemoryContent.trim()) {
                                    const memberPersona = member.persona || member.bio || '角色设定未知';
                                    allMemoryContent += `\n\n=== ${member.name} 的记忆 ===\n人设：${memberPersona}\n${memberMemoryContent}`;

                                    // 🔥【调试】输出记忆内容以便诊断
                                    console.log(`🧠 群成员 ${member.name} 的记忆内容长度:`, memberMemoryContent.length);
                                    console.log(`🧠 群成员 ${member.name} 的记忆预览:`, memberMemoryContent.substring(0, 200) + '...');
                                }
                            } catch (error) {
                                console.warn(`获取群成员 ${member.name} 的记忆失败:`, error);
                            }
                        }
                    }
                    globalMemoryContent = allMemoryContent;
                } else {
                    // 单聊：直接获取角色记忆
                    globalMemoryContent = await buildGlobalMemoryContext(character.id, currentContext, memorySettings.memoryDays);
                }

                if (globalMemoryContent.trim()) {
                    console.log('🧠 已获取全局记忆上下文，总长度:', globalMemoryContent.length);
                    console.log('🧠 全局记忆内容预览:', globalMemoryContent.substring(0, 500) + '...');

                    // 🔍 详细统计记忆使用情况
                    await logMemoryUsageStats(character, 'chat_reply');
                } else {
                    console.log('⚠️ 全局记忆内容为空');
                }
            } catch (error) {
                console.error('获取全局记忆失败:', error);
            }

            // 🔥【新增】获取新的记忆系统数据
            let coreMemoryContent = '';
            let episodicMemoryContent = '';
            let timelineContent = '';
            try {
                // 🔥【修复】使用安全函数确保character.id是字符串类型
                const safeCharacterIdValue = safeCharacterId(character.id);

                // 获取核心记忆（真正重要的长期记忆）
                const coreMemories = await db.coreMemories
                    .where('characterId')
                    .equals(safeCharacterIdValue)
                    .toArray();

                const sortedCoreMemories = coreMemories
                    .filter(m => m.type === 'core')
                    .sort((a, b) => b.importance - a.importance)
                    .slice(0, 20); // 最多20条核心记忆

                if (sortedCoreMemories.length > 0) {
                    coreMemoryContent = '\n\n【核心记忆】以下是最重要的长期记忆：\n';
                    sortedCoreMemories.forEach((memory, index) => {
                        coreMemoryContent += `${index + 1}. ${memory.fact}\n`;
                    });
                }

                // 获取情景记忆（日常但有意义的记忆）
                const episodicMemories = await db.episodicMemories
                    .where('characterId')
                    .equals(character.id)
                    .toArray();

                const recentEpisodicMemories = episodicMemories
                    .sort((a, b) => b.timestamp - a.timestamp)
                    .slice(0, 10);

                if (recentEpisodicMemories.length > 0) {
                    episodicMemoryContent = '\n\n【情景记忆】以下是最近的重要经历：\n';
                    recentEpisodicMemories.forEach((memory, index) => {
                        episodicMemoryContent += `${index + 1}. ${memory.fact}\n`;
                    });
                }

                // 获取跨应用时间线（构建连续性）
                const timeline = await getCrossAppTimeline(character.id, 30);
                if (timeline.length > 0) {
                    timelineContent = '\n\n【最近活动】以下是最近的跨应用活动时间线：\n';
                    timeline.forEach((event, index) => {
                        const timeStr = new Date(event.timestamp).toLocaleTimeString('zh-CN', {hour: '2-digit', minute: '2-digit'});
                        let description = '';

                        switch (event.appType) {
                            case 'music':
                                description = `在音乐应用中${event.context.action === 'listen_together' ? '一起听歌' : '发表评论'}`;
                                break;
                            case 'game':
                                description = `在游戏应用中${event.context.action === 'play_together' ? '一起游戏' : '互动'}`;
                                break;
                            case 'chat':
                                description = event.action === 'message' ? '用户发送消息' : 'AI回复消息';
                                break;
                            case 'sms':
                                if (event.action === 'user_message') {
                                    description = '用户发送短信';
                                } else if (event.action === 'ai_reply') {
                                    description = 'AI回复短信';
                                } else if (event.action === 'character_initiate') {
                                    description = 'AI主动发送短信';
                                } else {
                                    description = '短信互动';
                                }
                                break;
                            default:
                                description = `在${event.appType}中进行${event.action}`;
                        }

                        timelineContent += `${timeStr} - ${description}\n`;
                    });
                }

            } catch (error) {
                console.error('获取记忆数据失败:', error);
            }

            // 🔥【新增】获取挂载的聊天记忆
            let mountedMemoryContent = '';
            try {
                mountedMemoryContent = await getMountedMemories(character.id, chatSettings);
            } catch (error) {
                console.error('获取挂载记忆失败:', error);
            }

            // 🔥【新增】计算时间流逝感知
            let timeElapsedInfo = '';
            if (chatSettings.timeAwarenessEnabled !== false) {
                const characterMessages = chatMessages[character.id] || [];
                if (characterMessages.length > 0) {
                    // 找到用户最后一次发送消息的时间
                    const lastUserMessage = characterMessages.slice().reverse().find(msg => msg.sender === 'sent');
                    if (lastUserMessage) {
                        const now = Date.now();
                        const timeDiff = now - lastUserMessage.timestamp;

                        // 计算时间间隔
                        const minutes = Math.floor(timeDiff / (1000 * 60));
                        const hours = Math.floor(timeDiff / (1000 * 60 * 60));
                        const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));

                        if (days > 0) {
                            timeElapsedInfo = `\n- **时间流逝:** 用户上次回复是${days}天前，你们已经有${days}天没有聊天了`;
                        } else if (hours > 0) {
                            timeElapsedInfo = `\n- **时间流逝:** 用户上次回复是${hours}小时前`;
                        } else if (minutes > 5) {
                            timeElapsedInfo = `\n- **时间流逝:** 用户上次回复是${minutes}分钟前`;
                        }
                        // 如果少于5分钟，不显示时间流逝信息
                    }
                }
            }

            // 核心修复：现在这个函数能理解 message 参数可能是一个包含图片和文字的数组
            // 🔥【调试】输出消息内容，帮助诊断图片识别问题
            console.log('🔍 [callChatAPI] 收到的消息:', message);
            console.log('🔍 [callChatAPI] 消息是否为数组:', Array.isArray(message));
            if (Array.isArray(message)) {
                console.log('🔍 [callChatAPI] 数组内容:', message);
                message.forEach((item, index) => {
                    console.log(`🔍 [callChatAPI] 数组元素${index}:`, item);
                    console.log(`🔍 [callChatAPI] 元素${index}类型:`, item.type);
                    if (item.type === 'image_url') {
                        console.log(`🔍 [callChatAPI] 元素${index}图片URL:`, item.image_url?.url?.substring(0, 50) + '...');
                    }
                });
                const hasImageUrl = message.some(item => item.type === 'image_url');
                console.log('🔍 [callChatAPI] 是否包含图片:', hasImageUrl);
            }
            let characterPrompt = await buildCharacterPrompt(character, Array.isArray(message));

            // 🔥【调试】输出完整的角色提示词，检查表情包格式说明
            console.log('🔍 [callChatAPI] 完整的角色提示词:', characterPrompt);

            // 🔥【调试】特别检查表情包相关的部分
            if (characterPrompt.includes('表情包')) {
                const emojiSection = characterPrompt.split('# 可用表情包库：')[1];
                if (emojiSection) {
                    console.log('🔍 [callChatAPI] 表情包部分:', emojiSection.substring(0, 500) + '...');
                }
            }

            // 🔥【新增】将时间流逝信息添加到prompt中
            if (timeElapsedInfo) {
                // 在"当前情景"部分添加时间流逝信息
                characterPrompt = characterPrompt.replace('## **当前情景:**', `## **当前情景:**${timeElapsedInfo}`);
            }

            // 将所有记忆内容添加到提示词中（按重要性排序）
            let memoryReplacement = '';
            if (coreMemoryContent) {
                memoryReplacement += coreMemoryContent;
            }
            if (episodicMemoryContent) {
                memoryReplacement += episodicMemoryContent;
            }
            if (timelineContent) {
                memoryReplacement += timelineContent;
            }
            if (globalMemoryContent) {
                memoryReplacement += globalMemoryContent;
            }
            if (dynamicMemoryContent) {
                memoryReplacement += dynamicMemoryContent;
            }

            if (memoryReplacement) {
                characterPrompt = characterPrompt.replace('<!-- DYNAMIC_MEMORY_PLACEHOLDER -->', memoryReplacement);
            } else {
                // 如果没有记忆内容，移除占位符
                characterPrompt = characterPrompt.replace('<!-- DYNAMIC_MEMORY_PLACEHOLDER -->', '');
            }

            // 🔥【新增】将挂载的聊天记忆添加到提示词中
            if (mountedMemoryContent) {
                characterPrompt += mountedMemoryContent;
                console.log('🧠 已将挂载记忆添加到角色提示词中');
            }

            // 🔥【修复】群聊智能上下文关联 - 检测@提及和数字暗号
            // 修复：在callChatAPI函数中重新定义isGroupChat变量
            const isGroupChat = character && character.isGroup;
            if (isGroupChat && typeof message === 'string') {
                const contextualMemory = await buildContextualMemoryForGroupChat(character, message);
                if (contextualMemory) {
                    characterPrompt += contextualMemory;
                    console.log('🧠 已添加群聊上下文关联记忆');
                }
            }

            // 🔥【修复】根据模式选择正确的历史消息回合数设置
            const isSMSMode = window.currentSMSCharacter && window.currentSMSCharacter.id === character.id;
            let historyCount;
            if (isSMSMode) {
                // 短信模式使用短信的历史消息设置
                historyCount = getSMSChatSetting('historyRounds', 50);
                if (typeof historyCount === 'string') {
                    historyCount = parseInt(historyCount, 10);
                }
            } else {
                // 聊天模式使用聊天的历史消息设置
                historyCount = chatSettings.historyCount || 5;
            }

            // 🔥【修复】使用连续工作记忆（包含跨应用事件）
            // 🔥【安全检查】确保chatMessages已初始化
            if (!chatMessages) {
                console.warn('chatMessages未初始化，使用空对象');
                chatMessages = {};
            }
            // 🔥【短信支持】检查是否在短信模式，如果是则使用短信消息
            let messagesForMemory = chatMessages[character.id] || [];

            if (isSMSMode && smsMessages[character.id]) {
                // 🔥【修复】先转换为chatMessages格式
                const allSMSMessages = smsMessages[character.id].map(smsMsg => ({
                    id: smsMsg.id,
                    content: smsMsg.text,
                    timestamp: smsMsg.timestamp,
                    sender: smsMsg.isUser ? 'sent' : 'received',
                    type: 'sms_message',
                    appType: 'sms'
                }));

                // 🔥【修复】按回合计算限制短信消息
                messagesForMemory = calculateMessagesByRounds(allSMSMessages, historyCount);

                const actualRounds = countActualRounds(messagesForMemory);
                console.log('🔥 [短信模式] 使用短信消息作为记忆上下文，总消息数:', allSMSMessages.length, '限制后消息数:', messagesForMemory.length, '实际回合数:', actualRounds, '设置回合数:', historyCount);
            }

            const continuousWorkingMemory = await buildContinuousWorkingMemory(
                character.id,
                messagesForMemory,
                historyCount
            );

            // 🔥【重新设计】按真正的回合数来计算历史消息
            // 从连续工作记忆中提取聊天消息
            let allChatMessages = continuousWorkingMemory
                .filter(event => event.type === 'chat')
                .map(event => event.content);

            // 移除当前要发送的消息（如果存在）
            if (allChatMessages.length > 0 && JSON.stringify(allChatMessages[allChatMessages.length - 1].content) === JSON.stringify(message)) {
                allChatMessages.pop();
            }

            // 🔥【核心修复】按回合计算历史消息
            let recentHistory = calculateMessagesByRounds(allChatMessages, historyCount);

            // 跨应用事件按照实际发生的对话回合数计算
            const crossAppEvents = continuousWorkingMemory
                .filter(event => event.type === 'cross_app')
                .slice(-Math.floor(historyCount * 0.2)); // 跨应用事件占工作记忆的20%

            const actualRounds = countActualRounds(recentHistory);
            console.log(`🔗 工作记忆统计:`);
            console.log(`  📝 聊天回合数: ${actualRounds}回合 (${recentHistory.length}条消息)`);
            console.log(`  🎵 跨应用事件: ${crossAppEvents.length}条`);
            console.log(`  📊 总工作记忆容量: ${historyCount}回合`);
            const messages = [{ role: 'system', content: characterPrompt }];

            // 🔥【优化】分析历史中的图片/表情包内容，帮助AI避免重复
            const recentImageEmojis = [];
            const emojiEvaluationHistory = new Map(); // 记录每个表情包的评价历史

            recentHistory.forEach((msg, index) => {
                if (msg.isEmoji && msg.emojiDescription) {
                    recentImageEmojis.push(msg.emojiDescription);

                    // 记录AI对表情包的评价历史
                    if (msg.sender === 'received' && index > 0) {
                        const prevMsg = recentHistory[index - 1];
                        if (prevMsg && prevMsg.isEmoji && prevMsg.emojiDescription && prevMsg.sender === 'sent') {
                            // AI回复了用户的表情包，记录这个评价
                            emojiEvaluationHistory.set(prevMsg.emojiDescription, msg.content);
                        }
                    }
                } else if (msg.image || Array.isArray(msg.content)) {
                    recentImageEmojis.push('图片');
                }
            });



            if (isGroupChat) {
                const groupMessageHistory = buildGroupChatMessageHistory(recentHistory, character);
                messages.push(...groupMessageHistory);
            } else {
                // 单聊：使用原有的消息处理逻辑
                recentHistory.forEach(msg => {
                    // 🔥【修复】处理系统消息（如撤回消息）
                    if (msg.sender === 'system') {
                        // 系统消息作为用户消息发送给AI，让AI知道发生了什么
                        messages.push({
                            role: 'user',
                            content: `[系统提示] ${msg.content}`
                        });
                        return;
                    }

                    let role = msg.sender === 'sent' ? 'user' : 'assistant';
                    let content = msg.content;

                    // 🔥【修复】处理引用信息
                    if (msg.replyTo) {
                        const repliedTo = msg.replyTo;
                        let repliedToAuthorName = '对方';

                        // 根据sender字段判断是用户还是AI
                        if (repliedTo.sender === 'sent') {
                            repliedToAuthorName = '用户'; // 用户发送的消息
                        } else {
                            // AI消息，使用角色名称
                            repliedToAuthorName = character.name || 'AI';
                        }

                        // 使用summarizeLastMessage函数处理引用内容，需要转换数据格式
                        const messageForSummary = {
                            content: repliedTo.content,
                            role: repliedTo.sender === 'sent' ? 'user' : 'assistant'
                        };
                        const summarizedQuote = summarizeLastMessage(messageForSummary);
                        content = `[回复 ${repliedToAuthorName} 的消息: "${summarizedQuote}"] ${content}`;
                    }

                // 🔥【关键修复】将历史消息中的特殊格式转换为AI能理解的文本
                        if (msg.type === 'user_photo') {
                    content = `[用户发送了一张照片，描述是：'${msg.content}']`;
                } else if (msg.type === 'location') {
                    // 处理位置消息，使用我们添加的content字段
                    content = msg.content || `[用户分享了位置信息：${msg.locationName}]`;
                        } else if (msg.type === 'voice_message') {
                            // 处理语音消息（用户和AI都可能发送）
                            if (msg.sender === 'sent') {
                            content = `[用户发来一条语音消息，内容是：'${msg.content}']`;
                            } else {
                                content = `[AI发来一条语音消息，内容是：'${msg.content}']`;
                            }
                        } else if (msg.type === 'transfer') {
                            // 🔥【修复】处理转账消息（用户和AI都可能发送）
                            if (msg.sender === 'sent') {
                    content = `[用户发起了转账：${msg.amount}元，备注：${msg.note || '无'}]`;
                            } else {
                                content = `[AI发起了转账：${msg.amount}元，备注：${msg.note || '无'}]`;
                            }
                        } else if (msg.type === 'payment_request') {
                            // 🛒【新增】处理代付请求消息 - 让AI能看到订单详情
                            if (msg.sender === 'sent') {
                                const orderDetails = msg.orderDetails || {};
                                const items = orderDetails.items || [];
                                const itemsText = items.map(item => {
                                    let itemText = `${item.name} x${item.quantity} (¥${item.price})`;
                                    // 🔥【修复】添加选项信息给AI
                                    if (item.selectedOptions && Object.keys(item.selectedOptions).length > 0) {
                                        const optionsText = Object.entries(item.selectedOptions).map(([key, value]) =>
                                            `${getOptionLabel(key)}: ${value}`
                                        ).join(', ');
                                        itemText += ` [${optionsText}]`;
                                    }
                                    return itemText;
                                }).join('、');
                                const statusText = msg.paymentStatus === 'paid' ? '（已支付）' :
                                                 msg.paymentStatus === 'rejected' ? '（已拒绝）' : '（待处理）';
                                content = `[用户发起了代付请求${statusText}：总金额¥${orderDetails.total || 0}，订单包含：${itemsText || '无商品信息'}]`;
                            } else {
                                content = `[AI尝试发起代付请求，已忽略]`;
                            }
                        } else if (msg.type === 'shared_post') {
                            // 【修复】处理分享的论坛帖子 - 使用完整内容包含评论
                            const sender = msg.sender === 'sent' ? '用户' : 'AI';
                            // 使用完整的content字段，包含帖子正文和所有评论
                            content = `[${sender} 分享了一个论坛帖子]\n${msg.content}`;
                        } else if (msg.type === 'forwarded_message') {
                            // 🔥【关键修复】处理转发消息 - 让AI能在历史记录中看到转发的具体内容
                            const sender = msg.sender === 'sent' ? '用户' : 'AI';
                            let forwardedContent = `[${sender} 转发了聊天记录：${msg.content}]`;

                            // 如果有转发的消息内容，展示具体内容
                            if (msg.forwardedMessages && msg.forwardedMessages.length > 0) {
                                forwardedContent += '\n转发的聊天内容：\n';
                                msg.forwardedMessages.forEach((fMsg, index) => {
                                    let senderName;
                                    if (fMsg.sender === 'sent') {
                                        senderName = fMsg.userName || '用户';
                                    } else {
                                        senderName = fMsg.name || fMsg.characterName || 'AI';
                                    }
                                    // 🔥【修复】使用safeExtractMessageContent安全地提取消息内容，避免[object Object]问题
                                    const fMsgContent = safeExtractMessageContent(fMsg);
                                    forwardedContent += `${senderName}: ${fMsgContent}\n`;
                                });
                            }
                            content = forwardedContent;
                        } else if (msg.type === 'order_confirmation') {
                            // 🛒【关键修复】处理订单确认消息 - 让AI能看到订单详情
                            if (msg.sender === 'sent') {
                                const orderDetails = msg.orderDetails || {};
                                const items = orderDetails.items || [];
                                const itemsText = items.map(item => {
                                    let itemText = `${item.name} x${item.quantity} (¥${item.price})`;
                                    // 添加选项信息给AI
                                    if (item.selectedOptions && Object.keys(item.selectedOptions).length > 0) {
                                        const optionsText = Object.entries(item.selectedOptions).map(([key, value]) =>
                                            `${getOptionLabel(key)}: ${value}`
                                        ).join(', ');
                                        itemText += ` [${optionsText}]`;
                                    }
                                    return itemText;
                                }).join('、');

                                const orderTypeText = msg.orderType === 'self_pay_self' ? '自己付款' :
                                                    msg.orderType === 'self_pay_ta' ? '为对方下单' :
                                                    msg.orderType === 'request_pay_self' ? '请对方代付' :
                                                    msg.orderType === 'request_pay_ta' ? '请对方代付为对方下单' : '下单';

                                content = `[用户${orderTypeText}成功：总金额¥${orderDetails.total || 0}，订单包含：${itemsText || '无商品信息'}]`;
                            } else {
                                content = `[AI下单成功]`;
                            }
                        } else if (msg.type === 'ai_image') {
                            // 🔥【修复】处理AI发送的图片
                            content = `[AI发送了一张图片，描述：${msg.imageDescription || '无描述'}]`;
                        } else if (msg.isEmoji && msg.image) {
                            // 🔥【优化】处理表情包消息 - 简化历史记录，避免重复评价
                            if (msg.sender === 'sent') {
                                // 检查是否是重复的表情包
                                const isDuplicate = recentHistory.slice(0, recentHistory.indexOf(msg))
                                    .some(prevMsg => prevMsg.isEmoji && prevMsg.emojiDescription === msg.emojiDescription);

                                if (isDuplicate) {
                                    content = `[用户发送了表情包]`; // 不包含具体描述，避免重复
                                } else {
                                    content = `[用户发送了表情包：${msg.emojiDescription || '表情包'}]`;
                                }
                            } else {
                                content = `[AI回复了表情包：${msg.emojiDescription || '表情包'}]`;
                            }
                } else if (Array.isArray(msg.content)) {
                    const textPart = msg.content.find(p => p.type === 'text')?.text || '';
                    // 🔥【优化】保留图片上下文但简化描述
                    if (textPart.trim()) {
                        content = `[用户发送了一张图片，并说：'${textPart}']`;
                    } else {
                        content = `[用户发送了一张图片]`;
                    }
                        } else if (msg.image && !msg.isEmoji) {
                                content = `[用户发送了一张图片]`;
                        } else if (typeof msg.content === 'object' && msg.content !== null) {
                            // 🔥【关键修复】处理未被处理的对象类型消息
                            console.warn('历史消息中发现未处理的对象类型:', msg);
                            content = '[特殊消息类型]';
                        } else if (!content || content === '') {
                            // 🔥【修复】处理空内容
                            content = '[空消息]';
                }

                // 🔥【安全检查】确保content是字符串
                if (typeof content !== 'string') {
                    console.warn('发现非字符串content，强制转换:', content);
                    content = String(content);
                }

                // 🔥【新增】为AI提供消息ID信息，方便引用
                if (msg.id) {
                    content = `[ID:${msg.id}] ${content}`;
                }

                    messages.push({ role, content });
                });
            }

            // 只有真正的跨应用事件才集成到工作记忆中
            if (crossAppEvents.length > 0) {
                const realCrossAppEvents = crossAppEvents.filter(event =>
                    event.appType !== 'chat' // 排除聊天事件
                );

                if (realCrossAppEvents.length > 0) {
                    let crossAppContext = '\n\n【跨应用活动记录】以下是最近的跨应用活动：\n';
                    realCrossAppEvents.forEach(event => {
                        const timeStr = new Date(event.timestamp).toLocaleTimeString('zh-CN', {hour: '2-digit', minute: '2-digit'});
                        let description = '';

                        switch (event.appType) {
                            case 'music':
                                if (event.content.action === 'listen_together') {
                                    description = `一起听歌：${event.content.songTitle}`;
                                } else if (event.content.action === 'song_comment') {
                                    description = `对歌曲《${event.content.songTitle}》评论：${event.content.comment}`;
                                }
                                break;
                            case 'game':
                                if (event.content && event.content.action === 'game_start') {
                                    description = `开始游戏：${event.content.gameName || '未知游戏'}`;
                                } else if (event.content && event.content.action === 'game_end') {
                                    description = `游戏结束：${event.content.gameName || '未知游戏'} (得分: ${event.content.score || 0})`;
                                } else if (event.content && event.content.action === 'game_chat') {
                                    const content = event.content.content || '';
                                    description = `游戏中${event.content.sender === 'user' ? '用户说' : 'AI回复'}：${content.substring(0, 25)}${content.length > 25 ? '...' : ''}`;
                                } else {
                                    // 🔥【修复】处理action为undefined或其他未知情况
                                    description = `游戏应用活动`;
                                }
                                break;
                            default:
                                description = `${event.appType}应用活动`;
                        }

                        crossAppContext += `[${timeStr}] ${description}\n`;
                    });

                    // 将跨应用上下文添加到系统提示中
                    characterPrompt += crossAppContext;
                    messages[0].content = characterPrompt;
                    console.log(`🔗 已将${realCrossAppEvents.length}条真正的跨应用事件集成到工作记忆中`);
                } else {
                    console.log(`⚠️ 没有真正的跨应用事件，所有${crossAppEvents.length}条都是聊天事件`);
                }
            }

            // 🔥【优化】如果最近讨论过图片或表情包，给AI一个强制性提示
            if (recentImageEmojis.length > 0) {
                const uniqueEmojis = [...new Set(recentImageEmojis)];
                let contextHint = `\n\n[重要提示：最近对话中包含了${uniqueEmojis.slice(-3).join('、')}等内容。`;

                // 如果有表情包评价历史，添加强制性指令
                if (emojiEvaluationHistory.size > 0) {
                    const evaluatedEmojis = Array.from(emojiEvaluationHistory.keys());
                    contextHint += `你已经评价过以下表情包：${evaluatedEmojis.join('、')}。严禁再次评价这些表情包的外观、内容或特征。`;
                }

                contextHint += `请专注于对话内容本身，不要重复评价已经评论过的表情包]`;
                characterPrompt += contextHint;
                messages[0].content = characterPrompt; // 更新系统提示
            }

            // 处理当前要发送的消息 (最关键的改动)
            // 如果 message 是数组，直接使用；如果是字符串，包装成数组
            let currentUserContent = Array.isArray(message) ? message : [{ type: 'text', text: message }];

            // 🔥【新增】检查当前消息是否是重复的表情包
            if (pendingUserMessage && pendingUserMessage.isEmoji && pendingUserMessage.emojiDescription) {
                const currentEmojiDesc = pendingUserMessage.emojiDescription;
                const hasEvaluatedBefore = emojiEvaluationHistory.has(currentEmojiDesc);

                if (hasEvaluatedBefore) {
                    // 如果之前评价过这个表情包，修改当前消息内容
                    currentUserContent = [{ type: 'text', text: `[用户发送了表情包，请直接回应对话内容，不要评价表情包本身]` }];
                } else {
                    // 第一次看到这个表情包，正常处理
                    currentUserContent = [{ type: 'text', text: `[用户发送了表情包：${currentEmojiDesc}]` }];
                }
            }

            messages.push({ role: 'user', content: currentUserContent });

            const isGemini = apiSettings.base.includes('generativelanguage.googleapis.com');
            let requestBody;
            let url;
            let headers;

            if (isGemini) {
                // Gemini API 格式
                url = `${apiSettings.base}/models/${apiSettings.model}:generateContent?key=${apiSettings.key}`;
                headers = { 'Content-Type': 'application/json' };

                // 转换消息为 Gemini 格式
                const geminiContents = messages.map(msg => {
                    const role = msg.role === 'assistant' ? 'model' : 'user';
                    const parts = [];

                    if (Array.isArray(msg.content)) {
                        console.log('🔍 [Gemini API] 处理多模态消息:', msg.content);
                        msg.content.forEach(item => {
                            if (item.type === 'text' && item.text) {
                                console.log('🔍 [Gemini API] 添加文本部分:', item.text.substring(0, 50) + '...');
                                parts.push({ text: item.text });
                            } else if (item.type === 'image_url' && item.image_url && item.image_url.url && item.image_url.url.startsWith('data:image')) {
                                console.log('🔍 [Gemini API] 检测到图片，开始处理...');
                                const mimeMatch = item.image_url.url.match(/data:image\/([^;]+);base64,(.+)/);
                                if (mimeMatch && mimeMatch[2] && mimeMatch[2].length > 0) {
                                    console.log('🔍 [Gemini API] 图片格式:', mimeMatch[1], '数据长度:', mimeMatch[2].length);
                                    parts.push({
                                        inline_data: { mime_type: `image/${mimeMatch[1]}`, data: mimeMatch[2] }
                        });
                                } else {
                                    console.log('❌ [Gemini API] 图片格式解析失败');
                                }
                            } else {
                                console.log('🔍 [Gemini API] 跳过项目:', item.type);
                            }
                        });
                    } else if (msg.content) {
                        parts.push({ text: msg.content });
                    }

                    // 确保每个消息至少有一个part
                    if (parts.length === 0) {
                        parts.push({ text: '' });
                    }
                    return { role, parts };
                });

                requestBody = {
                    contents: geminiContents,
                    generationConfig: {
                        temperature: apiSettings.temperature
                        // 移除maxOutputTokens，gemini不支持这个参数名
                    }
                };

            } else {
                // OpenAI 兼容格式 - 智能处理URL拼接
                // 修复：确保不会重复添加/v1路径
                if (apiSettings.base.endsWith('/v1')) {
                    url = `${apiSettings.base}/chat/completions`;
                } else if (apiSettings.base.includes('/v1/')) {
                    // 如果URL中已经包含/v1/路径，直接添加chat/completions
                    url = `${apiSettings.base}/chat/completions`;
                } else {
                    url = `${apiSettings.base}/v1/chat/completions`;
                }
                headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiSettings.key}`
                };
                requestBody = {
                    model: apiSettings.model,
                    messages: messages,
                    temperature: apiSettings.temperature
                };
        }

            const response = await fetch(url, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                    const errorData = await response.json();
                throw new Error(`API Error: ${response.status} - ${errorData.error?.message || '未知错误'}`);
            }

            const data = await response.json();
            return isGemini ? data.candidates?.[0]?.content?.parts?.[0]?.text : data.choices?.[0]?.message?.content;
        }

        // 【恢复】专门为论坛功能设计的API调用函数 (仅处理文本)
        async function callForumAPI(prompt) {
            console.log('🔥 [callForumAPI - Text Only] 函数被调用');

            if (!apiSettings.key) {
                console.error('🔥 [callForumAPI] API密钥未设置');
                throw new Error('请先在设置中填写API密钥');
            }

            const isGemini = apiSettings.base.includes('generativelanguage.googleapis.com');
            let requestBody;
            let url;
            let headers = { 'Content-Type': 'application/json' };

            if (isGemini) {
                url = `${apiSettings.base}/models/${apiSettings.model}:generateContent?key=${apiSettings.key}`;
                const geminiContents = [
                    {
                        role: 'user',
                        parts: [{ text: prompt }]
                    },
                    {
                        role: 'model',
                        parts: [{ text: '我明白了，我会生成论坛帖子的JSON数组格式：[{"authorName":"用户名","title":"标题","content":"内容"}]，绝对不会输出聊天消息格式。' }]
                    },
                    {
                        role: 'user',
                        parts: [{ text: '请现在开始生成论坛帖子，只输出JSON数组，不要聊天消息格式，不要任何解释文字。' }]
                    }
                ];
                requestBody = {
                    contents: geminiContents,
                    generationConfig: {
                        temperature: 0.8
                    }
                };
            } else {
                url = apiSettings.base.endsWith('/v1') ? `${apiSettings.base}/chat/completions` : `${apiSettings.base}/v1/chat/completions`;
                headers['Authorization'] = `Bearer ${apiSettings.key}`;
                requestBody = {
                    model: apiSettings.model,
                    messages: [
                        { role: "system", content: "你是一个论坛内容生成AI。重要：你必须严格输出JSON数组格式，不要输出聊天消息格式。论坛帖子格式：[{\"authorName\":\"用户名\",\"title\":\"标题\",\"content\":\"内容\"}]，绝对不要输出聊天格式：[\"消息1\",\"消息2\"]" },
                        { role: "user", content: prompt }
                    ],
                    temperature: 0.8,
                    max_tokens: 4096
                };
            }

            const response = await fetch(url, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error('🔥 [callForumAPI] API请求失败:', response.status, errorText);
                throw new Error(`API请求失败: ${response.status} - ${errorText}`);
            }

            const data = await response.json();
            let result;
            if (isGemini) {
                result = data.candidates?.[0]?.content?.parts?.[0]?.text || '[]';
            } else {
                result = data.choices?.[0]?.message?.content || '[]';
            }

            return result;
        }

        // 【新增】为论坛功能设计的API调用函数 (支持图片)
        async function callForumAPIWithImage(prompt, imageUrl) {
            console.log('🔥 [callForumAPIWithImage] 函数被调用', { imageUrl: !!imageUrl });

            if (!apiSettings.key) {
                throw new Error('请先在API设置中填写密钥');
            }
            if (!imageUrl) {
                // 如果没有图片，转而调用纯文本API
                return callForumAPI(prompt);
            }
            if (!isVisionModelSupported()) {
                throw new Error('当前模型不支持图片识别。请在API设置中选择支持视觉的模型，如 gpt-4o, gemini-1.5-pro 等。');
            }

            const isGemini = apiSettings.base.includes('generativelanguage.googleapis.com');
            let requestBody;
            let url;
            let headers = { 'Content-Type': 'application/json' };
            const systemPrompt = "你是一个论坛内容生成AI，请严格按照用户的指令和格式要求进行输出。";

            if (isGemini) {
                url = `${apiSettings.base}/models/${apiSettings.model}:generateContent?key=${apiSettings.key}`;

                const mimeMatch = imageUrl.match(/data:image\/([^;]+);base64,(.+)/);
                if (!mimeMatch) throw new Error('无效的图片数据格式');

                const geminiContents = [
                    {
                        role: 'user',
                        parts: [
                            { text: systemPrompt },
                            { text: prompt },
                            {
                                inline_data: {
                                    mime_type: `image/${mimeMatch[1]}`,
                                    data: mimeMatch[2]
                                }
                            }
                        ]
                    },
                    {
                        role: 'model',
                        parts: [{ text: '我明白了，我会按照指令生成包含图片理解的论坛回复。' }]
                    }
                ];

                requestBody = {
                    contents: geminiContents,
                    generationConfig: { temperature: 0.8 }
                };

            } else { // OpenAI 兼容格式
                url = apiSettings.base.endsWith('/v1') ? `${apiSettings.base}/chat/completions` : `${apiSettings.base}/v1/chat/completions`;
                headers['Authorization'] = `Bearer ${apiSettings.key}`;

                requestBody = {
                    model: apiSettings.model,
                    messages: [
                        { role: "system", content: systemPrompt },
                        {
                            role: "user",
                            content: [
                                { type: "text", text: prompt },
                                { type: "image_url", image_url: { url: imageUrl } }
                            ]
                        }
                    ],
                    temperature: 0.8,
                    max_tokens: 4096
                };
            }

            const response = await fetch(url, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`API请求失败: ${response.status} - ${errorText}`);
            }

            const data = await response.json();
            const result = isGemini
                ? data.candidates?.[0]?.content?.parts?.[0]?.text
                : data.choices?.[0]?.message?.content;

            return result || '[]';
        }

        // 🔥【手动清理所有损坏消息】立即清理所有聊天记录中的[object Object]
        async function emergencyCleanupAllMessages() {
            console.log('🔥 [紧急清理] 开始清理所有聊天记录中的损坏消息...');
            let totalCleaned = 0;

            for (const characterId in chatMessages) {
                if (chatMessages[characterId] && Array.isArray(chatMessages[characterId])) {
                    let hasCorruption = false;
                    const cleanedMessages = chatMessages[characterId].map(msg => {
                        if (msg.content === '[object Object]' ||
                            (typeof msg.content === 'object' && msg.content !== null && !Array.isArray(msg.content))) {
                            console.log('🔥 [紧急清理] 发现损坏消息:', msg);
                            hasCorruption = true;
                            totalCleaned++;

                            // 根据消息类型修复
                            if (msg.type === 'transfer') {
                                return {
                                    ...msg,
                                    content: `💰 转账 ¥${msg.amount || 0}${msg.note ? ` - ${msg.note}` : ''}`
                                };
                            } else {
                                return {
                                    ...msg,
                                    content: '[已修复的特殊消息]'
                                };
                            }
                        }
                        return msg;
                    });

                    if (hasCorruption) {
                        chatMessages[characterId] = cleanedMessages;
                        console.log(`🔥 [紧急清理] 清理了角色 ${characterId} 的损坏消息`);
                    }
                }
            }

            if (totalCleaned > 0) {
                // 🔥【优化】数据清理使用高效保存
                try {
                    const cleanedCharacterIds = Object.keys(chatMessages).filter(id =>
                        chatMessages[id] && chatMessages[id].length > 0);
                    await saveChatMessagesImmediate(cleanedCharacterIds);
                    console.log('✅ [高效数据清理] 消息已保存到数据库');
                } catch (error) {
                    console.error('数据清理保存失败，回退到全量保存:', error);
                    await saveChatMessages();
                }
                console.log(`🔥 [紧急清理] 总共清理了 ${totalCleaned} 条损坏消息`);

                // 重新渲染当前聊天
                if (currentChatCharacter) {
                    renderChatMessages(currentChatCharacter.id);
                }

                alert(`✅ 已清理 ${totalCleaned} 条损坏的消息！\n\n现在AI应该能正常显示转账等特殊消息了。`);
            } else {
                console.log('🔥 [紧急清理] 没有发现损坏的消息');
            }
        }

        // 🔥【新增】安全的数据库查询包装函数
        function safeCharacterId(characterId) {
            if (typeof characterId === 'string') {
                return characterId;
            } else if (typeof characterId === 'number') {
                return String(characterId);
            } else if (characterId && typeof characterId === 'object' && characterId.id) {
                return String(characterId.id);
            } else {
                console.error('❌ 无效的characterId类型:', typeof characterId, characterId);
                throw new Error(`Invalid characterId type: ${typeof characterId}`);
            }
        }

        // 🔥【新增】调试数据库中的数据类型
        async function debugDatabaseTypes() {
            try {
                console.log('🔍 检查数据库中的数据类型...');

                // 检查核心记忆表
                const coreMemories = await db.coreMemories.limit(5).toArray();
                console.log('📊 核心记忆样本:', coreMemories.map(m => ({
                    id: m.id,
                    characterId: m.characterId,
                    characterIdType: typeof m.characterId,
                    contextId: m.contextId,
                    contextIdType: typeof m.contextId
                })));

                // 检查时间线表
                const timeline = await db.crossAppTimeline.limit(5).toArray();
                console.log('📊 时间线样本:', timeline.map(t => ({
                    id: t.id,
                    characterId: t.characterId,
                    characterIdType: typeof t.characterId
                })));

                // 检查当前角色
                if (currentFootprintsCharacter) {
                    console.log('📊 当前足迹角色:', {
                        id: currentFootprintsCharacter.id,
                        idType: typeof currentFootprintsCharacter.id,
                        name: currentFootprintsCharacter.name
                    });
                }
            } catch (error) {
                console.error('❌ 调试数据库类型失败:', error);
            }
        }

        // 🔥【新增】安全提取消息内容的通用函数
        function safeExtractMessageContent(message) {
            if (typeof message.content === 'string') {
                return message.content;
            } else if (Array.isArray(message.content)) {
                // 处理多模态消息，提取文本部分
                const textPart = message.content.find(part => part.type === 'text');
                return textPart ? textPart.text : '[多媒体消息]';
            } else if (typeof message.content === 'object' && message.content !== null) {
                // 根据消息类型智能提取内容
                if (message.type === 'transfer') {
                    return `💰 转账 ¥${message.amount || 0}${message.note ? ` - ${message.note}` : ''}`;
                } else if (message.type === 'voice_message') {
                    return message.originalContent || '[语音消息]';
                } else if (message.type === 'user_photo') {
                    return message.photoDescription || '[图片消息]';
                } else if (message.type === 'location') {
                    return `📍 ${message.locationName || '位置信息'}`;
                } else {
                    // 尝试从对象中提取有用信息
                    return message.content.text ||
                           message.content.content ||
                           message.content.message ||
                           message.content.reply ||
                           '[特殊消息]';
                }
            } else {
                return String(message.content || '[消息内容]');
            }
        }

        // 🔥【新增】自动修复函数 - 在应用启动时静默运行
        async function autoFixCorruptedMessages() {
            console.log('🔧 [自动修复] 检查并修复损坏的消息...');
            let totalFixed = 0;

            for (const characterId in chatMessages) {
                if (chatMessages[characterId] && Array.isArray(chatMessages[characterId])) {
                    let hasCorruption = false;
                    const fixedMessages = chatMessages[characterId].map(msg => {
                        // 检查content字段是否损坏
                        if (msg.content === '[object Object]' ||
                            (typeof msg.content === 'object' && msg.content !== null && !Array.isArray(msg.content))) {

                            hasCorruption = true;
                            totalFixed++;

                            // 智能修复content字段
                            let fixedContent = '[消息内容已修复]';

                            if (msg.type === 'transfer') {
                                fixedContent = `💰 转账 ¥${msg.amount || 0}${msg.note ? ` - ${msg.note}` : ''}`;
                            } else if (msg.type === 'voice_message') {
                                fixedContent = msg.originalContent || '[语音消息]';
                            } else if (msg.type === 'user_photo') {
                                fixedContent = msg.photoDescription || '[图片消息]';
                            } else if (msg.type === 'location') {
                                fixedContent = `📍 ${msg.locationName || '位置信息'}`;
                            } else if (msg.type === 'recalled_message') {
                                // 🔥【新增】修复撤回消息中的[object Object]问题
                                const whoRecalled = msg.sender === 'system' ? '对方' : '你';
                                let originalText = '[消息内容]';
                                if (msg.originalContent && typeof msg.originalContent === 'string') {
                                    originalText = msg.originalContent;
                                } else if (typeof msg.content === 'object' && msg.content !== null) {
                                    // 尝试从损坏的content中提取信息
                                    originalText = msg.content.text ||
                                                 msg.content.content ||
                                                 msg.content.message ||
                                                 '[消息内容]';
                                }
                                fixedContent = `${whoRecalled}撤回了一条消息\n原文：${originalText}`;
                            } else if (typeof msg.content === 'object' && msg.content !== null) {
                                // 尝试从对象中提取有用信息
                                fixedContent = msg.content.text ||
                                             msg.content.content ||
                                             msg.content.message ||
                                             msg.content.reply ||
                                             '[消息内容已修复]';
                            }

                            return {
                                ...msg,
                                content: String(fixedContent), // 确保是字符串
                                autoFixed: true, // 标记为自动修复
                                fixedAt: Date.now()
                            };
                        }
                        return msg;
                    });

                    if (hasCorruption) {
                        chatMessages[characterId] = fixedMessages;
                        console.log(`🔧 [自动修复] 角色 ${characterId} 的 ${fixedMessages.filter(m => m.autoFixed).length} 条消息已修复`);
                    }
                }
            }

            if (totalFixed > 0) {
                console.log(`🔧 [自动修复] 总共修复了 ${totalFixed} 条损坏消息`);
                await saveChatMessages();
                return totalFixed;
            }

            return 0;
        }

        // 🔥【新增】数据完整性诊断工具
        async function diagnoseDataIntegrity() {
            console.log('🔍 ===== 开始数据完整性诊断 =====');

            const report = {
                memoryIssues: [],
                characterIssues: [],
                messageIssues: [],
                crossReferences: []
            };

            try {
                // 1. 检查聊天消息的角色归属
                console.log('🔍 检查聊天消息归属...');
                for (const [characterId, messages] of Object.entries(chatMessages)) {
                    if (!messages || !Array.isArray(messages)) continue;

                    // 检查是否有消息包含其他角色的信息
                    messages.forEach((msg, index) => {
                        if (msg.content && typeof msg.content === 'string') {
                            // 检查消息内容是否提到其他角色
                            characters.forEach(char => {
                                if (char.id !== characterId && msg.content.includes(char.name)) {
                                    report.crossReferences.push({
                                        type: 'message_mentions_other_character',
                                        characterId: characterId,
                                        messageIndex: index,
                                        mentionedCharacter: char.name,
                                        content: msg.content.substring(0, 100) + '...'
                                    });
                                }
                            });
                        }

                        // 检查消息的发送者信息
                        if (msg.name && msg.name !== characterId) {
                            const character = characters.find(c => c.id === characterId);
                            if (character && msg.name !== character.name) {
                                report.messageIssues.push({
                                    type: 'name_mismatch',
                                    characterId: characterId,
                                    messageIndex: index,
                                    expectedName: character.name,
                                    actualName: msg.name
                                });
                            }
                        }
                    });
                }

                // 2. 检查核心记忆的归属
                console.log('🔍 检查核心记忆归属...');
                const allMemories = await db.coreMemories.toArray();
                const memoryByCharacter = {};

                allMemories.forEach(memory => {
                    if (!memoryByCharacter[memory.characterId]) {
                        memoryByCharacter[memory.characterId] = [];
                    }
                    memoryByCharacter[memory.characterId].push(memory);
                });

                // 检查记忆内容是否提到其他角色
                for (const [characterId, memories] of Object.entries(memoryByCharacter)) {
                    memories.forEach(memory => {
                        characters.forEach(char => {
                            if (char.id !== characterId &&
                                (memory.content.includes(char.name) || memory.summary?.includes(char.name))) {
                                report.memoryIssues.push({
                                    type: 'memory_mentions_other_character',
                                    characterId: characterId,
                                    memoryId: memory.id,
                                    mentionedCharacter: char.name,
                                    content: memory.content.substring(0, 100) + '...'
                                });
                            }
                        });
                    });
                }

                // 3. 检查数据库中的消息归属
                console.log('🔍 检查数据库消息归属...');
                const dbMessages = await db.chatMessages.toArray();
                const dbMessagesByCharacter = {};

                dbMessages.forEach(dbMsg => {
                    if (!dbMessagesByCharacter[dbMsg.characterId]) {
                        dbMessagesByCharacter[dbMsg.characterId] = [];
                    }
                    dbMessagesByCharacter[dbMsg.characterId].push(dbMsg);
                });

                // 检查数据库与内存的一致性
                for (const [characterId, dbMsgs] of Object.entries(dbMessagesByCharacter)) {
                    const memoryMsgs = chatMessages[characterId] || [];
                    if (dbMsgs.length !== memoryMsgs.length) {
                        report.messageIssues.push({
                            type: 'db_memory_count_mismatch',
                            characterId: characterId,
                            dbCount: dbMsgs.length,
                            memoryCount: memoryMsgs.length
                        });
                    }
                }

                // 4. 生成诊断报告
                console.log('🔍 ===== 诊断报告 =====');
                console.log('跨角色引用:', report.crossReferences.length, '个');
                console.log('记忆问题:', report.memoryIssues.length, '个');
                console.log('消息问题:', report.messageIssues.length, '个');
                console.log('角色问题:', report.characterIssues.length, '个');

                if (report.crossReferences.length > 0) {
                    console.log('\n🚨 发现跨角色引用问题:');
                    report.crossReferences.forEach((issue, index) => {
                        console.log(`${index + 1}. 角色 ${issue.characterId} 的消息提到了 ${issue.mentionedCharacter}`);
                        console.log(`   内容: ${issue.content}`);
                    });
                }

                if (report.memoryIssues.length > 0) {
                    console.log('\n🚨 发现记忆归属问题:');
                    report.memoryIssues.forEach((issue, index) => {
                        console.log(`${index + 1}. 角色 ${issue.characterId} 的记忆提到了 ${issue.mentionedCharacter}`);
                        console.log(`   内容: ${issue.content}`);
                    });
                }

                if (report.messageIssues.length > 0) {
                    console.log('\n🚨 发现消息问题:');
                    report.messageIssues.forEach((issue, index) => {
                        console.log(`${index + 1}. ${issue.type}: 角色 ${issue.characterId}`);
                        if (issue.expectedName) {
                            console.log(`   期望名字: ${issue.expectedName}, 实际名字: ${issue.actualName}`);
                        }
                        if (issue.dbCount !== undefined) {
                            console.log(`   数据库消息数: ${issue.dbCount}, 内存消息数: ${issue.memoryCount}`);
                        }
                    });
                }

                return report;

            } catch (error) {
                console.error('数据完整性诊断失败:', error);
                return null;
            }
        }

        // 🔥【新增】运行数据完整性诊断的用户界面函数
        async function runDataIntegrityDiagnosis() {
            showToast('正在进行数据完整性诊断...', 'info');

            try {
                const report = await diagnoseDataIntegrity();

                if (!report) {
                    showToast('诊断失败，请查看控制台', 'error');
                    return;
                }

                // 生成诊断结果摘要
                const totalIssues = report.crossReferences.length +
                                  report.memoryIssues.length +
                                  report.messageIssues.length +
                                  report.characterIssues.length;

                let summaryText = `🔍 数据完整性诊断完成\n\n`;
                summaryText += `总计发现 ${totalIssues} 个潜在问题：\n`;
                summaryText += `• 跨角色引用: ${report.crossReferences.length} 个\n`;
                summaryText += `• 记忆归属问题: ${report.memoryIssues.length} 个\n`;
                summaryText += `• 消息数据问题: ${report.messageIssues.length} 个\n`;
                summaryText += `• 角色数据问题: ${report.characterIssues.length} 个\n\n`;

                if (totalIssues === 0) {
                    summaryText += `✅ 恭喜！没有发现数据完整性问题。\n角色记忆隔离正常，数据存储完整。`;
                    showToast('数据完整性检查通过！', 'success');
                } else {
                    summaryText += `⚠️ 发现了一些问题，详细信息请查看控制台。\n\n`;

                    if (report.crossReferences.length > 0) {
                        summaryText += `🚨 跨角色引用问题可能导致角色记忆错乱。\n`;
                    }

                    if (report.memoryIssues.length > 0) {
                        summaryText += `🚨 记忆归属问题可能导致角色知道不该知道的信息。\n`;
                    }

                    summaryText += `\n建议：\n`;
                    summaryText += `1. 查看控制台获取详细信息\n`;
                    summaryText += `2. 考虑清理相关角色的聊天记录\n`;
                    summaryText += `3. 如问题严重，可尝试数据重建功能`;

                    showToast('发现数据完整性问题，请查看详情', 'warning');
                }

                // 显示诊断结果
                alert(summaryText);

                // 在控制台输出详细报告
                console.log('🔍 ===== 详细诊断报告 =====');
                console.log('完整报告对象:', report);

            } catch (error) {
                console.error('数据完整性诊断出错:', error);
                showToast('诊断过程中出现错误', 'error');
            }
        }

        // 🔥【新增】修复数据库与内存不一致的问题
        async function fixDataSyncIssues() {
            console.log('🔧 开始修复数据同步问题...');
            showToast('正在修复数据同步问题...', 'info');

            try {
                let totalFixed = 0;
                const fixedCharacters = [];

                // 1. 重新从数据库加载所有消息
                console.log('🔧 重新从数据库加载消息...');
                const dbMessages = await db.chatMessages.toArray();
                const newChatMessages = {};

                // 按角色重新组织消息
                for (const dbMsg of dbMessages) {
                    const characterId = dbMsg.characterId;
                    if (!newChatMessages[characterId]) {
                        newChatMessages[characterId] = [];
                    }

                    if (dbMsg.messageData && typeof dbMsg.messageData === 'object') {
                        newChatMessages[characterId].push(dbMsg.messageData);
                    }
                }

                // 2. 对每个角色的消息进行排序和去重
                for (const [characterId, messages] of Object.entries(newChatMessages)) {
                    // 按时间戳排序
                    messages.sort((a, b) => a.timestamp - b.timestamp);

                    // 去重（基于ID和时间戳）
                    const uniqueMessages = [];
                    const seenIds = new Set();
                    const seenContentTime = new Set();

                    for (const msg of messages) {
                        const contentTimeKey = `${msg.content}_${msg.timestamp}`;

                        if (msg.id && seenIds.has(msg.id)) {
                            console.log(`🔧 跳过重复消息ID: ${msg.id}`);
                            continue;
                        }

                        if (seenContentTime.has(contentTimeKey)) {
                            console.log(`🔧 跳过重复内容: ${contentTimeKey.substring(0, 50)}...`);
                            continue;
                        }

                        if (msg.id) seenIds.add(msg.id);
                        seenContentTime.add(contentTimeKey);
                        uniqueMessages.push(msg);
                    }

                    newChatMessages[characterId] = uniqueMessages;
                }

                // 3. 比较并修复不一致的数据
                for (const [characterId, dbMessages] of Object.entries(newChatMessages)) {
                    const memoryMessages = chatMessages[characterId] || [];

                    if (dbMessages.length !== memoryMessages.length) {
                        console.log(`🔧 修复角色 ${characterId}: 数据库${dbMessages.length}条 -> 内存${memoryMessages.length}条`);

                        // 使用数据库中的数据作为权威数据源
                        chatMessages[characterId] = dbMessages;
                        fixedCharacters.push(characterId);
                        totalFixed += Math.abs(dbMessages.length - memoryMessages.length);
                    }
                }

                // 4. 清理数据库中的重复记录
                console.log('🔧 清理数据库重复记录...');
                await db.transaction('rw', db.chatMessages, async () => {
                    // 清空数据库
                    await db.chatMessages.clear();

                    // 重新插入去重后的数据
                    const newDbMessages = [];
                    for (const [characterId, messages] of Object.entries(chatMessages)) {
                        messages.forEach((message, index) => {
                            // 🔥【修复】使用更安全的ID生成策略，避免潜在的重复键问题
                            const stableId = `${characterId}_cleanup_${message.timestamp || Date.now()}_${index}_${Math.random().toString(36).substr(2, 6)}`;
                            newDbMessages.push({
                                id: stableId,
                                characterId: characterId,
                                timestamp: message.timestamp,
                                messageOrder: index,
                                originalMessageId: message.id,
                                messageData: message
                            });
                        });
                    }

                    if (newDbMessages.length > 0) {
                        await db.chatMessages.bulkAdd(newDbMessages);
                    }
                });

                // 5. 重新渲染当前聊天界面
                if (currentChatCharacter && fixedCharacters.includes(currentChatCharacter.id)) {
                    console.log('🔧 重新渲染当前聊天界面...');
                    renderChatMessages(currentChatCharacter.id);
                }

                // 6. 显示修复结果
                const resultMessage = totalFixed > 0
                    ? `✅ 数据同步修复完成！\n\n修复了 ${fixedCharacters.length} 个角色的数据不一致问题，\n共处理 ${totalFixed} 条消息差异。\n\n角色记忆现在应该更加准确了。`
                    : `✅ 数据同步检查完成！\n\n所有角色的数据库与内存数据已保持一致，\n没有发现需要修复的问题。`;

                console.log(`🔧 修复完成: ${fixedCharacters.length} 个角色, ${totalFixed} 条差异`);
                showToast('数据同步修复完成', 'success');
                alert(resultMessage);

                return {
                    fixedCharacters: fixedCharacters.length,
                    totalFixed: totalFixed
                };

            } catch (error) {
                console.error('数据同步修复失败:', error);
                showToast('数据同步修复失败，请查看控制台', 'error');
                throw error;
            }
        }

        // 🔥【数据清理函数】清理聊天记录中损坏的消息
        async function cleanupCorruptedMessages(characterId) {
            if (!chatMessages[characterId]) return;

            let hasCorruption = false;
            const cleanedMessages = chatMessages[characterId].map(msg => {
                // 🔥【修复】检查并修复content字段 - 保护多模态消息数组
                if (typeof msg.content === 'object' && msg.content !== null && !Array.isArray(msg.content)) {
                    console.log('发现损坏的消息content，正在修复:', msg);
                    hasCorruption = true;

                    // 根据消息类型修复content
                    if (msg.type === 'transfer') {
                        return {
                            ...msg,
                            content: `转账 ¥${msg.amount || 0}${msg.note ? ` - ${msg.note}` : ''}`
                        };
                    } else if (msg.type === 'voice_message') {
                        return {
                            ...msg,
                            content: msg.content.content || '[语音消息]'
                        };
                    } else if (msg.type === 'ai_image') {
                        return {
                            ...msg,
                            content: `[AI图片]${msg.imageDescription ? ` - ${msg.imageDescription}` : ''}`
                        };
                    } else if (msg.isEmoji) {
                        return {
                            ...msg,
                            content: `[表情包]${msg.emojiDescription ? ` - ${msg.emojiDescription}` : ''}`
                        };
                    } else {
                        // 通用修复：提取可能的文本内容
                        const possibleContent = msg.content.content || msg.content.message || msg.content.text || '[特殊消息]';
                        return {
                            ...msg,
                            content: possibleContent
                        };
                    }
                }

                // 🔥【关键修复】检查content是否为字符串或多模态数组 - 不要破坏多模态消息！
                if (msg.content && typeof msg.content !== 'string' && !Array.isArray(msg.content)) {
                    console.log('发现非字符串/非数组content，正在修复:', msg);
                    hasCorruption = true;
                    return {
                        ...msg,
                        content: String(msg.content)
                    };
                }

                // 🔥【新增】验证多模态消息数组的完整性
                if (Array.isArray(msg.content)) {
                    console.log('🔍 [多模态验证] 检测到多模态消息:', msg.content);
                    // 验证数组中的每个元素是否有效
                    const validContent = msg.content.filter(item => {
                        if (!item || typeof item !== 'object') return false;
                        if (item.type === 'text' && typeof item.text === 'string') return true;
                        if (item.type === 'image_url' && item.image_url && item.image_url.url) return true;
                        return false;
                    });

                    if (validContent.length !== msg.content.length) {
                        console.log('🔍 [多模态修复] 过滤无效元素:', msg.content.length, '->', validContent.length);
                        hasCorruption = true;
                        return {
                            ...msg,
                            content: validContent
                        };
                    }
                }

                return msg;
            });

            // 如果发现损坏的数据，保存修复后的数据
            if (hasCorruption) {
                console.log('检测到损坏的消息数据，已自动修复并保存');
                chatMessages[characterId] = cleanedMessages;
                // 🔥【优化】消息修复使用高效保存
                try {
                    await saveChatMessagesImmediate([characterId]);
                    console.log('✅ [高效消息修复] 消息已保存到数据库');
                } catch (error) {
                    console.error('消息修复保存失败，回退到全量保存:', error);
                    await saveChatMessages();
                }

                // 重新渲染聊天界面
                if (currentChatCharacter && currentChatCharacter.id === characterId) {
                    renderChatMessages(characterId);
                }
            }
        }

        // ================== 消息转发功能 ==================

        // 1. 显示转发目标选择模态框
        function showForwardTargetModal() {
            if (selectedMessages.size === 0) {
                showToast('请先选择要转发的消息', 'warning');
                return;
            }

            const listContainer = document.getElementById('forward-target-list');
            listContainer.innerHTML = '';

            // 合并单聊和群聊列表
            const allChats = [];

            // 添加单聊
            characters.forEach(character => {
                if (contacts.includes(character.id)) {
                    allChats.push({
                        id: character.id,
                        name: character.name,
                        avatarUrl: character.avatarUrl,
                        isGroup: false
                    });
                }
            });

            // 添加群聊
            groupChats.forEach(group => {
                allChats.push({
                    id: group.id,
                    name: group.name,
                    avatarUrl: group.avatarUrl,
                    isGroup: true
                });
            });

            if (allChats.length === 0) {
                listContainer.innerHTML = '<p class="empty-mount-chats">没有其他聊天可以转发</p>';
            } else {
                allChats.forEach(chat => {
                    const chatOption = document.createElement('div');
                    chatOption.className = 'chat-option-item';
                    chatOption.onclick = () => forwardMessagesTo(chat.id);

                    chatOption.innerHTML = `
                        <div class="chat-option-icon" style="background-color: ${chat.color || '#ddd'}; ${chat.avatarUrl ? `background-image: url(${chat.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                            ${!chat.avatarUrl ? (chat.isGroup ? '群' : chat.name.charAt(0)) : ''}
                        </div>
                        <div class="chat-option-text">
                            <div class="chat-option-title">${chat.name}</div>
                        </div>
                    `;
                    listContainer.appendChild(chatOption);
                });
            }

            showModal('forward-target-modal');
        }

        // 2. 执行转发操作
        async function forwardMessagesTo(targetChatId) {
            if (selectedMessages.size === 0) return;

            // 获取聊天设置和用户名
            const chatSettings = getCurrentChatSettings();
            const myName = chatSettings.myChatNickname || (personas.find(p => p.id === chatSettings.selectedIdentityId)?.name || '我');

            // 收集选中的消息，并保存原始的发送者信息
            const messagesToForward = [];
            const currentMessages = chatMessages[currentChatCharacter.id] || [];

            currentMessages.forEach(msg => {
                if (selectedMessages.has(msg.id)) {
                    // 创建消息副本并保存原始发送者信息
                    const msgCopy = { ...msg };
                    if (msg.sender === 'sent') {
                        msgCopy.userName = myName; // 保存用户名
                    } else {
                        msgCopy.characterName = currentChatCharacter.name; // 保存角色名
                    }
                    messagesToForward.push(msgCopy);
                }
            });

            // 按时间排序
            messagesToForward.sort((a, b) => a.timestamp - b.timestamp);

            // 获取源聊天信息
            const sourceChat = currentChatCharacter;

            let title = '';
            if (sourceChat.isGroup) {
                title = `${sourceChat.name}的群聊记录`;
            } else {
                title = `${myName}和${sourceChat.name}的聊天记录`;
            }

            // 创建转发消息卡片
            const forwardMessage = {
                id: Date.now().toString(),
                sender: 'sent', // 转发消息总是由用户发送
                type: 'forwarded_message',
                content: title,
                forwardedMessages: messagesToForward, // 存储所有被转发的消息
                timestamp: Date.now()
            };

            console.log('🔍 [转发消息创建] 转发消息对象:', forwardMessage);
            console.log('🔍 [转发消息创建] 转发的消息数量:', messagesToForward.length);
            console.log('🔍 [转发消息创建] 转发的消息内容:', messagesToForward);



            // 将转发消息添加到目标聊天
            if (!chatMessages[targetChatId]) {
                chatMessages[targetChatId] = [];
            }
            chatMessages[targetChatId].push(forwardMessage);
            // 🔥【高效保存】直接添加单条转发消息到数据库，避免全量重写
            try {
                const stableId = `${targetChatId}_${forwardMessage.id}_${chatMessages[targetChatId].length - 1}`;
                await db.chatMessages.add({
                    id: stableId,
                    characterId: targetChatId,
                    timestamp: forwardMessage.timestamp,
                    messageOrder: chatMessages[targetChatId].length - 1,
                    originalMessageId: forwardMessage.id,
                    messageData: forwardMessage
                });
                console.log('✅ [高效转发] 转发消息已保存到数据库');
            } catch (error) {
                console.error('转发消息单条保存失败，回退到批量保存:', error);
                await saveChatMessages(targetChatId);
            }

            hideModal('forward-target-modal');
            exitMessageSelectionMode(); // 退出多选模式
            renderMessageList(); // 刷新消息列表

            // 如果当前正打开目标聊天，则刷新并设置为待回复消息
            if (currentChatCharacter && currentChatCharacter.id === targetChatId) {
                renderChatMessages(targetChatId);

                // 🔥【关键修复】设置转发消息为待回复消息，让AI能看到转发内容
                pendingUserMessage = forwardMessage;
                console.log('🔍 [转发消息] 设置为待回复消息:', forwardMessage);

                // 更新智能回复按钮状态
                const smartReplyBtn = document.getElementById('smart-reply-btn');
                if (smartReplyBtn) {
                    smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                    smartReplyBtn.classList.add('waiting');
                }
            }

            showToast('消息已转发', 'success');
        }

        // 3. 在聊天窗口渲染转发消息卡片
        function renderForwardedMessage(message) {
            console.log('🔍 [renderForwardedMessage] 开始渲染转发消息:', message);

            const previewMessages = message.forwardedMessages.slice(0, 4);
            let previewHtml = '';

            // 获取转发消息的原始聊天设置和角色信息
            const forwardedMessages = message.forwardedMessages;
            console.log('🔍 [renderForwardedMessage] 转发消息数据:', forwardedMessages);

            if (forwardedMessages && forwardedMessages.length > 0) {
                console.log('🔍 [renderForwardedMessage] 转发消息数量:', forwardedMessages.length);
                // 从转发的消息中获取原始的发送者名字
                previewMessages.forEach((msg, index) => {
                    let senderName;
                    if (msg.sender === 'sent') {
                        // 用户发送的消息，使用消息中保存的用户名或默认名
                        senderName = msg.userName || '我';
                    } else {
                        // AI发送的消息，使用消息中保存的角色名
                        senderName = msg.name || msg.characterName || '角色';
                    }
                    // 🔥【修复】使用safeExtractMessageContent安全地提取消息内容，避免[object Object]问题
                    const messageContent = safeExtractMessageContent(msg);
                    let contentPreview = truncateText(messageContent, 20);
                    console.log(`🔍 [renderForwardedMessage] 预览消息${index + 1}: ${senderName}: ${contentPreview}`);
                    previewHtml += `<p>${senderName}: ${contentPreview}</p>`;
                });
            } else {
                console.log('❌ [renderForwardedMessage] 没有转发消息数据');
            }

            // 🔥【修复】使用data属性存储转发消息数据，避免JSON.stringify在onclick中的问题
            const messageId = message.id || Date.now().toString();
            console.log('🔍 [renderForwardedMessage] 渲染转发卡片，消息ID:', messageId, '转发消息数量:', message.forwardedMessages.length);

            return `
                <div class="forwarded-message-card" data-message-id="${messageId}" data-forwarded-title="${message.content.replace(/"/g, '&quot;')}" onclick="showForwardedMessagesById('${messageId}')">
                    <div class="forwarded-card-title">${message.content}</div>
                    <div class="forwarded-card-preview">${previewHtml}</div>
                    <div class="forwarded-card-footer">查看${message.forwardedMessages.length}条转发消息</div>
                </div>
            `;
        }

        // 4. 显示完整的转发消息记录
        function showForwardedMessages(messages, title) {
            const viewTitle = document.getElementById('forwarded-view-title');
            const viewContent = document.getElementById('forwarded-view-content');

            viewTitle.textContent = title;
            viewContent.innerHTML = '';

            messages.forEach(msg => {
                let senderName;
                if (msg.sender === 'sent') {
                    // 用户发送的消息，使用消息中保存的用户名或默认名
                    senderName = msg.userName || '我';
                } else {
                    // AI发送的消息，使用消息中保存的角色名
                    senderName = msg.name || msg.characterName || '角色';
                }

                // 🔥【修复】使用safeExtractMessageContent安全地提取消息内容，避免[object Object]问题
                const messageContent = safeExtractMessageContent(msg);

                const itemDiv = document.createElement('div');
                itemDiv.className = 'forwarded-message-item';
                itemDiv.innerHTML = `
                    <div class="forwarded-message-sender">${senderName}</div>
                    <div class="forwarded-message-content">${messageContent}</div>
                `;
                viewContent.appendChild(itemDiv);
            });

            showModal('forwarded-view-modal');
        }

        // 🔥【新增】通过消息ID显示转发消息记录 - 修复群聊中转发卡片点击问题
        function showForwardedMessagesById(messageId) {
            console.log('🔍 [转发卡片点击] 查找消息ID:', messageId);
            console.log('🔍 [转发卡片点击] 当前聊天角色:', currentChatCharacter?.name, '是否为群聊:', currentChatCharacter?.isGroup);

            // 在当前聊天记录中查找转发消息
            const currentMessages = chatMessages[currentChatCharacter.id] || [];
            console.log('🔍 [转发卡片点击] 当前聊天记录数量:', currentMessages.length);

            const forwardedMessage = currentMessages.find(msg => msg.id === messageId && msg.type === 'forwarded_message');
            console.log('🔍 [转发卡片点击] 查找结果:', forwardedMessage);

            if (forwardedMessage && forwardedMessage.forwardedMessages) {
                console.log('✅ [转发卡片点击] 找到转发消息，显示详情');
                console.log('🔍 [转发卡片点击] 转发消息数量:', forwardedMessage.forwardedMessages.length);
                showForwardedMessages(forwardedMessage.forwardedMessages, forwardedMessage.content);
            } else {
                console.error('❌ [转发卡片点击] 未找到转发消息:', messageId);
                console.log('🔍 [转发卡片点击] 所有消息ID列表:', currentMessages.map(msg => ({id: msg.id, type: msg.type})));
                showToast('无法找到转发的消息记录', 'error');
            }
        }

        // ================== 记忆设置相关功能 ==================

        // 获取挂载的聊天记忆
        async function getMountedMemories(currentCharacterId, chatSettings) {
            if (!chatSettings.memoryMountEnabled || !chatSettings.selectedMemoryChats || chatSettings.selectedMemoryChats.length === 0) {
                return '';
            }

            const mountCount = chatSettings.memoryMountCount || 3;
            let mountedMemoryContent = '';

            for (const chatId of chatSettings.selectedMemoryChats) {
                // 跳过当前聊天
                if (chatId === currentCharacterId) continue;

                // 获取该聊天的历史记录
                const chatHistory = chatMessages[chatId] || [];
                if (chatHistory.length === 0) continue;

                // 获取最近的几条记录
                const recentMessages = chatHistory.slice(-mountCount);
                if (recentMessages.length === 0) continue;

                // 获取聊天对象的名称
                let chatName = '未知聊天';
                let chatType = '单聊';

                // 查找单聊角色
                const character = characters.find(c => c.id === chatId);
                if (character) {
                    chatName = character.name;
                    chatType = '单聊';
                } else {
                    // 查找群聊
                    const group = groupChats.find(g => g.id === chatId);
                    if (group) {
                        chatName = group.name;
                        chatType = '群聊';
                    }
                }

                // 构建记忆内容
                mountedMemoryContent += `\n\n【${chatType}记忆 - ${chatName}】以下是与${chatName}的最近对话，可以作为背景参考：\n`;

                recentMessages.forEach(msg => {
                    let sender = '';
                    let content = msg.content || '';

                    if (msg.sender === 'sent') {
                        sender = '用户';
                    } else if (msg.sender === 'received' || msg.sender === 'ai') {
                        if (chatType === '群聊' && msg.name) {
                            sender = msg.name; // 群聊中的发言者名称
                        } else {
                            sender = chatName; // 单聊中使用角色名称
                        }
                    } else {
                        sender = '系统';
                    }

                    // 处理特殊消息类型
                    if (msg.type === 'voice_message') {
                        content = `[语音消息：${content}]`;
                    } else if (msg.type === 'transfer') {
                        content = `[转账：${msg.amount}元${msg.note ? ` - ${msg.note}` : ''}]`;
                    } else if (msg.type === 'ai_image') {
                        content = `[AI图片：${msg.imageDescription || '无描述'}]`;
                    } else if (msg.isEmoji) {
                        content = `[表情包：${msg.emojiDescription || '表情包'}]`;
                    } else if (msg.type === 'location') {
                        content = `[位置分享：${msg.locationName || '位置信息'}]`;
                    } else if (Array.isArray(content)) {
                        // 处理数组类型的内容（图片+文字）
                        const textPart = content.find(p => p.type === 'text')?.text || '';
                        content = textPart ? `[图片+文字：${textPart}]` : '[图片]';
                    }

                    // 确保content是字符串且不为空
                    if (typeof content !== 'string' || !content.trim()) {
                        content = '[特殊消息]';
                    }

                    mountedMemoryContent += `${sender}：${content}\n`;
                });
            }

            if (mountedMemoryContent.trim()) {
                console.log('🧠 成功加载挂载记忆，涉及聊天数:', chatSettings.selectedMemoryChats.length);
                return mountedMemoryContent;
            }

            return '';
        }

        function convertGroupChatToStandardFormat(groupChat) {
            if (!groupChat.members) return groupChat;

            // 转换成员数据结构
            const convertedMembers = groupChat.members.map(member => ({
                id: member.id,
                name: member.name,
                persona: member.persona || member.bio, // 🔥【关键】确保使用persona字段
                avatarUrl: member.avatarUrl,
                color: member.color
            }));

            // 确保有settings结构
            if (!groupChat.settings) {
                groupChat.settings = {
                    myPersona: '用户',
                    myNickname: '我'
                };
            }

            return {
                ...groupChat,
                members: convertedMembers
            };
        }

        function buildGroupChatMessageHistory(messages, groupChat) {
            if (!messages || !Array.isArray(messages)) return [];

            return messages.map(msg => {
                // 🔥【新增】处理群聊中的系统消息
                if (msg.sender === 'system') {
                    return { role: 'user', content: `[系统提示] ${msg.content}` };
                } else if (msg.sender === 'sent') {
                    // 用户消息：使用群聊设置中的昵称
                    const chatSettings = getCurrentChatSettings();
                    const myNickname = chatSettings.myChatNickname || groupChat.settings?.myNickname || '我';

                    let content;
                    if (msg.type === 'user_photo') {
                        content = `[${myNickname} 发送了一张描述的照片，内容是：'${msg.content}']`;
                    } else if (msg.type === 'voice_message') {
                        content = `[${myNickname} 发送了一条语音，内容是：'${msg.content}']`;
                    } else if (msg.type === 'transfer') {
                        content = `[${msg.senderName}向${msg.receiverName}转账 ${msg.amount}元, 备注: ${msg.note}]`;
                    } else if (msg.type === 'forwarded_message') {
                        // 🔥【关键修复】处理群聊中的转发消息
                        let forwardedContent = `[${myNickname} 转发了聊天记录：${msg.content}]`;

                        // 如果有转发的消息内容，展示具体内容
                        if (msg.forwardedMessages && msg.forwardedMessages.length > 0) {
                            forwardedContent += '\n转发的聊天内容：\n';
                            msg.forwardedMessages.forEach((fMsg, index) => {
                                let senderName;
                                if (fMsg.sender === 'sent') {
                                    senderName = fMsg.userName || '用户';
                                } else {
                                    senderName = fMsg.name || fMsg.characterName || 'AI';
                                }
                                // 🔥【修复】使用safeExtractMessageContent安全地提取消息内容，避免[object Object]问题
                                const fMsgContent = safeExtractMessageContent(fMsg);
                                forwardedContent += `${senderName}: ${fMsgContent}\n`;
                            });
                        }
                        content = forwardedContent;
                    } else if (msg.meaning) {
                        content = `${myNickname}: [发送了一个表情，意思是: '${msg.meaning}']`;
                    } else {
                        content = `${myNickname}: ${msg.content}`;
                    }

                    // 🔥【修复】处理用户消息的引用信息
                    if (msg.replyTo) {
                        const replyPrefix = `[${myNickname} 回复 ${msg.replyTo.senderName}: "${msg.replyTo.content}"] `;
                        content = replyPrefix + content.replace(`${myNickname}: `, '');
                    }

                    // 🔥【新增】为群聊消息添加ID信息，方便AI引用
                    if (msg.id) {
                        content = `[ID:${msg.id}] ${content}`;
                    }

                    return { role: 'user', content: content };
                } else {
                    // AI消息：根据senderId或name查找发送者
                    const sender = msg.senderName || msg.name || '未知';

                    let content;
                    if (msg.type === 'ai_image') {
                        content = `[${sender} 发送了一张图片]`;
                    } else if (msg.type === 'voice_message') {
                        content = `[${sender} 发送了一条语音，内容是：'${msg.content}']`;
                    } else if (msg.type === 'transfer') {
                        content = `[${msg.senderName}向${msg.receiverName}转账 ${msg.amount}元, 备注: ${msg.note}]`;
                    } else if (msg.type === 'forwarded_message') {
                        // 🔥【关键修复】处理群聊中AI发送的转发消息
                        let forwardedContent = `[${sender} 转发了聊天记录：${msg.content}]`;

                        // 如果有转发的消息内容，展示具体内容
                        if (msg.forwardedMessages && msg.forwardedMessages.length > 0) {
                            forwardedContent += '\n转发的聊天内容：\n';
                            msg.forwardedMessages.forEach((fMsg, index) => {
                                let senderName;
                                if (fMsg.sender === 'sent') {
                                    senderName = fMsg.userName || '用户';
                                } else {
                                    senderName = fMsg.name || fMsg.characterName || 'AI';
                                }
                                // 🔥【修复】使用safeExtractMessageContent安全地提取消息内容，避免[object Object]问题
                                const fMsgContent = safeExtractMessageContent(fMsg);
                                forwardedContent += `${senderName}: ${fMsgContent}\n`;
                            });
                        }
                        content = forwardedContent;
                    } else if (msg.meaning) {
                        content = `${sender}: [发送了一个表情，意思是: '${msg.meaning}']`;
                    } else if (Array.isArray(msg.content)) {
                        content = [...msg.content, { type: 'text', text: `${sender}:` }];
                    } else {
                        content = `${sender}: ${msg.content}`;
                    }

                    // 🔥【修复】处理AI消息的引用信息
                    if (msg.replyTo) {
                        const replyPrefix = `[${sender} 回复 ${msg.replyTo.senderName}: "${msg.replyTo.content}"] `;
                        content = replyPrefix + content.replace(`${sender}: `, '');
                    }

                    // 🔥【新增】为群聊消息添加ID信息，方便AI引用
                    if (msg.id) {
                        content = `[ID:${msg.id}] ${content}`;
                    }

                    return { role: 'user', content: content };
                }
            });
        }



        // 🔥【新增】监控localStorage使用情况
        function checkLocalStorageUsage() {
            try {
                let totalSize = 0;
                const items = [];

                for (let key in localStorage) {
                    if (localStorage.hasOwnProperty(key)) {
                        const size = localStorage[key].length;
                        totalSize += size;
                        items.push({ key, size });
                    }
                }

                const totalSizeMB = (totalSize / 1024 / 1024).toFixed(2);
                console.log(`📊 localStorage总使用量: ${totalSizeMB}MB`);

                // 显示最大的几个项目
                items.sort((a, b) => b.size - a.size);
                items.slice(0, 5).forEach(item => {
                    const sizeMB = (item.size / 1024 / 1024).toFixed(2);
                    console.log(`  - ${item.key}: ${sizeMB}MB`);
                });

                // 如果接近5MB限制，发出警告
                if (totalSize > 4 * 1024 * 1024) {
                    console.warn('⚠️ localStorage使用量接近限制，建议清理备份数据');
                }

                return { totalSize, items };
            } catch (error) {
                console.error('检查localStorage使用量失败:', error);
                return { totalSize: 0, items: [] };
            }
        }

        async function parseGroupChatAiResponse(aiResponseContent, groupChat) {
            try {
                // 🔥【修复】清理markdown代码块格式
                let cleanContent = aiResponseContent.trim();
                if (cleanContent.startsWith('```json')) {
                    cleanContent = cleanContent.replace(/^```json\s*/, '').replace(/\s*```$/, '');
                } else if (cleanContent.startsWith('```')) {
                    cleanContent = cleanContent.replace(/^```\s*/, '').replace(/\s*```$/, '');
                }

                const messagesArray = JSON.parse(cleanContent);
                if (!Array.isArray(messagesArray)) {
                    console.error('群聊AI响应不是数组格式');
                    return [];
                }

                const processedMessages = [];

                for (const msgData of messagesArray) {
                    if (typeof msgData === 'object' && msgData.name && msgData.message) {
                        const member = groupChat.members.find(m => m.name === msgData.name);
                        if (member) {
                            processedMessages.push({
                                id: Date.now() + Math.random(),
                                sender: 'received',
                                content: msgData.message,
                                timestamp: Date.now(),
                                senderId: member.id,
                                senderName: member.name,
                                name: member.name
                            });
                        }
                    } else if (typeof msgData === 'object' && msgData.name && msgData.type === 'ai_image') {
                        // 群聊图片消息
                        const member = groupChat.members.find(m => m.name === msgData.name);
                        if (member) {
                            processedMessages.push({
                                id: Date.now() + Math.random(),
                                sender: 'received',
                                type: 'ai_image',
                                content: msgData.description || 'AI描述的图片',
                                imageDescription: msgData.description,
                                timestamp: Date.now(),
                                senderId: member.id,
                                senderName: member.name,
                                name: member.name
                            });
                        }
                    } else if (typeof msgData === 'object' && msgData.name && msgData.type === 'voice_message') {
                        // 群聊语音消息
                        const member = groupChat.members.find(m => m.name === msgData.name);
                        if (member) {
                            processedMessages.push({
                                id: Date.now() + Math.random(),
                                sender: 'received',
                                type: 'voice_message',
                                content: msgData.content,
                                timestamp: Date.now(),
                                senderId: member.id,
                                senderName: member.name,
                                name: member.name
                            });
                        }
                    } else if (typeof msgData === 'object' && msgData.name && msgData.type === 'emoji') {
                        // 🔥【新增】群聊表情包消息
                        console.log('🔍 [parseGroupChatAiResponse] 检测到群聊表情包:', msgData);

                        const member = groupChat.members.find(m => m.name === msgData.name);
                        if (member) {
                            const matchingEmoji = await findEmojiForAI(msgData.description);
                            if (matchingEmoji) {
                                console.log('🔍 [parseGroupChatAiResponse] 找到匹配的表情包:', matchingEmoji);

                                processedMessages.push({
                                    id: Date.now() + Math.random(),
                                    sender: 'received',
                                    content: '', // 表情包消息不显示文字内容
                                    image: matchingEmoji.url,
                                    isEmoji: true,
                                    emojiDescription: matchingEmoji.description,
                                    timestamp: Date.now(),
                                    senderId: member.id,
                                    senderName: member.name,
                                    name: member.name
                                });

                                // 🔥【修复】角色发送的表情包不应该添加到用户的最近使用列表
                            } else {
                                console.warn('🔍 [parseGroupChatAiResponse] 找不到匹配的表情包:', msgData.description);

                                // 如果找不到匹配的表情包，发送错误消息
                                processedMessages.push({
                                    id: Date.now() + Math.random(),
                                    sender: 'received',
                                    content: `[表情包"${msgData.description}"不存在]`,
                                    timestamp: Date.now(),
                                    senderId: member.id,
                                    senderName: member.name,
                                    name: member.name
                                });
                            }
                        } else {
                            console.warn('🔍 [parseGroupChatAiResponse] 找不到发送表情包的成员:', msgData.name);
                        }
                    } else if (typeof msgData === 'string') {
                        // 🔥【关键修复】处理普通字符串消息 - 分配给第一个群成员
                        console.log('🔍 [parseGroupChatAiResponse] 检测到字符串消息:', msgData);
                        if (groupChat.members && groupChat.members.length > 0) {
                            const defaultMember = groupChat.members[0]; // 使用第一个成员作为默认发送者
                            processedMessages.push({
                                id: Date.now() + Math.random(),
                                sender: 'received',
                                content: msgData,
                                timestamp: Date.now(),
                                senderId: defaultMember.id,
                                senderName: defaultMember.name,
                                name: defaultMember.name
                            });
                            console.log('🔍 [parseGroupChatAiResponse] 字符串消息分配给:', defaultMember.name);
                        }
                    } else {
                        console.warn('🔍 [parseGroupChatAiResponse] 未识别的消息格式:', msgData);
                    }
                }

                return processedMessages;
            } catch (error) {
                console.error('解析群聊AI响应失败:', error);
                return [];
            }
        }

        // 加载群聊数据 - 使用IndexedDB（包含数据迁移和格式转换）
        async function loadGroupChats() {
            try {
                // 先从IndexedDB加载
                const savedGroupChats = await db.groupChats.toArray();

                if (savedGroupChats.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('groupChats');
                    if (localStorageData) {
                        console.log('检测到localStorage中的群聊数据，开始迁移...');
                        const localGroupChats = JSON.parse(localStorageData);

                        if (localGroupChats.length > 0) {
                            const migrationData = localGroupChats.map(group => convertGroupChatToStandardFormat({
                                id: group.id || Date.now().toString() + Math.random(),
                                name: group.name,
                                description: group.description || '',
                                members: group.members || [],
                                settings: group.settings || {},
                                createdAt: group.createdAt || new Date().toISOString(),
                                updatedAt: group.updatedAt || new Date().toISOString()
                            }));

                            // 迁移到IndexedDB
                            await db.groupChats.bulkAdd(migrationData);
                            groupChats = migrationData;
                            console.log('群聊数据迁移完成:', groupChats);
                        } else {
                            groupChats = [];
                        }
                    } else {
                        groupChats = [];
                    }
                } else {
                    groupChats = savedGroupChats.map(convertGroupChatToStandardFormat);
                    console.log('从IndexedDB加载群聊数据:', groupChats);
                }
            } catch (error) {
                console.error('加载群聊失败:', error);
                // 🔥【优化】如果IndexedDB失败，谨慎回退到localStorage
                const localStorageData = localStorage.getItem('groupChats');
                if (localStorageData) {
                    try {
                        const localData = JSON.parse(localStorageData);
                        // 🔥【新增】检查localStorage数据的大小和有效性
                        if (Array.isArray(localData) && localData.length > 0) {
                            groupChats = localData.map(convertGroupChatToStandardFormat);
                            console.log('从localStorage回退加载群聊数据（已转换格式）:', groupChats);

                            // 🔥【优化】尝试重新保存到IndexedDB
                            try {
                                await db.groupChats.bulkAdd(groupChats);
                                console.log('已将localStorage数据重新保存到IndexedDB');
                                // 成功保存后，可以考虑清理localStorage（如果数据过大）
                                const dataSize = localStorageData.length;
                                if (dataSize > 1024 * 1024) { // 超过1MB
                                    localStorage.removeItem('groupChats');
                                    console.log('已清理过大的localStorage备份');
                                }
                            } catch (saveError) {
                                console.warn('重新保存到IndexedDB失败:', saveError);
                            }
                        } else {
                            groupChats = [];
                        }
                    } catch (e) {
                        console.error('群聊数据解析失败:', e);
                        groupChats = [];
                    }
                } else {
                    groupChats = [];
                }
            }
        }

        // 🔥【修复】群聊消息和成员数据加载说明
        // 群聊消息存储在chatMessages表中，通过loadChatMessages()函数加载
        // 群聊成员信息存储在群聊对象的members属性中，通过loadGroupChats()函数加载
        console.log('ℹ️ 群聊数据加载：消息通过chatMessages表，成员通过groupChats对象的members属性');

        // 🔥【调试】检查当前使用的导入函数
        function debugImportFunction() {
            try {
                console.log('=== 导入函数调试 ===');

                // 检查函数源码
                const importFuncStr = window.importDataFromFile.toString();
                console.log('当前导入函数源码长度:', importFuncStr.length);

                // 检查是否包含特定标识
                const hasFixScript = importFuncStr.includes('修复脚本');
                const hasComprehensive = importFuncStr.includes('safeDataSave');
                const hasReplyToFix = importFuncStr.includes('修复引用消息');

                console.log('包含修复脚本标识:', hasFixScript);
                console.log('包含完整功能标识:', hasComprehensive);
                console.log('包含引用消息修复:', hasReplyToFix);

                // 分析支持的数据类型
                const supportedTypes = [];
                if (importFuncStr.includes('data.workingMemory')) supportedTypes.push('工作记忆');
                if (importFuncStr.includes('data.smsMessages')) supportedTypes.push('短信消息');
                if (importFuncStr.includes('data.wallpapers')) supportedTypes.push('壁纸');
                if (importFuncStr.includes('data.anniversaries')) supportedTypes.push('纪念日');
                if (importFuncStr.includes('data.blacklist')) supportedTypes.push('拉黑列表');

                console.log('支持的扩展数据类型:', supportedTypes);

                const result = `
导入函数调试结果：
- 当前使用: ${hasFixScript ? '第二处修复函数' : '第一处完整函数'}
- 功能完整性: ${hasComprehensive ? '完整' : '简化'}
- 引用消息修复: ${hasReplyToFix ? '支持' : '不支持'}
- 扩展数据类型支持: ${supportedTypes.length}种

${supportedTypes.length < 3 ? '⚠️ 警告：当前函数可能会丢失部分数据！' : '✅ 功能完整'}
                `;

                alert(result);

            } catch (error) {
                console.error('调试导入函数失败:', error);
                alert('调试失败: ' + error.message);
            }
        }

        // 🔥【调试】检查群聊数据
        async function debugGroupChatData() {
            try {
                console.log('=== 群聊数据调试 ===');

                // 检查内存中的群聊数据
                console.log('内存中的群聊数据:', groupChats);
                console.log('群聊数量:', groupChats.length);

                // 检查IndexedDB中的群聊数据
                const dbGroupChats = await db.groupChats.toArray();
                console.log('IndexedDB中的群聊数据:', dbGroupChats);
                console.log('IndexedDB群聊数量:', dbGroupChats.length);

                // 🔥【修复】检查chatMessages中的群聊消息（正确的存储位置）
                let groupChatMessageCount = 0;
                let groupMemberCount = 0;

                if (groupChats.length > 0) {
                    console.log('=== 群聊详细信息 ===');
                    groupChats.forEach((group, index) => {
                        console.log(`群聊 ${index + 1}: ${group.name} (ID: ${group.id})`);
                        console.log(`  成员:`, group.members);
                        if (group.members && Array.isArray(group.members)) {
                            groupMemberCount += group.members.length;
                        }

                        // 检查该群聊的消息
                        const groupMessages = chatMessages[group.id] || [];
                        console.log(`  消息数量: ${groupMessages.length}`);
                        groupChatMessageCount += groupMessages.length;

                        if (groupMessages.length > 0) {
                            console.log(`  最近消息:`, groupMessages.slice(-3));
                        }
                    });
                }

                // 🔥【废弃】这些表不再使用
                console.log('⚠️ 注意：groupChatMessages和groupChatMembers表已废弃');
                console.log('群聊消息现在存储在chatMessages表中');
                console.log('群聊成员现在存储在群聊对象的members属性中');

                console.log('=== 调试结束 ===');

                // 显示结果给用户
                const summary = `
群聊调试结果：
- 内存中群聊数量: ${groupChats.length}
- IndexedDB群聊数量: ${dbGroupChats.length}
- 群聊消息数量: ${groupChatMessageCount}条 (存储在chatMessages表中)
- 群聊成员数量: ${groupMemberCount}个 (存储在群聊对象中)

${groupChats.length > 0 ? '✅ 发现群聊数据' : '❌ 未发现群聊数据'}
                `;
                alert(summary);

            } catch (error) {
                console.error('调试群聊数据失败:', error);
                alert('调试失败: ' + error.message);
            }
        }

        // 显示历史消息设置
        function showHistorySettings() {
            const chatSettings = getCurrentChatSettings();
            const historyCount = chatSettings.historyCount;
            document.getElementById('history-messages-count').value = Math.min(historyCount, 100);
            document.getElementById('custom-history-count').value = historyCount;
            document.getElementById('history-count-display').textContent = historyCount + '回合';

            // 绑定滑块事件
            document.getElementById('history-messages-count').oninput = function() {
                const value = parseInt(this.value);
                document.getElementById('history-count-display').textContent = value + '回合';
                document.getElementById('custom-history-count').value = value;
            };

            // 绑定自定义输入框事件
            document.getElementById('custom-history-count').oninput = function() {
                const value = Math.max(0, Math.min(500, parseInt(this.value) || 0));
                this.value = value;
                if (value <= 100) {
                    document.getElementById('history-messages-count').value = value;
                }
                document.getElementById('history-count-display').textContent = value + '回合';
            };

            showModal('history-settings-modal');
        }

        // 保存历史消息设置
        function saveHistorySettings() {
            const chatSettings = getCurrentChatSettings();
            const customValue = parseInt(document.getElementById('custom-history-count').value);
            chatSettings.historyCount = Math.max(0, Math.min(500, customValue || 0));

            // 更新设置界面显示的当前值
            document.getElementById('current-history-count').textContent = chatSettings.historyCount + '回合';

            saveCurrentChatSettings(chatSettings);
            hideModal('history-settings-modal');
            showToast('历史消息设置已保存', 'success');
        }

        // 显示头像设置
        function showAvatarSettings() {
            // 加载当前聊天窗口的头像设置
            const chatSettings = getCurrentChatSettings();

            // 设置隐藏头像选项
            const hideAvatarsCheckbox = document.getElementById('hide-avatars');
            if (hideAvatarsCheckbox) {
                hideAvatarsCheckbox.checked = chatSettings.hideAvatars || false;
            }

            // 设置头像形状选项
            const avatarShape = chatSettings.avatarShape || 'circle';
            const avatarShapeRadios = document.querySelectorAll('input[name="avatar-shape"]');
            avatarShapeRadios.forEach(radio => {
                radio.checked = radio.value === avatarShape;
                // 更新选项卡的选中状态
                const radioOption = radio.closest('.shape-radio-option');
                if (radio.checked) {
                    radioOption.classList.add('selected');
                } else {
                    radioOption.classList.remove('selected');
                }
            });

            // 更新预览头像的形状
            updateAvatarPreviewShape(avatarShape);

            // 设置我的头像预览
            const myAvatarPreview = document.getElementById('my-chat-avatar-preview');
            if (chatSettings.myChatAvatar) {
                myAvatarPreview.style.backgroundImage = `url(${chatSettings.myChatAvatar})`;
                myAvatarPreview.style.backgroundSize = 'cover';
                myAvatarPreview.style.backgroundPosition = 'center';
                myAvatarPreview.innerHTML = '';
            } else {
                myAvatarPreview.style.backgroundImage = 'none';
                myAvatarPreview.innerHTML = '<i class="fas fa-user"></i>';
            }

            // 设置对方头像预览 - 显示当前实际使用的头像
            const aiAvatarPreview = document.getElementById('ai-chat-avatar-preview');
            const currentAiAvatar = chatSettings.aiChatAvatar;
            if (currentAiAvatar) {
                aiAvatarPreview.style.backgroundImage = `url(${currentAiAvatar})`;
                aiAvatarPreview.style.backgroundSize = 'cover';
                aiAvatarPreview.style.backgroundPosition = 'center';
                aiAvatarPreview.innerHTML = '';

                // 添加提示
                aiAvatarPreview.title = '当前显示聊天头像（可能被角色更换过）';
            } else {
                aiAvatarPreview.style.backgroundImage = 'none';
                aiAvatarPreview.innerHTML = '<i class="fas fa-robot"></i>';
                aiAvatarPreview.title = '使用默认头像';
            }

            // 绑定文件上传事件
            bindAvatarUploadEvents();

            // 绑定头像形状切换事件
            bindAvatarShapeEvents();

            showModal('avatar-settings-modal');
        }

        // 更新头像预览形状
        function updateAvatarPreviewShape(shape) {
            const myAvatarPreview = document.getElementById('my-chat-avatar-preview');
            const aiAvatarPreview = document.getElementById('ai-chat-avatar-preview');

            // 移除所有形状类
            myAvatarPreview.classList.remove('rounded-square');
            aiAvatarPreview.classList.remove('rounded-square');

            // 添加对应形状类
            if (shape === 'rounded-square') {
                myAvatarPreview.classList.add('rounded-square');
                aiAvatarPreview.classList.add('rounded-square');
            }
        }

        // 绑定头像形状切换事件
        function bindAvatarShapeEvents() {
            // 直接查找所有的radio按钮
            const avatarShapeRadios = document.querySelectorAll('input[name="avatar-shape"]');

            avatarShapeRadios.forEach(radio => {
                const option = radio.closest('.shape-radio-option');

                if (!option) {
                    console.warn('未找到radio选项容器:', radio);
                    return;
                }

                // 监听选项点击事件
                option.addEventListener('click', function() {
                    // 取消所有选项的选中状态
                    avatarShapeRadios.forEach(r => {
                        r.checked = false;
                        r.closest('.shape-radio-option').classList.remove('selected');
                    });

                    // 选中当前选项
                    radio.checked = true;
                    this.classList.add('selected');

                    // 更新预览
                    updateAvatarPreviewShape(radio.value);
                });

                // 监听radio的change事件
                radio.addEventListener('change', function() {
                    if (this.checked) {
                        // 取消其他选项的选中状态
                        avatarShapeRadios.forEach(r => {
                            if (r !== this) {
                                r.closest('.shape-radio-option').classList.remove('selected');
                            }
                        });

                        // 选中当前选项
                        option.classList.add('selected');

                        // 更新预览
                        updateAvatarPreviewShape(this.value);
                    }
                });
            });
        }

        // 生成带有正确形状类的头像HTML
        function generateAvatarHtml(options) {
            const {
                avatarUrl,
                backgroundColor,
                displayName,
                onClick,
                title,
                timestamp,
                timestampEnabled,
                timestampPosition,
                chatSettings
            } = options;

            // 获取头像形状设置
            const avatarShape = chatSettings?.avatarShape || 'circle';
            const shapeClass = avatarShape === 'rounded-square' ? ' rounded-square' : '';

            const backgroundStyle = avatarUrl
                ? `background-image: url(${avatarUrl}); background-size: cover; background-position: center;`
                : `background-color: ${backgroundColor};`;

            const onClickAttr = onClick ? `onclick="${onClick}"` : '';
            const titleAttr = title ? `title="${title}"` : '';
            const timestampHtml = timestampEnabled && timestampPosition === 'avatar' && timestamp
                ? `<div class="timestamp timestamp-avatar">${formatTimeOnly(timestamp)}</div>`
                : '';

            const content = avatarUrl ? '' : (displayName ? displayName.charAt(0) : '<i class="fas fa-user"></i>');

            return `<div class="message-avatar${shapeClass}" style="${backgroundStyle}" ${onClickAttr} ${titleAttr}>${content}${timestampHtml}</div>`;
        }

        // 显示昵称设置
        function showNicknameSettings() {
            const chatSettings = getCurrentChatSettings();
            document.getElementById('my-chat-nickname').value = chatSettings.myChatNickname || '';
            document.getElementById('ai-chat-nickname').value = chatSettings.aiChatNickname || '';
            showModal('nickname-settings-modal');
        }

        // 显示戳一戳后缀设置
        function showPokeSuffixSettings() {
            const chatSettings = getCurrentChatSettings();
            document.getElementById('my-poke-suffix').value = chatSettings.myPokeSuffix || '';
            document.getElementById('ai-poke-suffix').value = chatSettings.aiPokeSuffix || '';
            showModal('poke-suffix-modal');
        }

        // 显示聊天背景设置
        function showBackgroundSettings() {
            const backgroundPreview = document.getElementById('chat-background-preview');

            // 重置选择状态
            window.selectedChatBackground = undefined;

            // 使用currentChatCharacter.background而不是chatSettings.chatBackground
            if (currentChatCharacter && currentChatCharacter.background) {
                backgroundPreview.style.backgroundImage = `url(${currentChatCharacter.background})`;
                backgroundPreview.style.backgroundSize = 'cover';
                backgroundPreview.style.backgroundPosition = 'center';
                backgroundPreview.querySelector('.preview-text').style.display = 'none';
            } else {
                backgroundPreview.style.backgroundImage = 'none';
                backgroundPreview.querySelector('.preview-text').style.display = 'block';
                backgroundPreview.querySelector('.preview-text').textContent = '背景预览';
            }

            // 绑定背景上传事件
            document.getElementById('background-upload').onchange = function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        backgroundPreview.style.backgroundImage = `url(${event.target.result})`;
                        backgroundPreview.style.backgroundSize = 'cover';
                        backgroundPreview.style.backgroundPosition = 'center';
                        backgroundPreview.querySelector('.preview-text').style.display = 'none';
                        window.selectedChatBackground = event.target.result;
                    };
                    reader.readAsDataURL(e.target.files[0]);
                }
            };

            showModal('background-settings-modal');
        }

        // 显示气泡样式设置
        function showBubbleStyleSettings() {
            const chatSettings = getCurrentChatSettings();

            // 🔥【新增】检查是否为群聊，显示/隐藏群成员设置按钮
            const groupColorsBtn = document.getElementById('group-member-colors-btn');
            if (currentChatCharacter && currentChatCharacter.isGroup) {
                groupColorsBtn.style.display = 'block';
            } else {
                groupColorsBtn.style.display = 'none';
            }

            // 加载当前设置
            const currentStyle = chatSettings.bubbleStyle || 'default';
            document.getElementById('my-bubble-color').value = chatSettings.myBubbleColor || '#007AFF';
            document.getElementById('ai-bubble-color').value = chatSettings.aiBubbleColor || '#f0f0f0';

            // 加载分离的透明度设置
            document.getElementById('my-bubble-opacity').value = chatSettings.myBubbleOpacity || '1';
            document.getElementById('my-bubble-opacity-value').textContent = Math.round((chatSettings.myBubbleOpacity || 1) * 100) + '%';
            document.getElementById('ai-bubble-opacity').value = chatSettings.aiBubbleOpacity || '1';
            document.getElementById('ai-bubble-opacity-value').textContent = Math.round((chatSettings.aiBubbleOpacity || 1) * 100) + '%';

            // 设置当前选中的样式
            document.querySelectorAll('.bubble-style-option').forEach(option => {
                option.classList.remove('selected');
                if (option.dataset.style === currentStyle) {
                    option.classList.add('selected');
                }
            });

            // 绑定样式选择事件
            document.querySelectorAll('.bubble-style-option').forEach(option => {
                option.onclick = function() {
                    document.querySelectorAll('.bubble-style-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    this.classList.add('selected');
                    window.selectedBubbleStyle = this.dataset.style;
                    updatePreview(); // 实时预览
                };
            });

            // 绑定分离的透明度事件
            document.getElementById('my-bubble-opacity').oninput = function() {
                document.getElementById('my-bubble-opacity-value').textContent = Math.round(this.value * 100) + '%';
                updatePreview();
            };

            document.getElementById('ai-bubble-opacity').oninput = function() {
                document.getElementById('ai-bubble-opacity-value').textContent = Math.round(this.value * 100) + '%';
                updatePreview();
            };

            // 绑定颜色变化事件
            document.getElementById('my-bubble-color').oninput = updatePreview;
            document.getElementById('ai-bubble-color').oninput = updatePreview;

            // 加载气泡大小设置
            document.getElementById('bubble-padding').value = chatSettings.bubblePadding || '12';
            updatePaddingValue(chatSettings.bubblePadding || '12');

            // 绑定气泡大小事件
            document.getElementById('bubble-padding').oninput = function() {
                updatePaddingValue(this.value);
                updatePreview();
            };

            // 加载自定义CSS
            const customCSSTextarea = document.getElementById('custom-bubble-css');
            if (customCSSTextarea) {
                customCSSTextarea.value = chatSettings.customBubbleCSS || '';
            }

            window.selectedBubbleStyle = currentStyle;
            showModal('bubble-style-modal');

            // 初始化预览
            setTimeout(updatePreview, 100);
        }

        // 显示定时发布设置
        function showScheduleSettings() {
            const chatSettings = getCurrentChatSettings();

            document.getElementById('schedule-enabled').checked = chatSettings.scheduleEnabled || false;
            document.getElementById('schedule-enabled').onchange = function() {
                document.getElementById('schedule-times-group').style.display = this.checked ? 'block' : 'none';
            };

            // 触发一次显示状态更新
            document.getElementById('schedule-times-group').style.display =
                document.getElementById('schedule-enabled').checked ? 'block' : 'none';

            // 加载已有的时间点
            renderScheduleTimes();

            showModal('schedule-settings-modal');
        }

        // 异步函数，用于获取聊天窗口的专属设置
        async function getAsyncChatSettings(characterId = null) {
            // 1. 确定使用哪个角色ID
            const chatId = characterId || (currentChatCharacter ? currentChatCharacter.id : null);

            if (!chatId) {
                console.warn("无法获取设置：characterId 和 currentChatCharacter 都未定义，返回空设置");
                return {
                    historyCount: 30,
                    timestampEnabled: true,
                    timestampPosition: 'center',
                    bubbleStyle: 'default',
                    characterStatusEnabled: false
                };
            }

            // 🔥【关键修复】确保获取的是指定角色的设置，避免角色间设置混淆
            // 如果明确传入了characterId，则强制从数据库重新加载，确保数据准确性
            const forceReload = characterId !== null && characterId !== undefined;

            // 🔥【修复】使用窗口隔离的设置键
            const windowChatSettingsKey = `${chatId}_${windowId || 'default'}`;

            // 2. 【性能优化】首先检查内存中是否已有该聊天的设置（除非强制重新加载）
            if (!forceReload && chatSettings[windowChatSettingsKey]) {
                console.log(`✅ 从内存缓存获取角色 ${chatId} (窗口${windowId})的设置`);
                return chatSettings[windowChatSettingsKey];
            }

            // 🔥【兼容性】如果没有窗口隔离设置，检查旧的全局设置
            if (!forceReload && !chatSettings[windowChatSettingsKey] && chatSettings[chatId]) {
                console.log(`✅ 从内存缓存获取角色 ${chatId} 的全局设置（兼容模式）`);
                // 复制到窗口隔离设置中
                chatSettings[windowChatSettingsKey] = { ...chatSettings[chatId] };
                return chatSettings[windowChatSettingsKey];
            }

            // 3. 【核心逻辑】从 IndexedDB 数据库异步查询（强制重新加载或内存中没有）
                try {
                    // 优先尝试窗口隔离的设置
                    let dbSettings = null;
                    if (windowId) {
                        dbSettings = await db.windowChatSettings.where('[chatId+windowId]').equals([chatId, windowId]).first();
                    }

                    // 如果没有窗口隔离设置，尝试全局设置（兼容性）
                    if (!dbSettings) {
                        dbSettings = await db.chatSettings.get(chatId);
                    }

                    if (dbSettings && dbSettings.settings) {
                    // 查到了！存入内存并返回
                    const loadType = forceReload ? '强制重新加载' : '首次加载';
                    console.log(`✅ 从数据库${loadType}角色 ${chatId} (窗口${windowId})的设置`);
                        chatSettings[windowChatSettingsKey] = dbSettings.settings;

                        // 🔥【兼容性】同时更新全局设置
                        if (!chatSettings[chatId]) {
                            chatSettings[chatId] = { ...dbSettings.settings };
                        }

                    return dbSettings.settings;
                    }
                } catch (error) {
                console.error(`从数据库加载角色 ${chatId} (窗口${windowId})的设置失败:`, error);
                // 即使数据库查询失败，也要继续执行，尝试创建默认设置
            }

            // 4. 【处理新聊天】如果数据库里也没有，说明这是一个全新的聊天窗口
            console.log(`🔧 ID为 ${chatId} 的聊天无历史设置，正在创建默认设置...`);

            // 定义一份干净的默认设置
            const defaultSettings = {
                        // 记忆相关设置（原本的全局设置改为每个聊天独立）
                historyCount: 30,
                        crossChatMemory: 3,
                        enableDynamicMemory: true,
                        enableMusicMemory: true,
                        memoryMountEnabled: false,
                        memoryMountCount: 3,
                        selectedMemoryChats: [],
                        // 时间感知设置
                        timeAwarenessEnabled: true,
                        // 通话设置
                        aiCallEnabled: true,
                        // 心率监测设置
                        aiHeartrateEnabled: false,
                        // 社交动态设置
                        socialEnabled: false,
                        socialFrequency: 'medium',
                        // 后台互动设置
                        backgroundInteractionEnabled: true,
                        backgroundChatEnabled: true,
                        backgroundMomentsEnabled: true,
                        backgroundChatFrequency: 'low',
                        backgroundMomentsFrequency: 'low',
                        scheduledMomentsEnabled: false,
                        scheduledMomentsTimes: [],
                        // 🔥【关键修复】世界书相关设置
                        worldbookMountEnabled: false,
                        selectedWorldbooks: [],
                        linkedWorldBookIds: [], // 兼容旧版本字段名
                        // 其他原有设置
                        timestampEnabled: true, // 🔥【修复】默认开启时间戳
                timestampPosition: 'center',
                characterStatusEnabled: false,
                        // 🔥【新增】状态更新频率设置
                        statusUpdateFrequency: 'medium'
            };

            // 5. 将新创建的默认设置存入内存（使用窗口隔离键）
            chatSettings[windowChatSettingsKey] = defaultSettings;

            // 🔥【兼容性】同时保存到全局键
            if (!chatSettings[chatId]) {
                chatSettings[chatId] = { ...defaultSettings };
            }

            // 6. 【重要】同时，立即将这份默认设置保存回数据库，为这个新聊天建立档案
            try {
                // 🔥【新功能】优先保存到窗口隔离表
                if (windowId) {
                    await db.windowChatSettings.put({
                        chatId: chatId,
                        windowId: windowId,
                        settings: defaultSettings,
                        timestamp: Date.now()
                    });
                    console.log(`✅ 已为新聊天 ${chatId} (窗口${windowId})在窗口隔离表中创建了默认设置档案`);
                }

                // 🔥【兼容性】同时保存到原有的chatSettings表
                await db.chatSettings.put({
                    id: chatId,
                    chatId: chatId,
                    settings: defaultSettings
                });
                console.log(`✅ 已为新聊天 ${chatId} 在数据库中创建了默认设置档案`);
                } catch (error) {
                console.error(`为新聊天 ${chatId} (窗口${windowId})保存默认设置失败:`, error);
            }

            // 7. 返回这份全新的默认设置
            return defaultSettings;
        }

        // 兼容层 - 同步版本的getCurrentChatSettings + 窗口隔离支持
        // 注意：这个函数只会返回内存中的设置或默认设置，不会从数据库加载
        // 用于不方便修改为async/await的地方
        function getCurrentChatSettings() {
            if (!currentChatCharacter) return {};

            const chatId = currentChatCharacter.id;

            // 🔥【修复】使用窗口隔离的设置键
            const windowChatSettingsKey = `${chatId}_${windowId || 'default'}`;

            // 优先检查窗口隔离的设置
            if (chatSettings[windowChatSettingsKey]) {
                return chatSettings[windowChatSettingsKey];
            }

            // 🔥【兼容性】如果没有窗口隔离设置，尝试使用旧的全局设置
            if (chatSettings[chatId]) {
                // 复制到窗口隔离设置中，避免后续冲突
                chatSettings[windowChatSettingsKey] = { ...chatSettings[chatId] };
                return chatSettings[windowChatSettingsKey];
            }

            // 如果内存中没有，创建一个默认设置
            // 注意：这里不会保存到数据库，只是临时使用
            // 下次调用异步版本的getAsyncChatSettings时会正确加载/创建设置
            console.warn(`⚠️ 使用了同步版本获取ID为 ${chatId} (窗口${windowId})的设置，但内存中没有缓存，返回临时默认设置`);

            const defaultSettings = {
                historyCount: 30,
                crossChatMemory: 3,
                enableDynamicMemory: true,
                enableMusicMemory: true,
                memoryMountEnabled: false,
                memoryMountCount: 3,
                selectedMemoryChats: [],
                timeAwarenessEnabled: true,
                aiCallEnabled: true,
                aiHeartrateEnabled: false,
                characterStatusEnabled: false,
                socialEnabled: false,
                socialFrequency: 'medium',
                backgroundInteractionEnabled: true,
                backgroundChatEnabled: true,
                backgroundMomentsEnabled: true,
                backgroundChatFrequency: 'low',
                backgroundMomentsFrequency: 'low',
                scheduledMomentsEnabled: false,
                scheduledMomentsTimes: [],
                timestampEnabled: true,
                timestampPosition: 'center',
                aiHeartrateEnabled: false,
                // 🔥【关键修复】添加世界书相关设置
                worldbookMountEnabled: false,
                selectedWorldbooks: [],
                linkedWorldBookIds: [], // 兼容旧版本字段名
                // 🔥【新增】状态更新频率设置
                statusUpdateFrequency: 'medium',
                // 🔥【修复】添加头像设置，确保不为空
                aiChatAvatar: '', // 聊天专用头像
                userChatAvatar: '' // 用户聊天专用头像
            };

            // 同时触发一个异步加载，以便后续使用
            getAsyncChatSettings().then(settings => {
                console.log(`✅ 后台异步加载ID为 ${chatId} 的设置完成`);
            }).catch(error => {
                console.error(`后台异步加载ID为 ${chatId} 的设置失败:`, error);
            });

            return defaultSettings;
        }

        // 🔥【重构】保存当前聊天的设置 - 完全依赖IndexedDB + 自动保存 + 窗口隔离
        async function saveCurrentChatSettings(settings) {
            if (!currentChatCharacter) return;

            const chatId = currentChatCharacter.id;

            // 🔥【修复】使用窗口隔离的设置键
            const windowChatSettingsKey = `${chatId}_${windowId || 'default'}`;

            // 🔥【修复】同步更新全局chatSettings（使用窗口隔离键）
            chatSettings[windowChatSettingsKey] = settings;

            // 🔥【兼容性】同时更新旧的全局键，但优先级较低
            if (!chatSettings[chatId] || windowId) {
                chatSettings[chatId] = { ...settings };
            }

            try {
                // 🔥【新功能】优先保存到窗口隔离表
                if (windowId) {
                    // 🔥【修复】先查找是否已存在相同的chatId+windowId组合
                    const existingSetting = await db.windowChatSettings.where('[chatId+windowId]').equals([chatId, windowId]).first();

                    if (existingSetting) {
                        // 更新现有记录
                        await db.windowChatSettings.update(existingSetting.id, {
                            settings: settings,
                            timestamp: Date.now()
                        });
                        console.log(`✅ 窗口隔离聊天设置已更新到IndexedDB (角色: ${chatId}, 窗口: ${windowId})`);
                    } else {
                        // 创建新记录
                        await db.windowChatSettings.add({
                            chatId: chatId,
                            windowId: windowId,
                            settings: settings,
                            timestamp: Date.now()
                        });
                        console.log(`✅ 窗口隔离聊天设置已保存到IndexedDB (角色: ${chatId}, 窗口: ${windowId})`);
                    }
                }

                // 🔥【兼容性】同时保存到原有的chatSettings表
                await db.chatSettings.put({
                    id: chatId,
                    chatId: chatId,
                    settings: settings
                });

                console.log(`✅ 聊天设置已保存到IndexedDB (角色: ${chatId})`);

                // 🔥【新增】触发自动保存机制，防止数据丢失
                scheduleAutoSave(chatId);

            } catch (error) {
                console.error('🚨 保存聊天设置到IndexedDB失败:', error);

                // 🔥【紧急备份】只在IndexedDB完全失败时才使用localStorage
                try {
                    console.warn('⚠️ 正在进行紧急备份...');
                    const emergencySettings = {
                        selectedIdentityId: settings.selectedIdentityId,
                        aiChatNickname: settings.aiChatNickname,
                        myChatNickname: settings.myChatNickname,
                        hideAvatars: settings.hideAvatars,
                        bubbleStyle: settings.bubbleStyle,
                        timestampEnabled: settings.timestampEnabled,
                        timestampPosition: settings.timestampPosition
                    };

                    const emergencyKey = windowId ? `chatSettings_emergency_${chatId}_${windowId}` : `chatSettings_emergency_${chatId}`;
                    localStorage.setItem(emergencyKey, JSON.stringify(emergencySettings));
                    console.log('✅ 紧急备份已保存');
                    showToast('⚠️ 数据库保存失败，已启用紧急备份', 'warning');

                } catch (localError) {
                    console.error('🚨 紧急备份也失败了:', localError);
                    showToast('❌ 设置保存失败！请检查存储空间', 'error');
                }
            }
        }



        // 显示记忆挂载设置
        async function showMemoryMountSettings() {
            const chatSettings = await getAsyncChatSettings();
            // 加载当前设置
            document.getElementById('memory-mount-enabled').checked = chatSettings.memoryMountEnabled || false;
            document.getElementById('memory-mount-count').value = chatSettings.memoryMountCount || 3;
            document.getElementById('memory-mount-display').textContent = (chatSettings.memoryMountCount || 3) + '条';

            // 控制详细设置的显示
            toggleMemoryMountDetails();

            // 绑定事件
            document.getElementById('memory-mount-enabled').onchange = toggleMemoryMountDetails;
            document.getElementById('memory-mount-count').oninput = function() {
                document.getElementById('memory-mount-display').textContent = this.value + '条';
            };

            // 渲染聊天列表
            renderMemoryMountChatList();

            showModal('memory-mount-modal');
        }

        // 切换记忆挂载详细设置显示
        function toggleMemoryMountDetails() {
            const enabled = document.getElementById('memory-mount-enabled').checked;
            document.getElementById('memory-mount-details').style.display = enabled ? 'block' : 'none';
            document.getElementById('memory-mount-chats').style.display = enabled ? 'block' : 'none';

            // 更新主设置界面显示
            document.getElementById('current-memory-mount').textContent = enabled ? '已开启' : '已关闭';
        }

        // 渲染记忆挂载聊天列表
        async function renderMemoryMountChatList() {
            const container = document.getElementById('memory-mount-list');
            container.innerHTML = '';

            if (characters.length === 0 && groupChats.length === 0) {
                container.innerHTML = '<p class="empty-mount-chats">暂无可挂载的聊天</p>';
                return;
            }

            // 添加单人聊天
            characters.forEach(character => {
                if (currentChatCharacter && character.id === currentChatCharacter.id) return; // 不显示当前聊天

                const item = document.createElement('div');
                item.className = 'mount-item';
                item.innerHTML = `
                    <input type="checkbox" id="mount-${character.id}" value="${character.id}" class="mount-checkbox">
                    <div class="mount-avatar-small" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''} display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                        ${character.avatarUrl ? '' : character.name.charAt(0)}
                    </div>
                    <div>
                        <div class="mount-name">${character.name}</div>
                        <div class="mount-type">单聊</div>
                    </div>
                `;
                container.appendChild(item);
            });

            // 添加群聊
            groupChats.forEach(group => {
                if (currentChatCharacter && group.id === currentChatCharacter.id) return; // 不显示当前聊天

                const item = document.createElement('div');
                item.className = 'mount-item';
                item.innerHTML = `
                    <input type="checkbox" id="mount-${group.id}" value="${group.id}" class="mount-checkbox">
                    <div class="mount-avatar-group">
                        群
                    </div>
                    <div>
                        <div class="mount-name">${group.name}</div>
                                                    <div class="mount-type">群聊 (${group.members ? group.members.length + 1 : 1}人)</div>
                    </div>
                `;
                container.appendChild(item);
            });

            // 加载已选择的聊天
            const chatSettings = await getAsyncChatSettings();
            const selectedChats = chatSettings.selectedMemoryChats || [];
            selectedChats.forEach(chatId => {
                const checkbox = document.getElementById(`mount-${chatId}`);
                if (checkbox) checkbox.checked = true;
            });
        }

        // 保存记忆挂载设置
        async function saveMemoryMountSettings() {
            const chatSettings = await getAsyncChatSettings();
            chatSettings.memoryMountEnabled = document.getElementById('memory-mount-enabled').checked;
            chatSettings.memoryMountCount = parseInt(document.getElementById('memory-mount-count').value);

            // 获取选中的聊天
            const checkboxes = document.querySelectorAll('#memory-mount-list input[type="checkbox"]:checked');
            chatSettings.selectedMemoryChats = Array.from(checkboxes).map(cb => cb.value);

            // 更新主设置界面显示
            document.getElementById('current-memory-mount').textContent = chatSettings.memoryMountEnabled ? '已开启' : '已关闭';

            await saveCurrentChatSettings(chatSettings);
            hideModal('memory-mount-modal');
            showToast('记忆挂载设置已保存', 'success');
        }

        // 更新预览
        function updatePreview() {
            const previewAi = document.getElementById('preview-ai');
            const previewUser = document.getElementById('preview-user');
            const previewContainer = document.getElementById('bubble-preview');

            if (!previewAi || !previewUser || !previewContainer) return;

            // 获取当前设置
            const myColor = document.getElementById('my-bubble-color')?.value || '#007AFF';
            const aiColor = document.getElementById('ai-bubble-color')?.value || '#f0f0f0';
            const myOpacity = document.getElementById('my-bubble-opacity')?.value || '1';
            const aiOpacity = document.getElementById('ai-bubble-opacity')?.value || '1';
            const padding = document.getElementById('bubble-padding')?.value || '12';
            const customCSS = document.getElementById('custom-bubble-css')?.value || '';

            // 应用基础样式
            previewUser.style.backgroundColor = myColor;
            previewUser.style.opacity = myOpacity;
            previewUser.style.padding = `${padding}px`;

            previewAi.style.backgroundColor = aiColor;
            previewAi.style.opacity = aiOpacity;
            previewAi.style.padding = `${padding}px`;

            // 应用气泡样式类
            previewContainer.className = 'preview-container';
            if (window.selectedBubbleStyle) {
                previewContainer.classList.add(`bubble-style-${window.selectedBubbleStyle}`);
            }

            // 应用自定义CSS
            applyPreviewCSS(customCSS);
        }

        // 应用自定义CSS到预览
        function applyPreviewCSS(css) {
            // 移除旧的预览样式
            const oldStyle = document.getElementById('preview-custom-style');
            if (oldStyle) oldStyle.remove();

            if (!css.trim()) return;

            // 创建新的样式
            const style = document.createElement('style');
            style.id = 'preview-custom-style';

            // 🔥【修复】预览区域现在使用与实际聊天界面相同的HTML结构
            // 直接应用CSS到预览区域，添加作用域前缀
            let scopedCSS = css.replace(/^/gm, '#bubble-preview ');

            // 确保伪元素不会阻挡预览区域的交互
            scopedCSS += `
                #bubble-preview *::before,
                #bubble-preview *::after {
                    pointer-events: none !important;
                }
            `;

            style.textContent = scopedCSS;
            document.head.appendChild(style);
        }

        // 应用自定义CSS到实际聊天界面
        function applyCustomBubbleCSS() {
            const chatSettings = getCurrentChatSettings();
            const css = chatSettings.customBubbleCSS;

            // 移除旧的自定义样式
            const oldStyle = document.getElementById('custom-bubble-style');
            if (oldStyle) oldStyle.remove();

            if (!css || !css.trim()) {
                window.hasCustomBubbleStyle = false;
                return;
            }

            // 🔥【简化】直接应用CSS，不进行复杂转换
            // 用户需要使用标准的选择器：.message-container.sent .message-bubble 等
            let adaptedCSS = css;

            // 只添加必要的安全样式，确保功能不受影响
            adaptedCSS += `
                /* 确保伪元素不阻挡交互 */
                .message-container::before,
                .message-container::after,
                .message-bubble::before,
                .message-bubble::after {
                    pointer-events: none !important;
                }

                /* 确保语音消息可点击 */
                .voice-message {
                    position: relative !important;
                    z-index: 10 !important;
                    pointer-events: auto !important;
                }
            `;

            const style = document.createElement('style');
            style.id = 'custom-bubble-style';
            style.textContent = adaptedCSS;
            document.head.appendChild(style);

            // 设置全局标志
            window.hasCustomBubbleStyle = true;

            console.log('🎨 自定义CSS已应用（标准模式）');
        }

        // 保存聊天头像设置
        async function saveChatAvatarSettings() {
            const chatSettings = getCurrentChatSettings();

            // 保存隐藏头像设置
            const hideAvatarsCheckbox = document.getElementById('hide-avatars');
            if (hideAvatarsCheckbox) {
                chatSettings.hideAvatars = hideAvatarsCheckbox.checked;
            }

            // 保存头像形状设置
            const avatarShapeRadios = document.querySelectorAll('input[name="avatar-shape"]');
            for (const radio of avatarShapeRadios) {
                if (radio.checked) {
                    chatSettings.avatarShape = radio.value;
                    break;
                }
            }

            // 🔥【压缩头像】在保存前压缩头像数据
            if (window.selectedMyChatAvatar) {
                chatSettings.myChatAvatar = await compressImage(window.selectedMyChatAvatar, 200, 0.7);
            }
            if (window.selectedAiChatAvatar) {
                chatSettings.aiChatAvatar = await compressImage(window.selectedAiChatAvatar, 200, 0.7);
            }

            try {
                await saveCurrentChatSettings(chatSettings);
                hideModal('avatar-settings-modal');

                // 刷新聊天界面以显示新头像
                if (currentChatCharacter) {
                    renderChatMessages(currentChatCharacter.id);
                }

                showToast('头像设置已保存', 'success');
            } catch (error) {
                console.error('保存头像设置失败:', error);
                showToast('保存失败，存储空间可能不足', 'error');
            }
        }

        // 保存昵称设置
        async function saveChatNicknameSettings() {
            const chatSettings = getCurrentChatSettings();

            chatSettings.myChatNickname = document.getElementById('my-chat-nickname').value.trim();
            chatSettings.aiChatNickname = document.getElementById('ai-chat-nickname').value.trim();

            await saveCurrentChatSettings(chatSettings);
            hideModal('nickname-settings-modal');

            // 更新聊天界面标题
            if (currentChatCharacter) {
                let displayTitle = chatSettings.aiChatNickname || currentChatCharacter.name;

                // 🔥【修复】群聊标题显示成员数量
                if (currentChatCharacter.isGroup && currentChatCharacter.members) {
                    const memberCount = currentChatCharacter.members.length + 1; // +1 包括用户自己
                    displayTitle = `${displayTitle}（${memberCount}）`;
                }

                const chatTitle = document.getElementById('api-chat-title');
                if (chatTitle) {
                    chatTitle.textContent = displayTitle;
                    // 🔥【新增】清除正在输入状态并保存新的原始标题
                    chatTitle.classList.remove('typing-status');
                    chatTitle.dataset.originalTitle = displayTitle;
                }
            }

            // 刷新聊天界面
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }

            // 🔥【修复】刷新消息列表和联系人列表以显示新昵称
            renderMessageList();
            renderContactList();

            showToast('昵称设置已保存', 'success');
        }

        // 保存戳一戳后缀设置
        async function savePokeSuffixSettings() {
            const chatSettings = getCurrentChatSettings();

            chatSettings.myPokeSuffix = document.getElementById('my-poke-suffix').value.trim();
            chatSettings.aiPokeSuffix = document.getElementById('ai-poke-suffix').value.trim();

            await saveCurrentChatSettings(chatSettings);
            hideModal('poke-suffix-modal');
            showToast('戳一戳后缀设置已保存', 'success');
        }

        // 保存聊天背景设置
        async function saveChatBackgroundSettings() {
    // 1. 确保有当前聊天角色
    if (!currentChatCharacter) return;

    // 2. 根据用户的操作更新背景设置
    // window.selectedChatBackground 在你选择或移除背景时被赋值
    let backgroundToApply;

            if (window.selectedChatBackground === null) {
        // 用户点击了"移除背景"
        backgroundToApply = null;
            } else if (window.selectedChatBackground) {
        // 用户选择了新背景
        backgroundToApply = await compressImage(window.selectedChatBackground, 800, 0.8);
    } else {
        // 用户没做任何更改，保持原有设置不变
        backgroundToApply = currentChatCharacter.background;
    }

    // 3. [关键] 立即应用背景设置，这会自动更新currentChatCharacter.background并保存
    await applyChatBackground(backgroundToApply);

    // 4. 清理并关闭模态框
    hideModal('background-settings-modal');
    window.selectedChatBackground = undefined; // 清理临时变量
            showToast('聊天背景设置已保存', 'success');
        }

        // 移除背景
        function removeBackground() {
            const backgroundPreview = document.getElementById('chat-background-preview');
            backgroundPreview.style.backgroundImage = 'none';
            backgroundPreview.querySelector('.preview-text').style.display = 'block';
            backgroundPreview.querySelector('.preview-text').textContent = '已移除背景';
            window.selectedChatBackground = null;
        }

        // 更新气泡大小显示值
        function updatePaddingValue(value) {
            const paddingValue = document.getElementById('bubble-padding-value');
            if (paddingValue) {
                if (value <= 6) {
                    paddingValue.textContent = '超紧凑';
                } else if (value <= 10) {
                    paddingValue.textContent = '紧凑';
                } else if (value <= 14) {
                    paddingValue.textContent = '中等';
                } else {
                    paddingValue.textContent = '宽松';
                }
            }
        }

        // 保存气泡样式设置
        async function saveBubbleStyleSettings() {
            const chatSettings = getCurrentChatSettings();

            // 保存样式选择
            if (window.selectedBubbleStyle) {
                chatSettings.bubbleStyle = window.selectedBubbleStyle;
            }

            // 保存颜色设置
            chatSettings.myBubbleColor = document.getElementById('my-bubble-color').value;
            chatSettings.aiBubbleColor = document.getElementById('ai-bubble-color').value;

            // 保存分离的透明度设置
            chatSettings.myBubbleOpacity = document.getElementById('my-bubble-opacity').value;
            chatSettings.aiBubbleOpacity = document.getElementById('ai-bubble-opacity').value;

            // 保存气泡大小设置
            chatSettings.bubblePadding = document.getElementById('bubble-padding').value;

            // 保存自定义CSS设置
            const customCSS = document.getElementById('custom-bubble-css').value;
            chatSettings.customBubbleCSS = customCSS;

            await saveCurrentChatSettings(chatSettings);

            // 🔥【修复】立即应用气泡样式
            applyBubbleStyle();

            // 应用自定义CSS
            applyCustomBubbleCSS();

            // 🔥【修复】立即更新气泡样式显示
            updateBubbleStyleDisplay();

            hideModal('bubble-style-modal');

            // 刷新聊天界面以应用新设置
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }

            showToast('气泡样式设置已保存', 'success');
        }

        // 显示时间戳设置
        function showTimestampSettings() {
            const chatSettings = getCurrentChatSettings();

            // 设置时间戳开关状态
            const timestampEnabled = document.getElementById('timestamp-modal-enabled');
            if (timestampEnabled) {
                // 如果设置未定义，默认为true
                timestampEnabled.checked = chatSettings.timestampEnabled !== false;
            }

            // 设置时间戳位置选项
            const timestampPosition = chatSettings.timestampPosition || 'center';
            const positionRadios = document.querySelectorAll('input[name="timestamp-position"]');
            positionRadios.forEach(radio => {
                radio.checked = radio.value === timestampPosition;
            });

            // 绑定时间戳开关变化事件
            if (timestampEnabled) {
                timestampEnabled.onchange = function() {
                    const optionsGroup = document.getElementById('timestamp-options-group');
                    if (optionsGroup) {
                        optionsGroup.style.display = this.checked ? 'block' : 'none';
                    }
                };

                // 触发一次显示状态更新
                const optionsGroup = document.getElementById('timestamp-options-group');
                if (optionsGroup) {
                    optionsGroup.style.display = timestampEnabled.checked ? 'block' : 'none';
                }
            }

            showModal('timestamp-settings-modal');
        }

        // 保存时间戳设置
        async function saveTimestampSettings() {
            const chatSettings = getCurrentChatSettings();

            // 获取时间戳开关状态
            const timestampEnabled = document.getElementById('timestamp-modal-enabled');
            if (timestampEnabled) {
                chatSettings.timestampEnabled = timestampEnabled.checked;
            }

            // 获取选中的时间戳位置
            const selectedPosition = document.querySelector('input[name="timestamp-position"]:checked');
            if (selectedPosition) {
                chatSettings.timestampPosition = selectedPosition.value;
            }

            await saveCurrentChatSettings(chatSettings);
            hideModal('timestamp-settings-modal');

            // 重新渲染聊天消息以应用新的时间戳设置
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }

            showToast('时间戳设置已保存', 'success');
        }

        // 🔥【新增】群成员气泡颜色设置功能
        function showGroupMemberColorSettings() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) {
                showToast('只有群聊可以设置成员气泡颜色', 'warning');
                return;
            }

            // 🔥【新增】先关闭气泡样式设置窗口，避免层级遮挡
            hideModal('bubble-style-modal');

            const container = document.getElementById('group-member-colors-list');
            container.innerHTML = '';

            const chatSettings = getCurrentChatSettings();
            const memberColors = chatSettings.memberBubbleColors || {};

            // 获取群成员列表
            const group = groupChats.find(g => g.id === currentChatCharacter.id);
            console.log('当前群聊:', currentChatCharacter);
            console.log('找到的群聊:', group);
            console.log('群聊成员:', group?.members);

            if (!group || !group.members || group.members.length === 0) {
                container.innerHTML = '<p class="text-center-gray">该群聊暂无成员。请先在群聊信息中添加成员。</p>';
                showModal('group-member-colors-modal');
                return;
            }

            // 为每个群成员创建颜色设置项
            group.members.forEach(member => {
                // 兼容不同的成员数据结构
                const memberId = typeof member === 'string' ? member : member.id;
                const character = characters.find(c => c.id === memberId);
                if (!character) {
                    console.log('找不到角色:', memberId, '所有角色:', characters.map(c => ({id: c.id, name: c.name})));
                    return;
                }

                const memberColor = memberColors[memberId] || '#f0f0f0';

                const memberItem = document.createElement('div');
                memberItem.className = 'setting-item';
                memberItem.innerHTML = `
                    <div class="setting-left">
                        <div class="setting-label" style="display: flex; align-items: center; gap: 8px;">
                            <div class="character-avatar" style="width: 24px; height: 24px; background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''} display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 12px; border-radius: 50%;">
                                ${character.avatarUrl ? '' : character.name.charAt(0)}
                            </div>
                            ${character.name}
                        </div>
                        <div class="setting-desc">设置 ${character.name} 的专属气泡颜色</div>
                    </div>
                    <div class="setting-right">
                        <input type="color" id="member-color-${memberId}" class="color-input" value="${memberColor}" style="width: 40px; height: 30px;">
                    </div>
                `;

                container.appendChild(memberItem);
            });

            showModal('group-member-colors-modal');
        }

        function saveGroupMemberColors() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;

            const chatSettings = getCurrentChatSettings();
            if (!chatSettings.memberBubbleColors) {
                chatSettings.memberBubbleColors = {};
            }

            // 获取群成员列表
            const group = groupChats.find(g => g.id === currentChatCharacter.id);
            if (!group || !group.members) return;

            // 保存每个成员的颜色设置
            group.members.forEach(member => {
                // 兼容不同的成员数据结构
                const memberId = typeof member === 'string' ? member : member.id;
                const colorInput = document.getElementById(`member-color-${memberId}`);
                if (colorInput) {
                    chatSettings.memberBubbleColors[memberId] = colorInput.value;
                }
            });

            saveCurrentChatSettings(chatSettings);
            hideModal('group-member-colors-modal');

            // 刷新聊天界面以应用新颜色
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }

            showToast('群成员气泡颜色已保存', 'success');
        }

        // 头像上传处理函数
        function avatarUploadHandler(e) {
            console.log('avatar-upload change事件被触发');
            if (e.target.files && e.target.files[0]) {
                const file = e.target.files[0];

                console.log('选择了文件:', file.name, '大小:', file.size, 'bytes', '类型:', file.type);

                // 检查文件类型
                if (!file.type.startsWith('image/')) {
                    alert('请选择图片文件');
                    e.target.value = ''; // 清空选择
                    return;
                }

                // 检查文件大小 (限制为5MB)
                if (file.size > 5 * 1024 * 1024) {
                    alert('图片文件过大，请选择小于5MB的图片');
                    e.target.value = ''; // 清空选择
                    return;
                }

                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const avatarPreview = document.getElementById('avatar-preview');
                        const avatarPreviewText = document.getElementById('avatar-preview-text');

                        console.log('文件读取成功，开始设置预览');

                        if (!avatarPreview) {
                            console.error('找不到avatar-preview元素');
                            alert('找不到头像预览元素');
                            return;
                        }

                        // 添加has-image类来覆盖默认背景
                        avatarPreview.classList.add('has-image');

                        // 强制设置背景图片并清除所有其他背景样式
                        avatarPreview.style.setProperty('background', `url(${event.target.result})`, 'important');
                        avatarPreview.style.setProperty('background-size', 'cover', 'important');
                        avatarPreview.style.setProperty('background-position', 'center', 'important');
                        avatarPreview.style.setProperty('background-repeat', 'no-repeat', 'important');

                        // 隐藏文字
                        if (avatarPreviewText) {
                            avatarPreviewText.style.display = 'none';
                        }

                        // 存储图片数据用于后续保存
                        window.selectedAvatarData = event.target.result;

                        // 验证样式是否正确设置
                        console.log('头像预览UI更新完成，背景图片已设置');
                        console.log('当前avatar-preview的样式:', {
                            background: avatarPreview.style.background,
                            backgroundSize: avatarPreview.style.backgroundSize,
                            backgroundPosition: avatarPreview.style.backgroundPosition,
                            className: avatarPreview.className
                        });

                        console.log('头像预览设置成功，图片数据已存储');
                    } catch (error) {
                        console.error('设置头像预览时发生错误:', error);
                        alert('设置头像预览失败，请重试: ' + error.message);
                    }
                };

                reader.onerror = function() {
                    console.error('文件读取失败');
                    alert('图片读取失败，请重试');
                    e.target.value = ''; // 清空选择
                };

                reader.readAsDataURL(file);
            } else {
                console.log('没有选择文件或files为空');
            }
        }

        // 加载自定义表情包 - 使用IndexedDB（包含数据迁移）
        async function loadCustomEmojis() {
            try {
                const savedCustomEmojis = await db.customEmojis.toArray();

                if (savedCustomEmojis.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('customEmojis');
                    if (localStorageData) {
                        console.log('检测到localStorage中的自定义表情包数据，开始迁移...');
                        const localEmojis = JSON.parse(localStorageData);

                        // 为迁移的表情包添加isPersonal标识，默认为个人表情包
                        const migratedEmojis = localEmojis.map(emoji => ({
                            ...emoji,
                            isPersonal: emoji.isPersonal !== undefined ? emoji.isPersonal : true
                        }));

                        if (migratedEmojis.length > 0) {
                            await db.customEmojis.bulkAdd(migratedEmojis);
                        }

                        // 🔥【核心修复】只加载个人表情包到内存，库表情包不需要加载到内存
                        customEmojis = migratedEmojis.filter(emoji => emoji.isPersonal !== false);
                        console.log('自定义表情包迁移完成:', customEmojis);
                    } else {
                        customEmojis = [];
                    }
                } else {
                    // 🔥【核心修复】只加载个人表情包到内存，库表情包不需要加载到内存
                    customEmojis = savedCustomEmojis.filter(emoji => emoji.isPersonal !== false);
                    console.log('从IndexedDB加载个人表情包:', customEmojis);
                }

                // 🔧【修复】recentEmojis也从IndexedDB加载，彻底解决localStorage问题
                const savedRecentEmojis = await db.recentEmojis.orderBy('lastUsed').reverse().toArray();
                if (savedRecentEmojis.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localRecentEmojis = localStorage.getItem('recentEmojis');
                    if (localRecentEmojis) {
                        console.log('检测到localStorage中的recentEmojis数据，开始迁移...');
                        const localRecents = JSON.parse(localRecentEmojis);

                        if (localRecents.length > 0) {
                            // 限制为10个
                            const limitedRecents = localRecents.slice(0, 10);
                            const recentEmojisWithId = limitedRecents.map((emoji, index) => ({
                                id: index + 1,
                                url: emoji.url,
                                description: emoji.description || '表情包',
                                lastUsed: Date.now() - index * 1000
                            }));
                            await db.recentEmojis.bulkAdd(recentEmojisWithId);
                            recentEmojis = limitedRecents;

                            // 清理localStorage
                            localStorage.removeItem('recentEmojis');
                            console.log('recentEmojis迁移完成并清理localStorage');
                        } else {
                            recentEmojis = [];
                        }
                    } else {
                        recentEmojis = [];
                    }
                } else {
                    // 从IndexedDB转换回原格式
                    recentEmojis = savedRecentEmojis.map(item => ({
                        url: item.url,
                        description: item.description
                    }));
                    console.log('从IndexedDB加载recentEmojis:', recentEmojis);
                }
            } catch (error) {
                console.error('加载自定义表情包失败:', error);
                // 如果IndexedDB失败，尝试从localStorage加载
                const localStorageData = localStorage.getItem('customEmojis');
                if (localStorageData) {
                    customEmojis = JSON.parse(localStorageData);
                    console.log('从localStorage备份加载自定义表情包:', customEmojis);
                } else {
                    customEmojis = [];
                }

                // 尝试从IndexedDB加载recentEmojis
                try {
                    const savedRecentEmojis = await db.recentEmojis.orderBy('lastUsed').reverse().toArray();
                    if (savedRecentEmojis.length > 0) {
                        recentEmojis = savedRecentEmojis.map(item => ({
                            url: item.url,
                            description: item.description
                        }));
                    } else {
                        recentEmojis = [];
                    }
                } catch (dbError) {
                    // 如果IndexedDB失败，尝试从localStorage加载
                    const localRecentEmojis = localStorage.getItem('recentEmojis');
                    if (localRecentEmojis) {
                        recentEmojis = JSON.parse(localRecentEmojis);
                    } else {
                        recentEmojis = [];
                    }
                }
            }
        }

        // 保存自定义表情包 - 使用IndexedDB
        async function saveCustomEmojis() {
            try {
                // 🔥【关键修复】只删除个人表情包，保护库表情包
                await db.transaction('rw', db.customEmojis, async () => {
                    // 先删除所有个人表情包（isPersonal为true或undefined的记录）
                    // 保留库表情包（isPersonal为false的记录）

                    // 🔥【修复】使用filter方法而不是where().equals()来避免undefined值的索引问题
                    // 删除所有个人表情包（isPersonal !== false）
                    await db.customEmojis.filter(emoji => emoji.isPersonal !== false).delete();

                    // 然后添加当前的个人表情包，确保isPersonal字段有明确的值
                    if (customEmojis.length > 0) {
                        const personalEmojis = customEmojis.map(emoji => ({
                            ...emoji,
                            isPersonal: true // 🔥【修复】确保个人表情包有明确的isPersonal值
                        }));
                        await db.customEmojis.bulkAdd(personalEmojis);
                    }
                });

                console.log('个人表情包保存成功');
            } catch (error) {
                console.error('保存自定义表情包失败:', error);
                showToast('❌ 表情包保存失败', 'error');
            }
        }

        // 显示自定义表情包面板
        function showCustomEmojiPanel() {
            const panel = document.getElementById('custom-emoji-panel');
            const isVisible = panel.style.display === 'block';

            if (isVisible) {
                panel.style.display = 'none';
                document.removeEventListener('click', hideCustomEmojiPanel);
            } else {
                panel.style.display = 'block';
                renderEmojiGrid();

                // 点击其他地方关闭面板
                setTimeout(() => {
                    document.addEventListener('click', hideCustomEmojiPanel);
                }, 100);
            }
        }

        // 隐藏自定义表情包面板
        function hideCustomEmojiPanel(e) {
            const panel = document.getElementById('custom-emoji-panel');

            // 如果没有传递事件参数，直接隐藏面板
            if (!e) {
                if (panel) {
                    panel.style.display = 'none';
                    document.removeEventListener('click', hideCustomEmojiPanel);
                }
                return;
            }

            const emojiBtn = e.target.closest('.chat-action-btn');

            if (panel && !panel.contains(e.target) && !emojiBtn) {
                panel.style.display = 'none';
                document.removeEventListener('click', hideCustomEmojiPanel);
            }
        }

        // 渲染表情包网格
        async function renderEmojiGrid() {
            const grid = document.getElementById('emoji-grid');
            grid.innerHTML = '';

            let emojisToShow = [];

            if (currentEmojiTab === 'recent') {
                emojisToShow = await getFilteredEmojis(recentEmojis);
            } else if (currentEmojiTab === 'custom') {
                emojisToShow = await getFilteredEmojis(customEmojis);
            }

            // 添加表情包
            emojisToShow.forEach((emoji, index) => {
                const emojiItem = document.createElement('div');
                emojiItem.className = 'custom-emoji-item';
                emojiItem.style.backgroundImage = emoji.url && emoji.url !== 'undefined' ? `url(${emoji.url})` : 'none';
                emojiItem.onclick = () => sendEmojiMessage(emoji);

                // 为自定义表情包和最近使用表情包添加删除按钮
                if (currentEmojiTab === 'custom' || currentEmojiTab === 'recent') {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'emoji-delete-btn';
                    deleteBtn.innerHTML = '×';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        if (currentEmojiTab === 'custom') {
                        deleteCustomEmoji(index);
                        } else if (currentEmojiTab === 'recent') {
                            deleteRecentEmoji(index);
                        }
                    };
                    emojiItem.appendChild(deleteBtn);
                }

                grid.appendChild(emojiItem);
            });

            // 如果是自定义标签页，添加上传按钮
            if (currentEmojiTab === 'custom') {
                const uploadItem = document.createElement('div');
                uploadItem.className = 'custom-emoji-item placeholder';
                uploadItem.innerHTML = '+';
                uploadItem.onclick = () => document.getElementById('emoji-upload').click();
                grid.appendChild(uploadItem);
            }

            // 如果没有表情包，显示提示
            if (emojisToShow.length === 0) {
                const emptyMsg = document.createElement('div');
                emptyMsg.className = 'empty-emoji-grid';

                                                if (currentEmojiTab === 'recent') {
                                    emptyMsg.textContent = '还没有使用过表情包';
                                } else {
                                    emptyMsg.textContent = '还没有表情包，点击+号添加';
                                }

                grid.appendChild(emptyMsg);
            }
        }

        // 发送表情包消息
        async function sendEmojiMessage(emoji) {
            console.log('🎭 发送表情包:', emoji);

            if (!currentChatCharacter) return;

            // 添加到最近使用
            addToRecentEmojis(emoji);

            // 🔥【修复】表情包消息只显示图片，不显示文字内容
            const messageId = Date.now().toString();
            const emojiMessage = {
                id: messageId,
                sender: 'sent',
                content: '', // 表情包消息不显示文字内容
                image: emoji.url,
                isEmoji: true,
                emojiDescription: emoji.description || '自定义表情包',
                timestamp: Date.now()
            };

            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }

            chatMessages[currentChatCharacter.id].push(emojiMessage);
            // 🔥【高效保存】直接添加单条表情包消息到数据库，避免全量重写
            try {
                const stableId = `${currentChatCharacter.id}_${emojiMessage.id}_${chatMessages[currentChatCharacter.id].length - 1}`;
                await db.chatMessages.add({
                    id: stableId,
                    characterId: currentChatCharacter.id,
                    timestamp: emojiMessage.timestamp,
                    messageOrder: chatMessages[currentChatCharacter.id].length - 1,
                    originalMessageId: emojiMessage.id,
                    messageData: emojiMessage
                });
                console.log('✅ [高效表情包] 表情包消息已保存到数据库');
            } catch (error) {
                console.error('表情包消息单条保存失败，回退到批量保存:', error);
                saveChatMessages();
            }

            // 渲染消息
            renderChatMessages(currentChatCharacter.id);

            // 🔥【新增】触发角色状态更新
            triggerStatusUpdateAfterMessage(currentChatCharacter.id);

            // 隐藏表情包面板
            hideCustomEmojiPanel();

            // 设置待回复消息，支持智能回复按钮
            pendingUserMessage = emojiMessage;

            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = '点击获取AI回复';
            }

            // 注释掉自动回复，改为手动回复模式
            // setTimeout(() => {
            //     sendAIEmojiResponse(emoji);
            // }, 1000 + Math.random() * 2000);
        }

        // 保存最近使用的表情包到IndexedDB
        async function saveRecentEmojis() {
            try {
                // 限制最近使用表情包数量为10个
                const maxRecentEmojis = 10;
                if (recentEmojis.length > maxRecentEmojis) {
                    recentEmojis = recentEmojis.slice(0, maxRecentEmojis);
                }

                await db.transaction('rw', db.recentEmojis, async () => {
                    await db.recentEmojis.clear();
                    if (recentEmojis.length > 0) {
                        const recentEmojisWithId = recentEmojis.map((emoji, index) => ({
                            id: index + 1,
                            url: emoji.url,
                            description: emoji.description || '表情包',
                            lastUsed: Date.now() - index * 1000 // 确保顺序
                        }));
                        await db.recentEmojis.bulkAdd(recentEmojisWithId);
                    }
                });
            } catch (error) {
                console.error('保存最近表情包失败:', error);
            }
        }

        // 添加到最近使用的表情包
        async function addToRecentEmojis(emoji) {
            // 移除已存在的相同表情包
            recentEmojis = recentEmojis.filter(e => e.url !== emoji.url);

            // 添加到开头
            recentEmojis.unshift(emoji);

            // 限制最近使用数量为20个
            if (recentEmojis.length > 20) {
                recentEmojis = recentEmojis.slice(0, 20);
            }

            // 只保存最近使用的表情包，不触发个人表情包保存
            await saveRecentEmojis();
        }

        // 检测当前模型是否支持视觉功能
        function isVisionModelSupported() {
            // 支持视觉的模型列表
            const visionModels = [
                // OpenAI GPT系列
                'gpt-4-vision',
                'gpt-4o',
                'gpt-4-turbo',
                'gpt-4o-mini',

                // Google Gemini系列
                'gemini-1.5-pro',
                'gemini-1.5-flash',
                'gemini-2.0-flash',
                'gemini-2.5-pro',
                'gemini-2.5-flash',
                'gemini-exp',
                'gemini-pro-vision',

                // Anthropic Claude系列
                'claude-3-opus',
                'claude-3-sonnet',
                'claude-3-haiku',
                'claude-3.5-sonnet',
                'claude-3.5-haiku',

                // 国产模型
                'qwen-vl',
                'qwen2-vl',
                'yi-vision',
                'glm-4v',
                'internvl',
                'cogvlm',

                // 其他模型
                'llava',
                'moondream',
                'phi-3-vision'
            ];

            const currentModel = apiSettings.model?.toLowerCase() || '';

            // 检查当前模型是否包含任何支持视觉的模型名称
            const isVisionSupported = visionModels.some(model => currentModel.includes(model.toLowerCase()));

            // 输出调试信息
            console.log('当前模型:', currentModel);
            console.log('是否支持视觉:', isVisionSupported);

            return isVisionSupported;
        }

        // 注释：AI对表情包的自动回复功能已移除，现在使用手动回复模式
        // 表情包和图片都通过智能回复按钮来触发AI回复

        // 删除自定义表情包
        function deleteCustomEmoji(index) {
            if (confirm('确定要删除这个表情包吗？')) {
                customEmojis.splice(index, 1);
                saveCustomEmojis();
                renderEmojiGrid();
            }
        }

        // 删除最近使用的表情包
        function deleteRecentEmoji(index) {
            if (confirm('确定要从最近使用中删除这个表情包吗？')) {
                recentEmojis.splice(index, 1);
                saveCustomEmojis(); // 🔧【修复】现在使用IndexedDB保存
                renderEmojiGrid();
            }
        }

        // 初始化表情包上传功能
        function initializeEmojiUpload() {
            const emojiInput = document.getElementById('emoji-upload');
            if (emojiInput) {
                emojiInput.addEventListener('change', handleEmojiUpload);
            }

            // 绑定标签页切换事件
            document.querySelectorAll('.emoji-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    // 移除所有active类
                    document.querySelectorAll('.emoji-tab').forEach(t => t.classList.remove('active'));
                    // 添加当前active类
                    this.classList.add('active');

                    // 切换当前标签页
                    currentEmojiTab = this.dataset.tab;
                    renderEmojiGrid();
                });
            });
        }

        // 切换工具面板显示/隐藏
        function toggleToolsPanel() {
            const panel = document.getElementById('tools-panel');
            const toggleBtn = document.getElementById('toggle-tools-btn');
            const emojiPanel = document.getElementById('custom-emoji-panel');

            if (!panel || !toggleBtn) return;

            const isVisible = panel.style.display === 'block';

            if (isVisible) {
                // 隐藏工具面板
                hideToolsPanel();
            } else {
                // 显示工具面板
                showToolsPanel();

                // 隐藏表情包面板
                if (emojiPanel) {
                    emojiPanel.style.display = 'none';
                }

                // 点击其他地方关闭面板
                setTimeout(() => {
                    document.addEventListener('click', handleToolsPanelOutsideClick);
                }, 100);
            }
        }

        // 显示工具面板
        function showToolsPanel() {
            const panel = document.getElementById('tools-panel');
            const toggleBtn = document.getElementById('toggle-tools-btn');

            // 🔥【新增】根据聊天类型显示/隐藏单聊专用工具项
            const singleChatOnlyItems = document.querySelectorAll('.single-chat-only');
            const isGroupChat = currentChatCharacter && currentChatCharacter.isGroup;
            singleChatOnlyItems.forEach(item => {
                if (isGroupChat) {
                    item.style.display = 'none';
                } else {
                    item.style.display = '';
                }
            });

            if (panel) {
                panel.style.display = 'block';
                panel.style.animation = 'toolsPanelSlideUp 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)';
            }

            if (toggleBtn) {
                toggleBtn.classList.add('active');
            }
        }

        // 隐藏工具面板
        function hideToolsPanel() {
            const panel = document.getElementById('tools-panel');
            const toggleBtn = document.getElementById('toggle-tools-btn');

            if (panel) {
                panel.style.display = 'none';
            }

            if (toggleBtn) {
                toggleBtn.classList.remove('active');
            }

            // 移除点击外部关闭的事件监听器
            document.removeEventListener('click', handleToolsPanelOutsideClick);
        }

        // 处理工具面板外部点击事件
        function handleToolsPanelOutsideClick(e) {
            const panel = document.getElementById('tools-panel');
            const toggleBtn = document.getElementById('toggle-tools-btn');

            // 如果点击的是工具面板内部或触发按钮，不关闭面板
            if (panel && !panel.contains(e.target) &&
                toggleBtn && !toggleBtn.contains(e.target)) {
                hideToolsPanel();
            }
        }

        // 处理表情包上传
        function handleEmojiUpload(e) {
            const files = e.target.files;
            if (!files || files.length === 0) return;

            Array.from(files).forEach(file => {
                if (!file.type.startsWith('image/')) {
                    alert('请选择图片文件');
                    return;
                }

                // 检查GIF格式，提醒用户可能的问题
                if (file.type === 'image/gif') {
                    const confirmed = confirm('检测到GIF格式的表情包！\n\n⚠️ 注意事项：\n• AI可以发送这个GIF动图\n• 但Gemini API无法识别GIF内容\n• 重新生成功能可能失效\n• 建议使用静态图片格式\n\n是否仍要上传这个GIF表情包？');
                    if (!confirmed) {
                        return;
                    }
                }

                if (file.size > 5 * 1024 * 1024) {
                    alert('图片文件过大，请选择小于5MB的图片');
                    return;
                }

                const reader = new FileReader();
                reader.onload = function(event) {
                    // 准备个人表情包数据
                    const emojiData = {
                        id: Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9),
                        url: event.target.result,
                        addedAt: new Date().toISOString(),
                        isPersonal: true // 标识为个人表情包
                    };

                    // 存储待处理的表情包数据
                    pendingPersonalEmojiData = emojiData;

                    // 显示描述添加模态框
                    showPersonalEmojiDescriptionModal(event.target.result);
                };

                reader.readAsDataURL(file);
            });

            // 清空文件输入
            e.target.value = '';
        }

        // 显示个人表情包描述添加模态框
        function showPersonalEmojiDescriptionModal(imageUrl) {
            const modal = document.getElementById('personal-emoji-description-modal');
            const previewImage = document.getElementById('personal-emoji-preview-image');
            const descriptionInput = document.getElementById('personal-emoji-description-input');

            // 设置预览图片
            previewImage.src = imageUrl;

            // 清空描述输入框
            descriptionInput.value = '';

            // 显示模态框
            modal.style.display = 'flex';

            // 聚焦到描述输入框
            setTimeout(() => {
                descriptionInput.focus();
            }, 100);

            // 添加键盘事件监听
            const handleKeyDown = (e) => {
                if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                    // Ctrl+Enter 或 Cmd+Enter 确认
                    confirmPersonalEmojiDescription();
                    descriptionInput.removeEventListener('keydown', handleKeyDown);
                } else if (e.key === 'Escape') {
                    // Esc 取消
                    hidePersonalEmojiDescriptionModal();
                    descriptionInput.removeEventListener('keydown', handleKeyDown);
                }
            };

            descriptionInput.addEventListener('keydown', handleKeyDown);
        }

        // 隐藏个人表情包描述添加模态框
        function hidePersonalEmojiDescriptionModal(event) {
            if (event && event.target !== event.currentTarget) {
                return;
            }

            const modal = document.getElementById('personal-emoji-description-modal');
            modal.style.display = 'none';

            // 清空待处理的数据
            pendingPersonalEmojiData = null;
        }

        // 确认个人表情包描述
        function confirmPersonalEmojiDescription() {
            if (!pendingPersonalEmojiData) return;

            const descriptionInput = document.getElementById('personal-emoji-description-input');
            const description = descriptionInput.value.trim() || '表情包';

            // 创建新的表情包
            const emoji = {
                id: pendingPersonalEmojiData.id,
                url: pendingPersonalEmojiData.url,
                description: description,
                addedAt: pendingPersonalEmojiData.addedAt,
                isPersonal: pendingPersonalEmojiData.isPersonal
            };

            customEmojis.push(emoji);
            saveCustomEmojis();

            // 如果当前在自定义标签页，重新渲染
            if (currentEmojiTab === 'custom') {
                renderEmojiGrid();
            }

            // 隐藏模态框
            document.getElementById('personal-emoji-description-modal').style.display = 'none';

            // 清空待处理的数据
            pendingPersonalEmojiData = null;

            // 显示成功提示
            showToast('表情包已添加', 'success');
        }

        // ===== 表情包库功能 =====

        // 加载表情包库
        async function loadEmojiLibraries() {
            try {
                emojiLibraries = await db.emojiLibraries.toArray();
                renderEmojiLibraryList();
            } catch (error) {
                console.error('加载表情包库失败:', error);
                emojiLibraries = [];
            }
        }

        // 保存表情包库
        async function saveEmojiLibraries() {
            try {
                await db.transaction('rw', db.emojiLibraries, async () => {
                    await db.emojiLibraries.clear();
                    if (emojiLibraries.length > 0) {
                        await db.emojiLibraries.bulkAdd(emojiLibraries);
                    }
                });
                console.log('表情包库保存成功');
            } catch (error) {
                console.error('保存表情包库失败:', error);
            }
        }

        // 切换面具区域展开/收起
        function togglePersonaSection() {
            const content = document.getElementById('persona-content');
            const chevron = document.getElementById('persona-chevron');

            isPersonaExpanded = !isPersonaExpanded;

            if (isPersonaExpanded) {
                content.style.display = 'block';
                chevron.classList.add('expanded');
            } else {
                content.style.display = 'none';
                chevron.classList.remove('expanded');
            }
        }

        // 切换表情包库区域展开/收起
        function toggleEmojiLibrarySection() {
            const content = document.getElementById('emoji-library-content');
            const chevron = document.getElementById('emoji-library-chevron');

            isEmojiLibraryExpanded = !isEmojiLibraryExpanded;

            if (isEmojiLibraryExpanded) {
                content.style.display = 'block';
                chevron.classList.add('expanded');
                renderEmojiLibraryList();
            } else {
                content.style.display = 'none';
                chevron.classList.remove('expanded');
            }
        }

        // 渲染表情包库列表
        function renderEmojiLibraryList() {
            const listContainer = document.getElementById('emoji-library-list');
            if (!listContainer) return;

            if (emojiLibraries.length === 0) {
                listContainer.innerHTML = `
                    <div class="emoji-library-empty-state">
                        <p>还没有表情包库</p>
                        <p>点击上方按钮创建第一个表情包库</p>
                    </div>
                `;
                return;
            }

            listContainer.innerHTML = emojiLibraries.map(library => `
                <div class="emoji-library-item" onclick="openEmojiLibrary('${library.id}')">
                    <div class="emoji-library-item-info">
                        <div class="emoji-library-item-name">${library.name}</div>
                        <div class="emoji-library-item-stats" id="library-stats-${library.id}">计算中...</div>
                    </div>
                    <div class="emoji-library-item-actions">
                        <div class="emoji-library-action-btn" onclick="event.stopPropagation(); editEmojiLibrary('${library.id}')" title="编辑">
                            <i class="fas fa-edit"></i>
                        </div>
                        <div class="emoji-library-action-btn delete" onclick="event.stopPropagation(); deleteEmojiLibrary('${library.id}')" title="删除">
                            <i class="fas fa-trash"></i>
                        </div>
                    </div>
                </div>
            `).join('');

            // 异步更新每个库的统计信息
            emojiLibraries.forEach(async (library) => {
                const count = await getEmojiLibraryItemCount(library.id);
                const statsElement = document.getElementById(`library-stats-${library.id}`);
                if (statsElement) {
                    statsElement.textContent = `${count} 个表情包`;
                }
            });
        }

        // 获取表情包库中的表情包数量
        async function getEmojiLibraryItemCount(libraryId) {
            try {
                const count = await db.emojiLibraryItems.where('libraryId').equals(libraryId).count();
                return count;
            } catch (error) {
                console.error('获取表情包库统计失败:', error);
                return 0;
            }
        }

        // 🔥【紧急修复】详细检查所有表情包数据
        async function checkAllEmojiData() {
            console.log('🚨 [URGENT] 详细检查所有表情包数据...');

            try {
                // 获取所有表情包
                const allEmojis = await db.customEmojis.toArray();
                console.log('🚨 [URGENT] 数据库中所有表情包:');

                allEmojis.forEach((emoji, index) => {
                    console.log(`${index + 1}. ID: ${emoji.id}`);
                    console.log(`   描述: "${emoji.description}"`);
                    console.log(`   文件名: ${emoji.name}`);
                    console.log(`   上传时间: ${emoji.uploadTime}`);
                    console.log(`   isPersonal: ${emoji.isPersonal}`);
                    console.log(`   ---`);
                });

                // 检查关联记录
                const allItems = await db.emojiLibraryItems.toArray();
                console.log('🚨 [URGENT] 所有关联记录:');
                allItems.forEach(item => {
                    console.log(`  库: ${item.libraryId} -> 表情包: ${item.emojiId}`);
                });

                // 检查是否有表情包被错误标记为个人表情包
                const recentEmojis = allEmojis.filter(emoji => {
                    const uploadTime = new Date(emoji.uploadTime);
                    const now = new Date();
                    const hoursDiff = (now - uploadTime) / (1000 * 60 * 60);
                    return hoursDiff < 24; // 最近24小时上传的
                });

                console.log('🚨 [URGENT] 最近24小时上传的表情包:', recentEmojis.length, '个');
                recentEmojis.forEach(emoji => {
                    console.log(`  最近: "${emoji.description}" isPersonal: ${emoji.isPersonal}`);
                });

                return {
                    allEmojis: allEmojis,
                    recentEmojis: recentEmojis,
                    associations: allItems
                };

            } catch (error) {
                console.error('🚨 [URGENT] 检查失败:', error);
                return { error: error.message };
            }
        }

        // 🚨【数据丢失诊断】检查浏览器存储状态
        async function diagnoseBrowserStorage() {
            console.log('🚨 [DIAGNOSE] 开始诊断浏览器存储状态...');

            try {
                // 检查存储配额
                if ('storage' in navigator && 'estimate' in navigator.storage) {
                    const estimate = await navigator.storage.estimate();
                    console.log('🚨 [DIAGNOSE] 浏览器存储状态:', {
                        已使用: Math.round(estimate.usage / 1024 / 1024) + 'MB',
                        总配额: Math.round(estimate.quota / 1024 / 1024) + 'MB',
                        使用率: Math.round(estimate.usage / estimate.quota * 100) + '%'
                    });
                }

                // 检查IndexedDB数据库大小
                const allEmojis = await db.customEmojis.toArray();
                const totalSize = allEmojis.reduce((size, emoji) => {
                    return size + (emoji.url ? emoji.url.length : 0);
                }, 0);

                console.log('🚨 [DIAGNOSE] IndexedDB表情包数据:', {
                    表情包数量: allEmojis.length,
                    估计大小: Math.round(totalSize / 1024 / 1024) + 'MB'
                });

                // 检查是否有浏览器清理的迹象
                const oldestEmoji = allEmojis.reduce((oldest, emoji) => {
                    const emojiTime = new Date(emoji.uploadTime);
                    const oldestTime = new Date(oldest.uploadTime);
                    return emojiTime < oldestTime ? emoji : oldest;
                }, allEmojis[0]);

                if (oldestEmoji) {
                    const oldestTime = new Date(oldestEmoji.uploadTime);
                    const hoursSinceOldest = (new Date() - oldestTime) / (1000 * 60 * 60);
                    console.log('🚨 [DIAGNOSE] 最老的表情包:', {
                        描述: oldestEmoji.description,
                        上传时间: oldestEmoji.uploadTime,
                        距今小时数: Math.round(hoursSinceOldest)
                    });
                }

                return {
                    allEmojis: allEmojis,
                    totalSize: totalSize
                };

            } catch (error) {
                console.error('🚨 [DIAGNOSE] 诊断失败:', error);
                return { error: error.message };
            }
        }

        // 🚨【紧急恢复】重新上传丢失的表情包
        function showEmojiRecoveryInstructions() {
            console.log('🚨 [RECOVERY] 表情包数据完全丢失，需要重新上传');

            const instructions = `
🚨 表情包数据丢失恢复指南：

1. 你的表情包数据已经完全丢失，需要重新上传
2. 为了避免再次丢失，建议：

   📱 手机端操作：
   - 重新创建表情包库
   - 重新上传表情包
   - 上传后立即测试AI是否能使用

   💾 数据备份：
   - 上传完成后，导出表情包库作为备份
   - 定期检查表情包库状态

   🔧 预防措施：
   - 避免在上传过程中刷新页面
   - 确保网络连接稳定
   - 一次不要上传太多表情包

3. 如果问题再次发生，可能需要检查：
   - 浏览器存储设置
   - 是否有自动清理数据的扩展
   - 设备存储空间是否充足
            `;

            console.log(instructions);
            showToast('请查看控制台的恢复指南', 'info');

            return instructions;
        }

        // 🔥【紧急修复】手动恢复表情包库关联
        async function manualRecoverEmojis(libraryName) {
            console.log('🚨 [MANUAL] 手动恢复表情包库:', libraryName);

            try {
                // 找到目标库
                const targetLibrary = emojiLibraries.find(lib => lib.name === libraryName);
                if (!targetLibrary) {
                    console.error('🚨 [MANUAL] 找不到库:', libraryName);
                    return;
                }

                // 获取所有没有关联记录的库表情包
                const allLibraryEmojis = await db.customEmojis.where('isPersonal').equals(false).toArray();
                const existingItems = await db.emojiLibraryItems.toArray();

                const orphanedEmojis = allLibraryEmojis.filter(emoji =>
                    !existingItems.some(item => item.emojiId === emoji.id)
                );

                console.log('🚨 [MANUAL] 找到孤立表情包:', orphanedEmojis.length, '个');
                orphanedEmojis.forEach(emoji => {
                    console.log(`  - "${emoji.description}" (${emoji.id})`);
                });

                // 将所有孤立的表情包关联到目标库
                const newAssociations = orphanedEmojis.map(emoji => ({
                    libraryId: targetLibrary.id,
                    emojiId: emoji.id,
                    addedAt: emoji.uploadTime || new Date().toISOString()
                }));

                if (newAssociations.length > 0) {
                    await db.emojiLibraryItems.bulkAdd(newAssociations);
                    console.log('🚨 [MANUAL] 恢复了', newAssociations.length, '个关联记录到库:', libraryName);

                    // 重新加载统计
                    await loadEmojiLibraries();
                    showToast(`成功恢复 ${newAssociations.length} 个表情包到 ${libraryName}`, 'success');
                } else {
                    showToast('没有找到需要恢复的表情包', 'info');
                }

            } catch (error) {
                console.error('🚨 [MANUAL] 手动恢复失败:', error);
                showToast('恢复失败: ' + error.message, 'error');
            }
        }

        // 🔥【新增】修复工具：恢复丢失的表情包库关联记录
        async function recoverEmojiLibraryAssociations() {
            console.log('🔧 [RECOVER] 开始恢复表情包库关联记录...');

            try {
                // 获取所有表情包库
                const libraries = await db.emojiLibraries.toArray();
                console.log('🔧 [RECOVER] 找到表情包库:', libraries.length, '个');

                // 获取所有库表情包（isPersonal === false）
                const libraryEmojis = await db.customEmojis.where('isPersonal').equals(false).toArray();
                console.log('🔧 [RECOVER] 找到库表情包:', libraryEmojis.length, '个');
                console.log('🔧 [RECOVER] 库表情包详情:', libraryEmojis.map(e => ({
                    id: e.id,
                    name: e.name,
                    description: e.description,
                    uploadTime: e.uploadTime
                })));

                // 获取现有的关联记录
                const existingItems = await db.emojiLibraryItems.toArray();
                console.log('🔧 [RECOVER] 现有关联记录:', existingItems.length, '个');

                // 找出没有关联记录的库表情包
                const orphanedEmojis = libraryEmojis.filter(emoji =>
                    !existingItems.some(item => item.emojiId === emoji.id)
                );
                console.log('🔧 [RECOVER] 孤立的库表情包:', orphanedEmojis.length, '个');

                if (orphanedEmojis.length > 0) {
                    console.log('🔧 [RECOVER] 孤立表情包详情:', orphanedEmojis.map(e => ({
                        id: e.id,
                        name: e.name,
                        description: e.description,
                        uploadTime: e.uploadTime
                    })));

                    // 提供手动分配选项
                    const libraryOptions = libraries.map((lib, index) => `${index + 1}. ${lib.name}`).join('\n');
                    const choice = prompt(`发现 ${orphanedEmojis.length} 个孤立的表情包需要重新分配到表情包库。\n\n可用的表情包库：\n${libraryOptions}\n\n请选择要分配到的库（输入数字），或输入 'auto' 自动分配：`);

                    if (choice === null) {
                        showToast('取消恢复操作', 'info');
                        return;
                    }

                    const recoveredAssociations = [];

                    if (choice.toLowerCase() === 'auto') {
                        // 自动分配：根据上传时间
                        for (const emoji of orphanedEmojis) {
                            const emojiTime = new Date(emoji.uploadTime).getTime();
                            let bestLibrary = null;
                            let minTimeDiff = Infinity;

                            for (const library of libraries) {
                                const libraryTime = new Date(library.createdAt).getTime();
                                const timeDiff = Math.abs(emojiTime - libraryTime);

                                if (timeDiff < minTimeDiff) {
                                    minTimeDiff = timeDiff;
                                    bestLibrary = library;
                                }
                            }

                            if (bestLibrary) {
                                recoveredAssociations.push({
                                    libraryId: bestLibrary.id,
                                    emojiId: emoji.id,
                                    addedAt: emoji.uploadTime || new Date().toISOString()
                                });

                                console.log(`🔧 [RECOVER] 自动分配表情包 "${emoji.description}" 到库 "${bestLibrary.name}"`);
                            }
                        }
                    } else {
                        // 手动分配：所有表情包分配到指定库
                        const libraryIndex = parseInt(choice) - 1;
                        if (libraryIndex >= 0 && libraryIndex < libraries.length) {
                            const targetLibrary = libraries[libraryIndex];

                            for (const emoji of orphanedEmojis) {
                                recoveredAssociations.push({
                                    libraryId: targetLibrary.id,
                                    emojiId: emoji.id,
                                    addedAt: emoji.uploadTime || new Date().toISOString()
                                });

                                console.log(`🔧 [RECOVER] 手动分配表情包 "${emoji.description}" 到库 "${targetLibrary.name}"`);
                            }
                        } else {
                            showToast('无效的库选择', 'error');
                            return;
                        }
                    }

                    if (recoveredAssociations.length > 0) {
                        await db.emojiLibraryItems.bulkAdd(recoveredAssociations);
                        console.log('🔧 [RECOVER] 恢复了', recoveredAssociations.length, '个关联记录');

                        // 重新加载库列表以更新统计
                        await loadEmojiLibraries();

                        showToast(`成功恢复 ${recoveredAssociations.length} 个表情包的关联记录`, 'success');
                    } else {
                        showToast('没有找到需要恢复的关联记录', 'info');
                    }
                } else {
                    showToast('所有表情包都有正确的关联记录', 'success');
                }

            } catch (error) {
                console.error('🔧 [RECOVER] 恢复关联记录失败:', error);
                showToast('恢复失败: ' + error.message, 'error');
            }
        }

        // 显示创建表情包库表单
        function showCreateLibraryForm() {
            document.getElementById('emoji-library-form-title').textContent = '新建表情包库';
            document.getElementById('emoji-library-name-input').value = '';
            document.getElementById('emoji-library-description-input').value = '';
            document.getElementById('emoji-library-form-modal').style.display = 'flex';
            currentEmojiLibrary = null;
        }

        // 编辑表情包库
        function editEmojiLibrary(libraryId) {
            const library = emojiLibraries.find(lib => lib.id === libraryId);
            if (!library) return;

            document.getElementById('emoji-library-form-title').textContent = '编辑表情包库';
            document.getElementById('emoji-library-name-input').value = library.name;
            document.getElementById('emoji-library-description-input').value = library.description || '';
            document.getElementById('emoji-library-form-modal').style.display = 'flex';
            currentEmojiLibrary = library;
        }

        // 隐藏表情包库表单
        function hideEmojiLibraryForm(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('emoji-library-form-modal').style.display = 'none';
            currentEmojiLibrary = null;
        }

        // 保存表情包库
        async function saveEmojiLibrary() {
            const name = document.getElementById('emoji-library-name-input').value.trim();
            const description = document.getElementById('emoji-library-description-input').value.trim();

            if (!name) {
                alert('请输入库名称');
                return;
            }

            try {
                if (currentEmojiLibrary) {
                    // 编辑现有库
                    currentEmojiLibrary.name = name;
                    currentEmojiLibrary.description = description;
                    currentEmojiLibrary.updatedAt = new Date().toISOString();

                    await db.emojiLibraries.put(currentEmojiLibrary);
                } else {
                    // 创建新库
                    const newLibrary = {
                        id: `library_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                        name: name,
                        description: description,
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    };

                    emojiLibraries.push(newLibrary);
                    await db.emojiLibraries.add(newLibrary);
                }

                hideEmojiLibraryForm();
                renderEmojiLibraryList();
                showToast(currentEmojiLibrary ? '表情包库更新成功' : '表情包库创建成功', 'success');
            } catch (error) {
                console.error('保存表情包库失败:', error);
                showToast('保存失败', 'error');
            }
        }

        // 删除表情包库
        async function deleteEmojiLibrary(libraryId) {
            const library = emojiLibraries.find(lib => lib.id === libraryId);
            if (!library) return;

            const count = await getEmojiLibraryItemCount(libraryId);
            const confirmMsg = count > 0
                ? `确定要删除表情包库"${library.name}"吗？\n\n这个库中有 ${count} 个表情包，删除后表情包将回到未分类状态。`
                : `确定要删除表情包库"${library.name}"吗？`;

            if (!confirm(confirmMsg)) return;

            try {
                // 删除库中的所有关联记录
                await db.emojiLibraryItems.where('libraryId').equals(libraryId).delete();

                // 删除库本身
                await db.emojiLibraries.delete(libraryId);

                // 从内存中移除
                emojiLibraries = emojiLibraries.filter(lib => lib.id !== libraryId);

                renderEmojiLibraryList();
                showToast('表情包库删除成功', 'success');
            } catch (error) {
                console.error('删除表情包库失败:', error);
                showToast('删除失败', 'error');
            }
        }

        // 打开表情包库详情页面
        async function openEmojiLibrary(libraryId) {
            const library = emojiLibraries.find(lib => lib.id === libraryId);
            if (!library) return;

            currentEmojiLibrary = library;

            // 更新页面标题
            document.getElementById('emoji-library-title').textContent = library.name;

            // 显示页面
            showApp('emoji-library-screen');

            // 加载表情包库内容
            await loadEmojiLibraryContent(libraryId);
        }

        // 加载表情包库内容
        async function loadEmojiLibraryContent(libraryId) {
            try {
                // 获取库中的表情包关联记录
                const libraryItems = await db.emojiLibraryItems.where('libraryId').equals(libraryId).toArray();

                // 获取对应的表情包数据 - 从数据库中直接查找
                const emojiIds = libraryItems.map(item => item.emojiId);
                const allEmojis = await db.customEmojis.where('id').anyOf(emojiIds).toArray();

                // 渲染表情包网格
                renderEmojiLibraryGrid(allEmojis);

            } catch (error) {
                console.error('加载表情包库内容失败:', error);
                showToast('加载失败', 'error');
            }
        }

        // 渲染表情包库网格
        function renderEmojiLibraryGrid(emojis) {
            const grid = document.getElementById('emoji-library-grid');
            const emptyState = document.getElementById('emoji-library-empty');
            const statsContainer = document.getElementById('emoji-library-stats');

            if (emojis.length === 0) {
                grid.style.display = 'none';
                emptyState.style.display = 'block';
                statsContainer.style.display = 'none';
                return;
            }

            grid.style.display = 'grid';
            emptyState.style.display = 'none';
            statsContainer.style.display = 'flex';

            // 计算统计信息
            const totalEmojis = emojis.length;
            const describedEmojis = emojis.filter(emoji =>
                emoji.description && emoji.description !== emoji.name && emoji.description.trim() !== ''
            ).length;
            const undescribedEmojis = totalEmojis - describedEmojis;

            // 更新统计显示
            document.getElementById('total-emojis').textContent = totalEmojis;
            document.getElementById('described-emojis').textContent = describedEmojis;
            document.getElementById('undescribed-emojis').textContent = undescribedEmojis;

            const undescribedWarning = document.getElementById('undescribed-warning');
            if (undescribedEmojis > 0) {
                undescribedWarning.style.display = 'block';
            } else {
                undescribedWarning.style.display = 'none';
            }

            grid.innerHTML = emojis.map(emoji => {
                const hasDescription = emoji.description && emoji.description !== emoji.name && emoji.description.trim() !== '';
                const displayDescription = hasDescription ? emoji.description : '点击添加描述';

                return `
                    <div class="emoji-library-grid-item" data-emoji-id="${emoji.id}">
                        <div class="emoji-image-container">
                            <input type="checkbox" class="emoji-checkbox" data-emoji-id="${emoji.id}" style="display: none;">
                            <img src="${emoji.url}" alt="${emoji.description}" title="${emoji.description}">
                            <button class="remove-btn" onclick="removeEmojiFromLibrary('${emoji.id}')" title="从库中移除">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="emoji-description-area ${!hasDescription ? 'no-description' : ''}"
                             onclick="editEmojiDescription('${emoji.id}')"
                             title="点击编辑描述">
                            <div class="emoji-description-text">${displayDescription}</div>
                            <div class="emoji-description-hint">
                                ${!hasDescription ? '⚠️ 未设置描述' : '✓ 已设置描述'}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // 从表情包库中移除表情包
        async function removeEmojiFromLibrary(emojiId) {
            if (!currentEmojiLibrary) return;

            if (!confirm('确定要从这个表情包库中移除这个表情包吗？\n\n表情包本身不会被删除，只是从当前库中移除。')) {
                return;
            }

            try {
                await db.emojiLibraryItems
                    .where('[libraryId+emojiId]')
                    .equals([currentEmojiLibrary.id, emojiId])
                    .delete();

                // 重新加载库内容
                await loadEmojiLibraryContent(currentEmojiLibrary.id);
                showToast('移除成功', 'success');

            } catch (error) {
                console.error('移除表情包失败:', error);
                showToast('移除失败', 'error');
            }
        }

        // 编辑表情包描述
        async function editEmojiDescription(emojiId) {
            // 🔥【修复】从数据库中查找表情包（因为库表情包不在内存中）
            const emoji = await db.customEmojis.get(emojiId);
            if (!emoji) return;

            // 先移除可能存在的旧模态框
            const existingModal = document.getElementById('emoji-description-modal');
            if (existingModal) {
                existingModal.remove();
            }

            const currentDescription = emoji.description && emoji.description !== emoji.name ? emoji.description : '';

            // 创建编辑模态框
            const modal = document.createElement('div');
            modal.id = 'emoji-description-modal';
            modal.className = 'modal-overlay';
            modal.style.display = 'flex';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 400px;">
                    <div class="modal-header">
                        <h3>编辑表情包描述</h3>
                        <button class="modal-close-btn" onclick="closeEmojiDescriptionModal()">×</button>
                    </div>
                    <div class="modal-body">
                        <div class="emoji-preview" style="text-align: center; margin-bottom: 15px;">
                            <img src="${emoji.url}" alt="表情包预览" style="max-width: 80px; max-height: 80px; border-radius: 8px;">
                        </div>
                        <div class="form-group">
                            <label class="form-label">表情包描述</label>
                            <textarea id="emoji-description-input" class="form-textarea"
                                      placeholder="请描述这个表情包的含义、情绪或使用场景，帮助AI理解何时使用..."
                                      rows="3" maxlength="100">${currentDescription}</textarea>

                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="modal-btn cancel-btn" onclick="closeEmojiDescriptionModal()">取消</button>
                        <button class="modal-btn confirm-btn" onclick="saveEmojiDescription('${emojiId}')">保存</button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // 聚焦到文本框
            setTimeout(() => {
                const textarea = document.getElementById('emoji-description-input');
                if (textarea) {
                    textarea.focus();
                    textarea.setSelectionRange(textarea.value.length, textarea.value.length);
                }
            }, 100);
        }

        // 关闭表情包描述编辑模态框
        function closeEmojiDescriptionModal() {
            const modal = document.getElementById('emoji-description-modal');
            if (modal) {
                modal.remove();
            }
        }

        // 保存表情包描述
        async function saveEmojiDescription(emojiId) {
            const descriptionInput = document.getElementById('emoji-description-input');
            if (!descriptionInput) {
                console.error('找不到描述输入框');
                showToast('保存失败：找不到输入框', 'error');
                return;
            }

            const description = descriptionInput.value.trim();

            if (!description) {
                alert('请输入表情包描述');
                return;
            }

            try {
                // 🔥【修复】从数据库中获取表情包并更新
                const emoji = await db.customEmojis.get(emojiId);
                if (emoji) {
                    emoji.description = description;

                    // 如果是个人表情包，也更新内存中的数据
                    if (emoji.isPersonal !== false) {
                        const memoryEmoji = customEmojis.find(e => e.id === emojiId);
                        if (memoryEmoji) {
                            memoryEmoji.description = description;
                        }
                    }

                    // 更新数据库
                    await db.customEmojis.put(emoji);

                    // 重新加载库内容以更新显示
                    if (currentEmojiLibrary) {
                        await loadEmojiLibraryContent(currentEmojiLibrary.id);
                    }

                    showToast('描述保存成功', 'success');

                    // 关闭模态框
                    closeEmojiDescriptionModal();
                } else {
                    showToast('找不到对应的表情包', 'error');
                }

            } catch (error) {
                console.error('保存表情包描述失败:', error);
                showToast('保存失败', 'error');
            }
        }

        // 隐藏表情包库详情页面
        function hideEmojiLibraryScreen() {
            hideApp('emoji-library-screen');
            currentEmojiLibrary = null;
            // 返回到chatapp的"我"标签页
            showApp('chat-screen');
            switchChatTab('profile-page');
        }



        // 触发表情包上传
        function triggerEmojiUpload() {
            document.getElementById('emoji-library-upload').click();
        }

        // 删除当前表情包库
        async function deleteCurrentEmojiLibrary() {
            if (!currentEmojiLibrary) return;

            if (confirm(`确定要删除表情包库"${currentEmojiLibrary.name}"吗？\n\n删除后无法恢复，但表情包本身不会被删除。`)) {
                try {
                    // 删除库中的所有关联项
                    await db.emojiLibraryItems.where('libraryId').equals(currentEmojiLibrary.id).delete();

                    // 删除库本身
                    await db.emojiLibraries.delete(currentEmojiLibrary.id);

                    showToast('表情包库已删除', 'success');

                    // 返回到表情包库列表
                    showEmojiLibraryList();

                } catch (error) {
                    console.error('删除表情包库失败:', error);
                    showToast('删除失败', 'error');
                }
            }
        }

        // 初始化表情包库上传功能
        function initEmojiLibraryUpload() {
            const uploadInput = document.getElementById('emoji-library-upload');
            const uploadArea = document.getElementById('emoji-library-upload-area');

            if (uploadInput) {
                uploadInput.addEventListener('change', handleEmojiLibraryUpload);
            }

            if (uploadArea) {
                // 拖拽上传功能
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });

                uploadArea.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                });

                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');

                    const files = Array.from(e.dataTransfer.files).filter(file =>
                        file.type.startsWith('image/')
                    );

                    if (files.length > 0) {
                        processEmojiFiles(files);
                    }
                });
            }
        }

        // 处理表情包库文件上传
        async function handleEmojiLibraryUpload(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;

            await processEmojiFiles(files);

            // 清空文件输入
            event.target.value = '';
        }

        // 处理表情包文件
        async function processEmojiFiles(files) {
            if (!currentEmojiLibrary) {
                showToast('请先选择一个表情包库', 'error');
                return;
            }

            const validFiles = files.filter(file => file.type.startsWith('image/'));
            if (validFiles.length === 0) {
                showToast('请选择有效的图片文件', 'error');
                return;
            }

            let successCount = 0;
            let errorCount = 0;

            for (const file of validFiles) {
                try {
                    await uploadEmojiToLibrary(file);
                    successCount++;
                } catch (error) {
                    console.error('上传表情包失败:', error);
                    errorCount++;
                }
            }

            if (successCount > 0) {
                showToast(`成功上传 ${successCount} 个表情包`, 'success');
                // 重新加载库内容
                await loadEmojiLibraryContent(currentEmojiLibrary.id);
            }

            if (errorCount > 0) {
                showToast(`${errorCount} 个文件上传失败`, 'error');
            }
        }

        // 上传表情包到库
        async function uploadEmojiToLibrary(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();

                reader.onload = async (e) => {
                    try {
                        const imageUrl = e.target.result;

                        // 创建新的表情包
                        const newEmoji = {
                            id: `emoji_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                            name: file.name.split('.')[0],
                            description: '', // 初始为空，用户稍后添加描述
                            url: imageUrl,
                            category: 'custom',
                            uploadTime: new Date().toISOString(),
                            isPersonal: false // 标识为库表情包，不是个人表情包
                        };

                        // 🔥【核心修复】库表情包只存储到数据库，不添加到任何内存数组
                        // 因为库表情包不应该出现在用户的表情包选择器中
                        await db.customEmojis.add(newEmoji);

                        // 添加到当前表情包库
                        const libraryItem = {
                            libraryId: currentEmojiLibrary.id,
                            emojiId: newEmoji.id,
                            addedAt: new Date().toISOString()
                        };

                        await db.emojiLibraryItems.add(libraryItem);

                        resolve(newEmoji);
                    } catch (error) {
                        reject(error);
                    }
                };

                reader.onerror = () => reject(new Error('文件读取失败'));
                reader.readAsDataURL(file);
            });
        }



        // ===== 表情包库挂载功能 =====

        // 显示表情包库挂载设置
        function showEmojiLibraryMountSettings() {
            console.log('showEmojiLibraryMountSettings called');
            if (!currentChatCharacter) {
                console.log('No current chat character');
                return;
            }

            const chatSettings = getCurrentChatSettings();
            console.log('Chat settings:', chatSettings);

            // 设置开关状态
            document.getElementById('emoji-library-mount-enabled').checked = chatSettings.emojiLibraryMountEnabled || false;

            // 渲染表情包库列表
            renderEmojiLibraryMountList();

            // 显示/隐藏详细设置
            toggleEmojiLibraryMountDetails();

            console.log('About to show modal');
            showModal('emoji-library-mount-modal');
            console.log('Modal should be shown');
        }

        // 切换表情包库挂载详细设置显示
        function toggleEmojiLibraryMountDetails() {
            const enabled = document.getElementById('emoji-library-mount-enabled').checked;
            document.getElementById('emoji-library-mount-details').style.display = enabled ? 'block' : 'none';

            // 更新主设置界面显示
            updateEmojiLibraryMountDisplay();
        }

        // 渲染表情包库挂载列表
        function renderEmojiLibraryMountList() {
            const container = document.getElementById('emoji-library-mount-list');
            if (!container) return;

            if (emojiLibraries.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <p>还没有表情包库</p>
                        <p>请先在"我"页面创建表情包库</p>
                    </div>
                `;
                return;
            }

            const chatSettings = getCurrentChatSettings();
            const selectedLibraries = chatSettings.selectedEmojiLibraries || [];

            container.innerHTML = emojiLibraries.map(library => `
                <label class="checkbox-item">
                    <input type="checkbox"
                           value="${library.id}"
                           ${selectedLibraries.includes(library.id) ? 'checked' : ''}
                           onchange="updateEmojiLibraryMountDisplay()">
                    <span class="checkbox-label">
                        <div class="library-name">${library.name}</div>
                        <div class="library-desc">${library.description || '无描述'}</div>
                    </span>
                </label>
            `).join('');
        }

        // 更新表情包库挂载显示状态
        function updateEmojiLibraryMountDisplay() {
            const statusElement = document.getElementById('current-emoji-library-mount');
            if (!statusElement) return;

            const chatSettings = getCurrentChatSettings();
            const enabled = chatSettings.emojiLibraryMountEnabled || false;
            const selectedLibraries = chatSettings.selectedEmojiLibraries || [];

            if (!enabled) {
                statusElement.textContent = '未启用';
                statusElement.style.color = '#999';
                return;
            }

            if (selectedLibraries.length === 0) {
                statusElement.textContent = '已启用，未选择库';
                statusElement.style.color = '#ff9500';
                return;
            }

            const libraryNames = selectedLibraries.map(id => {
                const library = emojiLibraries.find(lib => lib.id === id);
                return library ? library.name : '未知库';
            });

            if (libraryNames.length === 1) {
                statusElement.textContent = libraryNames[0];
            } else {
                statusElement.textContent = `${libraryNames.length}个库`;
            }
            // 🔥【修复】移除强制蓝色，使用默认颜色与其他设置项保持一致
            statusElement.style.color = '';
        }

        // 保存表情包库挂载设置
        async function saveEmojiLibraryMountSettings() {
            if (!currentChatCharacter) return;

            const chatSettings = getCurrentChatSettings();

            // 保存开关状态
            chatSettings.emojiLibraryMountEnabled = document.getElementById('emoji-library-mount-enabled').checked;

            // 保存选中的表情包库
            const checkboxes = document.querySelectorAll('#emoji-library-mount-list input[type="checkbox"]:checked');
            chatSettings.selectedEmojiLibraries = Array.from(checkboxes).map(cb => cb.value);

            await saveCurrentChatSettings(chatSettings);
            updateEmojiLibraryMountDisplay();
            hideModal('emoji-library-mount-modal');

            const selectedCount = chatSettings.selectedEmojiLibraries ? chatSettings.selectedEmojiLibraries.length : 0;
            if (chatSettings.emojiLibraryMountEnabled && selectedCount > 0) {
                showToast(`表情包库挂载设置已保存，已挂载 ${selectedCount} 个库`, 'success');

                // 重新加载表情包面板以应用新设置
                if (document.getElementById('custom-emoji-panel').style.display !== 'none') {
                    loadCustomEmojis();
                }
            } else if (chatSettings.emojiLibraryMountEnabled) {
                showToast('表情包库挂载已启用，但未选择任何库', 'info');
            } else {
                showToast('表情包库挂载已关闭', 'info');
            }
        }

        // 根据表情包库挂载设置过滤表情包
        async function getFilteredEmojis(emojis) {
            // 🔥【核心修复】聊天界面的表情包选择器只显示用户个人表情包
            // 表情包库中的表情包永远不应该出现在用户的表情包选择器中
            // 表情包库是给AI角色用的，不是给用户用的
            return emojis.filter(emoji => emoji.isPersonal !== false);
        }

        // 🔥【新增】清理表情包库中的无效关联记录
        async function cleanupEmojiLibraryItems() {
            try {
                console.log('🧹 [cleanupEmojiLibraryItems] 开始清理无效的表情包库关联记录');

                // 获取所有关联记录
                const allItems = await db.emojiLibraryItems.toArray();
                console.log('🧹 [cleanupEmojiLibraryItems] 总关联记录数:', allItems.length);

                // 检查每个关联记录对应的表情包是否存在
                const invalidItems = [];
                for (const item of allItems) {
                    const emoji = await db.customEmojis.get(item.emojiId);
                    if (!emoji) {
                        invalidItems.push(item);
                    }
                }

                console.log('🧹 [cleanupEmojiLibraryItems] 发现无效关联记录数:', invalidItems.length);

                // 删除无效的关联记录
                if (invalidItems.length > 0) {
                    const invalidIds = invalidItems.map(item => item.id);
                    await db.emojiLibraryItems.bulkDelete(invalidIds);
                    console.log('🧹 [cleanupEmojiLibraryItems] 已清理无效关联记录:', invalidIds);
                }

                return invalidItems.length;
            } catch (error) {
                console.error('🧹 [cleanupEmojiLibraryItems] 清理失败:', error);
                return 0;
            }
        }

        // 🔥【新增】获取挂载的表情包库中的所有表情包
        async function getMountedEmojiLibraryEmojis() {
            try {
                const chatSettings = getCurrentChatSettings();

                // 如果没有启用表情包库挂载或没有选中的库，返回个人表情包
                if (!chatSettings.emojiLibraryMountEnabled || !chatSettings.selectedEmojiLibraries || chatSettings.selectedEmojiLibraries.length === 0) {
                    return customEmojis;
                }

                // 先清理无效的关联记录
                await cleanupEmojiLibraryItems();

                const allMountedEmojis = [];

                // 从所有挂载的表情包库中获取表情包
                for (const libraryId of chatSettings.selectedEmojiLibraries) {
                    const libraryItems = await db.emojiLibraryItems.where('libraryId').equals(libraryId).toArray();
                    const emojiIds = libraryItems.map(item => item.emojiId);
                    const libraryEmojis = await db.customEmojis.where('id').anyOf(emojiIds).toArray();
                    allMountedEmojis.push(...libraryEmojis);
                }



                return allMountedEmojis;
            } catch (error) {
                console.error('获取挂载表情包时出错:', error);
                // 出错时回退到个人表情包
                return customEmojis;
            }
        }

        // 🔥【修复】AI查找表情包的函数 - 从挂载的表情包库中查找
        async function findEmojiForAI(description) {
            try {


                // 获取当前聊天的设置
                const chatSettings = getCurrentChatSettings();

                // 如果启用了表情包库挂载且有选中的库
                if (chatSettings.emojiLibraryMountEnabled && chatSettings.selectedEmojiLibraries && chatSettings.selectedEmojiLibraries.length > 0) {
                    // 从挂载的表情包库中查找
                    for (const libraryId of chatSettings.selectedEmojiLibraries) {
                        // 获取库中的表情包关联记录
                        const libraryItems = await db.emojiLibraryItems.where('libraryId').equals(libraryId).toArray();

                        // 获取对应的表情包数据
                        const emojiIds = libraryItems.map(item => item.emojiId);

                        const libraryEmojis = await db.customEmojis.where('id').anyOf(emojiIds).toArray();

                        // 先尝试严格匹配
                        let matchingEmoji = libraryEmojis.find(emoji => emoji.description === description);

                        // 如果严格匹配失败，尝试trim后匹配
                        if (!matchingEmoji) {
                            matchingEmoji = libraryEmojis.find(emoji => emoji.description?.trim() === description?.trim());
                        }

                        // 如果还是失败，尝试忽略大小写匹配
                        if (!matchingEmoji) {
                            matchingEmoji = libraryEmojis.find(emoji =>
                                emoji.description?.toLowerCase().trim() === description?.toLowerCase().trim()
                            );
                        }

                        if (matchingEmoji) {
                            return matchingEmoji;
                        }
                    }

                    return null;
                } else {
                    // 如果没有挂载表情包库，从个人表情包中查找
                    return customEmojis.find(emoji => emoji.description === description);
                }
            } catch (error) {
                console.error('查找表情包时出错:', error);
                // 出错时回退到个人表情包
                return customEmojis.find(emoji => emoji.description === description);
            }
        }

        // 判断颜色是否为浅色
        function isLightColor(color) {
            // 将颜色转换为RGB值
            let r, g, b;

            if (color.startsWith('#')) {
                // 十六进制颜色
                const hex = color.slice(1);
                if (hex.length === 3) {
                    r = parseInt(hex[0] + hex[0], 16);
                    g = parseInt(hex[1] + hex[1], 16);
                    b = parseInt(hex[2] + hex[2], 16);
                } else {
                    r = parseInt(hex.substr(0, 2), 16);
                    g = parseInt(hex.substr(2, 2), 16);
                    b = parseInt(hex.substr(4, 2), 16);
                }
            } else if (color.startsWith('rgb')) {
                // RGB颜色
                const matches = color.match(/\d+/g);
                if (matches && matches.length >= 3) {
                    r = parseInt(matches[0]);
                    g = parseInt(matches[1]);
                    b = parseInt(matches[2]);
                }
            } else {
                // 默认为深色
                return false;
            }

            // 计算亮度
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            return brightness > 128;
        }

        // 更新气泡预览
        function updateBubblePreview() {
            const myColor = document.getElementById('my-bubble-color')?.value || '#007AFF';
            const aiColor = document.getElementById('ai-bubble-color')?.value || '#f0f0f0';
            const myOpacity = document.getElementById('my-bubble-opacity')?.value || '1';
            const aiOpacity = document.getElementById('ai-bubble-opacity')?.value || '1';

            // 更新预览气泡
            const demoMyBubble = document.getElementById('demo-my-bubble');
            const demoAiBubble = document.getElementById('demo-ai-bubble');

            if (demoMyBubble) {
                // 使用rgba背景色而不是opacity
                const transparentMyColor = convertColorWithOpacity(myColor, myOpacity);
                demoMyBubble.style.backgroundColor = transparentMyColor;
                demoMyBubble.style.color = isLightColor(myColor) ? '#333' : '#fff';
            }

            if (demoAiBubble) {
                // 使用rgba背景色而不是opacity
                const transparentAiColor = convertColorWithOpacity(aiColor, aiOpacity);
                demoAiBubble.style.backgroundColor = transparentAiColor;
                demoAiBubble.style.color = isLightColor(aiColor) ? '#333' : '#fff';
            }

            // 更新颜色预览
            const myPreview = document.getElementById('my-bubble-preview');
            const aiPreview = document.getElementById('ai-bubble-preview');

            if (myPreview) {
                // 使用rgba背景色而不是opacity
                const transparentMyColor = convertColorWithOpacity(myColor, myOpacity);
                myPreview.style.backgroundColor = transparentMyColor;
                myPreview.textContent = '我的气泡';
            }

            if (aiPreview) {
                // 使用rgba背景色而不是opacity
                const transparentAiColor = convertColorWithOpacity(aiColor, aiOpacity);
                aiPreview.style.backgroundColor = transparentAiColor;
                aiPreview.textContent = '对方气泡';
            }
        }

        // 绑定头像上传事件
        function bindAvatarUploadEvents() {
            // 我的头像上传
            const myAvatarUpload = document.getElementById('my-chat-avatar-upload');
            if (myAvatarUpload) {
                myAvatarUpload.onchange = function(e) {
                    if (e.target.files && e.target.files[0]) {
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            const preview = document.getElementById('my-chat-avatar-preview');
                            if (preview) {
                                preview.style.backgroundImage = `url(${event.target.result})`;
                                preview.style.backgroundSize = 'cover';
                                preview.style.backgroundPosition = 'center';
                                preview.innerHTML = '';
                                window.selectedMyChatAvatar = event.target.result;
                            }
                        };
                        reader.readAsDataURL(e.target.files[0]);
                    }
                };
            }

            // AI头像上传
            const aiAvatarUpload = document.getElementById('ai-chat-avatar-upload');
            if (aiAvatarUpload) {
                aiAvatarUpload.onchange = function(e) {
                    if (e.target.files && e.target.files[0]) {
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            const preview = document.getElementById('ai-chat-avatar-preview');
                            if (preview) {
                                preview.style.backgroundImage = `url(${event.target.result})`;
                                preview.style.backgroundSize = 'cover';
                                preview.style.backgroundPosition = 'center';
                                preview.innerHTML = '';
                                window.selectedAiChatAvatar = event.target.result;
                            }
                        };
                        reader.readAsDataURL(e.target.files[0]);
                    }
                };
            }
        }

        // 初始化头像上传功能
        function initializeAvatarUpload() {
            const avatarInput = document.getElementById('avatar-upload');
            if (!avatarInput) {
                console.error('找不到avatar-upload元素');
                return;
            }

            // 移除旧的事件监听器
            avatarInput.removeEventListener('change', avatarUploadHandler);

            // 添加新的事件监听器
            avatarInput.addEventListener('change', avatarUploadHandler);
            console.log('头像上传事件监听器已绑定');
        }

        // 更新聊天设置界面的显示状态
        async function updateChatSettingsDisplay() {
            if (!currentChatCharacter) {
                console.log("更新聊天设置界面显示：无当前聊天角色，跳过操作");
                return;
            }

            const chatSettings = await getAsyncChatSettings();

            // 🔥【新增】控制角色专属音效设置显示（只对单聊显示）
            const characterSoundSettings = document.getElementById('character-sound-settings');
            if (characterSoundSettings) {
                const isGroupChat = currentChatCharacter.isGroup;
                characterSoundSettings.style.display = isGroupChat ? 'none' : 'block';
            }

            // 更新历史消息数显示
            const historyCountElement = document.getElementById('current-history-count');
            if (historyCountElement) {
                historyCountElement.textContent = chatSettings.historyCount + '回合';
            }

            // 更新记忆挂载显示
            const memoryMountElement = document.getElementById('current-memory-mount');
            if (memoryMountElement) {
                memoryMountElement.textContent = chatSettings.memoryMountEnabled ? '已开启' : '已关闭';
            }

            // 更新世界书挂载显示
            updateWorldbookMountDisplay();

            // 更新表情包库挂载显示
            updateEmojiLibraryMountDisplay();

            // 更新时间感知开关
            const timeAwarenessCheckbox = document.getElementById('time-awareness-enabled');
            if (timeAwarenessCheckbox) {
                timeAwarenessCheckbox.checked = chatSettings.timeAwarenessEnabled;
            }

            // 更新通话设置
            const aiCallCheckbox = document.getElementById('ai-call-enabled');
            if (aiCallCheckbox) {
                aiCallCheckbox.checked = chatSettings.aiCallEnabled;
            }

            // 更新心率监测设置
            const aiHeartrateCheckbox = document.getElementById('ai-heartrate-enabled');
            if (aiHeartrateCheckbox) {
                aiHeartrateCheckbox.checked = chatSettings.aiHeartrateEnabled;
            }

            // 更新角色状态显示设置
            const characterStatusCheckbox = document.getElementById('character-status-enabled');
            if (characterStatusCheckbox) {
                characterStatusCheckbox.checked = chatSettings.characterStatusEnabled || false;
                // 🔥【新增】控制状态更新频率设置的显示
                const statusFrequencySetting = document.getElementById('status-frequency-setting');
                if (statusFrequencySetting) {
                    statusFrequencySetting.style.display = chatSettings.characterStatusEnabled ? 'flex' : 'none';
                }
            }

            // 🔥【修复】更新状态更新频率设置 - 从全局设置读取
            const statusUpdateFrequencySelect = document.getElementById('status-update-frequency');
            if (statusUpdateFrequencySelect) {
                const globalFrequency = localStorage.getItem('globalStatusUpdateFrequency') || 'medium';
                statusUpdateFrequencySelect.value = globalFrequency;
            }



            // 更新后台互动设置
            const backgroundInteractionCheckbox = document.getElementById('background-interaction-enabled');
            if (backgroundInteractionCheckbox) {
                backgroundInteractionCheckbox.checked = chatSettings.backgroundInteractionEnabled;
                // 控制详细设置显示
                const backgroundSettings = document.getElementById('background-interaction-settings');
                if (backgroundSettings) {
                    backgroundSettings.style.display = chatSettings.backgroundInteractionEnabled ? 'block' : 'none';
                }
            }

            const backgroundChatFrequencySelect = document.getElementById('background-chat-frequency');
            if (backgroundChatFrequencySelect) {
                backgroundChatFrequencySelect.value = chatSettings.backgroundChatFrequency || 'low';
            }

            const backgroundChatEnabledCheckbox = document.getElementById('background-chat-enabled');
            if (backgroundChatEnabledCheckbox) {
                backgroundChatEnabledCheckbox.checked = chatSettings.backgroundChatEnabled === true;
                // 控制频率设置显示 - 需要同时检查总开关和子开关
                const chatFrequencySetting = document.getElementById('chat-frequency-setting');
                if (chatFrequencySetting) {
                    chatFrequencySetting.style.display = (chatSettings.backgroundInteractionEnabled === true && chatSettings.backgroundChatEnabled === true) ? 'block' : 'none';
                }
            }

            const backgroundMomentsEnabledCheckbox = document.getElementById('background-moments-enabled');
            if (backgroundMomentsEnabledCheckbox) {
                backgroundMomentsEnabledCheckbox.checked = chatSettings.backgroundMomentsEnabled === true;
                // 控制相关设置显示 - 需要同时检查总开关和子开关
                const momentsEnabled = (chatSettings.backgroundInteractionEnabled === true && chatSettings.backgroundMomentsEnabled === true);
                const momentsFrequencySetting = document.getElementById('moments-frequency-setting');
                const scheduledMomentsSetting = document.getElementById('scheduled-moments-setting');
                const testPublishSetting = document.getElementById('test-publish-setting');

                if (momentsFrequencySetting) {
                    momentsFrequencySetting.style.display = momentsEnabled ? 'flex' : 'none';
                }
                if (scheduledMomentsSetting) {
                    scheduledMomentsSetting.style.display = momentsEnabled ? 'flex' : 'none';
                }
                if (testPublishSetting) {
                    testPublishSetting.style.display = momentsEnabled ? 'flex' : 'none';
                }
            }

            const backgroundMomentsFrequencySelect = document.getElementById('background-moments-frequency');
            if (backgroundMomentsFrequencySelect) {
                backgroundMomentsFrequencySelect.value = chatSettings.backgroundMomentsFrequency || 'low';
            }

            const scheduledMomentsEnabledCheckbox = document.getElementById('scheduled-moments-enabled');
            if (scheduledMomentsEnabledCheckbox) {
                scheduledMomentsEnabledCheckbox.checked = chatSettings.scheduledMomentsEnabled || false;
                // 控制时间设置按钮显示
                const scheduledTimesButton = document.querySelector('button[onclick="showScheduleTimesModal()"]');
                if (scheduledTimesButton) {
                    scheduledTimesButton.style.display = chatSettings.scheduledMomentsEnabled ? 'inline-block' : 'none';
                }
            }

            // 更新定时发布时间显示
            updateScheduleTimesDisplay();

            // 🔥【新增】更新后台写日记设置
            const backgroundDiaryCheckbox = document.getElementById('background-diary-enabled');
            if (backgroundDiaryCheckbox) {
                backgroundDiaryCheckbox.checked = chatSettings.backgroundDiaryEnabled === true;
                // 控制时间设置显示 - 需要同时检查总开关和子开关
                const diaryTimeSetting = document.getElementById('diary-time-setting');
                if (diaryTimeSetting) {
                    const showSetting = (chatSettings.backgroundInteractionEnabled === true && chatSettings.backgroundDiaryEnabled === true);
                    diaryTimeSetting.style.display = showSetting ? 'flex' : 'none';
                }
            }

            // 🔥【新增】更新日记时间输入框
            const diaryTimeInput = document.getElementById('diary-time-input');
            if (diaryTimeInput) {
                diaryTimeInput.value = chatSettings.backgroundDiaryTime || '';
                console.log(`🔄 [设置界面] 更新日记时间显示: ${chatSettings.backgroundDiaryTime || '未设置'}`);
            }

            // 🔥【修复】更新时间戳设置 - 默认开启
            const timestampCheckbox = document.getElementById('timestamp-enabled');
            if (timestampCheckbox) {
                // 如果设置未定义，默认为true
                const isEnabled = chatSettings.timestampEnabled !== false;
                timestampCheckbox.checked = isEnabled;
                console.log('🕐 时间戳开关状态:', isEnabled);
            }

            // 绑定事件监听器来保存设置变化
            bindChatSettingsEvents();
        }

        // 绑定聊天设置的事件监听器
        function bindChatSettingsEvents() {
            // 时间感知开关
            const timeAwarenessCheckbox = document.getElementById('time-awareness-enabled');
            if (timeAwarenessCheckbox) {
                timeAwarenessCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.timeAwarenessEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                };
            }

            // 通话设置
            const aiCallCheckbox = document.getElementById('ai-call-enabled');
            if (aiCallCheckbox) {
                aiCallCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.aiCallEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    showToast(`角色主动拨打电话已${this.checked ? '开启' : '关闭'}`, 'success');
                };
            }

            // 心率监测设置
            const aiHeartrateCheckbox = document.getElementById('ai-heartrate-enabled');
            if (aiHeartrateCheckbox) {
                aiHeartrateCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.aiHeartrateEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);

                    // 立即更新心率显示状态
                    if (currentChatCharacter) {
                        updateAiHeartrate();
                    }

                    showToast(`角色心率监测已${this.checked ? '开启' : '关闭'}`, 'success');
                };
            }



            // 后台互动设置
            const backgroundInteractionCheckbox = document.getElementById('background-interaction-enabled');
            if (backgroundInteractionCheckbox) {
                backgroundInteractionCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundInteractionEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    // 显示/隐藏详细设置
                    const backgroundSettings = document.getElementById('background-interaction-settings');
                    if (backgroundSettings) {
                        backgroundSettings.style.display = this.checked ? 'block' : 'none';
                    }

                    // 🔥【修复】当总开关关闭时，同时更新子开关的显示状态
                    if (!this.checked) {
                        // 隐藏所有子功能的设置
                        const chatFrequencySetting = document.getElementById('chat-frequency-setting');
                        const momentsFrequencySetting = document.getElementById('moments-frequency-setting');
                        const scheduledMomentsSetting = document.getElementById('scheduled-moments-setting');
                        const testPublishSetting = document.getElementById('test-publish-setting');

                        if (chatFrequencySetting) chatFrequencySetting.style.display = 'none';
                        if (momentsFrequencySetting) momentsFrequencySetting.style.display = 'none';
                        if (scheduledMomentsSetting) scheduledMomentsSetting.style.display = 'none';
                        if (testPublishSetting) testPublishSetting.style.display = 'none';
                    } else {
                        // 总开关开启时，根据子开关状态显示相应设置
                        const backgroundChatEnabled = chatSettings.backgroundChatEnabled === true;
                        const backgroundMomentsEnabled = chatSettings.backgroundMomentsEnabled === true;

                        const chatFrequencySetting = document.getElementById('chat-frequency-setting');
                        const momentsFrequencySetting = document.getElementById('moments-frequency-setting');
                        const scheduledMomentsSetting = document.getElementById('scheduled-moments-setting');
                        const testPublishSetting = document.getElementById('test-publish-setting');

                        if (chatFrequencySetting) chatFrequencySetting.style.display = backgroundChatEnabled ? 'block' : 'none';
                        if (momentsFrequencySetting) momentsFrequencySetting.style.display = backgroundMomentsEnabled ? 'flex' : 'none';
                        if (scheduledMomentsSetting) scheduledMomentsSetting.style.display = backgroundMomentsEnabled ? 'block' : 'none';
                        if (testPublishSetting) testPublishSetting.style.display = backgroundMomentsEnabled ? 'flex' : 'none';
                    }

                    // 🔥【修复】只重新初始化当前角色的定时器
                    if (currentChatCharacter) {
                        await scheduleProactiveChatForCharacter(currentChatCharacter.id);
                        console.log(`✅ [设置更改] ${currentChatCharacter.name} 主动聊天定时器已重新设置`);
                    }
                };
            }

            const backgroundChatFrequencySelect = document.getElementById('background-chat-frequency');
            if (backgroundChatFrequencySelect) {
                backgroundChatFrequencySelect.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundChatFrequency = this.value;
                    await saveCurrentChatSettings(chatSettings);
                };
            }

            const backgroundChatEnabledCheckbox = document.getElementById('background-chat-enabled');
            if (backgroundChatEnabledCheckbox) {
                backgroundChatEnabledCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundChatEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);

                    // 🔥【修复】控制频率设置显示 - 需要同时检查总开关和子开关
                    const chatFrequencySetting = document.getElementById('chat-frequency-setting');
                    if (chatFrequencySetting) {
                        const showSetting = (chatSettings.backgroundInteractionEnabled === true && this.checked);
                        chatFrequencySetting.style.display = showSetting ? 'block' : 'none';
                    }

                    // 🔥【修复】只重新初始化当前角色的定时器
                    if (currentChatCharacter) {
                        await scheduleProactiveChatForCharacter(currentChatCharacter.id);
                        console.log(`✅ [设置更改] ${currentChatCharacter.name} 主动聊天定时器已重新设置`);
                    }
                };
            }

            const backgroundMomentsEnabledCheckbox = document.getElementById('background-moments-enabled');
            if (backgroundMomentsEnabledCheckbox) {
                backgroundMomentsEnabledCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundMomentsEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);

                    // 🔥【修复】控制相关设置显示 - 需要同时检查总开关和子开关
                    const momentsFrequencySetting = document.getElementById('moments-frequency-setting');
                    const scheduledMomentsSetting = document.getElementById('scheduled-moments-setting');
                    const testPublishSetting = document.getElementById('test-publish-setting');

                    const showSettings = (chatSettings.backgroundInteractionEnabled === true && this.checked);

                    if (momentsFrequencySetting) {
                        momentsFrequencySetting.style.display = showSettings ? 'flex' : 'none';
                    }
                    if (scheduledMomentsSetting) {
                        scheduledMomentsSetting.style.display = showSettings ? 'flex' : 'none';
                    }
                    if (testPublishSetting) {
                        testPublishSetting.style.display = showSettings ? 'flex' : 'none';
                    }

                    // 🔥【修复】只重新初始化当前角色的定时器
                    if (currentChatCharacter) {
                        await scheduleProactiveChatForCharacter(currentChatCharacter.id);
                        console.log(`✅ [设置更改] ${currentChatCharacter.name} 主动聊天定时器已重新设置`);
                    }
                };
            }

            const backgroundMomentsFrequencySelect = document.getElementById('background-moments-frequency');
            if (backgroundMomentsFrequencySelect) {
                backgroundMomentsFrequencySelect.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundMomentsFrequency = this.value;
                    await saveCurrentChatSettings(chatSettings);

                    // 🔥【修复】重新初始化全局后台互动系统
                    await initGlobalBackgroundInteractionSystem();
                };
            }

            const scheduledMomentsEnabledCheckbox = document.getElementById('scheduled-moments-enabled');
            if (scheduledMomentsEnabledCheckbox) {
                scheduledMomentsEnabledCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.scheduledMomentsEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);

                    // 控制时间设置按钮显示
                    const scheduledTimesButton = document.querySelector('button[onclick="showScheduleTimesModal()"]');
                    if (scheduledTimesButton) {
                        scheduledTimesButton.style.display = this.checked ? 'inline-block' : 'none';
                    }

                    // 重新初始化定时发布系统
                    initScheduledMomentsSystem();
                };
            }

            // 🔥【新增】后台写日记开关设置
            const backgroundDiaryCheckbox = document.getElementById('background-diary-enabled');
            if (backgroundDiaryCheckbox) {
                backgroundDiaryCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundDiaryEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);

                    // 控制时间设置显示 - 需要同时检查总开关和子开关
                    const diaryTimeSetting = document.getElementById('diary-time-setting');
                    if (diaryTimeSetting) {
                        const showSetting = (chatSettings.backgroundInteractionEnabled === true && this.checked);
                        diaryTimeSetting.style.display = showSetting ? 'flex' : 'none';
                    }

                    // 重新初始化后台写日记系统
                    if (currentChatCharacter) {
                        await initBackgroundDiarySystem(currentChatCharacter.id);
                    }

                    showToast(`后台写日记已${this.checked ? '开启' : '关闭'}`, 'success');
                };
            }

            // 🔥【修复】时间戳设置事件绑定
            const timestampCheckbox = document.getElementById('timestamp-enabled');
            if (timestampCheckbox) {
                timestampCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.timestampEnabled = this.checked; // 直接设置布尔值
                    await saveCurrentChatSettings(chatSettings);
                    // 重新渲染聊天消息
                    if (currentChatCharacter) {
                        renderChatMessages(currentChatCharacter.id);
                    }
                    console.log('🕐 时间戳设置已更新:', this.checked);
                };
            }

            // 角色状态显示设置
            const characterStatusCheckbox = document.getElementById('character-status-enabled');
            if (characterStatusCheckbox) {
                characterStatusCheckbox.onchange = async function() {
                    console.log('状态显示开关被点击:', this.checked);
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.characterStatusEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);

                    // 🔥【新增】控制状态更新频率设置的显示
                    const statusFrequencySetting = document.getElementById('status-frequency-setting');
                    if (statusFrequencySetting) {
                        statusFrequencySetting.style.display = this.checked ? 'flex' : 'none';
                    }

                    // 重新渲染聊天界面以显示/隐藏状态
                    if (currentChatCharacter) {
                        renderChatMessages(currentChatCharacter.id);
                        // 更新聊天标题区域的状态显示
                        const headerContainer = document.querySelector('#api-chat-screen .header');
                        if (headerContainer) {
                            renderCharacterStatus(currentChatCharacter.id, headerContainer);
                        }
                    }

                    // 🔥【新增】重启状态更新定时器以应用新设置
                    restartCharacterStatusTimer();

                    showToast(`角色状态显示已${this.checked ? '开启' : '关闭'}`, 'success');
                };
            } else {
                console.warn('找不到character-status-enabled元素');
            }

            // 🔥【修复】状态更新频率设置 - 保存为全局设置
            const statusUpdateFrequencySelect = document.getElementById('status-update-frequency');
            if (statusUpdateFrequencySelect) {
                statusUpdateFrequencySelect.onchange = async function() {
                    // 🔥【修复】保存为全局设置，而不是角色专属设置
                    localStorage.setItem('globalStatusUpdateFrequency', this.value);

                    // 同时更新当前角色的设置以保持一致性
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.statusUpdateFrequency = this.value;
                    await saveCurrentChatSettings(chatSettings);

                    // 重启状态更新定时器以应用新频率
                    restartCharacterStatusTimer();

                    const frequencyNames = {
                        'high': '高频',
                        'medium-high': '中高频',
                        'medium': '中频',
                        'medium-low': '中低频',
                        'low': '低频'
                    };

                    showToast(`状态更新频率已设置为${frequencyNames[this.value]}`, 'success');
                };
            }
        }

        // 初始化聊天设置界面
        async function initializeChatSettings() {
            console.log("开始初始化聊天设置界面");

            // 初始化UI相关事件
            initChatSettingsUIEvents();

            // 如果没有currentChatCharacter，只初始化UI事件，不加载设置
            if (!currentChatCharacter) {
                console.log("初始化聊天设置界面：无当前聊天角色，只初始化UI事件");
                return;
            }

            // 更新身份显示
            await updateChatIdentityDisplay();

            // 更新气泡样式显示
            await updateBubbleStyleDisplay();

            // 🔥【新增】初始化角色专属音效设置
            await initCharacterSoundSettings();

            // 更新所有设置显示状态
            await updateChatSettingsDisplay();

            // 加载当前聊天的设置
            if (currentChatCharacter) {
                const chatSettings = await getAsyncChatSettings();
            }
        }

        // 初始化聊天设置UI相关事件
        function initChatSettingsUIEvents() {



            // 🔥【修复】绑定后台互动开关事件 - 这里只处理UI显示，实际保存在另一个地方处理
            const backgroundInteractionCheckbox = document.getElementById('background-interaction-enabled');
            if (backgroundInteractionCheckbox) {
                backgroundInteractionCheckbox.addEventListener('change', async function() {
                    const backgroundSettings = document.getElementById('background-interaction-settings');
                    if (backgroundSettings) {
                        backgroundSettings.style.display = this.checked ? 'block' : 'none';
                    }

                    // 🔥【修复】当总开关关闭时，同时隐藏所有子功能的设置
                    if (!this.checked) {
                        const chatFrequencySetting = document.getElementById('chat-frequency-setting');
                        const momentsFrequencySetting = document.getElementById('moments-frequency-setting');
                        const scheduledMomentsSetting = document.getElementById('scheduled-moments-setting');
                        const testPublishSetting = document.getElementById('test-publish-setting');
                        const diaryTimeSetting = document.getElementById('diary-time-setting');

                        if (chatFrequencySetting) chatFrequencySetting.style.display = 'none';
                        if (momentsFrequencySetting) momentsFrequencySetting.style.display = 'none';
                        if (scheduledMomentsSetting) scheduledMomentsSetting.style.display = 'none';
                        if (testPublishSetting) testPublishSetting.style.display = 'none';
                        if (diaryTimeSetting) diaryTimeSetting.style.display = 'none';

                        clearAllBackgroundTimers();
                    } else {
                        // 🔥【修复】如果开启后台互动，重新初始化全局系统（总开关影响所有角色）
                        await initGlobalBackgroundInteractionSystem();
                    }
                });
            }

            // 🔥【修复】绑定主动聊天开关事件 - 这里只处理UI显示，实际保存在另一个地方处理
            const backgroundChatCheckbox = document.getElementById('background-chat-enabled');
            if (backgroundChatCheckbox) {
                backgroundChatCheckbox.addEventListener('change', async function() {
                    // 🔥【修复】需要检查总开关状态
                    const backgroundInteractionCheckbox = document.getElementById('background-interaction-enabled');
                    const totalSwitchEnabled = backgroundInteractionCheckbox ? backgroundInteractionCheckbox.checked : false;

                    const frequencySetting = document.getElementById('chat-frequency-setting');
                    if (frequencySetting) {
                        const showSetting = (totalSwitchEnabled && this.checked);
                        frequencySetting.style.display = showSetting ? 'block' : 'none';
                    }

                    // 🔥【修复】重新初始化全局后台互动系统
                    await initGlobalBackgroundInteractionSystem();
                });
            }

            // 🔥【修复】绑定主动发动态开关事件 - 这里只处理UI显示，实际保存在另一个地方处理
            const backgroundMomentsCheckbox = document.getElementById('background-moments-enabled');
            if (backgroundMomentsCheckbox) {
                backgroundMomentsCheckbox.addEventListener('change', async function() {
                    // 🔥【修复】需要检查总开关状态
                    const backgroundInteractionCheckbox = document.getElementById('background-interaction-enabled');
                    const totalSwitchEnabled = backgroundInteractionCheckbox ? backgroundInteractionCheckbox.checked : false;

                    const showSettings = (totalSwitchEnabled && this.checked);

                    const frequencySetting = document.getElementById('moments-frequency-setting');
                    const scheduledMomentsSetting = document.getElementById('scheduled-moments-setting');
                    const testPublishSetting = document.getElementById('test-publish-setting');

                    if (frequencySetting) frequencySetting.style.display = showSettings ? 'flex' : 'none';
                    if (scheduledMomentsSetting) scheduledMomentsSetting.style.display = showSettings ? 'flex' : 'none';
                    if (testPublishSetting) testPublishSetting.style.display = showSettings ? 'flex' : 'none';

                    // 🔥【修复】只重新初始化当前角色的动态定时器
                    if (currentChatCharacter) {
                        const characterId = currentChatCharacter.id;
                        // 清除现有的动态定时器
                        if (backgroundTimers[characterId + '_moments']) {
                            clearInterval(backgroundTimers[characterId + '_moments']);
                            delete backgroundTimers[characterId + '_moments'];
                        }

                        // 如果开启了动态功能，重新设置定时器
                        const chatSettings = getCurrentChatSettings();
                        if (chatSettings.backgroundInteractionEnabled && chatSettings.backgroundMomentsEnabled) {
                            const momentsInterval = getBackgroundMomentsInterval(chatSettings.backgroundMomentsFrequency || 'low');
                            backgroundTimers[characterId + '_moments'] = setInterval(() => {
                                triggerBackgroundMoments(characterId);
                            }, momentsInterval);
                            console.log(`✅ [设置更改] ${currentChatCharacter.name} 主动发动态定时器已重新设置，间隔: ${momentsInterval}ms`);
                        } else {
                            console.log(`🚫 [设置更改] ${currentChatCharacter.name} 主动发动态已关闭`);
                        }
                    }
                });
            }

            // 🔥【新增】绑定后台写日记开关事件
            const backgroundDiaryCheckbox = document.getElementById('background-diary-enabled');
            if (backgroundDiaryCheckbox) {
                backgroundDiaryCheckbox.addEventListener('change', async function() {
                    // 检查总开关状态
                    const backgroundInteractionCheckbox = document.getElementById('background-interaction-enabled');
                    const totalSwitchEnabled = backgroundInteractionCheckbox ? backgroundInteractionCheckbox.checked : false;

                    const diaryTimeSetting = document.getElementById('diary-time-setting');
                    if (diaryTimeSetting) {
                        const showSetting = (totalSwitchEnabled && this.checked);
                        diaryTimeSetting.style.display = showSetting ? 'flex' : 'none';
                    }

                    // 重新初始化后台写日记系统
                    if (currentChatCharacter) {
                        await initBackgroundDiarySystem(currentChatCharacter.id);
                    }
                });
            }

            // 主动拨打电话开关事件已在上面的 initChatSettingsUIEvents 中处理



            // 绑定选择模式按钮事件
            const selectionCancelBtn = document.getElementById('selection-cancel-btn');
            const selectionDeleteBtn = document.getElementById('selection-delete-btn');

            if (selectionCancelBtn) {
                selectionCancelBtn.addEventListener('click', exitMessageSelectionMode);
            }

            if (selectionDeleteBtn) {
                selectionDeleteBtn.addEventListener('click', function() {
                    if (selectedMessages.size === 0) return;

                    deleteSelectedMessages();
                });
            }
        }

        // 戳一戳功能
        async function pokeCharacter(characterId) {
            if (!currentChatCharacter || currentChatCharacter.id !== characterId) {
                return;
            }

            const chatSettings = getCurrentChatSettings();
            const pokeSuffix = chatSettings.aiPokeSuffix || ''; // 🔥【修复】用户戳角色应该使用aiPokeSuffix
            const characterName = chatSettings.aiChatNickname || currentChatCharacter.name;

            // 创建戳一戳系统消息
            const pokeMessage = {
                id: Date.now().toString(),
                sender: 'system',
                content: `你戳了戳${characterName}${pokeSuffix}`,
                timestamp: Date.now(),
                isPoke: true
            };

            // 添加到聊天记录
            if (!chatMessages[characterId]) {
                chatMessages[characterId] = [];
            }

            chatMessages[characterId].push(pokeMessage);
            // 🔥【高效保存】直接添加单条戳一戳消息到数据库，避免全量重写
            try {
                // 🔥【修复】使用时间戳和随机数确保ID唯一性，避免重复键错误
                const stableId = `${characterId}_poke_${pokeMessage.timestamp}_${Math.random().toString(36).substr(2, 9)}_${chatMessages[characterId].length - 1}`;
                await db.chatMessages.add({
                    id: stableId,
                    characterId: characterId,
                    timestamp: pokeMessage.timestamp,
                    messageOrder: chatMessages[characterId].length - 1,
                    originalMessageId: pokeMessage.id,
                    messageData: pokeMessage
                });
                console.log('✅ [高效戳一戳] 戳一戳消息已保存到数据库');
            } catch (error) {
                console.error('戳一戳消息单条保存失败，回退到批量保存:', error);
                saveChatMessages();
            }

            // 渲染消息
            renderChatMessages(characterId);

            // 模拟角色回应（40%概率）
            if (Math.random() < 0.4) {
                setTimeout(() => {
                    const myPokeSuffix = chatSettings.myPokeSuffix || ''; // 🔥【修复】角色戳用户应该使用myPokeSuffix
                    const aiPokeMessage = {
                        id: Date.now().toString(),
                        sender: 'system',
                        content: `${characterName}戳了戳你${myPokeSuffix}`,
                        timestamp: Date.now(),
                        isPoke: true
                    };

                    chatMessages[characterId].push(aiPokeMessage);
                    // 🔥【高效保存】直接添加单条AI戳一戳回应消息到数据库，避免全量重写
                    try {
                        // 🔥【修复】使用时间戳和随机数确保ID唯一性，避免重复键错误
                        const stableId = `${characterId}_poke_reply_${aiPokeMessage.timestamp}_${Math.random().toString(36).substr(2, 9)}_${chatMessages[characterId].length - 1}`;
                        db.chatMessages.add({
                            id: stableId,
                            characterId: characterId,
                            timestamp: aiPokeMessage.timestamp,
                            messageOrder: chatMessages[characterId].length - 1,
                            originalMessageId: aiPokeMessage.id,
                            messageData: aiPokeMessage
                        }).then(() => {
                            console.log('✅ [高效AI戳一戳] AI戳一戳回应消息已保存到数据库');
                        }).catch(error => {
                            console.error('AI戳一戳消息单条保存失败:', error);
                        });
                    } catch (error) {
                        console.error('AI戳一戳消息保存失败，回退到批量保存:', error);
                        saveChatMessages();
                    }
                    renderChatMessages(characterId);
                }, 1000 + Math.random() * 2000);
            }
        }

        // 显示聊天选项
        function showChatOptions() {
            showModal('chat-options-modal');
        }

        // 显示单聊身份选择（第一步）
        function showSingleChatSelector() {
            hideModal('chat-options-modal');
            showPersonaSelectionForSingleChat();
        }

        // 显示单聊身份选择
        function showPersonaSelectionForSingleChat() {
            const modalHTML = `
                <div class="modal" id="persona-selection-modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 class="modal-title">选择身份</h3>
                            <button class="modal-close" onclick="hidePersonaSelectionModal()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p class="selection-description">请选择你在这次对话中使用的身份面具</p>
                            <div class="persona-selection-list" id="persona-selection-list">
                                ${personas.map(persona => `
                                    <div class="persona-selection-item" data-persona-id="${persona.id}">
                                        <div class="persona-selection-avatar" style="${persona.avatarUrl ? `background-image: url(${persona.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                                            ${persona.avatarUrl ? '' : persona.name.charAt(0)}
                                        </div>
                                        <div class="persona-selection-info">
                                            <div class="persona-selection-name">${persona.name}</div>
                                            <div class="persona-selection-desc">${truncateText(persona.description || '暂无描述', 100)}</div>
                                        </div>
                                        <div class="persona-selection-check">
                                            <i class="fas fa-check"></i>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-secondary" onclick="hidePersonaSelectionModal()">取消</button>
                            <button class="modal-primary" id="confirm-persona-btn" onclick="confirmPersonaAndShowCharacters()" disabled>下一步：选择角色</button>
                        </div>
                    </div>
                </div>
            `;

            // 移除已存在的模态框
            const existingModal = document.getElementById('persona-selection-modal');
            if (existingModal) {
                existingModal.remove();
            }

            document.body.insertAdjacentHTML('beforeend', modalHTML);

            // 绑定点击事件
            document.querySelectorAll('.persona-selection-item').forEach(item => {
                item.addEventListener('click', function() {
                    document.querySelectorAll('.persona-selection-item').forEach(i => i.classList.remove('selected'));
                    this.classList.add('selected');
                    window.selectedPersonaForChat = this.dataset.personaId;
                    document.getElementById('confirm-persona-btn').disabled = false;
                });
            });
        }

        // 隐藏身份选择模态框
        function hidePersonaSelectionModal() {
            const modal = document.getElementById('persona-selection-modal');
            if (modal) {
                modal.remove();
            }
            window.selectedPersonaForChat = null;
        }

        // 确认身份选择并显示角色选择
        function confirmPersonaAndShowCharacters() {
            if (!window.selectedPersonaForChat) return;

            hidePersonaSelectionModal();
            showCharacterSelectionForSingleChat();
        }

        // 显示单聊角色选择（第二步）
        function showCharacterSelectionForSingleChat() {
            // 🔥【修复】保存当前选中的身份ID，防止在后续流程中丢失
            const savedPersonaId = window.selectedPersonaForChat;
            console.log('=== showCharacterSelectionForSingleChat ===');
            console.log('保存的身份ID:', savedPersonaId);

            const modalBody = document.getElementById('single-chat-body');
            modalBody.innerHTML = '';

            if (characters.length === 0) {
                modalBody.innerHTML = '<p class="empty-mount-chats">还没有角色，请先创建角色</p>';
            } else {
                characters.forEach(character => {
                    const chatOption = document.createElement('div');
                    // 🔥【新增】检查角色是否已存在对话，添加不同的CSS类
                    const hasExistingChat = contacts.includes(character.id);
                    chatOption.className = `chat-option-item ${hasExistingChat ? 'has-existing-chat' : ''}`;

                    chatOption.onclick = () => {
                        // 🔥【修复】使用保存的身份ID而不是全局变量
                        console.log('=== 角色选择点击事件 ===');
                        console.log('选中的角色:', character.name);
                        console.log('使用的身份ID:', savedPersonaId);

                        hideModal('single-chat-modal');
                        // 设置选择的身份并开始聊天
                        startChatWithPersona(character, savedPersonaId);

                        // 清理临时变量
                        window.selectedPersonaForChat = null;
                    };

                    // 🔥【新增】为已存在对话的角色添加状态提示
                    const statusIndicator = hasExistingChat ? `
                        <div class="chat-status-indicator">
                            <i class="fas fa-comments"></i>
                            <span>已有对话</span>
                        </div>
                    ` : '';

                    chatOption.innerHTML = `
                        <div class="chat-option-icon" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                            ${character.avatarUrl ? '' : character.name.charAt(0)}
                        </div>
                        <div class="chat-option-text">
                            <div class="chat-option-title">${character.name}${hasExistingChat ? ' <span class="chat-exists-badge">已有对话</span>' : ''}</div>
                            <div class="chat-option-desc">${truncateText(character.bio || '暂无描述', 80)}</div>
                        </div>
                        ${statusIndicator}
                    `;

                    modalBody.appendChild(chatOption);
                });
            }

            showModal('single-chat-modal');
        }

        async function startChatWithPersona(character, personaId) {
            console.log('✅[修复] startChatWithPersona 被调用');

            // 🔥【新增】检查该角色是否已存在对话
            if (contacts.includes(character.id)) {
                // 角色已存在对话，询问用户是否要继续或取消
                const existingSettings = chatSettings[character.id] || {};
                const existingPersona = personas.find(p => p.id === existingSettings.selectedIdentityId);
                const existingIdentityName = existingPersona ? existingPersona.name : '未知身份';

                const confirmed = confirm(
                    `角色「${character.name}」已存在对话！\n` +
                    `当前对话使用的身份：${existingIdentityName}\n\n` +
                    `选择「确定」：继续使用现有对话\n` +
                    `选择「取消」：放弃本次操作`
                );

                if (confirmed) {
                    // 用户选择继续使用现有对话，直接开始聊天
                    startChat(character);
                    return;
                } else {
                    // 用户选择取消，不进行任何操作
                    return;
                }
            }

            // 🔥【新增身份设置逻辑】角色不存在对话，创建新对话并设置身份
            if (personaId) {
                // 获取或创建此聊天的专属设置
                let settings = chatSettings[character.id] || {};
                settings.selectedIdentityId = personaId;
                const selectedPersona = personas.find(p => p.id === personaId);
                if (selectedPersona) {
                    settings.myChatAvatar = selectedPersona.avatarUrl || '';
                    settings.myChatNickname = selectedPersona.name || '';
                    chatSettings[character.id] = settings;
                    await saveCurrentChatSettings(settings);
                }
            }

            // 添加到联系人列表
            console.log('✅[修复] 发现新联系人，正在同步保存...');
            contacts.push(character.id);
            // 使用 await 确保保存操作完成后再继续
            await saveContacts();
            console.log('✅[修复] 新联系人保存成功，内存中的 contacts 列表:', contacts);
            // 保存成功后，立即刷新一次消息列表的后台数据
            renderMessageList();

            // 开始聊天
            startChat(character);
        }


        // 切换群聊成员选择
        function toggleGroupMemberSelection(characterId) {
            const index = selectedGroupMembers.indexOf(characterId);
            const checkbox = document.getElementById(`checkbox-${characterId}`);
            const memberItem = checkbox.closest('.group-member-item');

            if (index > -1) {
                selectedGroupMembers.splice(index, 1);
                checkbox.classList.remove('checked');
                checkbox.innerHTML = '';
                memberItem.classList.remove('selected');
            } else {
                if (selectedGroupMembers.length >= 20) {
                    alert('最多只能选择20个成员');
                    return;
                }
                selectedGroupMembers.push(characterId);
                checkbox.classList.add('checked');
                checkbox.innerHTML = '<i class="fas fa-check"></i>';
                memberItem.classList.add('selected');
            }
        }

 // --- 请从这里开始，完整复制所有代码 ---

// 1. 显示聊天选项（入口函数，保持不变）
        function showGroupChatSelector() {
            hideModal('chat-options-modal');
            showPersonaSelectionForGroupChat();
        }

// 2. 显示群聊身份选择
        function showPersonaSelectionForGroupChat() {
            const modalHTML = `
                <div class="modal" id="persona-selection-group-modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 class="modal-title">选择身份</h3>
                            <button class="modal-close" onclick="hidePersonaSelectionGroupModal()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p class="selection-description">请选择你在这个群聊中使用的身份面具</p>
                            <div class="persona-selection-list" id="persona-selection-group-list">
                                ${personas.map(persona => `
                                    <div class="persona-selection-item" data-persona-id="${persona.id}">
                                <div class="persona-selection-avatar" style="${persona.avatarUrl ? `background-image: url('${persona.avatarUrl}'); background-size: cover; background-position: center;` : ''}">
                                            ${persona.avatarUrl ? '' : persona.name.charAt(0)}
                                        </div>
                                        <div class="persona-selection-info">
                                            <div class="persona-selection-name">${persona.name}</div>
                                            <div class="persona-selection-desc">${truncateText(persona.description || '暂无描述', 100)}</div>
                                        </div>
                                <div class="persona-selection-check"><i class="fas fa-check"></i></div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-secondary" onclick="hidePersonaSelectionGroupModal()">取消</button>
                    <button class="modal-primary" id="confirm-group-persona-btn" disabled>下一步：设置群聊</button>
                        </div>
                    </div>
                </div>
            `;

            const existingModal = document.getElementById('persona-selection-group-modal');
    if (existingModal) existingModal.remove();
            document.body.insertAdjacentHTML('beforeend', modalHTML);

    let selectedPersonaId = null;

            document.querySelectorAll('#persona-selection-group-modal .persona-selection-item').forEach(item => {
                item.addEventListener('click', function() {
                    document.querySelectorAll('#persona-selection-group-modal .persona-selection-item').forEach(i => i.classList.remove('selected'));
                    this.classList.add('selected');
            selectedPersonaId = this.dataset.personaId;
                    document.getElementById('confirm-group-persona-btn').disabled = false;
                    console.log('✅ 选择了身份:', selectedPersonaId, '身份名称:', this.querySelector('.persona-selection-name').textContent);
                });
            });

    // 关键修复：让“下一步”按钮的点击事件直接调用下一步函数，并把ID传过去
    document.getElementById('confirm-group-persona-btn').onclick = () => {
        console.log('✅ 点击下一步按钮，当前selectedPersonaId值为:', selectedPersonaId);
        if (selectedPersonaId) {
            console.log('✅ 准备调用confirmPersonaAndShowGroupSettings，传递ID:', selectedPersonaId);
            confirmPersonaAndShowGroupSettings(selectedPersonaId);
        } else {
            console.error('❌ 未选择身份就点击了下一步');
            alert('请先选择一个身份面具');
        }
    };
}

// 3. 隐藏身份选择模态框的函数
        function hidePersonaSelectionGroupModal() {
            const modal = document.getElementById('persona-selection-group-modal');
    if (modal) modal.remove();
}

// 4. 确认身份并显示群成员选择
function confirmPersonaAndShowGroupSettings(personaId) {
    console.log('✅ confirmPersonaAndShowGroupSettings被调用，接收到的personaId:', personaId);
            hidePersonaSelectionGroupModal();
    showGroupChatMemberSelection(personaId); // 将选择的ID作为参数传递给下一步
        }

// 5. 显示群成员选择 (已恢复简介显示)
function showGroupChatMemberSelection(personaId) {
    console.log('✅ showGroupChatMemberSelection被调用，接收到的personaId:', personaId);

    // 立即将personaId存储到全局变量中，确保不会丢失
    window.currentGroupPersonaId = personaId;
            document.getElementById('group-chat-name').value = '';
            selectedGroupMembers = [];

            const membersContainer = document.getElementById('group-chat-members');
            membersContainer.innerHTML = '';

            if (characters.length < 2) {
                membersContainer.innerHTML = '<p class="empty-mount-chats">至少需要2个角色才能创建群聊</p>';
            } else {
                characters.forEach(character => {
                    const memberItem = document.createElement('div');
                    memberItem.className = 'group-member-item';
                    memberItem.onclick = () => toggleGroupMemberSelection(character.id);
            // 关键修复：恢复了显示角色简介的HTML代码
                    memberItem.innerHTML = `
                <div class="group-member-checkbox" id="checkbox-${character.id}"></div>
                <div class="message-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url('${character.avatarUrl}');` : ''}">
                            ${character.avatarUrl ? '' : character.name.charAt(0)}
                        </div>
                        <div class="chat-option-text">
                            <div class="chat-option-title">${character.name}</div>
                    <div class="chat-option-desc">${truncateText(character.bio || '暂无简介', 80)}</div>
                </div>`;
                    membersContainer.appendChild(memberItem);
                });
            }

    // 关键修复：将 personaId 绑定到最终的“创建群聊”按钮上
    console.log('✅ 在第一个位置绑定创建按钮，personaId:', personaId);
    const createBtn = document.getElementById('group-chat-modal').querySelector('.modal-primary');
    createBtn.onclick = () => {
        console.log('✅ 第一个位置的创建群聊按钮被点击，直接使用参数personaId:', personaId);
        createGroupChat(personaId);
    }; // 绑定带参数的创建函数

            showModal('group-chat-modal');
        }

// 6. 切换群成员选择状态 (无修改，但为了完整性包含在此)
        function toggleGroupMemberSelection(characterId) {
            const index = selectedGroupMembers.indexOf(characterId);
            const checkbox = document.getElementById(`checkbox-${characterId}`);
            const memberItem = checkbox.closest('.group-member-item');

            if (index > -1) {
                selectedGroupMembers.splice(index, 1);
                checkbox.classList.remove('checked');
                checkbox.innerHTML = '';
                memberItem.classList.remove('selected');
            } else {
                if (selectedGroupMembers.length >= 20) {
                    alert('最多只能选择20个成员');
                    return;
                }
                selectedGroupMembers.push(characterId);
                checkbox.classList.add('checked');
                checkbox.innerHTML = '<i class="fas fa-check"></i>';
                memberItem.classList.add('selected');
            }
        }


// 7. 创建群聊（最终版本）
async function createGroupChat(personaId) {
    console.log(`✅ createGroupChat被调用，身份ID: ${personaId}`);

    const groupName = document.getElementById('group-chat-name').value.trim();
    if (!groupName) return alert('请输入群聊名称');
    if (selectedGroupMembers.length < 2) return alert('至少需要选择2个成员');

    const memberDetails = selectedGroupMembers.map(memberId => {
        const character = characters.find(c => c.id === memberId);
        return {
            id: character.id,
            name: character.name,
            persona: character.bio,  // 🔥【关键】使用persona字段而不是bio
            avatarUrl: character.avatarUrl,
            color: character.color
        };
    });

    const groupChat = {
        id: 'group_' + Date.now().toString(),
        name: groupName,
        members: memberDetails,
        isGroup: true,
        createdAt: new Date().toISOString(),
        settings: {
            myPersona: '', // 将在下面设置
            myNickname: '我' // 默认昵称
        }
    };

    // 🔥【关键修复】保存用户身份设置，同时兼容两种格式
    if (personaId) {
        const selectedPersona = personas.find(p => p.id === personaId);
        if (selectedPersona) {
            groupChat.settings.myPersona = selectedPersona.description || selectedPersona.name;
            groupChat.settings.myNickname = selectedPersona.name;

            // 同时保持原有的chatSettings格式（index.html兼容性）
            const chatSettings = {
                selectedIdentityId: personaId,
                myChatAvatar: selectedPersona.avatarUrl,
                myChatNickname: selectedPersona.name,
                selectedPersonaData: { ...selectedPersona },
                myPersona: selectedPersona.description || selectedPersona.name
            };

            // 确保 window.chatSettings 已初始化
            if (!window.chatSettings) {
                window.chatSettings = {};
            }
            window.chatSettings[groupChat.id] = chatSettings;
            await db.chatSettings.put({ id: groupChat.id, chatId: groupChat.id, settings: chatSettings });
            console.log('✅ 群聊身份设置已成功保存（双格式兼容）');
        } else {
            console.error('❌ 创建群聊时未找到ID为 ' + personaId + ' 的身份。');
        }
    }

    if (!groupChats) groupChats = [];
    groupChats.push(groupChat);
    await saveGroupChats();
    hideModal('group-chat-modal');
    renderMessageList();
    alert(`群聊"${groupName}"创建成功！`);
}

// --- 请复制到这里结束 ---

        // 保存群聊数据 - 使用IndexedDB
        async function saveGroupChats() {
            try {
                console.log('保存群聊数据到IndexedDB:', groupChats);

                // 检查数据完整性
                if (!groupChats || !Array.isArray(groupChats)) {
                    console.error('群聊数据无效:', groupChats);
                    groupChats = [];
                }

                // 验证每个群聊对象的完整性
                const validGroupChats = groupChats.filter(chat => {
                    if (!chat || !chat.id || !chat.name) {
                        console.warn('发现无效的群聊对象:', chat);
                        return false;
                    }
                    return true;
                });

                // 如果有无效数据，更新数组
                if (validGroupChats.length !== groupChats.length) {
                    groupChats = validGroupChats;
                    console.log('已过滤无效数据，有效群聊数量:', groupChats.length);
                }

                // 使用事务来确保数据一致性
                await db.transaction('rw', db.groupChats, async () => {
                // 清空现有数据
                await db.groupChats.clear();

                    // 逐个插入数据以避免批量插入的ID冲突问题
                    for (const chat of groupChats) {
                        try {
                            await db.groupChats.add(chat);
                        } catch (addError) {
                            console.warn('插入群聊失败，尝试更新:', chat.id, addError);
                            // 如果添加失败，尝试更新
                            await db.groupChats.put(chat);
                        }
                    }
                });

                console.log('群聊数据保存成功到IndexedDB');

                // 🔥【优化】智能localStorage备份策略 - 只在数据量小时备份
                try {
                    const dataSize = JSON.stringify(groupChats).length;
                    const maxLocalStorageSize = 1024 * 1024; // 1MB限制，为其他数据留空间

                    if (dataSize < maxLocalStorageSize) {
                        localStorage.setItem('groupChats', JSON.stringify(groupChats));
                        console.log(`群聊数据备份到localStorage成功 (${(dataSize/1024).toFixed(1)}KB)`);
                    } else {
                        // 数据太大，移除localStorage备份
                        localStorage.removeItem('groupChats');
                        console.log(`群聊数据过大 (${(dataSize/1024/1024).toFixed(1)}MB)，跳过localStorage备份，仅使用IndexedDB`);
                    }
                } catch (storageError) {
                    console.warn('localStorage备份失败:', storageError);
                    // 如果是容量不足，清理localStorage备份
                    if (storageError.name === 'QuotaExceededError') {
                        try {
                            localStorage.removeItem('groupChats');
                            console.log('localStorage容量不足，已清理群聊备份');
                        } catch (e) {
                            console.warn('清理localStorage失败:', e);
                        }
                    }
                }

            } catch (error) {
                console.error('保存群聊到IndexedDB失败:', error);
                console.error('错误详情:', error.name, error.message);

                // 如果IndexedDB失败，回退到localStorage
                try {
                    localStorage.setItem('groupChats', JSON.stringify(groupChats || []));
                    console.log('群聊数据回退保存到localStorage成功');
                    showToast('群聊已保存到本地存储', 'info');
                } catch (localError) {
                    console.error('localStorage保存也失败:', localError);
                    console.error('localStorage错误详情:', localError.name, localError.message);

                    // 检查是否是存储空间不足
                    if (localError.name === 'QuotaExceededError') {
                        alert('存储空间不足，请清理一些数据后重试');
                    } else {
                        alert('保存群聊失败，请尝试刷新页面重新操作');
                    }

                    // 恢复到之前的状态
                    groupChats.pop(); // 移除刚添加的群聊
                    throw localError;
                }
            }
        }

        // 渲染定时发布时间点
        function renderScheduleTimes() {
            const container = document.getElementById('schedule-times-container');
            if (!container) return;

            const chatSettings = getCurrentChatSettings();
            const scheduleTimes = chatSettings.scheduleTimes || [];

            container.innerHTML = '';

            scheduleTimes.forEach((time, index) => {
                const timeItem = document.createElement('div');
                timeItem.className = 'schedule-time-item';
                timeItem.innerHTML = `
                    <input type="time" value="${time}" onchange="updateScheduleTime(${index}, this.value)">
                    <button onclick="removeScheduleTime(${index})">×</button>
                `;
                container.appendChild(timeItem);
            });
        }

        // 添加定时发布时间点
        async function addScheduleTime() {
            const chatSettings = getCurrentChatSettings();
            if (!chatSettings.scheduleTimes) {
                chatSettings.scheduleTimes = [];
            }

            if (chatSettings.scheduleTimes.length >= 10) {
                alert('最多只能设置10个时间点');
                return;
            }

            chatSettings.scheduleTimes.push('09:00');
            await saveCurrentChatSettings(chatSettings);
            renderScheduleTimes();
        }

        // 更新定时发布时间点
        async function updateScheduleTime(index, newTime) {
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.scheduleTimes && chatSettings.scheduleTimes[index] !== undefined) {
                chatSettings.scheduleTimes[index] = newTime;
                await saveCurrentChatSettings(chatSettings);
            }
        }

        // 移除定时发布时间点
        async function removeScheduleTime(index) {
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.scheduleTimes && chatSettings.scheduleTimes[index] !== undefined) {
                chatSettings.scheduleTimes.splice(index, 1);
                await saveCurrentChatSettings(chatSettings);
                renderScheduleTimes();
            }
        }

        // 保存定时发布设置
        async function saveScheduleSettings() {
            const chatSettings = getCurrentChatSettings();
            chatSettings.scheduleEnabled = document.getElementById('schedule-enabled').checked;

            await saveCurrentChatSettings(chatSettings);
            hideModal('schedule-settings-modal');
            showToast('定时发布设置已保存', 'success');
        }

        // 显示世界书挂载设置
        function showWorldbookMountSettings() {
            const chatSettings = getCurrentChatSettings();

            // 加载当前设置
            document.getElementById('worldbook-mount-enabled').checked = chatSettings.worldbookMountEnabled || false;

            // 控制详细设置的显示
            toggleWorldbookMountDetails();

            // 绑定事件
            document.getElementById('worldbook-mount-enabled').onchange = toggleWorldbookMountDetails;

            // 渲染世界书列表
            renderWorldbookMountList();

            showModal('worldbook-mount-modal');
        }

        // 切换世界书挂载详细设置显示
        function toggleWorldbookMountDetails() {
            const enabled = document.getElementById('worldbook-mount-enabled').checked;
            document.getElementById('worldbook-mount-details').style.display = enabled ? 'block' : 'none';

            // 更新主设置界面显示
            updateWorldbookMountDisplay();
        }

        // 更新世界书挂载显示状态
        function updateWorldbookMountDisplay() {
            // 如果没有当前聊天角色，跳过
            if (!currentChatCharacter) {
                console.log("更新世界书挂载显示：无当前聊天角色，跳过操作");
                return;
            }

            const chatSettings = getCurrentChatSettings();
            const displayElement = document.getElementById('current-worldbook-mount');

            if (!displayElement) {
                console.log("更新世界书挂载显示：无显示元素，跳过操作");
                return;
            }

            if (!chatSettings.worldbookMountEnabled) {
                displayElement.textContent = '未挂载';
                return;
            }

            const selectedWorldbooks = chatSettings.selectedWorldbooks || [];
            if (selectedWorldbooks.length === 0) {
                displayElement.textContent = '已启用但未选择';
            } else if (selectedWorldbooks.length === 1) {
                const worldbook = worldbooks.find(w => w.id === selectedWorldbooks[0]);
                displayElement.textContent = worldbook ? `已挂载: ${worldbook.title}` : '已挂载: 1个';
            } else {
                displayElement.textContent = `已挂载: ${selectedWorldbooks.length}个`;
            }
        }

        // 渲染世界书挂载列表
        function renderWorldbookMountList() {
            const container = document.getElementById('worldbook-mount-list');
            container.innerHTML = '';

            // 过滤掉全局世界书，只显示局部世界书
            const localWorldbooks = worldbooks.filter(w => !w.isGlobal);

            if (localWorldbooks.length === 0) {
                container.innerHTML = '<p class="empty-mount-chats">暂无局部世界书，请先在世界书应用中创建</p>';
                return;
            }

            const chatSettings = getCurrentChatSettings();
            const selectedWorldbooks = chatSettings.selectedWorldbooks || [];

            localWorldbooks.forEach(worldbook => {
                const item = document.createElement('div');
                item.className = 'mount-item worldbook-mount-item';

                const isSelected = selectedWorldbooks.includes(worldbook.id);

                item.innerHTML = `
                    <input type="checkbox" id="worldbook-${worldbook.id}" value="${worldbook.id}" ${isSelected ? 'checked' : ''} class="worldbook-checkbox">
                    <div class="worldbook-content-flex">
                        <div class="worldbook-title-text">
                            ${worldbook.title}
                        </div>
                        <div class="worldbook-desc-text">
                            ${worldbook.content.length > 100 ? worldbook.content.substring(0, 100) + '...' : worldbook.content}
                        </div>
                        <div class="worldbook-date-text">
                            创建于: ${new Date(worldbook.createdAt).toLocaleDateString('zh-CN')} |
                            字数: ${worldbook.content.length}
                        </div>
                    </div>
                `;

                // 点击整个条目也能切换选择状态
                item.onclick = (e) => {
                    if (e.target.type !== 'checkbox') {
                        const checkbox = item.querySelector('input[type="checkbox"]');
                        checkbox.checked = !checkbox.checked;
                    }
                };

                container.appendChild(item);
            });

            // 添加提示说明全局世界书自动应用
            const globalInfo = document.createElement('div');
            globalInfo.className = 'worldbook-global-info';
            globalInfo.innerHTML = '<p class="global-worldbook-note">注意：全局世界书已自动应用于所有聊天，无需手动挂载。</p>';
            container.appendChild(globalInfo);
        }

        // 保存世界书挂载设置
        function saveWorldbookMountSettings() {
            const chatSettings = getCurrentChatSettings();

            chatSettings.worldbookMountEnabled = document.getElementById('worldbook-mount-enabled').checked;

            // 获取选中的世界书
            const checkboxes = document.querySelectorAll('#worldbook-mount-list input[type="checkbox"]:checked');
            chatSettings.selectedWorldbooks = Array.from(checkboxes).map(cb => cb.value);

            saveCurrentChatSettings(chatSettings);
            updateWorldbookMountDisplay();
            hideModal('worldbook-mount-modal');

            const selectedCount = chatSettings.selectedWorldbooks ? chatSettings.selectedWorldbooks.length : 0;
            if (chatSettings.worldbookMountEnabled && selectedCount > 0) {
                showToast(`世界书挂载设置已保存，已挂载 ${selectedCount} 个世界书`, 'success');
            } else if (chatSettings.worldbookMountEnabled) {
                showToast('世界书挂载已启用，但未选择任何世界书', 'info');
            } else {
                showToast('世界书挂载已关闭', 'info');
            }
        }

        // 身份选择器功能已移除，身份在创建对话时选择

        // 压缩图片以减少存储空间
        function compressImage(dataUrl, maxWidth = 300, quality = 0.8) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    // 计算新的尺寸，保持宽高比
                    let { width, height } = img;
                    if (width > height) {
                        if (width > maxWidth) {
                            height = (height * maxWidth) / width;
                            width = maxWidth;
                        }
                    } else {
                        if (height > maxWidth) {
                            width = (width * maxWidth) / height;
                            height = maxWidth;
                        }
                    }

                    canvas.width = width;
                    canvas.height = height;

                    // 绘制并压缩
                    ctx.drawImage(img, 0, 0, width, height);
                    const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);

                    console.log(`图片压缩：${Math.round(dataUrl.length/1024)}KB -> ${Math.round(compressedDataUrl.length/1024)}KB`);
                    resolve(compressedDataUrl);
                };
                img.src = dataUrl;
            });
        }



        // 🔥【紧急修复】恢复设置并刷新界面
        function recoverAndRefreshSettings() {
            if (!currentChatCharacter) {
                showToast('请先选择一个聊天窗口', 'warning');
                return;
            }

            const chatId = currentChatCharacter.id;
            console.log(`开始恢复聊天设置: ${chatId}`);
            console.log('当前设置状态:', JSON.stringify(chatSettings[chatId], null, 2));

            // 显示恢复进度
            showToast('正在尝试恢复设置...', 'info');

            // 🔥【直接恢复方法】强制从localStorage恢复，不通过getCurrentChatSettings
            const savedLocalStorage = localStorage.getItem(`chatSettings_${chatId}`);
            if (savedLocalStorage) {
                try {
                    const recoveredSettings = JSON.parse(savedLocalStorage);
                    console.log('从localStorage恢复的设置:', JSON.stringify(recoveredSettings, null, 2));

                    // 直接覆盖全局设置
                    chatSettings[chatId] = recoveredSettings;

                    // 立即刷新当前界面的显示（如果在设置界面）
                    if (document.getElementById('api-chat-settings-screen').style.display !== 'none') {
                        updateChatSettingsDisplay();
                    }

                    // 刷新聊天消息界面
                    if (currentChatCharacter) {
                        renderChatMessages(currentChatCharacter.id);
                    }

                    showToast('设置恢复成功！', 'success');
                    console.log('设置恢复完成，当前设置:', JSON.stringify(chatSettings[chatId], null, 2));
                    return;
                } catch (error) {
                    console.error('解析localStorage设置失败:', error);
                }
            }

            // 如果localStorage失败，尝试从IndexedDB恢复
            db.chatSettings.get(chatId).then(dbSettings => {
                if (dbSettings && dbSettings.settings) {
                    console.log('从IndexedDB恢复的设置:', JSON.stringify(dbSettings.settings, null, 2));

                    // 直接覆盖全局设置
                    chatSettings[chatId] = dbSettings.settings;

                    // 同步到localStorage
                    localStorage.setItem(`chatSettings_${chatId}`, JSON.stringify(dbSettings.settings));

                    // 立即刷新界面
                    if (document.getElementById('api-chat-settings-screen').style.display !== 'none') {
                        updateChatSettingsDisplay();
                    }

                    if (currentChatCharacter) {
                        renderChatMessages(currentChatCharacter.id);
                    }

                    showToast('从备份数据恢复设置成功！', 'success');
                    console.log('从IndexedDB恢复设置成功:', JSON.stringify(dbSettings.settings, null, 2));
                } else {
                    showToast('未找到备份数据，设置可能已永久丢失', 'error');
                    console.log('未找到任何备份数据');
                }
            }).catch(error => {
                console.error('从IndexedDB恢复设置失败:', error);
                showToast('恢复设置失败，请联系技术支持', 'error');
            });
        }

        // 🔥【紧急修复】尝试恢复被覆盖的聊天设置
        function recoverChatSettings() {
            if (!currentChatCharacter) return false;

            const chatId = currentChatCharacter.id;
            console.log('尝试恢复聊天设置...');

            // 尝试从localStorage恢复
            const savedSettings = localStorage.getItem(`chatSettings_${chatId}`);
            if (savedSettings) {
                try {
                    const userSettings = JSON.parse(savedSettings);
                    chatSettings[chatId] = userSettings;
                    console.log('从localStorage恢复聊天设置成功:', userSettings);
                    return true;
                } catch (error) {
                    console.error('从localStorage恢复设置失败:', error);
                }
            }

            // 尝试从IndexedDB恢复
            db.chatSettings.get(chatId).then(dbSettings => {
                if (dbSettings && dbSettings.settings) {
                    chatSettings[chatId] = dbSettings.settings;
                    console.log('从IndexedDB恢复聊天设置成功:', dbSettings.settings);
                    // 同步到localStorage
                    localStorage.setItem(`chatSettings_${chatId}`, JSON.stringify(dbSettings.settings));
                    return true;
                }
            }).catch(error => {
                console.error('从IndexedDB恢复设置失败:', error);
            });

            return false;
        }

        // 强制刷新所有头像显示
        function forceRefreshAvatars() {
            const chatSettings = getCurrentChatSettings();
            const currentAvatar = chatSettings.aiChatAvatar || currentChatCharacter.avatarUrl;

            console.log('强制刷新头像显示，当前头像:', currentAvatar ? currentAvatar.substring(0, 50) + '...' : '无头像');

            // 刷新聊天界面中所有角色头像
            const messageAvatars = document.querySelectorAll('.message-avatar');
            messageAvatars.forEach(avatar => {
                // 检查是否是当前角色的头像（通过点击事件判断）
                const onclickAttr = avatar.getAttribute('onclick');
                if (onclickAttr && onclickAttr.includes(`'${currentChatCharacter.id}'`)) {
                    if (currentAvatar && currentAvatar !== 'undefined') {
                        avatar.style.backgroundImage = `url(${currentAvatar})`;
                        avatar.style.backgroundSize = 'cover';
                        avatar.style.backgroundPosition = 'center';
                        avatar.innerHTML = '';
                    } else {
                        avatar.style.backgroundImage = 'none';
                        avatar.innerHTML = currentChatCharacter.name.charAt(0);
                    }
                }
            });

            // 如果当前在头像设置界面，也刷新预览
            const aiAvatarPreview = document.getElementById('ai-chat-avatar-preview');
            if (aiAvatarPreview && currentAvatar && currentAvatar !== 'undefined') {
                aiAvatarPreview.style.backgroundImage = `url(${currentAvatar})`;
                aiAvatarPreview.style.backgroundSize = 'cover';
                aiAvatarPreview.style.backgroundPosition = 'center';
                aiAvatarPreview.innerHTML = '';

                // 更新提示信息
                aiAvatarPreview.title = '当前显示聊天头像（可能被角色更换过）';
            }
        }

        // 📊 计算存储空间使用情况
        async function calculateStorageUsage() {
            try {
                let chatSize = 0;
                let characterSize = 0;
                let settingsSize = 0;
                let emojiSize = 0;

                // 计算聊天记录大小
                const chatMessagesData = await db.chatMessages.toArray();
                chatSize = JSON.stringify(chatMessagesData).length;

                // 计算角色数据大小
                const charactersData = await db.characters.toArray();
                characterSize = JSON.stringify(charactersData).length;

                // 计算聊天设置大小
                const chatSettingsData = await db.chatSettings.toArray();
                settingsSize = JSON.stringify(chatSettingsData).length;

                // 计算表情包大小
                const emojisData = await db.customEmojis.toArray();
                emojiSize = JSON.stringify(emojisData).length;

                const total = chatSize + characterSize + settingsSize + emojiSize;

                // 更新显示
                document.getElementById('chat-storage-size').textContent = formatBytes(chatSize);
                document.getElementById('character-storage-size').textContent = formatBytes(characterSize);
                document.getElementById('settings-storage-size').textContent = formatBytes(settingsSize);
                document.getElementById('emoji-storage-size').textContent = formatBytes(emojiSize);
                document.getElementById('total-storage-size').textContent = formatBytes(total);

                return { chatSize, characterSize, settingsSize, emojiSize, total };
            } catch (error) {
                console.error('计算存储使用情况失败:', error);
                return null;
            }
        }

        // 格式化字节数为可读格式
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // 🧹 压缩所有图片
        async function compressAllImages() {
            if (!confirm('将压缩所有头像和背景图片，这可能需要一些时间。确定继续吗？')) {
                return;
            }

            showToast('正在压缩图片...', 'info');
            let compressedCount = 0;

            try {
                // 压缩角色头像
                for (const character of characters) {
                    if (character.avatarUrl && character.avatarUrl.length > 50000) {
                        character.avatarUrl = await compressImage(character.avatarUrl, 150, 0.6);
                        compressedCount++;
                    }
                }
                await saveCharacters();

                // 压缩聊天设置中的头像
                for (const chatId of Object.keys(chatSettings)) {
                    const settings = chatSettings[chatId];
                    if (settings) {
                        if (settings.aiChatAvatar && settings.aiChatAvatar.length > 50000) {
                            settings.aiChatAvatar = await compressImage(settings.aiChatAvatar, 150, 0.6);
                            compressedCount++;
                        }
                        if (settings.myChatAvatar && settings.myChatAvatar.length > 50000) {
                            settings.myChatAvatar = await compressImage(settings.myChatAvatar, 150, 0.6);
                            compressedCount++;
                        }
                        if (settings.chatBackground && settings.chatBackground.length > 100000) {
                            settings.chatBackground = await compressImage(settings.chatBackground, 800, 0.7);
                            compressedCount++;
                        }
                    }
                }
                await saveChatSettings();

                // 更新存储使用情况
                calculateStorageUsage();

                showToast(`图片压缩完成！共处理了 ${compressedCount} 张图片`, 'success');
            } catch (error) {
                console.error('压缩图片失败:', error);
                showToast('压缩过程中出现错误', 'error');
            }
        }

        // 🧹 旧版清理存储空间（保留兼容性）
        async function cleanupStorageSpace() {
            if (!confirm('将清理以下数据以释放存储空间：\n\n• 所有角色的动态头像\n• localStorage中的过期数据\n• 压缩现有头像数据\n\n确定要继续吗？')) {
                return;
            }

            showToast('正在清理存储空间...', 'info');
            let cleanedSize = 0;
            let cleanedItems = 0;

            try {
                // 1. 清除所有AI聊天头像
                Object.keys(chatSettings).forEach(chatId => {
                    if (chatSettings[chatId] && chatSettings[chatId].aiChatAvatar) {
                        delete chatSettings[chatId].aiChatAvatar;
                        cleanedItems++;
                    }
                });

                // 2. 清理localStorage中的过期chatSettings
                for (let i = localStorage.length - 1; i >= 0; i--) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('chatSettings_')) {
                        const value = localStorage.getItem(key);
                        if (value) {
                            cleanedSize += value.length;
                            localStorage.removeItem(key);
                            cleanedItems++;
                        }
                    }
                }

                // 3. 压缩所有现有头像数据
                for (const chatId of Object.keys(chatSettings)) {
                    const settings = chatSettings[chatId];
                    if (settings) {
                        if (settings.aiChatAvatar && settings.aiChatAvatar.length > 50000) {
                            settings.aiChatAvatar = await compressImage(settings.aiChatAvatar, 150, 0.6);
                            cleanedItems++;
                        }
                        if (settings.myChatAvatar && settings.myChatAvatar.length > 50000) {
                            settings.myChatAvatar = await compressImage(settings.myChatAvatar, 150, 0.6);
                            cleanedItems++;
                        }
                    }
                }

                // 4. 重新保存压缩后的设置到IndexedDB
                await saveChatSettings();

                // 5. 刷新当前界面
                if (currentChatCharacter) {
                    renderChatMessages(currentChatCharacter.id);
                }

                const sizeKB = Math.round(cleanedSize / 1024);
                showToast(`清理完成！释放了约 ${sizeKB}KB 空间，处理了 ${cleanedItems} 项数据`, 'success');

            } catch (error) {
                console.error('清理存储空间失败:', error);
                showToast('清理过程中出现错误，请重试', 'error');
            }
        }

        // 清除AI聊天头像
        function clearAiChatAvatar() {
            if (!currentChatCharacter) return;

            const chatSettings = getCurrentChatSettings();
            if (chatSettings.aiChatAvatar) {
                delete chatSettings.aiChatAvatar;
                saveCurrentChatSettings(chatSettings);

                // 刷新聊天界面
                if (currentChatCharacter) {
                    renderChatMessages(currentChatCharacter.id);
                }

                // 刷新设置界面预览
                forceRefreshAvatars();

                showToast('已清除聊天头像，恢复为角色卡默认头像', 'success');
            } else {
                showToast('没有聊天头像需要清除', 'info');
            }
        }

        // 保存聊天身份选择
        function saveChatIdentity() {
            if (!window.selectedChatIdentityId) {
                alert('请选择一个身份');
                return;
            }

            const chatSettings = getCurrentChatSettings();
            const selectedPersona = personas.find(p => p.id === window.selectedChatIdentityId);

            if (selectedPersona) {
                chatSettings.selectedIdentityId = selectedPersona.id;

                // 如果选中的身份有头像，自动设置为聊天头像（如果当前没有设置的话）
                if (selectedPersona.avatarUrl && !chatSettings.myChatAvatar) {
                    chatSettings.myChatAvatar = selectedPersona.avatarUrl;
                }

                // 如果选中的身份有名称，自动设置为聊天昵称（如果当前没有设置的话）
                if (selectedPersona.name && !chatSettings.myChatNickname) {
                    chatSettings.myChatNickname = selectedPersona.name;
                }

                saveCurrentChatSettings(chatSettings);

                // 更新显示
                updateChatIdentityDisplay();

                // 刷新聊天界面
                if (currentChatCharacter) {
                    renderChatMessages(currentChatCharacter.id);
                }

                hideModal('identity-selector-modal');
                showToast(`已选择身份"${selectedPersona.name}"`, 'success');
            }
        }

        // 更新聊天身份显示
        async function updateChatIdentityDisplay() {
            // 如果没有当前聊天角色，就不执行后续操作
            if (!currentChatCharacter) {
                console.log("更新聊天身份显示：无当前聊天角色，跳过操作");
                return;
            }

            const chatSettings = await getAsyncChatSettings();
            const selectedIdentityId = chatSettings.selectedIdentityId || 'default';
            const selectedPersona = personas.find(p => p.id === selectedIdentityId);

            const displayElement = document.getElementById('current-chat-identity');
            if (displayElement && selectedPersona) {
                displayElement.textContent = selectedPersona.name;
            }
        }

        // 更新气泡样式显示
        async function updateBubbleStyleDisplay() {
            // 如果没有当前聊天角色，就不执行后续操作
            if (!currentChatCharacter) {
                console.log("更新气泡样式显示：无当前聊天角色，跳过操作");
                return;
            }

            const chatSettings = await getAsyncChatSettings();
            const styleNames = {
                'default': '默认样式',
                'shadow': '经典阴影',
                'tail': '经典气泡',
                'paper': '纸张样式'
            };

            const displayElement = document.getElementById('current-bubble-style');
            if (displayElement) {
                const currentStyle = chatSettings.bubbleStyle || 'default';
                displayElement.textContent = styleNames[currentStyle] || '默认样式';
            }
        }

        // 全局头像上传处理函数
        function handleAvatarUploadClick() {
            console.log('点击了上传头像按钮');
            const input = document.getElementById('avatar-upload');
            if (input) {
                console.log('找到了input元素，准备触发点击');
                input.click();
            } else {
                console.error('找不到avatar-upload元素');
                alert('找不到文件上传元素，请刷新页面重试');
            }
        }

        // 该函数已被删除，使用上面的异步IndexedDB版本

        // 🔥【修复】添加消息长按监听器 - 支持手机端菜单操作
        function addMessageLongPressListener(messageContainer, messageId) {
            let pressTimer = null;
            let isLongPress = false;
            let startPos = { x: 0, y: 0 };

            // 检测是否为移动设备
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                             'ontouchstart' in window ||
                             navigator.maxTouchPoints > 0;

            const startLongPress = (e) => {
                if (isMessageSelectionMode) {
                    // 在选择模式下，只处理点击选择，不处理长按
                    return;
                }

                // 🔥【修复】记录起始位置，用于检测移动
                const touch = e.touches ? e.touches[0] : e;
                startPos.x = touch.clientX;
                startPos.y = touch.clientY;

                isLongPress = false;
                pressTimer = setTimeout(() => {
                    isLongPress = true;

                    // 🔥【修复】添加触觉反馈（移动端）
                    if (navigator.vibrate && isMobile) {
                        navigator.vibrate(50);
                    }

                    // 🔥【新增】手机端显示操作菜单，桌面端进入多选模式
                    if (isMobile) {
                        showMobileMessageMenu(messageId, e);
                    } else {
                        enterMessageSelectionMode(messageId);
                    }
                }, isMobile ? 600 : 800); // 移动端更短的长按时间
            };

            const cancelLongPress = (e) => {
                if (pressTimer) {
                    clearTimeout(pressTimer);
                    pressTimer = null;
                }

                // 🔥【修复】延迟重置长按标记，避免立即触发点击
                setTimeout(() => {
                    isLongPress = false;
                }, 100);
            };

            const checkMove = (e) => {
                if (!pressTimer) return;

                // 🔥【修复】检测移动距离，如果移动超过阈值则取消长按
                const touch = e.touches ? e.touches[0] : e;
                const moveX = Math.abs(touch.clientX - startPos.x);
                const moveY = Math.abs(touch.clientY - startPos.y);

                if (moveX > 10 || moveY > 10) {
                    cancelLongPress(e);
                }
            };

            const handleClick = (e) => {
                // 在选择模式下，所有消息都可以点击切换选择状态
                if (isMessageSelectionMode) {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleMessageSelection(messageId);
                    return;
                }

                // 如果是长按触发后的点击，不处理
                if (isLongPress) {
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }
            };

            // 🔥【修复】优化事件监听器，确保移动端正常工作
            if (isMobile) {
                // 移动端使用触摸事件
                messageContainer.addEventListener('touchstart', startLongPress, { passive: false });
                messageContainer.addEventListener('touchend', cancelLongPress, { passive: false });
                messageContainer.addEventListener('touchmove', checkMove, { passive: false });
                messageContainer.addEventListener('touchcancel', cancelLongPress, { passive: false });
            } else {
                // 桌面端使用鼠标事件
                messageContainer.addEventListener('mousedown', startLongPress);
                messageContainer.addEventListener('mouseup', cancelLongPress);
                messageContainer.addEventListener('mouseleave', cancelLongPress);
                messageContainer.addEventListener('mousemove', checkMove);
            }

            // 点击事件 - 使用捕获阶段确保优先处理
            messageContainer.addEventListener('click', handleClick, true);
        }

        // 🔥【重新设计】显示消息上方按钮条
        function showMobileMessageMenu(messageId, event) {
            console.log('移动端长按菜单，messageId:', messageId);
            selectedMessageId = messageId;

            // 检查消息是否是用户发送的
            const messages = chatMessages[currentChatCharacter.id] || [];
            const message = messages.find(msg => msg.id === messageId);
            const isUserMessage = message && message.sender === 'sent';

            // 隐藏已存在的按钮条
            hideMessageActionBar();

            // 找到对应的消息容器
            const messageContainer = document.querySelector(`[data-message-id="${messageId}"]`);
            if (!messageContainer) {
                console.log('错误：找不到消息容器');
                return;
            }
            console.log('找到消息容器:', messageContainer);

            // 创建按钮条
            const actionBar = document.createElement('div');
            actionBar.className = 'message-action-bar';
            actionBar.id = 'message-action-bar';

            // 构建按钮列表
            const buttons = ['引用', '复制'];

            // 🔥【新增】只有AI角色消息才显示心声选项
            if (!isUserMessage) {
                buttons.push('心声');
            }

            // 🔥【修复】所有消息都可以编辑，用户消息可以撤回
            buttons.push('编辑');

            if (isUserMessage) {
                buttons.push('撤回');
            }
            buttons.push('多选');

            actionBar.innerHTML = buttons.map(text => {
                let action = '';
                switch(text) {
                    case '引用': action = `replyToMessage('${messageId}')`; break;
                    case '复制': action = `copyMessage('${messageId}')`; break;
                    case '心声': action = `showInnerThoughtsModal('${messageId}')`; break;
                    case '编辑': action = `showEditMessageModal('${messageId}')`; break;
                    case '撤回': action = `deleteMessage('${messageId}')`; break;
                    case '多选': action = `enterMessageSelectionMode('${messageId}')`; break;
                }
                return `<button class="message-action-btn" onclick="${action}; hideMessageActionBar();">${text}</button>`;
            }).join('');

            // 添加到消息容器
            messageContainer.appendChild(actionBar);

            // 显示动画
            setTimeout(() => {
                actionBar.classList.add('show');
            }, 10);

            // 添加全局点击监听器
            setTimeout(() => {
                document.addEventListener('click', hideMessageActionBarOnClickOutside);
                document.addEventListener('touchstart', hideMessageActionBarOnClickOutside);
            }, 100);
        }

        // 🔥【重新设计】隐藏消息按钮条
        function hideMessageActionBar() {
            const actionBar = document.getElementById('message-action-bar');
            if (actionBar) {
                actionBar.classList.remove('show');
                setTimeout(() => {
                    if (actionBar.parentNode) {
                        actionBar.parentNode.removeChild(actionBar);
                    }
                }, 300);
            }
            selectedMessageId = null;

            // 移除全局点击监听器
            document.removeEventListener('click', hideMessageActionBarOnClickOutside);
            document.removeEventListener('touchstart', hideMessageActionBarOnClickOutside);
        }

        // 🔥【新增】点击外部隐藏按钮条
        function hideMessageActionBarOnClickOutside(event) {
            const actionBar = document.getElementById('message-action-bar');
            if (actionBar && !actionBar.contains(event.target)) {
                hideMessageActionBar();
            }
        }

        // 🔥【兼容】保持旧函数名
        function hideMobileMessageMenu() {
            hideMessageActionBar();
        }

        // 进入消息选择模式
        function enterMessageSelectionMode(initialMessageId) {
            if (isMessageSelectionMode) {
                return;
            }

            isMessageSelectionMode = true;
            selectedMessages.clear();
            selectedMessages.add(initialMessageId);

            // 添加选择模式CSS类
            const chatScreen = document.getElementById('api-chat-screen');
            if (chatScreen) {
                chatScreen.classList.add('selection-mode');
            }

            updateMessageSelectionUI();
        }

        // 切换消息选择状态
        function toggleMessageSelection(messageId) {
            if (!isMessageSelectionMode) return;

            if (selectedMessages.has(messageId)) {
                selectedMessages.delete(messageId);
            } else {
                selectedMessages.add(messageId);
            }

            updateMessageSelectionUI();

            // 如果没有选中的消息，退出选择模式
            if (selectedMessages.size === 0) {
                exitMessageSelectionMode();
            }
        }

        // 退出消息选择模式
        function exitMessageSelectionMode() {
            if (!isMessageSelectionMode) return;

            isMessageSelectionMode = false;

            // 移除选择模式CSS类
            const chatScreen = document.getElementById('api-chat-screen');
            if (chatScreen) {
                chatScreen.classList.remove('selection-mode');
            }

            // 🔥【修复】清除所有选中状态，包括撤回消息
            const selectedContainers = document.querySelectorAll('[data-message-id].selected');
            selectedContainers.forEach(container => {
                container.classList.remove('selected');
            });

            selectedMessages.clear();
            updateMessageSelectionUI();
        }



        // 更新消息选择UI
        function updateMessageSelectionUI() {
            // 🔥【修复】查找所有带有messageId的容器，包括撤回消息
            const allContainers = document.querySelectorAll('[data-message-id]');

            allContainers.forEach(container => {
                const messageId = container.dataset.messageId;
                if (messageId) {
                    if (selectedMessages.has(messageId)) {
                        container.classList.add('selected');
                    } else {
                        container.classList.remove('selected');
                    }
                }
            });

            // 更新选择计数显示
            const countElement = document.getElementById('selection-count');
            if (countElement) {
                countElement.textContent = `已选 ${selectedMessages.size} 条`;
            }
        }

        // 🔥【修复】防止重复删除操作的标志
        let isDeletingMessages = false;

        // 删除选中的消息
        async function deleteSelectedMessages() {
            // 防止重复操作
            if (isDeletingMessages) {
                console.log('删除操作正在进行中，请稍候...');
                return;
            }
            if (selectedMessages.size === 0) return;

            if (!currentChatCharacter) return;

            if (confirm(`确定要删除选中的 ${selectedMessages.size} 条消息吗？此操作不可恢复！`)) {
                isDeletingMessages = true; // 设置删除标志
                const characterId = currentChatCharacter.id;

                if (chatMessages[characterId]) {
                    // 🔥【高效删除】直接在数据库中删除选中的消息，避免全量重写
                    try {
                        const messagesToDelete = [];
                        chatMessages[characterId].forEach(message => {
                            if (selectedMessages.has(message.id)) {
                                messagesToDelete.push(message);
                            }
                        });

                        // 清理每条被删除消息的时间线记录
                        for (const message of messagesToDelete) {
                            try {
                                await deleteRelatedTimelineEvents(message);
                                // 🔥【修复】安全处理消息内容，支持字符串和对象类型
                                const contentPreview = typeof message.content === 'string'
                                    ? message.content.substring(0, 30)
                                    : (message.content?.text || message.content?.message || '[复杂消息]');
                                console.log(`🗑️ 已清理消息的时间线记录: ${contentPreview}...`);
                            } catch (error) {
                                console.error('清理时间线记录失败:', error);
                            }
                        }

                        // 🔥【关键优化】直接从数据库删除选中的消息
                        const dbMessagesToDelete = [];
                        for (const message of messagesToDelete) {
                            const dbMessage = await db.chatMessages
                                .where('characterId').equals(characterId)
                                .and(msg => msg.originalMessageId === message.id)
                                .first();
                            if (dbMessage) {
                                dbMessagesToDelete.push(dbMessage.id);
                            }
                        }

                        if (dbMessagesToDelete.length > 0) {
                            await db.chatMessages.bulkDelete(dbMessagesToDelete);
                            console.log(`✅ [高效删除] 数据库删除了 ${dbMessagesToDelete.length} 条消息`);
                        }

                        // 更新内存中的消息（过滤掉删除的消息）
                        chatMessages[characterId] = chatMessages[characterId].filter(message => {
                            return !selectedMessages.has(message.id);
                        });

                        // 刷新UI（不调用saveChatMessages，避免哈希检测）
                        renderChatMessages(characterId);
                        renderMessageList(); // 更新消息列表

                    } catch (error) {
                        console.error('高效删除失败，回退到传统方式:', error);
                        // 回退到原有的删除方式
                        chatMessages[characterId] = chatMessages[characterId].filter(message => {
                            return !selectedMessages.has(message.id);
                        });
                        saveChatMessages();
                        renderChatMessages(characterId);
                        renderMessageList();
                    }
                }

                // 退出选择模式
                exitMessageSelectionMode();

                // 🔥【修复】重置删除标志，允许后续删除操作
                isDeletingMessages = false;
            } else {
                // 🔥【修复】用户取消删除时也要重置标志
                isDeletingMessages = false;
            }
        }

        // 悬浮按钮功能
        // 变量控制等待回复状态
        let isWaitingForReply = false;
        let pendingUserMessage = null;

      // 用这段新代码，完整替换掉旧的 regenerateLastResponse 函数
        async function regenerateLastResponse() {
            if (!currentChatCharacter) {
                alert('请先选择一个角色');
                return;
            }

            // 防止重复调用
            if (window._isRegenerating) {
                console.log('重新生成正在进行中，忽略重复调用');
                return;
            }
            window._isRegenerating = true;

            const characterId = currentChatCharacter.id;
            const messages = chatMessages[characterId] || [];

            // 找到最后一条AI消息及其对应的用户消息
            let lastAiMessageIndex = -1;
            let lastUserMessageIndex = -1;

            for (let i = messages.length - 1; i >= 0; i--) {
                if (messages[i].sender === 'received' && lastAiMessageIndex === -1) {
                    lastAiMessageIndex = i;
                }
                if (lastAiMessageIndex !== -1 && messages[i].sender === 'sent' && lastUserMessageIndex === -1) {
                    lastUserMessageIndex = i;
                    break;
                }
            }

            if (lastAiMessageIndex === -1) {
                alert('没有找到AI回复可以重新生成');
                return;
            }

            if (lastUserMessageIndex === -1) {
                alert('没有找到对应的用户消息');
                return;
            }

            const userMessage = messages[lastUserMessageIndex];

            // 删除从最后一条用户消息后的所有AI消息
            chatMessages[characterId] = messages.slice(0, lastUserMessageIndex + 1);
            // 🔥【高效保存】批量删除AI消息，避免全量重写
            try {
                const messagesToDelete = [];
                for (let i = lastUserMessageIndex + 1; i < messages.length; i++) {
                    const message = messages[i];
                    const dbMessage = await db.chatMessages
                        .where('characterId').equals(characterId)
                        .and(msg => msg.originalMessageId === message.id)
                        .first();
                    if (dbMessage) {
                        messagesToDelete.push(dbMessage.id);
                    }
                }

                if (messagesToDelete.length > 0) {
                    await db.chatMessages.bulkDelete(messagesToDelete);
                    console.log(`✅ [高效重新生成] 删除了 ${messagesToDelete.length} 条AI消息`);
                }
            } catch (error) {
                console.error('重新生成删除消息失败，回退到批量保存:', error);
                await saveChatMessages();
            }
            await renderChatMessagesAsync(characterId);

            // 🔥【修复】确保在renderChatMessages完成后再显示typing-indicator
            console.log('🔧 [regenerateLastResponse] 准备显示typing-indicator');
            // 添加小延迟确保DOM更新完成
            await new Promise(resolve => {
                setTimeout(() => {
                    showTypingIndicator();
                    resolve();
                }, 100);
            });

            const delay = Math.random() * 2000 + 1000;
            await new Promise(resolve => setTimeout(resolve, delay));

            try {
                let response;

                // 🔥【核心修复】使用新的多模态处理逻辑
                console.log('🔍 [AI处理调试] 用户消息结构:', userMessage);
                console.log('🔍 [AI处理调试] 是否有image字段:', !!userMessage.image);
                console.log('🔍 [AI处理调试] 是否为表情包:', userMessage.isEmoji);
                console.log('🔍 [AI处理调试] content是否为数组:', Array.isArray(userMessage.content));

                if (Array.isArray(userMessage.content)) {
                    // 这是多模态消息（图文）
                    console.log('🔍 [AI处理调试] 走多模态分支');

                    // 🔥【核心修复】检查多模态消息中是否包含表情包
                    const hasImage = userMessage.content.some(item => item.type === 'image_url');
                    const isEmojiMessage = userMessage.originalMessages?.some(msg => msg.isEmoji);

                    console.log('🔍 [多模态调试] 包含图片:', hasImage);
                    console.log('🔍 [多模态调试] 是表情包消息:', isEmojiMessage);
                    console.log('🔍 [多模态调试] 表情包识别设置:', apiSettings.emojiRecognitionEnabled);

                    // 🔥【新增】检查是否为动图表情包
                    const emojiMsg = userMessage.originalMessages?.find(msg => msg.isEmoji);
                    const isGifEmoji = emojiMsg?.image?.includes('data:image/gif') || emojiMsg?.url?.includes('data:image/gif');

                    console.log('🔍 [动图检测] 是否为GIF表情包:', isGifEmoji);

                    if (hasImage && isEmojiMessage && (apiSettings.emojiRecognitionEnabled === false || isGifEmoji)) {
                        // 表情包且用户关闭了表情包识别，或者是动图表情包，发送描述文字
                        const reason = isGifEmoji ? '动图表情包' : '表情包识别已关闭';
                        const emojiPrompt = `[用户发送了表情包：${emojiMsg?.emojiDescription || '自定义表情包'}]`;
                        console.log(`🔍 [多模态修复] 发送文字描述 (${reason}):`, emojiPrompt);
                        response = await callChatAPI(emojiPrompt, currentChatCharacter);
                    } else {
                        response = await callChatAPI(userMessage.content, currentChatCharacter);
                    }
                } else if (userMessage.image) {
                    console.log('🔍 [AI处理调试] 走图片分支');

                    // 🔥【新增】检查是否为动图表情包
                    const isGifEmoji = userMessage.isEmoji && userMessage.image?.includes('data:image/gif');
                    console.log('🔍 [图片分支动图检测] 是否为GIF表情包:', isGifEmoji);

                    // 🔥【核心修复】根据设置决定是否识别表情包
                    if (userMessage.isEmoji && (apiSettings.emojiRecognitionEnabled === false || isGifEmoji)) {
                        // 表情包且用户关闭了表情包识别，或者是动图表情包，发送描述文字
                        const reason = isGifEmoji ? '动图表情包' : '表情包识别已关闭';
                        const emojiPrompt = `[用户发送了表情包：${userMessage.emojiDescription || '自定义表情包'}]`;
                        console.log(`🔍 [图片分支修复] 发送文字描述 (${reason}):`, emojiPrompt);
                        response = await callChatAPI(emojiPrompt, currentChatCharacter);
                    } else {
                        // 普通图片或启用了表情包识别，发送图片
                        const messageContent = [
                            { type: 'text', text: userMessage.content || "" },
                            { type: 'image_url', image_url: { url: userMessage.image } }
                        ];
                        console.log('🔍 [表情包调试] 发送给AI的消息内容:', messageContent);
                        console.log('🔍 [表情包调试] 表情包URL:', userMessage.image);
                        console.log('🔍 [表情包调试] 是否为表情包:', userMessage.isEmoji);
                        response = await callChatAPI(messageContent, currentChatCharacter);
                    }
                } else if (userMessage.type === 'transfer') {
                    // 🔥【关键修复】转账消息特殊处理 - 构造转账提示文本
                    const transferPrompt = `[用户发起了转账：${userMessage.amount}元，备注：${userMessage.note || '无'}]`;
                    response = await callChatAPI(transferPrompt, currentChatCharacter);
                } else {
                    console.log('🔍 [AI处理调试] 走普通文本分支');
                    console.log('🔍 [AI处理调试] userMessage完整结构:', userMessage);
                    console.log('🔍 [AI处理调试] userMessage.image存在吗:', !!userMessage.image);
                    console.log('🔍 [AI处理调试] userMessage.isEmoji值:', userMessage.isEmoji);

                    // 🔥【核心修复】检查是否是表情包消息但content为空的情况
                    if (userMessage.image && userMessage.isEmoji) {
                        console.log('🔍 [AI处理调试] 检测到表情包消息，重新路由到图片处理');
                        console.log('🔍 [AI处理调试] 表情包URL:', userMessage.image);
                        console.log('🔍 [AI处理调试] 表情包描述:', userMessage.emojiDescription);
                        console.log('🔍 [AI处理调试] 表情包识别设置:', apiSettings.emojiRecognitionEnabled);

                        // 表情包消息应该走图片处理分支
                        console.log('🔍 [表情包开关调试] apiSettings:', apiSettings);
                        console.log('🔍 [表情包开关调试] emojiRecognitionEnabled值:', apiSettings.emojiRecognitionEnabled);

                        // 🔥【新增】检查是否为动图表情包
                        const isGifEmoji = userMessage.image?.includes('data:image/gif');
                        console.log('🔍 [else分支动图检测] 是否为GIF表情包:', isGifEmoji);

                        if (apiSettings.emojiRecognitionEnabled === false || isGifEmoji) {
                            // 表情包且用户关闭了表情包识别，或者是动图表情包，发送描述文字
                            const reason = isGifEmoji ? '动图表情包' : '表情包识别已关闭';
                            const emojiPrompt = `[用户发送了表情包：${userMessage.emojiDescription || '自定义表情包'}]`;
                            console.log(`🔍 [else分支修复] 发送文字描述 (${reason}):`, emojiPrompt);
                            response = await callChatAPI(emojiPrompt, currentChatCharacter);
                        } else {
                            // 普通图片或启用了表情包识别，发送图片
                            const messageContent = [
                                { type: 'text', text: userMessage.content || "" },
                                { type: 'image_url', image_url: { url: userMessage.image } }
                            ];
                            console.log('🔍 [表情包修复] 发送给AI的消息内容:', messageContent);
                            console.log('🔍 [表情包修复] 图片URL长度:', userMessage.image?.length);
                            response = await callChatAPI(messageContent, currentChatCharacter);
                        }
                    } else {
                        // 普通文本消息
                        let finalPrompt = userMessage.content; // 默认使用原始消息内容

                        // 🔥【关键修复】检查用户消息是否为引用回复
                        if (userMessage.replyTo) {
                            const quoteText = summarizeLastMessage({ content: userMessage.replyTo.content });
                            finalPrompt = `[回复 ${userMessage.replyTo.senderName} 的消息: "${quoteText}"] ${userMessage.content}`;
                            console.log('✅ [重新生成] 构建用户引用提示:', finalPrompt);
                        }

                        response = await callChatAPI(finalPrompt, currentChatCharacter);
                    }
                }
                const aiMessages = await parseAiResponse(response);

                // 🔥【修复】不要在这里立即隐藏"正在输入中"，让每条消息处理时控制

                for (let i = 0; i < aiMessages.length; i++) {
                    const msgData = aiMessages[i];
                    let aiMessage;

                    console.log('🔍 [callChatAPI] 处理消息:', i, msgData);

            if (typeof msgData === 'object' && msgData !== null) {
                if (msgData.type === 'voice_message') {
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', type: 'voice_message', content: msgData.content, timestamp: Date.now() + i * 100 };
                } else if (msgData.type === 'ai_image') {
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', type: 'ai_image', content: msgData.description || 'AI描述的图片', imageDescription: msgData.description, timestamp: Date.now() + i * 100 };

                    // 🔥【关键修复】如果是群聊消息，添加发送者信息
                    if (msgData.name) {
                        console.log('🔍 [callChatAPI-AI图片] 检测到群聊消息，发送者:', msgData.name);
                        aiMessage.name = msgData.name;
                        // 查找对应的群成员ID
                        if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                            const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                            if (member) {
                                aiMessage.senderId = member.id;
                                console.log('🔍 [callChatAPI-AI图片] 找到群成员ID:', member.id);
                            } else {
                                console.log('🔍 [callChatAPI-AI图片] 未找到群成员:', msgData.name);
                            }
                        }
                    }
                } else if (msgData.type === 'transfer') {
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', type: 'transfer', amount: msgData.amount, note: msgData.note, timestamp: Date.now() + i * 100 };
                } else if (msgData.type === 'poke') {
                    // 🔥【新增】处理AI主动戳一戳
                    console.log('🔍 [callChatAPI-第二处] AI主动戳一戳:', msgData);
                    const chatSettings = getCurrentChatSettings();
                    const userNickname = chatSettings.myChatNickname || '你';
                    const pokeSuffix = chatSettings.myPokeSuffix || ''; // 🔥【修复】AI戳用户应该使用myPokeSuffix

                    aiMessage = {
                        id: (Date.now() + i).toString(),
                        sender: 'system',
                        content: `${currentChatCharacter.name}戳了戳${userNickname}${pokeSuffix}`,
                        timestamp: Date.now() + i * 100,
                        isPoke: true
                    };
                } else if (msgData.type === 'payment_request') {
                    // AI不能发起代付请求，忽略
                    console.log('🛒 [AI代付请求-早期分支] AI尝试发起代付请求，已忽略:', msgData);
                    aiMessage = null;
                } else if (msgData.type === 'emoji' && !msgData.name) {
                    // 🔥【关键修复】处理表情包消息 - 仅处理没有name字段的表情包（非群聊格式）
                    console.log('🔍 [callChatAPI] 进入单聊表情包分支:', msgData);
                    const matchingEmoji = await findEmojiForAI(msgData.description);
                    if (matchingEmoji) {
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: '',
                            image: matchingEmoji.url,
                            isEmoji: true,
                            emojiDescription: matchingEmoji.description,
                            timestamp: Date.now() + i * 100
                        };

                        // 🔥【修复】角色发送的表情包不应该添加到用户的最近使用列表
                    } else {
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: `[表情包"${msgData.description}"不存在]`,
                            timestamp: Date.now() + i * 100
                        };
                    }
                } else if (msgData.type === 'recall_previous') {
                    // 🔥【新增】处理AI撤回上一条消息
                    console.log('🔥 AI请求撤回上一条消息:', msgData);

                    // 查找上一条AI消息
                    const allMessages = chatMessages[currentChatCharacter.id] || [];
                    let lastAIMessageIndex = -1;

                    for (let j = allMessages.length - 1; j >= 0; j--) {
                        if (allMessages[j].sender === 'received') {
                            lastAIMessageIndex = j;
                            break;
                        }
                    }

                    if (lastAIMessageIndex !== -1) {
                        const messageToRecall = allMessages[lastAIMessageIndex];
                        console.log('🔥 找到要撤回的消息:', messageToRecall);

                        // 调用撤回消息处理函数
                        await handleRecalledMessage(messageToRecall.content, messageToRecall.id);
                    } else {
                        console.warn('🔥 没有找到可撤回的AI消息');
                        // 如果没有找到消息，显示一条提示
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: '[AI撤回了上一条消息]',
                            timestamp: Date.now() + i * 100
                        };
                    }
                    continue; // 跳过正常的消息处理流程
                } else if (msgData.type === 'change_avatar') {
                        if (msgData.avatar_url) {
                            // 🔥【修复】先处理占位符替换，再验证和执行头像更换
                            let actualAvatarUrl = msgData.avatar_url;
                            if (msgData.avatar_url === 'CURRENT_USER_IMAGE' ||
                                msgData.avatar_url === 'CURRENT_USER_IMAGE' ||
                                msgData.avatar_url === '用户发送的图片URL' ||
                                msgData.avatar_url === '图片URL') {
                                const recentUserImage = getRecentUserImage();
                                if (recentUserImage) {
                                    actualAvatarUrl = recentUserImage;
                                } else {
                                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[无法更换头像，没有找到可用的图片]', timestamp: Date.now() + i * 100 };
                                    continue;
                                }
                            }

                            const isValidAvatar = await validateAvatarSource(actualAvatarUrl);
                            if (isValidAvatar) {
                                const success = await changeCharacterAvatarByAI(actualAvatarUrl, msgData.reason || '心情变化');
                            if (success) continue;
                            else aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[头像更换失败]', timestamp: Date.now() + i * 100 };
                                } else {
                            aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[无效的头像来源，头像更换失败]', timestamp: Date.now() + i * 100 };
                                }
                            } else {
                        continue;
                    }
                } else if (msgData.type === 'reply_to') {
                    // 🔥【新增】处理AI引用回复
                    console.log('🔍 [引用回复-早期分支] 进入引用回复处理，msgData:', msgData);
                    // 查找被引用的消息
                    const referencedMessage = findMessageById(msgData.message_id);
                    console.log('🔍 [引用回复-早期分支] 查找到的被引用消息:', referencedMessage);

                    if (referencedMessage) {
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: msgData.content,
                            replyTo: {
                                id: referencedMessage.id,
                                content: referencedMessage.content,
                                senderName: referencedMessage.sender === 'sent' ? (getCurrentPersonaName() || '用户') : (currentChatCharacter.name || 'AI')
                            },
                            timestamp: Date.now() + i * 100
                        };

                        // 🔥【修复】为群聊引用回复添加发送者信息
                        if (msgData.name && currentChatCharacter?.isGroup && currentChatCharacter.members) {
                            const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                            if (member) {
                                aiMessage.name = msgData.name;
                                aiMessage.senderId = member.id;
                                console.log('🔍 [引用回复-早期分支] 设置群聊发送者:', msgData.name, 'ID:', member.id);
                            } else {
                                console.log('🔍 [引用回复-早期分支] 未找到群成员:', msgData.name);
                            }
                        }
                    } else {
                        // 如果找不到被引用的消息，发送普通消息
                        console.warn('找不到被引用的消息ID:', msgData.message_id);
                        aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: msgData.content, timestamp: Date.now() + i * 100 };

                        // 🔥【修复】为群聊引用回复添加发送者信息（找不到被引用消息的情况）
                        if (msgData.name && currentChatCharacter?.isGroup && currentChatCharacter.members) {
                            const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                            if (member) {
                                aiMessage.name = msgData.name;
                                aiMessage.senderId = member.id;
                                console.log('🔍 [引用回复-早期分支-fallback] 设置群聊发送者:', msgData.name, 'ID:', member.id);
                            } else {
                                console.log('🔍 [引用回复-早期分支-fallback] 未找到群成员:', msgData.name);
                            }
                        }
                    }
                } else if (msgData.name && msgData.type === 'emoji') {
                    // 🔥【新增】处理直接的群聊表情包格式 {"name": "角色名", "type": "emoji", "description": "表情包描述"}
                    console.log('🔍 [群聊表情包-直接格式] 检测到直接格式的群聊表情包:', msgData);

                    let senderId = null;
                    if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                        console.log('🔍 [群聊表情包-直接格式] 查找成员详情:', {
                            targetName: msgData.name,
                            allMembers: currentChatCharacter.members,
                            memberNames: currentChatCharacter.members.map(m => m.name)
                        });

                        const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                        if (member) {
                            senderId = member.id;
                            console.log('🔍 [群聊表情包-直接格式] 找到成员:', member, 'senderId:', senderId);
                        } else {
                            console.warn('🔍 [群聊表情包-直接格式] 未找到成员:', msgData.name);
                            console.warn('🔍 [群聊表情包-直接格式] 可用成员名称:', currentChatCharacter.members.map(m => m.name));
                        }
                    }

                    const matchingEmoji = await findEmojiForAI(msgData.description);
                    if (matchingEmoji) {
                        console.log('🔍 [群聊表情包-直接格式] 找到匹配的表情包:', matchingEmoji);

                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            name: msgData.name,
                            senderId: senderId,
                            content: '', // 表情包消息不显示文字内容
                            image: matchingEmoji.url,
                            isEmoji: true,
                            emojiDescription: matchingEmoji.description,
                            timestamp: Date.now() + i * 100
                        };

                        console.log('🔍 [群聊表情包-直接格式] 创建的消息对象:', aiMessage);
                        // 🔥【修复】角色发送的表情包不应该添加到用户的最近使用列表
                    } else {
                        console.warn('🔍 [群聊表情包-直接格式] 找不到匹配的表情包:', msgData.description);

                        // 如果找不到匹配的表情包，发送错误消息
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            name: msgData.name,
                            senderId: senderId,
                            content: `[表情包"${msgData.description}"不存在]`,
                            timestamp: Date.now() + i * 100
                        };
                    }
                } else if (msgData.name && msgData.message) {
                    // 🔥【关键修复】这是群聊的特殊格式
                    console.log('🔍 [群聊消息] 处理群聊消息:', msgData);
                    console.log('🔍 [群聊消息] msgData.message类型:', typeof msgData.message, 'msgData.message:', msgData.message);

                    let senderId = null;
                    if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                        // 🔥【修复】优先使用persona字段查找成员
                        console.log('🔍 [群聊身份] 查找成员:', msgData.name, '在群聊:', currentChatCharacter.name);
                        console.log('🔍 [群聊身份] 群成员列表:', currentChatCharacter.members);

                        const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                        if (member) {
                            senderId = member.id;
                            console.log('🔍 [群聊身份] 找到成员:', member, 'senderId:', senderId);
                        } else {
                            console.warn('🔍 [群聊身份] 未找到成员:', msgData.name);
                        }
                    }

                    // --- 关键修复：检查群聊消息内容是否为特殊类型 ---
                    if (typeof msgData.message === 'object' && msgData.message.type === 'voice_message') {
                        // 如果消息内容是一个语音消息对象
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'voice_message', // 在外层消息上设置正确的类型
                            name: msgData.name,
                            senderId: senderId,
                            content: msgData.message.content, // 提取真正的语音文字内容
                            timestamp: Date.now() + i * 100
                        };
                    } else if (typeof msgData.message === 'object' && msgData.message.type === 'reply_to') {
                        // 🔥【新增】群聊中的引用回复
                        const referencedMessage = findMessageById(msgData.message.message_id);
                        if (referencedMessage) {
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                name: msgData.name,
                                senderId: senderId,
                                content: msgData.message.content,
                                replyTo: {
                                    id: referencedMessage.id,
                                    content: referencedMessage.content,
                                    senderName: referencedMessage.sender === 'sent' ? (getCurrentPersonaName() || '用户') : (referencedMessage.name || referencedMessage.senderName || 'AI')
                                },
                                timestamp: Date.now() + i * 100
                            };
                        } else {
                            // 如果找不到被引用的消息，发送普通群聊消息
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                name: msgData.name,
                                senderId: senderId,
                                content: msgData.message.content,
                                timestamp: Date.now() + i * 100
                            };
                        }
                    } else if (typeof msgData.message === 'object' && msgData.message.type === 'emoji') {
                        // 🔥【关键修复】如果消息内容是一个表情包对象
                        console.log('🔍 [群聊表情包] 检测到群聊表情包消息:', msgData);

                        const matchingEmoji = await findEmojiForAI(msgData.message.description);
                        if (matchingEmoji) {
                            console.log('🔍 [群聊表情包] 找到匹配的表情包:', matchingEmoji);

                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                name: msgData.name,
                                senderId: senderId,
                                content: '', // 表情包消息不显示文字内容
                                image: matchingEmoji.url,
                                isEmoji: true,
                                emojiDescription: matchingEmoji.description,
                                timestamp: Date.now() + i * 100
                            };

                            console.log('🔍 [群聊表情包] 创建的消息对象:', aiMessage);
                            console.log('🔍 [群聊表情包] senderId设置为:', senderId, 'name设置为:', msgData.name);

                            // 🔥【修复】角色发送的表情包不应该添加到用户的最近使用列表
                        } else {
                            console.warn('🔍 [群聊表情包] 找不到匹配的表情包:', msgData.message.description);

                            // 如果找不到匹配的表情包，发送错误消息
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                name: msgData.name,
                                senderId: senderId,
                                content: `[表情包"${msgData.message.description}"不存在]`,
                                timestamp: Date.now() + i * 100
                            };
                        }
                    } else if (typeof msgData.message === 'object' && msgData.message.type === 'transfer') {
                        // 🔥【修复】如果消息内容是一个转账对象
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'transfer', // 在外层消息上设置正确的类型
                            name: msgData.name,
                            senderId: senderId,
                            amount: msgData.message.amount, // 提取转账金额
                            note: msgData.message.note, // 提取转账备注
                            timestamp: Date.now() + i * 100
                        };
                    } else if (typeof msgData.message === 'object' && msgData.message.type === 'friend_request') {
                        // 🔥【新增】如果消息内容是一个好友申请对象
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'friend_request', // 在外层消息上设置正确的类型
                            name: msgData.name,
                            senderId: senderId,
                            message: msgData.message.message, // 提取好友申请消息
                            timestamp: Date.now() + i * 100
                        };
                    } else {
                        // 对于普通的文本消息
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            name: msgData.name,
                            senderId: senderId,
                            content: msgData.message, // 内容本身是字符串
                            timestamp: Date.now() + i * 100
                        };
                    }
                    // --- 修复结束 ---
                        } else {
                    // 🔥【关键修复】检查是否是特殊类型对象但未被上面的条件捕获
                    if (typeof msgData === 'object' && msgData !== null) {
                        if (msgData.type === 'transfer') {
                            // 转账对象被遗漏了，重新处理
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                type: 'transfer',
                                amount: msgData.amount,
                                note: msgData.note,
                                timestamp: Date.now() + i * 100
                            };
                        } else if (msgData.type === 'voice_message') {
                            // 语音消息对象被遗漏了，重新处理
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                type: 'voice_message',
                                content: msgData.content,
                                timestamp: Date.now() + i * 100
                            };
                        } else if (msgData.type === 'ai_image') {
                            // AI图片对象被遗漏了，重新处理
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                type: 'ai_image',
                                content: '',
                                image: `data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="200" height="150" viewBox="0 0 200 150"><rect width="200" height="150" fill="#f0f0f0"/><text x="100" y="75" text-anchor="middle" font-family="Arial" font-size="12" fill="#666">[AI描述的图片]</text></svg>')}`,
                                imageDescription: msgData.description,
                                timestamp: Date.now() + i * 100
                            };
                        } else if (msgData.type === 'payment_request') {
                            // AI不能发起代付请求，忽略
                            console.log('🛒 [AI代付请求-遗漏分支] AI尝试发起代付请求，已忽略:', msgData);
                            aiMessage = null;
                        } else if (msgData.type === 'emoji') {
                            // 🔥【修复】表情包对象被遗漏了，重新处理 - 支持群聊
                            console.log('🔍 [遗漏表情包] 检测到遗漏的表情包对象:', msgData);

                            const matchingEmoji = await findEmojiForAI(msgData.description);
                            if (matchingEmoji) {
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    content: '',
                                    image: matchingEmoji.url,
                                    isEmoji: true,
                                    emojiDescription: matchingEmoji.description,
                                    timestamp: Date.now() + i * 100
                                };

                                // 🔥【关键修复】如果是群聊，需要设置发送者信息
                                if (currentChatCharacter && currentChatCharacter.isGroup) {
                                    // 对于群聊中的表情包，需要指定是哪个角色发送的
                                    // 由于这是在处理遗漏的表情包对象，我们需要从当前群聊中选择一个默认角色
                                    if (currentChatCharacter.members && currentChatCharacter.members.length > 0) {
                                        const defaultMember = currentChatCharacter.members[0];
                                        aiMessage.name = defaultMember.name;
                                        aiMessage.senderId = defaultMember.id;
                                        console.log('🔍 [遗漏表情包] 设置默认发送者:', defaultMember.name, 'ID:', defaultMember.id);
                                    }
                                }

                                console.log('🔍 [遗漏表情包] 创建的消息对象:', aiMessage);

                                // 🔥【修复】角色发送的表情包不应该添加到用户的最近使用列表
                            } else {
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    content: `[表情包"${msgData.description}"不存在]`,
                                    timestamp: Date.now() + i * 100
                                };

                                // 🔥【关键修复】错误消息也需要群聊发送者信息
                                if (currentChatCharacter && currentChatCharacter.isGroup) {
                                    if (currentChatCharacter.members && currentChatCharacter.members.length > 0) {
                                        const defaultMember = currentChatCharacter.members[0];
                                        aiMessage.name = defaultMember.name;
                                        aiMessage.senderId = defaultMember.id;
                                    }
                                }
                            }
                        } else {
                            // 🔥【修复】检查是否是特殊指令对象
                            if (msgData.type && ['create_anniversary', 'create_appointment', 'block_user', 'system_command', 'internal_action', 'background_task'].includes(msgData.type)) {
                                console.log('🔧 [regenerateLastResponse] 检测到特殊指令对象，跳过显示:', msgData);
                                continue; // 跳过这个消息，不创建aiMessage
                            }
                            // 其他对象类型，尝试提取文本内容
                            const displayContent = msgData.content || msgData.message || msgData.text || msgData.reply || '[不支持的消息格式]';
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: displayContent, timestamp: Date.now() + i * 100 };
                        }
                                            } else {
                        // 普通字符串或其他基本类型
                        const displayContent = String(msgData);
                        aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: displayContent, timestamp: Date.now() + i * 100 };
                    }
                        }
                                            } else {
                // 🔥【关键修复 - regenerateLastResponse版本】检查是否是特殊类型对象但未被上面的条件捕获
                if (typeof msgData === 'object' && msgData !== null) {
                    if (msgData.type === 'transfer') {
                        // 转账对象被遗漏了，重新处理
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'transfer',
                            amount: msgData.amount,
                            note: msgData.note,
                            timestamp: Date.now() + i * 100
                        };
                    } else if (msgData.type === 'voice_message') {
                        // 语音消息对象被遗漏了，重新处理
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'voice_message',
                            content: msgData.content,
                            timestamp: Date.now() + i * 100
                        };
                    } else if (msgData.type === 'ai_image') {
                        // AI图片对象被遗漏了，重新处理
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'ai_image',
                            content: msgData.description || 'AI描述的图片',
                            imageDescription: msgData.description,
                            timestamp: Date.now() + i * 100
                        };

                        // 🔥【关键修复】如果是群聊消息，添加发送者信息
                        if (msgData.name) {
                            console.log('🔍 [第四处-AI图片] 检测到群聊消息，发送者:', msgData.name);
                            aiMessage.name = msgData.name;
                            // 查找对应的群成员ID
                            if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                                const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                                if (member) {
                                    aiMessage.senderId = member.id;
                                    console.log('🔍 [第四处-AI图片] 找到群成员ID:', member.id);
                                } else {
                                    console.log('🔍 [第四处-AI图片] 未找到群成员:', msgData.name);
                                }
                            }
                        }
                    } else if (msgData.type === 'emoji') {
                        // 表情包对象被遗漏了，重新处理
                        const matchingEmoji = await findEmojiForAI(msgData.description);
                        if (matchingEmoji) {
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                content: '',
                                image: matchingEmoji.url,
                                isEmoji: true,
                                emojiDescription: matchingEmoji.description,
                                timestamp: Date.now() + i * 100
                            };
                            // 🔥【修复】角色发送的表情包不应该添加到用户的最近使用列表
                        } else {
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                content: `[表情包"${msgData.description}"不存在]`,
                                timestamp: Date.now() + i * 100
                            };
                        }
                    } else {
                        // 🔥【修复】检查是否是特殊指令对象
                        if (msgData.type && ['create_anniversary', 'create_appointment', 'block_user', 'system_command', 'internal_action', 'background_task'].includes(msgData.type)) {
                            console.log('🔧 [regenerateLastResponse-2] 检测到特殊指令对象，跳过显示:', msgData);
                            continue; // 跳过这个消息，不创建aiMessage
                        }
                        // 其他对象类型，尝试提取文本内容
                        const displayContent = msgData.content || msgData.message || msgData.text || msgData.reply || '[不支持的消息格式]';
                        aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: displayContent, timestamp: Date.now() + i * 100 };
                    }
                } else if (typeof msgData === 'string') {
                    // 🔥【修复】普通字符串消息 - 确保正确处理
                    console.log('🔥 [DEBUG] 处理普通字符串消息:', msgData);
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: msgData, timestamp: Date.now() + i * 100 };
                } else {
                    // 其他基本类型
                    console.log('🔥 [DEBUG] 处理其他类型消息:', typeof msgData, msgData);
                aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: String(msgData), timestamp: Date.now() + i * 100 };
                }
                    }

                    chatMessages[characterId].push(aiMessage);
                    // 🔥【高效保存】直接添加单条AI消息到数据库，避免全量重写
                    try {
                        // 🔥【修复】使用时间戳和随机数确保ID唯一性，避免重复键错误
                        const stableId = `${characterId}_ai_reply_${aiMessage.timestamp}_${Math.random().toString(36).substr(2, 9)}_${chatMessages[characterId].length - 1}`;
                        await db.chatMessages.add({
                            id: stableId,
                            characterId: characterId,
                            timestamp: aiMessage.timestamp,
                            messageOrder: chatMessages[characterId].length - 1,
                            originalMessageId: aiMessage.id,
                            messageData: aiMessage
                        });
                        console.log('✅ [高效AI回复] 单条消息已保存到数据库');
                    } catch (error) {
                        console.error('AI消息单条保存失败，回退到批量保存:', error);
                        await saveChatMessages();
                    }

            // 🔥【新增】记录AI回复到全局记忆事件
            const character = characters.find(c => c.id === characterId);
            if (character) {
                // 🔥【修复】构建安全的事件数据，避免循环引用
                const eventData = {
                    sender: characterId,
                    content: aiMessage.content || '[特殊消息]',
                    messageType: aiMessage.type || 'text'
                };

                // 🔥【修复】如果是引用消息，添加引用信息但避免对象嵌套
                if (aiMessage.replyTo) {
                    eventData.replyToId = aiMessage.replyTo.id;
                    eventData.replyToSender = aiMessage.replyTo.senderName;
                    eventData.replyToContent = aiMessage.replyTo.content;
                }

                await recordMemoryEvent(
                    [characterId, 'user'],
                    {
                        type: character.isGroup ? 'group_chat' : 'private_chat',
                        id: characterId
                    },
                    'message',
                    eventData,
                    0.7 // AI消息重要性
                );
            }

                    // 🔥【修复】在第一条消息处理完后隐藏"正在输入中"
                    if (i === 0) {
                        hideTypingIndicator();
                    }

                    // 🔥【修复】使用addMessageWithAnimation添加单个消息，而不是重新渲染整个列表
                    addMessageWithAnimation(aiMessage, characterId);

                    // 🔥【修复】在消息之间正确显示"正在输入中"提示
                    if (i < aiMessages.length - 1) {
                        const delay = Math.random() * 1000 + 500;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        showTypingIndicator();
                        await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));
                        hideTypingIndicator();
                    }
                }
            } catch (error) {
                console.error('重新生成失败:', error);
                hideTypingIndicator();
                const errorMessage = {
                    id: Date.now().toString(),
                    sender: 'received',
                    content: `[重新生成失败: ${error.message}]`,
                    timestamp: Date.now()
                };
                chatMessages[characterId].push(errorMessage);
                // 🔥【优化】错误消息使用高效保存
                try {
                    await saveChatMessagesImmediate([characterId]);
                    console.log('✅ [高效错误消息] 消息已保存到数据库');
                } catch (error) {
                    console.error('错误消息保存失败，回退到全量保存:', error);
                    await saveChatMessages();
                }
                renderChatMessages(characterId);
            } finally {
                // 🔥【修复】在这里也清除待回复消息，并重置重新生成标志
                pendingUserMessage = null;
                window._isRegenerating = false;
            }

            updateFloatingButtonsVisibility();
        }

        // 🔥【重构】智能回复功能 - 统一消息格式，移除复杂的合并逻辑
        function triggerSmartReply() {
            // 🔥【调试】添加调用栈追踪
            console.log('🚨 [DEBUG] triggerSmartReply 被调用！');
            console.log('🚨 [DEBUG] 调用栈:', new Error().stack);

            if (!currentChatCharacter) {
                alert('请先选择一个角色');
                return;
            }

            if (isWaitingForReply) {
                // 🔥【修复】不使用弹窗，改为显示按钮状态提示
                return;
            }

            const messages = chatMessages[currentChatCharacter.id] || [];

            // 🔥【修复】收集同一轮对话中的所有未回复用户消息
            let unrepliedUserMessages = [];
            let lastAIMessageIndex = -1;

            // 找到最后一条AI消息的位置
            for (let i = messages.length - 1; i >= 0; i--) {
                if (messages[i].sender === 'received') {
                    lastAIMessageIndex = i;
                    break;
                }
            }

            // 收集最后一条AI消息之后的所有用户消息
            for (let i = lastAIMessageIndex + 1; i < messages.length; i++) {
                if (messages[i].sender === 'sent') {
                    unrepliedUserMessages.push(messages[i]);
                }
            }

            // 🔥【修复】定义变量
            const lastUserMessage = messages.slice().reverse().find(msg => msg.sender === 'sent');
            const hasUnrepliedUserMessage = unrepliedUserMessages.length > 0;

            // 情况1：有未回复的用户消息
            if (unrepliedUserMessages.length > 0) {
                console.log('🔍 [triggerSmartReply] 找到未回复的用户消息数量:', unrepliedUserMessages.length);

                // 🔥【关键修复】合并所有未回复的用户消息内容
                const mergedContent = [];
                let mergedMessageId = '';
                let latestTimestamp = 0;

                unrepliedUserMessages.forEach((msg, index) => {
                    console.log(`🔍 [triggerSmartReply] 处理消息 ${index + 1}:`, {
                        id: msg.id,
                        type: msg.type,
                        contentLength: Array.isArray(msg.content) ? msg.content.length : 1,
                        hasImage: Array.isArray(msg.content) ? msg.content.some(item => item.type === 'image_url') : !!msg.image
                    });

                    // 🔥【关键修复】跳过已处理的转账消息，避免重复处理
                    if (msg.type === 'transfer' && msg.status) {
                        console.log('🔍 [triggerSmartReply] 跳过已处理的转账消息:', msg);
                        return; // 跳过这条消息
                    }

                    if (Array.isArray(msg.content)) {
                        mergedContent.push(...msg.content);
                    } else if (msg.type === 'transfer') {
                        // 🔥【关键修复】处理转账消息 - 转换为AI能理解的文本格式
                        const transferText = `[用户发起了转账：${msg.amount}元，备注：${msg.note || '无'}]`;
                        mergedContent.push({ type: 'text', text: transferText });
                        console.log('🔍 [triggerSmartReply] 添加转账消息:', transferText);
                    } else if (msg.type === 'voice_message') {
                        // 🔥【新增】处理语音消息
                        const voiceText = `[用户发来一条语音消息，内容是：'${msg.content}']`;
                        mergedContent.push({ type: 'text', text: voiceText });
                        console.log('🔍 [triggerSmartReply] 添加语音消息:', voiceText);
                    } else if (msg.type === 'user_photo') {
                        // 🔥【新增】处理用户照片
                        const photoText = `[用户发送了一张照片，描述是：'${msg.content}']`;
                        mergedContent.push({ type: 'text', text: photoText });
                        console.log('🔍 [triggerSmartReply] 添加照片消息:', photoText);
                    } else if (msg.type === 'location') {
                        // 🔥【新增】处理位置消息
                        const locationText = msg.content || `[用户分享了位置信息：${msg.locationName}]`;
                        mergedContent.push({ type: 'text', text: locationText });
                        console.log('🔍 [triggerSmartReply] 添加位置消息:', locationText);
                    } else if (msg.image) {
                        // 🔥【核心修复】处理表情包和图片消息
                        if (msg.content) {
                            mergedContent.push({ type: 'text', text: msg.content });
                        }
                        mergedContent.push({ type: 'image_url', image_url: { url: msg.image } });
                    } else {
                        // 兼容旧格式的字符串消息
                        mergedContent.push({ type: 'text', text: msg.content });
                    }

                    mergedMessageId += msg.id + '_';
                    latestTimestamp = Math.max(latestTimestamp, msg.timestamp);
                });

                // 创建合并后的消息对象
                pendingUserMessage = {
                    id: mergedMessageId.slice(0, -1), // 移除最后的下划线
                    sender: 'sent',
                    content: mergedContent,
                    timestamp: latestTimestamp,
                    isMerged: true, // 标记为合并消息
                    originalMessages: unrepliedUserMessages // 保留原始消息引用
                };

                console.log('🔍 [triggerSmartReply] 合并后的消息:', {
                    contentLength: pendingUserMessage.content.length,
                    hasText: pendingUserMessage.content.some(item => item.type === 'text'),
                    hasImage: pendingUserMessage.content.some(item => item.type === 'image_url'),
                    textCount: pendingUserMessage.content.filter(item => item.type === 'text').length,
                    imageCount: pendingUserMessage.content.filter(item => item.type === 'image_url').length
                });

                processAIReply();
                return;
            }

            // 情况2：最后的用户消息已有AI回复，需要AI续写
            if (lastUserMessage && !hasUnrepliedUserMessage) {
                // 检查从最后一条用户消息后的AI回复回合数
                let aiReplyRounds = 0;
                let lastUserMessageIndex = -1;

                // 找到最后一条用户消息的索引
                for (let i = messages.length - 1; i >= 0; i--) {
                    if (messages[i].sender === 'sent') {
                        lastUserMessageIndex = i;
                        break;
                    }
                }

                // 计算从最后一条用户消息后的AI回复回合数
                // 一回合 = 连续的AI消息直到下一个断点
                if (lastUserMessageIndex !== -1) {
                    let inAIReplyRound = false;

                    for (let i = lastUserMessageIndex + 1; i < messages.length; i++) {
                        if (messages[i].sender === 'received') {
                            if (!inAIReplyRound) {
                                // 开始新的AI回复回合
                                aiReplyRounds++;
                                inAIReplyRound = true;
                            }
                            // 继续当前回合（多条连续AI消息算一回合）
                        } else {
                            // 如果有其他类型消息，结束当前回合
                            inAIReplyRound = false;
                        }
                    }
                }

                // AI回复逻辑：
                // aiReplyRounds = 0: 没有回复用户消息，不应该到这里
                // aiReplyRounds = 1: 已回复用户消息1回合，现在是第1次续写（第2回合）
                // aiReplyRounds = 2: 已回复+续写1回合，现在是第2次续写（第3回合）
                // aiReplyRounds >= 3: 已回复+续写2回合，提示用户发消息

                if (aiReplyRounds >= 3) {
                    const characterName = currentChatCharacter.name;
                    alert(`${characterName}已经说了很多话了，先和${characterName}说说话吧~`);
                    return;
                }

                // 🔥【修复】在续写前也要检查是否有未处理的转账
                const lastUserTransfer = messages.slice().reverse().find(msg =>
                    msg.sender === 'sent' && msg.type === 'transfer' && !msg.status);
                if (lastUserTransfer) {
                    // 如果有未处理的转账，先设置为待处理，然后处理回复
                    pendingUserMessage = lastUserTransfer;
                    processAIReply();
                    return;
                }

                // AI续写对话（第1次或第2次续写）
                processAIContinuation();
                return;
            }

            // 情况3：没有用户消息
            alert('请先发送一条消息，然后点击此按钮来获取AI回复');
        }

                // 处理AI续写对话
        async function processAIContinuation() {
            if (!currentChatCharacter) return;

            // 防止重复调用
            if (isWaitingForReply) {
                console.log('AI正在续写中，忽略重复调用');
                return;
            }

            // 🔥【关键修复】记录当前聊天角色ID，确保AI续写消息归属到正确的聊天窗口
            const continuingCharacterId = currentChatCharacter.id;

            isWaitingForReply = true;

            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.disabled = true;
                smartReplyBtn.style.opacity = '0.65';
                smartReplyBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            }

            // 显示正在输入提示
            showTypingIndicator();

            // 添加随机延迟
            const delay = Math.random() * 2000 + 1000;
            await new Promise(resolve => setTimeout(resolve, delay));

            try {
                // 获取AI最后的消息内容，以便基于此续写
                const messages = chatMessages[continuingCharacterId] || [];
                let lastAIMessage = "";

                // 找到最后一条AI消息
                for (let i = messages.length - 1; i >= 0; i--) {
                    if (messages[i].sender === 'received') {
                        lastAIMessage = messages[i].content || "";
                        break;
                    }
                }

                // 构建续写提示词，基于AI自己最后的话来续写
                let continuationPrompt = "你刚才说了：\"" + lastAIMessage + "\"\n\n";
                continuationPrompt += "现在请基于你刚才说的话，主动继续这个话题或者自然地转到相关话题。就像真实聊天中，你想要继续表达更多想法，或者询问对方的看法，或者分享相关的内容。请自然地继续对话，不要重复之前说过的话。";
                continuationPrompt += "\n\n🚨 重要提醒：请严格遵守JSON格式，每条消息必须分开发送，绝对不能将多条消息合并在一个元素中！正确格式：[\"消息1\", \"消息2\"]，错误格式：[\"消息1\\n消息2\"]";

                const response = await callChatAPI(continuationPrompt, currentChatCharacter);
                const aiMessages = await parseAiResponse(response);

                // 🔥【修复】在续写时也要检查是否有转账需要处理
                const chatHistory = chatMessages[continuingCharacterId] || [];
                const lastUserMessage = chatHistory.slice().reverse().find(msg =>
                    msg.sender === 'sent' && msg.type === 'transfer' && !msg.status);
                if (lastUserMessage) {
                    console.log('🔥 [续写] 检测到用户转账消息，开始处理转账:', {
                        lastUserMessage,
                        aiMessages,
                        characterName: currentChatCharacter?.name
                    });
                    await processUserTransfer(lastUserMessage, aiMessages, continuingCharacterId);
                }

                hideTypingIndicator();

                // 逐条发送消息
                for (let i = 0; i < aiMessages.length; i++) {
                    const msgData = aiMessages[i];
                    let aiMessage;

                    if (typeof msgData === 'object' && msgData.type === 'recall_previous') {
                        // 🔥【新增】处理AI撤回上一条消息
                        console.log('🔥 [续写] AI请求撤回上一条消息:', msgData);

                        // 查找上一条AI消息
                        const allMessages = chatMessages[continuingCharacterId] || [];
                        let lastAIMessageIndex = -1;

                        for (let j = allMessages.length - 1; j >= 0; j--) {
                            if (allMessages[j].sender === 'received') {
                                lastAIMessageIndex = j;
                                break;
                            }
                        }

                        if (lastAIMessageIndex !== -1) {
                            const messageToRecall = allMessages[lastAIMessageIndex];
                            console.log('🔥 [续写] 找到要撤回的消息:', messageToRecall);

                            // 调用撤回消息处理函数
                            await handleRecalledMessage(messageToRecall.content, messageToRecall.id);
                        } else {
                            console.warn('🔥 [续写] 没有找到可撤回的AI消息');
                        }
                        continue; // 跳过正常的消息处理流程
                    } else if (typeof msgData === 'object' && msgData.type === 'voice_message') {
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'voice_message',
                            content: msgData.content,
                            timestamp: Date.now() + i * 100
                        };
                    } else if (typeof msgData === 'object' && msgData.type === 'ai_image') {
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'ai_image',
                            content: msgData.description || 'AI描述的图片',
                            imageDescription: msgData.description,
                            timestamp: Date.now() + i * 100
                        };

                        // 🔥【关键修复】如果是群聊消息，添加发送者信息
                        if (msgData.name) {
                            console.log('🔍 [第三处-AI图片] 检测到群聊消息，发送者:', msgData.name);
                            aiMessage.name = msgData.name;
                            // 查找对应的群成员ID
                            if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                                const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                                if (member) {
                                    aiMessage.senderId = member.id;
                                    console.log('🔍 [第三处-AI图片] 找到群成员ID:', member.id);
                                } else {
                                    console.log('🔍 [第三处-AI图片] 未找到群成员:', msgData.name);
                                }
                            }
                        }
                    } else if (typeof msgData === 'object' && msgData.type === 'transfer') {
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'transfer',
                            amount: msgData.amount,
                            note: msgData.note,
                            timestamp: Date.now() + i * 100
                        };
                    } else if (typeof msgData === 'object' && msgData.type === 'poke') {
                        // 🔥【新增】处理AI主动戳一戳(第三处)
                        console.log('🔍 [callChatAPI-第三处] AI主动戳一戳:', msgData);
                        const chatSettings = getCurrentChatSettings();
                        const userNickname = chatSettings.myChatNickname || '你';
                        const pokeSuffix = chatSettings.myPokeSuffix || ''; // 🔥【修复】AI戳用户应该使用myPokeSuffix

                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'system',
                            content: `${currentChatCharacter.name}戳了戳${userNickname}${pokeSuffix}`,
                            timestamp: Date.now() + i * 100,
                            isPoke: true
                        };
                    } else if (typeof msgData === 'object' && msgData.type === 'emoji') {
                        // 处理AI发送的表情包 - 从本地表情包库中查找
                        console.log('🔍 [callChatAPI] 进入通用表情包分支:', msgData);
                        const matchingEmoji = await findEmojiForAI(msgData.description);

                        if (matchingEmoji) {
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                content: '',
                                image: matchingEmoji.url,
                                isEmoji: true,
                                emojiDescription: matchingEmoji.description,
                                timestamp: Date.now() + i * 100
                            };

                            // 🔥【修复】如果是群聊消息，添加发送者信息
                            if (msgData.name) {
                                aiMessage.name = msgData.name;
                                // 查找对应的群成员ID
                                if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                                    const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                                    if (member) {
                                        aiMessage.senderId = member.id;
                                    }
                                }
                            }

                            // 🔥【修复】角色发送的表情包不应该添加到用户的最近使用列表
                        } else {
                            // 如果找不到表情包，显示错误信息
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                content: `[表情包"${msgData.description}"不存在]`,
                                timestamp: Date.now() + i * 100
                            };
                        }
                    } else if (typeof msgData === 'object' && msgData.type === 'change_avatar') {
                        // 🔥【新增】处理头像更换对象
                        console.log('处理头像更换消息(续写):', msgData);
                        if (msgData.avatar_url) {
                            // 🔥【修复】先处理占位符替换，再验证和执行头像更换
                            let actualAvatarUrl = msgData.avatar_url;
                            if (msgData.avatar_url === 'CURRENT_USER_IMAGE' ||
                                msgData.avatar_url === 'CURRENT_USER_IMAGE' ||
                                msgData.avatar_url === '用户发送的图片URL' ||
                                msgData.avatar_url === '图片URL') {
                                const recentUserImage = getRecentUserImage();
                                if (recentUserImage) {
                                    actualAvatarUrl = recentUserImage;
                                } else {
                                    aiMessage = {
                                        id: (Date.now() + i).toString(),
                                        sender: 'received',
                                        content: '[无法更换头像，没有找到可用的图片]',
                                        timestamp: Date.now() + i * 100
                                    };
                                    continue;
                                }
                            }

                            // 验证头像URL是否来自用户发送的图片或世界书中的URL
                            const isValidAvatar = await validateAvatarSource(actualAvatarUrl);
                            console.log('头像来源验证结果(续写):', isValidAvatar, '头像URL:', actualAvatarUrl);

                            if (isValidAvatar) {
                                // 执行头像更换
                                const success = await changeCharacterAvatarByAI(actualAvatarUrl, msgData.reason || '心情变化');
                                console.log('头像更换执行结果(续写):', success);
                                if (success) {
                                    // 跳过这条消息，只执行头像更换，系统消息已在changeCharacterAvatarByAI中添加
                                    continue;
                                } else {
                                    aiMessage = {
                                        id: (Date.now() + i).toString(),
                                        sender: 'received',
                                        content: '[头像更换失败]',
                                        timestamp: Date.now() + i * 100
                                    };
                                }
                            } else {
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    content: '[无效的头像来源，头像更换失败]',
                                    timestamp: Date.now() + i * 100
                                };
                            }
                        } else {
                            console.log('头像更换消息缺少avatar_url(续写)');
                            continue; // 如果没有有效的头像URL，跳过此消息
                        }
                    } else if (typeof msgData === 'object' && msgData !== null && msgData.name && msgData.message) {
                        // 🔥【群聊消息关键修复】群聊消息格式: {name: "角色名", message: "消息内容"}
                        console.log('🔥 [修复continuation] 发现群聊消息:', msgData);

                        // 查找群成员ID
                        let senderId = null;
                        if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                            const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                            if (member) {
                                senderId = member.id;
                            }
                        }

                        // --- 关键修复：检查群聊消息内容是否为特殊类型 ---
                        if (typeof msgData.message === 'object' && msgData.message.type === 'voice_message') {
                            // 如果消息内容是一个语音消息对象
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                type: 'voice_message', // 在外层消息上设置正确的类型
                                name: msgData.name,
                                senderId: senderId,
                                content: msgData.message.content, // 提取真正的语音文字内容
                                timestamp: Date.now() + i * 100
                            };
                        } else {
                            // 对于普通的文本消息
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            name: msgData.name,          // 保存发言者名字
                            senderId: senderId,          // 保存发言者ID
                            content: msgData.message,    // 使用message字段作为内容
                            timestamp: Date.now() + i * 100
                        };
                        }
                        // --- 修复结束 ---
                        console.log('✅ [修复continuation] 群聊消息已正确解析:', aiMessage);
                                            } else {
                        // 🔥【关键修复 - 续写版本】检查是否是特殊类型对象但未被上面的条件捕获
                        if (typeof msgData === 'object' && msgData !== null) {
                            if (msgData.type === 'transfer') {
                                // 转账对象被遗漏了，重新处理
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    type: 'transfer',
                                    amount: msgData.amount,
                                    note: msgData.note,
                                    timestamp: Date.now() + i * 100
                                };
                            } else if (msgData.type === 'voice_message') {
                                // 语音消息对象被遗漏了，重新处理
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    type: 'voice_message',
                                    content: msgData.content,
                                    timestamp: Date.now() + i * 100
                                };
                            } else if (msgData.type === 'ai_image') {
                                // AI图片对象被遗漏了，重新处理
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    type: 'ai_image',
                                    content: msgData.description || 'AI描述的图片',
                                    imageDescription: msgData.description,
                                    timestamp: Date.now() + i * 100
                                };

                                // 🔥【关键修复】如果是群聊消息，添加发送者信息
                                if (msgData.name) {
                                    console.log('🔍 [第五处-AI图片] 检测到群聊消息，发送者:', msgData.name);
                                    aiMessage.name = msgData.name;
                                    // 查找对应的群成员ID
                                    if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                                        const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                                        if (member) {
                                            aiMessage.senderId = member.id;
                                            console.log('🔍 [第五处-AI图片] 找到群成员ID:', member.id);
                                        } else {
                                            console.log('🔍 [第五处-AI图片] 未找到群成员:', msgData.name);
                                        }
                                    }
                                }
                            } else if (msgData.type === 'emoji') {
                                // 表情包对象被遗漏了，重新处理
                                const matchingEmoji = await findEmojiForAI(msgData.description);
                                if (matchingEmoji) {
                                    aiMessage = {
                                        id: (Date.now() + i).toString(),
                                        sender: 'received',
                                        content: '',
                                        image: matchingEmoji.url,
                                        isEmoji: true,
                                        emojiDescription: matchingEmoji.description,
                                        timestamp: Date.now() + i * 100
                                    };

                                    // 🔥【修复】如果是群聊消息，添加发送者信息
                                    if (msgData.name) {
                                        aiMessage.name = msgData.name;
                                        // 查找对应的群成员ID
                                        if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                                            const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                                            if (member) {
                                                aiMessage.senderId = member.id;
                                            }
                                        }
                                    }

                                    // 🔥【修复】角色发送的表情包不应该添加到用户的最近使用列表
                                } else {
                                    aiMessage = {
                                        id: (Date.now() + i).toString(),
                                        sender: 'received',
                                        content: `[表情包"${msgData.description}"不存在]`,
                                        timestamp: Date.now() + i * 100
                                    };
                                }
                            } else {
                                // 🔥【修复】检查是否是特殊指令对象
                                if (msgData.type && ['create_anniversary', 'create_appointment', 'block_user', 'system_command', 'internal_action', 'background_task'].includes(msgData.type)) {
                                    console.log('🔧 [processAIContinuation] 检测到特殊指令对象，跳过显示:', msgData);
                                    continue; // 跳过这个消息，不创建aiMessage
                                }
                                // 其他对象类型，尝试提取文本内容
                                const displayContent = msgData.content || msgData.message || msgData.text || msgData.reply || '[不支持的消息格式]';
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    content: displayContent,
                                    timestamp: Date.now() + i * 100
                                };
                            }
                        } else if (typeof msgData === 'string') {
                            // 普通字符串
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                content: msgData,
                                timestamp: Date.now() + i * 100
                            };
                        } else {
                            // 其他基本类型
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: String(msgData),
                            timestamp: Date.now() + i * 100
                        };
                        }
                    }

                    chatMessages[continuingCharacterId].push(aiMessage);
                    // 🔥【高效保存】直接添加单条续写消息到数据库，避免全量重写
                    try {
                        // 🔥【修复】使用时间戳和随机数确保ID唯一性，避免重复键错误
                        const stableId = `${continuingCharacterId}_continue_${aiMessage.timestamp}_${Math.random().toString(36).substr(2, 9)}_${chatMessages[continuingCharacterId].length - 1}`;
                        await db.chatMessages.add({
                            id: stableId,
                            characterId: continuingCharacterId,
                            timestamp: aiMessage.timestamp,
                            messageOrder: chatMessages[continuingCharacterId].length - 1,
                            originalMessageId: aiMessage.id,
                            messageData: aiMessage
                        });
                        console.log('✅ [高效续写] 单条消息已保存到数据库');
                    } catch (error) {
                        console.error('续写消息单条保存失败，回退到批量保存:', error);
                        saveChatMessages();
                    }
                    addMessageWithAnimation(aiMessage, continuingCharacterId);

                    // 🔥【修复】为续写的每条消息创建推送通知 - 使用正确的角色对象
                    if (typeof msgData === 'string' ||
                        (typeof msgData === 'object' && (msgData.type || (msgData.name && msgData.message)))) {
                        console.log('🔥 [推送通知] 续写消息，创建推送通知:', msgData);
                        // 🔥【关键修复】获取正在续写的角色对象，而不是当前聊天角色
                        const continuingCharacter = characters.find(c => c.id === continuingCharacterId);
                        if (continuingCharacter) {
                            createPushNotification(continuingCharacter, msgData, i * 500);
                        }
                    }

                    if (i < aiMessages.length - 1) {
                        const delay = Math.random() * 1000 + 500;
                        await new Promise(resolve => setTimeout(resolve, delay));

                        if (i < aiMessages.length - 1) {
                            showTypingIndicator();
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));
                            hideTypingIndicator();
                        }
                    }
                }

                // 🔥【修复】AI续写完成后更新消息列表，确保未读消息计数正确
                renderMessageList();
            } catch (error) {
                console.error('AI续写失败:', error);
                hideTypingIndicator();

                const errorMessage = {
                    id: Date.now().toString(),
                    sender: 'received',
                    content: `[续写失败: ${error.message}]`,
                    timestamp: Date.now()
                };

                chatMessages[continuingCharacterId].push(errorMessage);
                saveChatMessages();
                addMessageWithAnimation(errorMessage, continuingCharacterId);

                // 🔥【修复】错误消息也需要更新消息列表
                renderMessageList();
            } finally {
                // 重置状态
                isWaitingForReply = false;
                pendingUserMessage = null;

                // 恢复智能回复按钮
                if (smartReplyBtn) {
                    smartReplyBtn.disabled = false;
                    smartReplyBtn.style.opacity = '';
                    smartReplyBtn.style.animation = 'none';
                    smartReplyBtn.classList.remove('waiting');
                    smartReplyBtn.innerHTML = '<i class="fas fa-comment-dots"></i>';
                    smartReplyBtn.title = '获取AI回复';
                }

                // 更新按钮显示状态
                updateFloatingButtonsVisibility();
            }
        }

        // 🔥【新增】统一的消息创建函数，减少重复代码
        async function createAIMessage(msgData, index = 0) {
            const baseMessage = {
                id: (Date.now() + index).toString(),
                sender: 'received',
                timestamp: Date.now() + index * 100
            };

            // 处理群聊发送者信息
            if (msgData.name && currentChatCharacter?.isGroup && currentChatCharacter.members) {
                const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                if (member) {
                    baseMessage.name = msgData.name;
                    baseMessage.senderId = member.id;
                    console.log(`🔍 [createAIMessage] 设置群聊发送者: ${msgData.name} (ID: ${member.id})`);
                } else {
                    console.warn(`🔍 [createAIMessage] 未找到群成员: ${msgData.name}`);
                }
            }

            // 根据消息类型设置特定字段
            switch (msgData.type) {
                case 'ai_image':
                    return {
                        ...baseMessage,
                        type: 'ai_image',
                        content: msgData.description || 'AI描述的图片',
                        imageDescription: msgData.description
                    };
                case 'voice_message':
                    return {
                        ...baseMessage,
                        type: 'voice_message',
                        content: msgData.content
                    };
                case 'transfer':
                    return {
                        ...baseMessage,
                        type: 'transfer',
                        amount: msgData.amount,
                        note: msgData.note
                    };
                case 'poke':
                    // 🔥【新增】处理AI主动戳一戳
                    const chatSettings = getCurrentChatSettings();
                    const userNickname = chatSettings.myChatNickname || '你';
                    const pokeSuffix = chatSettings.myPokeSuffix || ''; // 🔥【修复】AI戳用户应该使用myPokeSuffix

                    return {
                        ...baseMessage,
                        sender: 'system',
                        content: `${currentChatCharacter.name}戳了戳${userNickname}${pokeSuffix}`,
                        isPoke: true
                    };
                case 'emoji':
                    // 🔥【核心修复】AI从挂载的表情包库中查找表情包
                    const matchingEmoji = await findEmojiForAI(msgData.description);
                    if (matchingEmoji) {
                        const emojiMessage = {
                            ...baseMessage,
                            content: '',
                            image: matchingEmoji.url,
                            isEmoji: true,
                            emojiDescription: matchingEmoji.description
                        };
                        // 🔥【修复】角色发送的表情包不应该添加到用户的最近使用列表
                        return emojiMessage;
                    } else {
                        return {
                            ...baseMessage,
                            content: `[表情包"${msgData.description}"不存在]`
                        };
                    }
                case 'update_poke_suffix':
                    // 🔥【新增】处理角色主动修改戳一戳后缀
                    console.log('🔍 [createAIMessage] 角色更新戳一戳后缀:', msgData);

                    // 🔥【修复】更新聊天设置中的AI戳一戳后缀（影响用户戳AI时的显示）
                    if (msgData.suffix !== undefined) {
                        const chatSettings = getCurrentChatSettings();
                        chatSettings.aiPokeSuffix = msgData.suffix || ''; // 🔥【修复】角色修改自己的戳一戳后缀应该修改aiPokeSuffix
                        await saveCurrentChatSettings(chatSettings);

                        console.log('✅ [createAIMessage] 戳一戳后缀已更新:', msgData.suffix);
                    }

                    // 返回系统提示消息
                    return {
                        id: (Date.now() + index).toString(),
                        sender: 'system',
                        content: `${currentChatCharacter.name}修改了自己的戳一戳后缀${msgData.suffix ? `为"${msgData.suffix}"` : '（清空）'}`,
                        timestamp: Date.now() + index * 100,
                        type: 'system_notification'
                    };
                default:
                    return {
                        ...baseMessage,
                        content: msgData.content || msgData.message || ''
                    };
            }
        }

        // 处理AI回复
        async function processAIReply() {
            // 🔥【调试】添加调用栈追踪
            console.log('🚨 [DEBUG] processAIReply 被调用！');
            console.log('🚨 [DEBUG] 调用栈:', new Error().stack);

            if (!currentChatCharacter) return;

            // 防止重复调用
            if (isWaitingForReply) {
                console.log('AI正在回复中，忽略重复调用');
                return;
            }

            // 🔥【关键修复】记录当前聊天角色ID，确保AI回复归属到正确的聊天窗口
            const replyingCharacterId = currentChatCharacter.id;

            // 智能选择最佳的用户消息（优先图片消息）
            console.log('🔍 [processAIReply] 函数开始时的 pendingUserMessage:', pendingUserMessage);
            const messages = chatMessages[replyingCharacterId] || [];
            console.log('🔍 [processAIReply] 所有消息数量:', messages.length);
            console.log('🔍 [processAIReply] 最后5条消息:', messages.slice(-5));
            const userMessages = messages.filter(msg => msg.sender === 'sent');
            console.log('🔍 [processAIReply] 用户消息数量:', userMessages.length);
            console.log('🔍 [processAIReply] 最后3条用户消息:', userMessages.slice(-3));

            // 🔥【调试】详细查看最后3条用户消息的内容
            const last3Messages = userMessages.slice(-3);
            last3Messages.forEach((msg, index) => {
                console.log(`🔍 [processAIReply] 用户消息${index + 1}:`, {
                    id: msg.id,
                    content: msg.content,
                    isArray: Array.isArray(msg.content),
                    timestamp: msg.timestamp
                });
            });

            // 🔥【修复】优先查找最近的转发消息，然后是图片消息
            const recentMessages = userMessages.slice(-5);

            // 🔥【关键修复】优先处理图片消息，即使有更新的文本消息
            // 首先查找转发消息
            const forwardedMessage = recentMessages.reverse().find(msg => msg.type === 'forwarded_message');

            // 🔥【彻底修复】不再强制查找历史图片，直接使用triggerSmartReply设置的pendingUserMessage
            if (forwardedMessage && !pendingUserMessage) {
                // 优先处理转发消息
                pendingUserMessage = forwardedMessage;
                console.log('🔍 [processAIReply] 找到转发消息，设置为待处理:', forwardedMessage);
            } else if (!pendingUserMessage) {
                // 如果没有特殊消息且没有待回复消息，使用最后一条用户消息
                const lastUserMessage = userMessages.slice(-1)[0]; // 重新获取最后一条消息
                console.log('🔍 [processAIReply] 没有待回复消息，使用最后一条用户消息:', lastUserMessage);
                if (lastUserMessage) {
                    pendingUserMessage = lastUserMessage;
                    console.log('🔍 [processAIReply] 设置最后一条用户消息为待处理:', lastUserMessage);
                } else {
                    return;
                }
            }

            // 🔍【调试】输出待处理的用户消息详情
            console.log('🔍 [processAIReply] 待处理的用户消息:', pendingUserMessage);
            console.log('🔍 [processAIReply] 消息类型:', pendingUserMessage?.type);
            console.log('🔍 [processAIReply] 消息内容:', pendingUserMessage?.content);
            console.log('🔍 [processAIReply] 内容是否为数组:', Array.isArray(pendingUserMessage?.content));
            console.log('🔍 [processAIReply] 是否有forwardedMessages:', !!pendingUserMessage?.forwardedMessages);
            console.log('🔍 [processAIReply] forwardedMessages长度:', pendingUserMessage?.forwardedMessages?.length);

            isWaitingForReply = true;

            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.disabled = true;
                smartReplyBtn.style.opacity = '0.65';
                smartReplyBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            }

            // 显示正在输入提示
            showTypingIndicator();

            // 添加随机延迟
            const delay = Math.random() * 2000 + 1000;
            await new Promise(resolve => setTimeout(resolve, delay));

            try {
                // 调用API，支持图片和表情包
                // 🔥【核心修复】正确处理多模态消息
                let response;

                // 🔥【优先处理】转发消息特殊处理 - 让AI能看到转发的聊天记录内容
                console.log('🔍 [转发消息检查] pendingUserMessage:', pendingUserMessage);
                console.log('🔍 [转发消息检查] 消息类型:', pendingUserMessage.type);
                console.log('🔍 [转发消息检查] 是否为群聊:', currentChatCharacter?.isGroup);
                if (pendingUserMessage.type === 'forwarded_message') {
                    console.log('🔍 [转发消息处理] 开始处理转发消息');
                    console.log('🔍 [转发消息处理] pendingUserMessage.forwardedMessages:', pendingUserMessage.forwardedMessages);

                    // 🔥【修复】获取当前用户的显示名称
                    const chatSettings = getCurrentChatSettings();
                    const currentUserName = chatSettings.myChatNickname || (personas.find(p => p.id === chatSettings.selectedIdentityId)?.name || '我');

                    let forwardedContent = `[${currentUserName}转发了聊天记录：${pendingUserMessage.content}]\n\n转发的聊天内容：\n`;

                    if (pendingUserMessage.forwardedMessages && pendingUserMessage.forwardedMessages.length > 0) {
                        console.log('🔍 [转发消息处理] 找到转发消息，数量:', pendingUserMessage.forwardedMessages.length);
                        pendingUserMessage.forwardedMessages.forEach((msg, index) => {
                            let senderName;
                            if (msg.sender === 'sent') {
                                senderName = msg.userName || currentUserName;
                            } else {
                                senderName = msg.name || msg.characterName || 'AI';
                            }
                            // 🔥【修复】使用safeExtractMessageContent安全地提取消息内容，避免[object Object]问题
                            const msgContent = safeExtractMessageContent(msg);
                            console.log(`🔍 [转发消息处理] 消息${index + 1}: ${senderName}: ${msgContent}`);
                            forwardedContent += `${senderName}: ${msgContent}\n`;
                        });
                    } else {
                        console.log('❌ [转发消息处理] 转发消息为空或不存在');
                        forwardedContent += '(转发内容为空)';
                    }

                    console.log('🔍 [转发消息] 当前聊天角色:', currentChatCharacter?.name, '是否为群聊:', currentChatCharacter?.isGroup);
                    console.log('🔍 [转发消息] 发送给AI的内容:', forwardedContent);

                    response = await callChatAPI(forwardedContent, currentChatCharacter);

                    console.log('🔍 [转发消息] AI原始回复:', response);
                } else if (Array.isArray(pendingUserMessage.content)) {
                    // 这是多模态消息（图文）
                    console.log('🔍 [processAIReply] 检测到多模态消息:', pendingUserMessage.content);

                    // 🔥【核心修复】检查多模态消息中是否包含表情包
                    const hasImage = pendingUserMessage.content.some(item => item.type === 'image_url');
                    const isEmojiMessage = pendingUserMessage.originalMessages?.some(msg => msg.isEmoji);

                    console.log('🔍 [processAIReply多模态调试] 包含图片:', hasImage);
                    console.log('🔍 [processAIReply多模态调试] 是表情包消息:', isEmojiMessage);
                    console.log('🔍 [processAIReply多模态调试] 表情包识别设置:', apiSettings.emojiRecognitionEnabled);

                    // 🔥【新增】检查是否为动图表情包
                    const emojiMsg = pendingUserMessage.originalMessages?.find(msg => msg.isEmoji);
                    const isGifEmoji = emojiMsg?.image?.includes('data:image/gif') || emojiMsg?.url?.includes('data:image/gif');

                    console.log('🔍 [processAIReply动图检测] 是否为GIF表情包:', isGifEmoji);

                    if (hasImage && isEmojiMessage && (apiSettings.emojiRecognitionEnabled === false || isGifEmoji)) {
                        // 表情包且用户关闭了表情包识别，或者是动图表情包，发送描述文字
                        const reason = isGifEmoji ? '动图表情包' : '表情包识别已关闭';
                        const emojiPrompt = `[用户发送了表情包：${emojiMsg?.emojiDescription || '自定义表情包'}]`;
                        console.log(`🔍 [processAIReply多模态修复] 发送文字描述 (${reason}):`, emojiPrompt);
                        response = await callChatAPI(emojiPrompt, currentChatCharacter);
                    } else {
                        response = await callChatAPI(pendingUserMessage.content, currentChatCharacter);
                    }
                } else if (pendingUserMessage.image) {
                    // 🔥【新增】检查是否为动图表情包
                    const isGifEmoji = pendingUserMessage.isEmoji && pendingUserMessage.image?.includes('data:image/gif');
                    console.log('🔍 [processAIReply图片分支动图检测] 是否为GIF表情包:', isGifEmoji);

                    // 🔥【核心修复】根据设置决定是否识别表情包
                    if (pendingUserMessage.isEmoji && (apiSettings.emojiRecognitionEnabled === false || isGifEmoji)) {
                        // 表情包且用户关闭了表情包识别，或者是动图表情包，发送描述文字
                        const reason = isGifEmoji ? '动图表情包' : '表情包识别已关闭';
                        const emojiPrompt = `[用户发送了表情包：${pendingUserMessage.emojiDescription || '自定义表情包'}]`;
                        console.log(`🔍 [processAIReply图片分支修复] 发送文字描述 (${reason}):`, emojiPrompt);
                        response = await callChatAPI(emojiPrompt, currentChatCharacter);
                    } else {
                        // 普通图片或启用了表情包识别，发送图片
                        const messageContent = [
                            { type: 'text', text: pendingUserMessage.content || "" },
                            { type: 'image_url', image_url: { url: pendingUserMessage.image } }
                        ];
                        response = await callChatAPI(messageContent, currentChatCharacter);
                    }
                } else if (pendingUserMessage.type === 'transfer') {
                    // 🔥【关键修复】转账消息特殊处理 - 构造转账提示文本
                    const transferPrompt = `[用户发起了转账：${pendingUserMessage.amount}元，备注：${pendingUserMessage.note || '无'}]`;
                    response = await callChatAPI(transferPrompt, currentChatCharacter);
                } else {
                    // 🔥【核心修复】检查是否是表情包消息但content为空的情况
                    if (pendingUserMessage.image && pendingUserMessage.isEmoji) {
                        console.log('🔍 [processAIReply修复] 检测到表情包消息，重新路由到图片处理');
                        // 表情包消息应该走图片处理分支
                        console.log('🔍 [processAIReply开关调试] apiSettings:', apiSettings);
                        console.log('🔍 [processAIReply开关调试] emojiRecognitionEnabled值:', apiSettings.emojiRecognitionEnabled);

                        // 🔥【新增】检查是否为动图表情包
                        const isGifEmoji = pendingUserMessage.image?.includes('data:image/gif');
                        console.log('🔍 [processAIReply else分支动图检测] 是否为GIF表情包:', isGifEmoji);

                        if (apiSettings.emojiRecognitionEnabled === false || isGifEmoji) {
                            // 表情包且用户关闭了表情包识别，或者是动图表情包，发送描述文字
                            const reason = isGifEmoji ? '动图表情包' : '表情包识别已关闭';
                            const emojiPrompt = `[用户发送了表情包：${pendingUserMessage.emojiDescription || '自定义表情包'}]`;
                            console.log(`🔍 [processAIReply else分支修复] 发送文字描述 (${reason}):`, emojiPrompt);
                            response = await callChatAPI(emojiPrompt, currentChatCharacter);
                        } else {
                            // 普通图片或启用了表情包识别，发送图片
                            const messageContent = [
                                { type: 'text', text: pendingUserMessage.content || "" },
                                { type: 'image_url', image_url: { url: pendingUserMessage.image } }
                            ];
                            console.log('🔍 [processAIReply修复] 发送给AI的消息内容:', messageContent);
                            response = await callChatAPI(messageContent, currentChatCharacter);
                        }
                    } else {
                        // 普通文本消息、位置消息、语音消息等
                        let finalPrompt = pendingUserMessage.content; // 默认使用原始消息内容

                        // 🔥【关键修复】检查当前用户消息是否为引用回复
                        if (pendingUserMessage.replyTo) {
                            // 使用 summarizeLastMessage 函数来截断被引用的消息内容
                            const quoteText = summarizeLastMessage({ content: pendingUserMessage.replyTo.content });

                            // 构建带有引用上下文的提示字符串
                            // 例如: [回复 AI的昵称 的消息: "你好呀"]: 我也很好
                            finalPrompt = `[回复 ${pendingUserMessage.replyTo.senderName} 的消息: "${quoteText}"] ${pendingUserMessage.content}`;
                            console.log('✅ 构建用户引用提示:', finalPrompt);
                        }

                        response = await callChatAPI(finalPrompt, currentChatCharacter);
                    }
                }

                const aiMessages = await parseAiResponse(response);

                for (const msgData of aiMessages) {
    // 检查是否是拉黑指令对象
    if (typeof msgData === 'object' && msgData !== null && msgData.type === 'block_user') {
        console.log('🚫 检测到AI拉黑指令对象:', msgData);
        // 使用指令中的 reason 作为拉黑理由
        await aiBlockUser(currentChatCharacter.id, msgData.reason || '对方未说明理由');
        // 拉黑后，通常不需要再显示后续消息，直接跳出循环
        break;
    }

    // 🔥【新增】检查是否是纪念日创建指令对象
    if (typeof msgData === 'object' && msgData !== null && msgData.type === 'create_anniversary') {
        console.log('🎉 检测到AI纪念日创建指令:', msgData);
        const anniversaryData = {
            name: msgData.name || '特别的日子',
            date: msgData.date || new Date().toISOString().split('T')[0],
            type: msgData.anniversary_type || 'other',
            description: msgData.description || '由角色创建的纪念日'
        };
        await createAnniversaryByCharacter(replyingCharacterId, anniversaryData);
        // 不要break，继续处理其他消息
    }

    // 🔥【新增】检查是否是约定创建指令对象
    if (typeof msgData === 'object' && msgData !== null && msgData.type === 'create_appointment') {
        console.log('📝 检测到AI约定创建指令:', msgData);
        const appointmentData = {
            name: msgData.name || '我们的约定',
            date: msgData.date || new Date().toISOString().split('T')[0],
            type: msgData.appointment_type || 'other',
            description: msgData.description || '由角色创建的约定',
            neverExpires: msgData.never_expires === true || msgData.neverExpires === true
        };
        await createAppointmentByCharacter(replyingCharacterId, appointmentData);
        // 不要break，继续处理其他消息
    }
}

                // 🔥【修复转账处理】检查是否有转账消息需要处理
                let transferMessage = null;
                if (pendingUserMessage && pendingUserMessage.type === 'transfer') {
                    // 直接的转账消息
                    transferMessage = pendingUserMessage;
                } else if (pendingUserMessage && pendingUserMessage.isMerged && pendingUserMessage.originalMessages) {
                    // 合并消息中的转账消息
                    transferMessage = pendingUserMessage.originalMessages.find(msg =>
                        msg.type === 'transfer' && !msg.status);
                }

                if (transferMessage) {
                    console.log('🔥 检测到用户转账消息，开始处理转账:', {
                        transferMessage,
                        aiMessages,
                        characterName: currentChatCharacter?.name
                    });
                    await processUserTransfer(transferMessage, aiMessages, replyingCharacterId);
                }

                // 🔥【修复】重新定义 allMessages 变量用于代付处理
                const allMessages = chatMessages[replyingCharacterId] || [];

                // 代付请求处理保持不变，只处理用户发起的代付请求
                console.log('🛒 [代付处理] AI回复完成，检查未处理代付请求');
                const unprocessedPayment = allMessages.slice().reverse().find(msg =>
                    msg.sender === 'sent' && msg.type === 'payment_request' && !msg.paymentStatus);
                if (unprocessedPayment) {
                    console.log('🛒 [代付处理] 发现未处理代付请求，分析AI回复:', unprocessedPayment);
                    await processPaymentRequestResponse(unprocessedPayment, aiMessages, replyingCharacterId);
                }

                // 🔥【恢复关键词触发机制】检查是否应该触发AI主动拨打电话
                if (pendingUserMessage && response) {
                    // 提取用户消息内容
                    let userMessageText = '';
                    if (Array.isArray(pendingUserMessage.content)) {
                        // 多模态消息，提取文本部分
                        const textParts = pendingUserMessage.content.filter(item => item.type === 'text');
                        userMessageText = textParts.map(item => item.text).join(' ');
                    } else {
                        userMessageText = pendingUserMessage.content || '';
                    }

                    // 检查是否触发AI主动拨打电话
                    checkForAICallTrigger(userMessageText, response);
                }

                // 🔥【修复】为AI的每条回复创建推送通知 - 支持群聊和单聊
                console.log('🔔 [推送通知] AI回复完成，准备创建推送通知，消息数量:', aiMessages.length);
                console.log('🔔 [推送通知] 当前聊天角色ID:', replyingCharacterId);
                console.log('🔔 [推送通知] 当前聊天角色对象:', currentChatCharacter);

                // 🔥【关键修复】区分单聊和群聊，从不同的数组中查找
                let replyingCharacter = characters.find(c => c.id === replyingCharacterId);

                // 如果在characters中找不到，检查是否是群聊
                if (!replyingCharacter) {
                    const replyingGroup = groupChats.find(g => g.id === replyingCharacterId);
                    if (replyingGroup) {
                        console.log('🔔 [推送通知] 找到群聊对象:', replyingGroup.name);
                        replyingCharacter = replyingGroup;
                    }
                }

                // 🔥【修复】如果还是找不到，直接使用当前聊天角色对象
                if (!replyingCharacter && currentChatCharacter) {
                    console.log('🔔 [推送通知] 使用当前聊天角色对象作为回复角色');
                    replyingCharacter = currentChatCharacter;
                }

                if (replyingCharacter) {
                    console.log('🔔 [推送通知] 找到回复角色:', replyingCharacter.name, '是否为群聊:', replyingCharacter.isGroup);
                    for (let i = 0; i < aiMessages.length; i++) {
                        const msgData = aiMessages[i];
                        console.log('🔔 [推送通知] 处理消息', i, ':', msgData);
                        if (typeof msgData === 'string' ||
                            (typeof msgData === 'object' && (msgData.type || (msgData.name && msgData.message)))) {
                            createPushNotification(replyingCharacter, msgData, i * 500);
                        }
                    }
                } else {
                    console.warn('🔔 [推送通知] 找不到回复角色，跳过推送通知创建，replyingCharacterId:', replyingCharacterId);
                }

                // 🔥【移除重复记录】这里的时间线记录逻辑已移动到下面的单条消息处理中，避免重复记录

// --- 请用这段全新的代码替换 ---
                hideTypingIndicator();

                for (let i = 0; i < aiMessages.length; i++) {
                    const msgData = aiMessages[i];
    let aiMessage; // 先声明变量

    console.log('🔍 [AI回复处理] 处理消息', i, '类型:', typeof msgData, '内容:', msgData);
    console.log('🔍 [AI回复处理] 当前聊天角色:', currentChatCharacter?.name, '是否为群聊:', currentChatCharacter?.isGroup);

    // 🔥【修复】跳过特殊指令对象，避免显示"不支持的消息格式"
    if (typeof msgData === 'object' && msgData !== null) {
        if (msgData.type === 'block_user') {
            console.log('🚫 跳过拉黑指令对象，不显示为消息:', msgData);
            continue;
        }
        if (msgData.type === 'create_anniversary') {
            console.log('🎉 跳过纪念日创建指令对象，不显示为消息:', msgData);
            continue;
        }
        if (msgData.type === 'create_appointment') {
            console.log('📝 跳过约定创建指令对象，不显示为消息:', msgData);
            continue;
        }
        // 🔥【新增】跳过其他可能的特殊指令对象
        if (msgData.type && ['system_command', 'internal_action', 'background_task'].includes(msgData.type)) {
            console.log('🔧 跳过系统指令对象，不显示为消息:', msgData);
            continue;
        }
    }

    if (typeof msgData === 'object' && msgData !== null) {
        if (msgData.type === 'voice_message') {
            aiMessage = await createAIMessage(msgData, i);
        } else if (msgData.type === 'ai_image') {
            aiMessage = await createAIMessage(msgData, i);
        } else if (msgData.type === 'transfer') {
            aiMessage = await createAIMessage(msgData, i);
        } else if (msgData.type === 'poke') {
            aiMessage = await createAIMessage(msgData, i);
        } else if (msgData.type === 'update_poke_suffix') {
            aiMessage = await createAIMessage(msgData, i);
        } else if (msgData.type === 'emoji') {
            aiMessage = await createAIMessage(msgData, i);
        } else if (msgData.type === 'ai_photo') {
            // 角色发送的"伪照片"
            console.log('处理角色照片消息:', msgData);
            // 确保我们有一个有效的描述
            const photoDesc = msgData.description || msgData.content || msgData.photoDescription || '角色发送的照片';
            console.log('照片描述:', photoDesc);
            aiMessage = {
                id: (Date.now() + i).toString(),
                sender: 'received',
                type: 'user_photo', // 使用与用户照片相同的类型以便复用渲染逻辑
                content: photoDesc,
                photoDescription: photoDesc,
                timestamp: Date.now() + i * 100
            };
        } else if (msgData.type === 'location') {
            // 角色发送的位置信息
            console.log('处理角色位置消息:', msgData);
            // 🔥【修复】优先使用locationName字段，name字段是角色名
            const locationName = msgData.locationName || msgData.name || '未知位置';
            console.log('位置名称:', locationName, '坐标:', msgData.coordinates || '未知坐标');
            aiMessage = {
                id: (Date.now() + i).toString(),
                sender: 'received',
                type: 'location', // 保持类型为location
                locationName: locationName,
                coordinates: msgData.coordinates || '未知坐标',
                content: `[角色分享了位置信息：${locationName}]`,
                timestamp: Date.now() + i * 100
            };

            // 🔥【修复】保留群聊的角色名字段
            if (msgData.name && isGroupChat) {
                aiMessage.name = msgData.name;
                // 🔥【修复】为群聊消息设置senderId
                const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                if (member) {
                    aiMessage.senderId = member.id;
                }
            }
        } else if (msgData.type === 'transfer') {
            aiMessage = { id: (Date.now() + i).toString(), sender: 'received', type: 'transfer', amount: msgData.amount, note: msgData.note, timestamp: Date.now() + i * 100 };
        } else if (msgData.type === 'poke') {
            // 🔥【新增】处理AI主动戳一戳(processAIReply第二处)
            console.log('🔍 [processAIReply-第二处] AI主动戳一戳:', msgData);
            const chatSettings = getCurrentChatSettings();
            const userNickname = chatSettings.myChatNickname || '你';
            const pokeSuffix = chatSettings.myPokeSuffix || ''; // 🔥【修复】AI戳用户应该使用myPokeSuffix

            aiMessage = {
                id: (Date.now() + i).toString(),
                sender: 'system',
                content: `${currentChatCharacter.name}戳了戳${userNickname}${pokeSuffix}`,
                timestamp: Date.now() + i * 100,
                isPoke: true
            };
        } else if (msgData.type === 'payment_request') {
            // AI不能发起代付请求，忽略
            console.log('🛒 [AI代付请求] AI尝试发起代付请求，已忽略:', msgData);
            aiMessage = null;
        } else if (msgData.type === 'order_confirmation') {
            // 🛒【新增】处理AI的订单确认
            console.log('🛒 [AI订单确认] 检测到AI订单确认:', msgData);

            // 生成订单号
            const orderNumber = 'SP' + Date.now().toString().slice(-8);

            // 构建订单详情
            const orderDetails = {
                orderNumber: orderNumber,
                items: msgData.items || [],
                total: msgData.total || 0,
                recipient: msgData.recipient || currentChatCharacter?.name || 'AI',
                timestamp: Date.now()
            };

            aiMessage = {
                id: (Date.now() + i).toString(),
                sender: 'received',
                type: 'order_confirmation',
                content: '订单确认',
                orderDetails: orderDetails,
                orderType: msgData.order_type || 'ai_order',
                timestamp: Date.now() + i * 100
            };

            console.log('🛒 [AI订单确认] 创建的订单确认消息:', aiMessage);
        } else if (msgData.type === 'emoji') {
            console.log('🔍 [processAIReply-表情包] 原始msgData:', msgData);
            const matchingEmoji = await findEmojiForAI(msgData.description);
                        if (matchingEmoji) {
                // 🔥【关键修复】为表情包消息添加群聊发送者信息
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    content: '',
                    image: matchingEmoji.url,
                    isEmoji: true,
                    emojiDescription: matchingEmoji.description,
                    timestamp: Date.now() + i * 100
                };

                // 🔥【关键修复】如果是群聊消息，添加发送者信息
                if (msgData.name) {
                    console.log('🔍 [processAIReply-表情包] 检测到群聊消息，发送者:', msgData.name);
                    aiMessage.name = msgData.name;
                    // 查找对应的群成员ID
                    if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                        const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                        if (member) {
                            aiMessage.senderId = member.id;
                            console.log('🔍 [processAIReply-表情包] 找到群成员ID:', member.id);
                        } else {
                            console.log('🔍 [processAIReply-表情包] 未找到群成员:', msgData.name);
                        }
                    }
                } else {
                    console.log('🔍 [processAIReply-表情包] msgData.name 不存在，可能是单聊');
                }

                console.log('🔍 [processAIReply-表情包] 创建的表情包消息:', aiMessage);
                // 🔥【修复】角色发送的表情包不应该添加到用户的最近使用列表
                        } else {
                aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: `[表情包"${msgData.description}"不存在]`, timestamp: Date.now() + i * 100 };
            }
        } else if (msgData.type === 'reply_to') {
            // 🔥【新增】处理AI引用回复消息
            console.log('🔍 [引用回复-主分支] 进入引用回复处理，msgData:', msgData);

            // 查找被引用的消息
            console.log('🔍 [引用回复-主分支] 查找消息ID:', msgData.message_id);
            console.log('🔍 [引用回复-主分支] replyingCharacterId:', replyingCharacterId);
            console.log('🔍 [引用回复-主分支] currentChatCharacter.id:', currentChatCharacter?.id);

            // 🔥【修复】使用正确的角色ID查找消息
            const characterId = currentChatCharacter?.id || replyingCharacterId;
            const allMessages = chatMessages[characterId] || [];
            console.log('🔍 [引用回复-主分支] 使用角色ID:', characterId);
            console.log('🔍 [引用回复-主分支] 当前角色的消息数量:', allMessages.length);

            // 🔥【修复】安全地获取最近消息的ID
            try {
                allMessages.slice(-5).map(m => m?.id || 'undefined');
            } catch (e) {
                console.error('🔍 [引用回复-主分支] 获取消息ID时出错:', e);
                console.log('🔍 [引用回复-主分支] allMessages:', allMessages);
            }

            const referencedMessage = allMessages.find(msg => msg.id === msgData.message_id);

            // 🔥【调试】如果没找到消息，尝试不同的查找方式
            if (!referencedMessage) {
                console.log('🔍 [引用回复-主分支] 未找到消息，尝试其他查找方式...');
                console.log('🔍 [引用回复-主分支] 查找目标ID类型:', typeof msgData.message_id, '值:', msgData.message_id);

                // 尝试数字格式查找
                const numericId = parseInt(msgData.message_id);
                const referencedByNumber = allMessages.find(msg => msg.id === numericId);
                console.log('🔍 [引用回复-主分支] 数字格式查找结果:', referencedByNumber);

                // 尝试字符串格式查找
                const referencedByString = allMessages.find(msg => msg.id === msgData.message_id.toString());
                console.log('🔍 [引用回复-主分支] 字符串格式查找结果:', referencedByString);

                // 显示所有消息的ID和类型
                console.log('🔍 [引用回复-主分支] 所有消息ID详情:', allMessages.map(m => ({id: m.id, type: typeof m.id, content: m.content?.substring?.(0, 20)})));
            }

            if (referencedMessage) {
                // 构建引用信息
                let referencedContent = '';

                // 🔥【修复】正确处理数组格式的消息内容
                if (Array.isArray(referencedMessage.content)) {
                    const textPart = referencedMessage.content.find(p => p.type === 'text');
                    const imagePart = referencedMessage.content.find(p => p.type === 'image_url');

                    if (textPart?.text) {
                        referencedContent = textPart.text;
                    } else if (imagePart) {
                        referencedContent = '[图片]';
                    } else {
                        referencedContent = '[多媒体消息]';
                    }
                } else {
                    referencedContent = referencedMessage.content || '';
                }

                const replyToInfo = {
                    id: referencedMessage.id,
                    content: referencedContent,
                    senderName: referencedMessage.sender === 'sent' ? '你' : (referencedMessage.name || currentChatCharacter?.name || '对方')
                };

                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    content: msgData.content || '',
                    replyTo: replyToInfo,
                    timestamp: Date.now() + i * 100
                };

                // 🔥【修复】为群聊引用回复添加发送者信息
                if (msgData.name && currentChatCharacter?.isGroup && currentChatCharacter.members) {
                    const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                    if (member) {
                        aiMessage.name = msgData.name;
                        aiMessage.senderId = member.id;
                        console.log('🔍 [引用回复-主分支] 设置群聊发送者:', msgData.name, 'ID:', member.id);
                    } else {
                        console.log('🔍 [引用回复-主分支] 未找到群成员:', msgData.name);
                    }
                }

            } else {
                console.warn('🔥 找不到被引用的消息ID:', msgData.message_id);
                // 如果找不到被引用的消息，就当作普通消息处理
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    content: msgData.content || '',
                    timestamp: Date.now() + i * 100
                };

                // 🔥【修复】为群聊引用回复添加发送者信息（找不到被引用消息的情况）
                if (msgData.name && currentChatCharacter?.isGroup && currentChatCharacter.members) {
                    const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                    if (member) {
                        aiMessage.name = msgData.name;
                        aiMessage.senderId = member.id;
                        console.log('🔍 [引用回复-主分支-fallback] 设置群聊发送者:', msgData.name, 'ID:', member.id);
                    } else {
                        console.log('🔍 [引用回复-主分支-fallback] 未找到群成员:', msgData.name);
                    }
                }
            }
        } else if (msgData.type === 'change_avatar') {
                        if (msgData.avatar_url) {
                            // 🔥【修复】先处理占位符替换，再验证和执行头像更换
                            let actualAvatarUrl = msgData.avatar_url;
                            if (msgData.avatar_url === 'CURRENT_USER_IMAGE' ||
                                msgData.avatar_url === 'CURRENT_USER_IMAGE' ||
                                msgData.avatar_url === '用户发送的图片URL' ||
                                msgData.avatar_url === '图片URL') {
                                const recentUserImage = getRecentUserImage();
                                if (recentUserImage) {
                                    actualAvatarUrl = recentUserImage;
                                } else {
                                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[无法更换头像，没有找到可用的图片]', timestamp: Date.now() + i * 100 };
                                    continue;
                                }
                            }

                            const isValidAvatar = await validateAvatarSource(actualAvatarUrl);
                            if (isValidAvatar) {
                                const success = await changeCharacterAvatarByAI(actualAvatarUrl, msgData.reason || '心情变化');
                                if (success) continue;
                                else aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[头像更换失败]', timestamp: Date.now() + i * 100 };
                            } else {
                                aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[无效的头像来源，头像更换失败]', timestamp: Date.now() + i * 100 };
                            }
                        } else {
                            continue;
                        }
        } else if (msgData.type === 'recall_previous') {
            // 🔥【新增】处理AI撤回上一条消息
            console.log('🔥 AI请求撤回上一条消息:', msgData);

            // 查找上一条AI消息
            const allMessages = chatMessages[replyingCharacterId] || [];
            let lastAIMessageIndex = -1;

            for (let j = allMessages.length - 1; j >= 0; j--) {
                if (allMessages[j].sender === 'received') {
                    lastAIMessageIndex = j;
                    break;
                }
            }

            if (lastAIMessageIndex !== -1) {
                const messageToRecall = allMessages[lastAIMessageIndex];
                console.log('🔥 找到要撤回的消息:', messageToRecall);

                // 调用撤回消息处理函数
                await handleRecalledMessage(messageToRecall.content, messageToRecall.id);
            } else {
                console.warn('🔥 没有找到可撤回的AI消息');
                // 如果没有找到消息，显示一条提示
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    content: '[AI撤回了上一条消息]',
                    timestamp: Date.now() + i * 100
                };
            }
            continue; // 跳过正常的消息处理流程
        } else if (msgData.type === 'voice_call') {
            // 🔥【新增】处理AI主动发起语音通话
            console.log('🔔 AI请求发起语音通话:', msgData);
            setTimeout(() => {
                initiateAICall(currentChatCharacter, msgData.reason || '想和你聊聊');
            }, 100 + Math.random() * 200); // 进一步减少延迟到0.1-0.3秒
            continue; // 跳过消息显示，因为这是一个动作指令
        } else if (msgData.type === 'video_call') {
            // 🔥【新增】处理AI主动发起视频通话
            console.log('🔔 AI请求发起视频通话:', msgData);
            setTimeout(() => {
                initiateAIVideoCall(currentChatCharacter, msgData.reason || '想和你视频聊聊');
            }, 100 + Math.random() * 200); // 进一步减少延迟到0.1-0.3秒
            continue; // 跳过消息显示，因为这是一个动作指令
        } else if (msgData.name && msgData.message) {
            // 这是群聊的特殊格式
            console.log('🔍 [AI回复处理] 检测到群聊格式消息:', msgData.name, msgData.message);
            let senderId = null;
            if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                if (member) {
                    senderId = member.id;
                    console.log('🔍 [AI回复处理] 找到群成员ID:', senderId);
                } else {
                    console.log('🔍 [AI回复处理] 未找到群成员:', msgData.name);
                }
            }

            // --- 关键修复：检查群聊消息内容是否为特殊类型 ---
            if (typeof msgData.message === 'object' && msgData.message.type === 'voice_message') {
                // 如果消息内容是一个语音消息对象
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    type: 'voice_message', // 在外层消息上设置正确的类型
                    name: msgData.name,
                    senderId: senderId,
                    content: msgData.message.content, // 提取真正的语音文字内容
                    timestamp: Date.now() + i * 100
                };
            } else if (typeof msgData.message === 'object' && msgData.message.type === 'transfer') {
                // 🔥【修复】如果消息内容是一个转账对象
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    type: 'transfer', // 在外层消息上设置正确的类型
                    name: msgData.name,
                    senderId: senderId,
                    amount: msgData.message.amount, // 提取转账金额
                    note: msgData.message.note, // 提取转账备注
                    timestamp: Date.now() + i * 100
                };
            } else if (typeof msgData.message === 'object' && msgData.message.type === 'friend_request') {
                // 🔥【新增】如果消息内容是一个好友申请对象(第二处)
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    type: 'friend_request', // 在外层消息上设置正确的类型
                    message: msgData.message.message, // 提取好友申请消息
                    timestamp: Date.now() + i * 100
                };
            } else {
                // 对于普通的文本消息
                console.log('🔍 [AI回复处理] 创建普通文本消息，name:', msgData.name, 'senderId:', senderId);
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    name: msgData.name,
                    senderId: senderId,
                    content: msgData.message, // 内容本身是字符串
                    timestamp: Date.now() + i * 100
                };
                console.log('🔍 [AI回复处理] 创建的aiMessage:', aiMessage);
            }
            // --- 修复结束 ---
                    } else {
            // 其他所有未知对象的处理 - 修复[object Object]问题
            let displayContent;
            if (msgData.content && typeof msgData.content === 'string') {
                displayContent = msgData.content;
            } else if (msgData.message && typeof msgData.message === 'string') {
                displayContent = msgData.message;
            } else if (msgData.text && typeof msgData.text === 'string') {
                displayContent = msgData.text;
            } else if (msgData.reply && typeof msgData.reply === 'string') {
                displayContent = msgData.reply;
            } else if (typeof msgData === 'string') {
                displayContent = msgData;
            } else {
                // 🔥【修复】检查是否是特殊指令对象，如果是则跳过而不是显示"不支持的消息格式"
                if (msgData.type && ['create_anniversary', 'create_appointment', 'block_user', 'system_command', 'internal_action', 'background_task', 'transfer_action'].includes(msgData.type)) {
                    console.log('🔧 检测到特殊指令对象，跳过显示:', msgData);
                    continue; // 跳过这个消息，不创建aiMessage
                }
                // 对于其他复杂对象，提取有用信息或显示类型提示
                console.warn('未处理的对象类型:', msgData);
                displayContent = '[不支持的消息格式]';
            }
            aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: displayContent, timestamp: Date.now() + i * 100 };
                            }
                        } else if (typeof msgData === 'string') {
                            // 普通字符串
                            aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: msgData, timestamp: Date.now() + i * 100 };
                        } else {
                            // 其他类型，强制转换为字符串
        aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: String(msgData), timestamp: Date.now() + i * 100 };
                    }

                    chatMessages[replyingCharacterId].push(aiMessage);
                    // 🔥【高效保存】直接添加单条回复消息到数据库，避免全量重写
                    try {
                        // 🔥【修复】使用时间戳和随机数确保ID唯一性，避免重复键错误
                        const stableId = `${replyingCharacterId}_reply_${aiMessage.timestamp}_${Math.random().toString(36).substr(2, 9)}_${chatMessages[replyingCharacterId].length - 1}`;
                        await db.chatMessages.add({
                            id: stableId,
                            characterId: replyingCharacterId,
                            timestamp: aiMessage.timestamp,
                            messageOrder: chatMessages[replyingCharacterId].length - 1,
                            originalMessageId: aiMessage.id,
                            messageData: aiMessage
                        });
                        console.log('✅ [高效回复] 单条消息已保存到数据库');
                    } catch (error) {
                        console.error('回复消息单条保存失败，回退到批量保存:', error);
                        await saveChatMessages();
                    }
                    addMessageWithAnimation(aiMessage, replyingCharacterId);

                    // 🔥【新增】触发角色状态更新
                    triggerStatusUpdateAfterMessage(replyingCharacterId);

                    // 🔥【修复】为每条AI消息记录时间线事件，避免重复记录
                    setTimeout(async () => {
                        try {
                            // 获取当前消息的内容
                            let eventContent = '';
                            let characterId = replyingCharacterId;

                            if (typeof msgData === 'string') {
                                eventContent = msgData;
                            } else if (typeof msgData === 'object' && msgData.name && msgData.message) {
                                // 群聊消息格式
                                eventContent = msgData.message;
                                // 查找群成员ID
                                if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                                    const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                                    if (member) characterId = member.id;
                                }
                            } else if (typeof msgData === 'object' && msgData.content) {
                                eventContent = msgData.content;
                            } else if (aiMessage && aiMessage.content) {
                                eventContent = aiMessage.content;
                            }

                            if (eventContent && characterId) {
                                // 🔥【修复】记录AI回复的时间线事件 - 群聊需要为每个成员记录
                                if (currentChatCharacter?.isGroup) {
                                    // 群聊：为每个群成员记录AI回复事件
                                    for (const member of currentChatCharacter.members || []) {
                                        // 🔥【关键修复】检查该成员是否设置了与当前群聊共享记忆
                                        const shouldRecord = await shouldRecordGroupMemoryForCharacter(member.id, currentChatCharacter.id);
                                        if (shouldRecord) {
                                            await recordCrossAppEvent(
                                                member.id, // 记录到每个成员的时间线下
                                                'chat',
                                                'ai_reply',
                                                {
                                                    id: member.id, // 🔥【修复】使用角色ID而不是群聊ID，确保记忆共享正常工作
                                                    type: 'group_chat',
                                                    sender: 'ai',
                                                    content: eventContent,
                                                    chatType: 'group',
                                                    groupName: currentChatCharacter.name,
                                                    groupId: currentChatCharacter.id // 🔥【新增】保留群聊ID用于区分
                                                },
                                                aiMessage.id
                                            );
                                            console.log(`🔥 [修复] 已记录AI回复时间线事件 - 角色: ${member.id}, 内容: ${eventContent.substring(0, 50)}...`);
                                        } else {
                                            console.log(`⏭️ 跳过记录 - 角色 ${member.id} 未与群聊 ${currentChatCharacter.id} 共享记忆`);
                                        }
                                    }
                                } else {
                                    // 单聊：正常记录
                                    await recordCrossAppEvent(
                                        replyingCharacterId,
                                        'chat',
                                        'ai_reply',
                                        {
                                            id: currentChatCharacter.id,
                                            type: 'private_chat',
                                            sender: 'ai',
                                            content: eventContent,
                                            chatType: 'single'
                                        },
                                        aiMessage.id
                                    );
                                    console.log(`🔥 [修复] 已记录AI回复时间线事件 - 角色: ${replyingCharacterId}, 内容: ${eventContent.substring(0, 50)}...`);
                                }
                            }
                        } catch (error) {
                            console.error('AI回复后记忆处理失败:', error);
                        }
                    }, 1000 + i * 200); // 延迟执行，每条消息间隔200ms，避免阻塞UI

                    if (i < aiMessages.length - 1) {
                        const delay = Math.random() * 1000 + 500;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        if (i < aiMessages.length - 1) {
                            showTypingIndicator();
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));
                            hideTypingIndicator();
                        }
                    }
                }

                // 🔥【修复】AI消息发送完成后更新消息列表，确保未读消息计数正确
                renderMessageList();

                // 🔥【优化】AI回复处理完成，纪念日创建已在消息处理循环中完成
            } catch (error) {
                console.error('AI回复失败:', error);
                hideTypingIndicator();

                const errorMessage = {
                    id: Date.now().toString(),
                    sender: 'received',
                    content: `[回复失败: ${error.message}]`,
                    timestamp: Date.now()
                };

                chatMessages[replyingCharacterId].push(errorMessage);
                saveChatMessages();
                addMessageWithAnimation(errorMessage, replyingCharacterId);

                // 🔥【修复】错误消息也需要更新消息列表
                renderMessageList();
            } finally {
                // 重置状态
                isWaitingForReply = false;
                pendingUserMessage = null;

                // 恢复智能回复按钮
                if (smartReplyBtn) {
                    smartReplyBtn.disabled = false;
                    smartReplyBtn.style.opacity = '';
                    smartReplyBtn.style.animation = 'none';
                    smartReplyBtn.classList.remove('waiting');
                    smartReplyBtn.innerHTML = '<i class="fas fa-comment-dots"></i>';
                    smartReplyBtn.title = '获取AI回复';
                }

                // 更新按钮显示状态
                updateFloatingButtonsVisibility();
            }
        }

        // 重置重新生成按钮状态
        function resetFloatingButtonsState() {
            // 重置待回复消息
            pendingUserMessage = null;
            isWaitingForReply = false;

            // 重置智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.disabled = false;
                smartReplyBtn.style.opacity = '';
                smartReplyBtn.style.animation = 'none';
                smartReplyBtn.innerHTML = '<i class="fas fa-comment-dots"></i>';
                smartReplyBtn.title = '获取AI回复';
                smartReplyBtn.classList.remove('waiting');
            }

            // 更新按钮显示状态
            updateFloatingButtonsVisibility();
        }

        // 更新重新生成按钮的显示状态
        function updateFloatingButtonsVisibility() {
            if (!currentChatCharacter) return;

            const regenerateToolItem = document.getElementById('regenerate-tool-item');
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            const messages = chatMessages[currentChatCharacter.id] || [];

            // 检查是否有AI消息可以重新生成
            const hasAIMessages = messages.some(msg => msg.sender === 'received');

            if (regenerateToolItem) {
                if (hasAIMessages) {
                    regenerateToolItem.style.display = 'flex';
                } else {
                    regenerateToolItem.style.display = 'none';
                }
            }

            if (smartReplyBtn) {
                // 智能回复按钮总是显示
                smartReplyBtn.classList.remove('hidden');
            }
        }

        // @群成员功能相关函数
        function handleMentionInput(e) {
            const input = e.target;
            const text = input.value;
            const cursorPos = input.selectionStart;

            // 查找最近的@符号位置
            let atPos = -1;
            for (let i = cursorPos - 1; i >= 0; i--) {
                if (text[i] === '@') {
                    atPos = i;
                    break;
                } else if (text[i] === ' ' || text[i] === '\n') {
                    break;
                }
            }

            if (atPos !== -1 && isGroupChat()) {
                // 找到@符号，显示群成员列表
                const query = text.substring(atPos + 1, cursorPos);
                mentionStartPos = atPos;
                currentMentionQuery = query;
                showMentionDropdown(query);
            } else {
                // 没有@符号或不是群聊，隐藏下拉框
                hideMentionDropdown();
            }
        }

        function handleMentionKeydown(e) {
            const dropdown = document.getElementById('mention-dropdown');
            const items = dropdown.querySelectorAll('.mention-item');

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedMentionIndex = Math.min(selectedMentionIndex + 1, items.length - 1);
                updateMentionSelection(items);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedMentionIndex = Math.max(selectedMentionIndex - 1, 0);
                updateMentionSelection(items);
            } else if (e.key === 'Enter' || e.key === 'Tab') {
                e.preventDefault();
                if (selectedMentionIndex >= 0 && items[selectedMentionIndex]) {
                    selectMention(items[selectedMentionIndex]);
                }
            } else if (e.key === 'Escape') {
                e.preventDefault();
                hideMentionDropdown();
            }
        }

        function isGroupChat() {
            return currentChatCharacter && groupChats.find(g => g.id === currentChatCharacter.id);
        }

        function showMentionDropdown(query) {
            if (!isGroupChat()) return;

            const group = groupChats.find(g => g.id === currentChatCharacter.id);
            if (!group || !group.members) return;

            const dropdown = document.getElementById('mention-dropdown');
            const filteredMembers = group.members.filter(member =>
                member.name.toLowerCase().includes(query.toLowerCase())
            );

            if (filteredMembers.length === 0) {
                hideMentionDropdown();
                return;
            }

            dropdown.innerHTML = '';
            filteredMembers.forEach((member, index) => {
                const item = document.createElement('div');
                item.className = 'mention-item';
                item.innerHTML = `
                    <div class="mention-avatar" style="background-color: ${member.color || '#4CAF50'}; ${member.avatarUrl ? `background-image: url(${member.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                        ${member.avatarUrl ? '' : member.name.charAt(0)}
                    </div>
                    <div class="mention-name">${member.name}</div>
                `;
                item.onclick = () => selectMention(item);
                item.dataset.memberName = member.name;
                item.dataset.memberId = member.id;
                dropdown.appendChild(item);
            });

            selectedMentionIndex = 0;
            updateMentionSelection(dropdown.querySelectorAll('.mention-item'));
            dropdown.style.display = 'block';
            mentionDropdownVisible = true;
        }

        function hideMentionDropdown() {
            const dropdown = document.getElementById('mention-dropdown');
            dropdown.style.display = 'none';
            mentionDropdownVisible = false;
            selectedMentionIndex = -1;
            mentionStartPos = -1;
            currentMentionQuery = '';
        }

        function updateMentionSelection(items) {
            items.forEach((item, index) => {
                if (index === selectedMentionIndex) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
        }

        function selectMention(item) {
            const memberName = item.dataset.memberName;
            const input = document.getElementById('api-chat-input');
            const text = input.value;

            // 替换@查询文本为@某人
            const beforeMention = text.substring(0, mentionStartPos);
            const afterMention = text.substring(mentionStartPos + 1 + currentMentionQuery.length);
            const newText = beforeMention + `@${memberName} ` + afterMention;

            input.value = newText;

            // 设置光标位置到@某人后面
            const newCursorPos = mentionStartPos + memberName.length + 2;
            input.setSelectionRange(newCursorPos, newCursorPos);

            hideMentionDropdown();
            input.focus();
        }

        // 处理消息中的@内容，将其转换为带样式的HTML
        function processMentions(content) {
            if (!content || typeof content !== 'string') return content;

            // 匹配@某人的模式
            return content.replace(/@([^\s@]+)/g, '<span class="mention-text">@$1</span>');
        }

        // 🔥【新增】构建群聊上下文关联记忆
        async function buildContextualMemoryForGroupChat(groupCharacter, userMessage) {
            try {
                let contextualMemory = '';

                // 检测@提及
                const mentionMatches = userMessage.match(/@([^\s@]+)/g);
                if (mentionMatches) {
                    for (const mention of mentionMatches) {
                        const mentionedName = mention.substring(1); // 移除@符号

                        // 查找被@的群成员
                        const mentionedMember = groupCharacter.members?.find(m => m.name === mentionedName);
                        if (mentionedMember) {
                            // 获取该成员的单聊记忆
                            const privateChatMemory = await getPrivateChatMemoryForMember(mentionedMember.id, userMessage);
                            if (privateChatMemory) {
                                contextualMemory += `\n\n# 与${mentionedName}的相关私聊记忆：\n${privateChatMemory}`;
                            }
                        }
                    }
                }

                // 检测数字暗号（6位以上数字）
                const numberMatches = userMessage.match(/\b\d{6,}\b/g);
                if (numberMatches) {
                    for (const number of numberMatches) {
                        // 在所有群成员的私聊记忆中搜索这个数字
                        for (const member of groupCharacter.members || []) {
                            const numberContext = await searchNumberInPrivateChat(member.id, number);
                            if (numberContext) {
                                contextualMemory += `\n\n# 关于数字"${number}"的私聊记忆（与${member.name}）：\n${numberContext}`;
                                break; // 找到一个就够了
                            }
                        }
                    }
                }

                return contextualMemory;
            } catch (error) {
                console.error('构建群聊上下文关联记忆失败:', error);
                return '';
            }
        }

        // 🔥【新增】获取群成员的私聊记忆
        async function getPrivateChatMemoryForMember(memberId, currentMessage) {
            try {
                // 获取最近的私聊记忆（最近5条）
                const recentPrivateMemories = await db.crossAppTimeline
                    .where('characterId').equals(memberId)
                    .and(event => event.appType === 'chat' &&
                                 event.context?.type === 'private_chat')
                    .reverse()
                    .limit(5)
                    .toArray();

                if (recentPrivateMemories.length === 0) return '';

                let memoryText = '';
                recentPrivateMemories.forEach(memory => {
                    const time = new Date(memory.timestamp).toLocaleString();
                    const content = memory.context?.content || memory.context?.message || '';
                    if (content) {
                        memoryText += `[${time}] ${memory.context?.sender === 'user' ? '用户' : 'AI'}说: ${content.substring(0, 50)}${content.length > 50 ? '...' : ''}\n`;
                    }
                });

                return memoryText;
            } catch (error) {
                console.error('获取私聊记忆失败:', error);
                return '';
            }
        }

        // 🔥【新增】在私聊记忆中搜索数字
        async function searchNumberInPrivateChat(memberId, number) {
            try {
                // 搜索包含该数字的私聊记忆
                const matchingMemories = await db.crossAppTimeline
                    .where('characterId').equals(memberId)
                    .and(event => event.appType === 'chat' &&
                                 event.context?.type === 'private_chat' &&
                                 (event.context?.content?.includes(number) ||
                                  event.context?.message?.includes(number)))
                    .reverse()
                    .limit(3)
                    .toArray();

                if (matchingMemories.length === 0) return '';

                let contextText = '';
                matchingMemories.forEach(memory => {
                    const time = new Date(memory.timestamp).toLocaleString();
                    const content = memory.context?.content || memory.context?.message || '';
                    if (content) {
                        contextText += `[${time}] ${memory.context?.sender === 'user' ? '用户' : 'AI'}说: ${content}\n`;
                    }
                });

                return contextText;
            } catch (error) {
                console.error('搜索数字记忆失败:', error);
                return '';
            }
        }

        // 修改原来的sendApiMessage函数，使其只发送消息到界面，不触发AI回复
        async function sendApiMessage() {
            const input = document.getElementById('api-chat-input');
            const message = input.value.trim();

            if (!message) return;

            if (!currentChatCharacter) {
                alert('请先选择一个角色');
                return;
            }

            // 🔥【修改】移除拉黑检查，允许消息正常发送

            // 防止重复发送
            if (input._isProcessing) return;
            input._isProcessing = true;

            try {
            // 🔥【统一格式】添加用户消息 - 使用数组格式
            const messageId = Date.now().toString();
            const userMessage = {
                id: messageId,
                sender: 'sent',
                content: [{ type: 'text', text: message }], // 统一使用数组格式
                timestamp: Date.now(),
                // 如果有引用消息，添加引用信息
                replyTo: currentReplyTo ? {
                    id: currentReplyTo.id,
                    content: currentReplyTo.content,
                    senderName: currentReplyTo.senderName
                } : null
            };

            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }

            chatMessages[currentChatCharacter.id].push(userMessage);
            // 🔥【高效保存】直接添加单条消息到数据库，避免全量重写
            try {
                const stableId = `${currentChatCharacter.id}_${userMessage.id}_${chatMessages[currentChatCharacter.id].length - 1}`;
                await db.chatMessages.add({
                    id: stableId,
                    characterId: currentChatCharacter.id,
                    timestamp: userMessage.timestamp,
                    messageOrder: chatMessages[currentChatCharacter.id].length - 1,
                    originalMessageId: userMessage.id,
                    messageData: userMessage
                });
                console.log('✅ [高效发送] 单条消息已保存到数据库');
            } catch (error) {
                console.error('单条消息保存失败，回退到批量保存:', error);
                await saveChatMessagesImmediate();
            }

            // 清空输入框
            input.value = '';

            // 🔥【新增】播放发送消息音效
            SoundManager.play(SoundManager.TYPES.MESSAGE_SENT, currentChatCharacter?.id);

            // 清除引用状态
            cancelReply();

            // 🔥【新增】清除当前聊天的引用状态存储
            if (currentChatCharacter) {
                delete chatReplyStates[currentChatCharacter.id];
            }

            // 🔥【新增】调整心率（用户发消息）
            adjustHeartrateForMessage(message, true);

            // 🔥【新增】重新安排主动聊天定时器
            onUserMessageSent(currentChatCharacter.id);

            // 🚫【移除】不再自动检测用户消息创建纪念日，这太不自然了

            // 使用动画添加消息而不是重新渲染整个列表
            addMessageWithAnimation(userMessage, currentChatCharacter.id);

            // 🔥【新增】检查拉黑状态并创建系统消息
            checkAndCreateBlockedSystemMessage(userMessage, currentChatCharacter.id);

            // 设置待回复消息
            pendingUserMessage = userMessage;

            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = '点击获取AI回复';
                }

            // 🔥【新增】触发记忆处理（简化版）
            setTimeout(async () => {
                try {
                    const messages = chatMessages[currentChatCharacter.id] || [];

                    // 🔥【修复】记录聊天时间线事件 - 群聊需要为每个成员记录
                    if (currentChatCharacter?.isGroup) {
                        // 群聊：为每个群成员记录用户消息事件
                        for (const member of currentChatCharacter.members || []) {
                            // 🔥【关键修复】检查该成员是否设置了与当前群聊共享记忆
                            const shouldRecord = await shouldRecordGroupMemoryForCharacter(member.id, currentChatCharacter.id);
                            if (shouldRecord) {
                                await recordCrossAppEvent(
                                    member.id, // 记录到每个成员的时间线下
                                    'chat',
                                    'user_message',
                                    {
                                        id: member.id, // 🔥【修复】使用角色ID而不是群聊ID，确保记忆共享正常工作
                                        type: 'group_chat',
                                        sender: 'user',
                                        content: message,
                                        chatType: 'group',
                                        groupName: currentChatCharacter.name,
                                        groupId: currentChatCharacter.id // 🔥【新增】保留群聊ID用于区分
                                    },
                                    messages[messages.length - 1]?.id
                                );
                            } else {
                                console.log(`⏭️ 跳过记录 - 角色 ${member.id} 未与群聊 ${currentChatCharacter.id} 共享记忆`);
                            }
                        }
                    } else {
                        // 单聊：正常记录
                        await recordCrossAppEvent(
                            currentChatCharacter.id,
                            'chat',
                            'user_message',
                            {
                                id: currentChatCharacter.id,
                                type: 'private_chat',
                                sender: 'user',
                                content: message,
                                chatType: 'single'
                            },
                            messages[messages.length - 1]?.id
                        );
                    }

                    // AI记忆提取（根据用户设置的间隔）
                    if (messages.length % MEMORY_CONFIG.AI_EXTRACT_INTERVAL === 0) {
                        const recentMessages = messages.slice(-MEMORY_CONFIG.AI_EXTRACT_INTERVAL);
                        // 🔥【修复】传入上下文ID用于记忆隔离
                        await extractMemoriesWithAI(currentChatCharacter.id, recentMessages, currentChatCharacter.id);
                        console.log(`🧠 触发记忆提取 - 角色: ${currentChatCharacter.name}, 消息数: ${messages.length}`);
                    }
                } catch (error) {
                    console.error('记忆处理失败:', error);
                }
            }, 1000); // 延迟1秒执行，避免阻塞UI

            } finally {
                // 确保处理完成后重置标志
                setTimeout(() => {
                    input._isProcessing = false;
                }, 100);
            }
        }

        // 语音录音相关变量
        let isRecording = false;
        let recordingStartTime = 0;

        // 处理语音录音
        async function handleVoiceRecording() {
            if (!currentChatCharacter) {
                alert('请先选择一个角色');
                return;
            }

            // 🔥【修复】移除对不存在按钮的依赖，直接显示语音输入对话框
                try {
                    const voiceText = await showVoiceInputDialog();
                    if (voiceText && voiceText.trim()) {
                        sendVoiceMessage(voiceText.trim());
                        console.log('语音消息发送成功');
                    }
                } catch (error) {
                    // 只有在真正取消时才显示取消消息
                    if (error.message === '用户取消') {
                        console.log('用户取消了语音输入');
                    } else {
                        console.error('语音消息发送失败:', error);
                    }
            }
        }

        // 重置录音状态 - 🔥【修复】移除对不存在按钮的依赖
        function resetRecordingState() {
            isRecording = false;
            // 不再需要操作按钮状态，因为我们使用的是工具面板中的语音按钮
        }

        // 显示语音输入对话框
        function showVoiceInputDialog() {
            return new Promise((resolve, reject) => {
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                `;

                const dialog = document.createElement('div');
                dialog.style.cssText = `
                    background: white;
                    border-radius: 12px;
                    padding: 20px;
                    width: 280px;
                    max-width: 90%;
                    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                `;

                dialog.innerHTML = `
                    <div style="text-align: center; margin-bottom: 15px;">
                        <h3 style="margin: 0; color: #333;">语音转文字</h3>
                        <p style="margin: 8px 0 0 0; color: #666; font-size: 14px;">请输入您想说的内容：</p>
                    </div>
                    <textarea id="voice-text-input" placeholder="在这里输入语音内容..." style="
                        width: 100%;
                        height: 80px;
                        border: 1px solid #ddd;
                        border-radius: 8px;
                        padding: 10px;
                        font-size: 14px;
                        resize: none;
                        box-sizing: border-box;
                        outline: none;
                    "></textarea>
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button id="voice-cancel-btn" style="
                            flex: 1;
                            padding: 10px;
                            border: 1px solid #ddd;
                            background: white;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 14px;
                        ">取消</button>
                        <button id="voice-send-btn" style="
                            flex: 1;
                            padding: 10px;
                            border: none;
                            background: #4a84c1;
                            color: white;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 14px;
                        ">发送</button>
                    </div>
                `;

                overlay.appendChild(dialog);
                document.body.appendChild(overlay);

                const textInput = dialog.querySelector('#voice-text-input');
                const cancelBtn = dialog.querySelector('#voice-cancel-btn');
                const sendBtn = dialog.querySelector('#voice-send-btn');

                // 自动聚焦到输入框
                setTimeout(() => textInput.focus(), 100);

                // 取消按钮
                cancelBtn.onclick = () => {
                    document.body.removeChild(overlay);
                    reject(new Error('用户取消'));
                };

                // 发送按钮
                sendBtn.onclick = () => {
                    const text = textInput.value.trim();
                    if (text) {
                        console.log('语音输入对话框：用户点击发送，内容:', text);
                        document.body.removeChild(overlay);
                        resolve(text);
                    } else {
                        console.log('语音输入对话框：内容为空，聚焦输入框');
                        textInput.focus();
                    }
                };

                // 点击遮罩关闭
                overlay.onclick = (e) => {
                    if (e.target === overlay) {
                        document.body.removeChild(overlay);
                        reject(new Error('用户取消'));
                    }
                };

                // 支持回车发送
                textInput.onkeydown = (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        console.log('语音输入框：用户按回车键发送');
                        sendBtn.click();
                    }
                };
            });
        }

                 // 发送语音消息
        async function sendVoiceMessage(text) {
            console.log('开始发送语音消息:', text);

            // 🔥【修改】移除拉黑检查，允许语音消息正常发送

            const messageId = Date.now().toString();
            const duration = Math.max(1, Math.ceil(text.length / 8)); // 根据文字长度计算"语音"时长

            const voiceMessage = {
                id: messageId,
                sender: 'sent',
                type: 'voice',
                content: text,
                duration: duration,
                timestamp: Date.now()
            };

            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }

            chatMessages[currentChatCharacter.id].push(voiceMessage);
            console.log('语音消息已添加到聊天记录');

            // 🔥【高效保存】直接添加单条语音消息到数据库，避免全量重写
            try {
                const stableId = `${currentChatCharacter.id}_${voiceMessage.id}_${chatMessages[currentChatCharacter.id].length - 1}`;
                await db.chatMessages.add({
                    id: stableId,
                    characterId: currentChatCharacter.id,
                    timestamp: voiceMessage.timestamp,
                    messageOrder: chatMessages[currentChatCharacter.id].length - 1,
                    originalMessageId: voiceMessage.id,
                    messageData: voiceMessage
                });
                console.log('✅ [高效语音] 语音消息已保存到数据库');
            } catch (error) {
                console.error('语音消息单条保存失败，回退到批量保存:', error);
                saveChatMessages();
            }

            // 🔥【新增】调整心率（用户发语音消息）
            adjustHeartrateForMessage(text, true);

            // 🔥【新增】重新安排主动聊天定时器
            onUserMessageSent(currentChatCharacter.id);

            // 添加语音消息到界面
            addMessageWithAnimation(voiceMessage, currentChatCharacter.id);
            console.log('语音消息已添加到界面');

            // 🔥【新增】检查拉黑状态并创建系统消息
            checkAndCreateBlockedSystemMessage(voiceMessage, currentChatCharacter.id);

            // 🔥【新增】触发角色状态更新
            triggerStatusUpdateAfterMessage(currentChatCharacter.id);

            // 设置待回复消息
            pendingUserMessage = voiceMessage;

            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = '点击获取AI回复';
            }

            console.log('语音消息发送流程完成');
        }

        // 切换语音文本显示
        function toggleVoiceText(voiceElement) {
            const container = voiceElement.closest('.voice-message-container') || voiceElement.closest('.message-container');
            if (!container) return;

            const textContent = container.querySelector('.voice-text-content');
            if (!textContent) {
                // 如果没有文本容器，创建一个
                const text = voiceElement.getAttribute('data-text');
                if (!text) return;

                const newTextContent = document.createElement('div');
                newTextContent.className = 'voice-text-content';
                newTextContent.textContent = text;

                // 根据消息类型决定插入位置
                if (container.classList.contains('voice-message-container')) {
                    container.appendChild(newTextContent);
                } else {
                    // 为旧格式创建语音容器
                    const voiceContainer = document.createElement('div');
                    voiceContainer.className = container.classList.contains('sent') ? 'voice-message-container sent' : 'voice-message-container received';

                    // 移动现有的消息气泡到语音容器中
                    const bubble = container.querySelector('.message-bubble');
                    if (bubble) {
                        container.removeChild(bubble);
                        voiceContainer.appendChild(bubble);
                        voiceContainer.appendChild(newTextContent);
                        container.appendChild(voiceContainer);
                    }
                }

                // 显示文本
                setTimeout(() => {
                    newTextContent.classList.add('visible');
                }, 10);

                return;
            }

            // 切换文本显示/隐藏
            if (textContent.classList.contains('visible')) {
                textContent.classList.remove('visible');
                setTimeout(() => {
                    textContent.style.display = 'none';
                }, 300);
            } else {
                textContent.style.display = 'block';
                setTimeout(() => {
                    textContent.classList.add('visible');
                }, 10);
            }
        }

        // 🔥【新增】防重复加载标志
        let isLoadingMoments = false;

        // 加载动态
        async function loadMoments() {
            try {
                // 🔥【修复】防止重复加载
                if (isLoadingMoments) {
                    console.log('动态正在加载中，跳过重复请求');
                    return;
                }

                isLoadingMoments = true;

                const momentsList = document.getElementById('moments-list');
                if (!momentsList) {
                    isLoadingMoments = false;
                    return;
                }

                // 🔥【修复】记录当前已显示的动态ID，避免重复显示
                const existingMomentIds = new Set();
                Array.from(momentsList.children).forEach(child => {
                    const momentId = child.getAttribute('data-moment-id');
                    if (momentId) {
                        existingMomentIds.add(momentId);
                    }
                });

                // 从数据库加载动态数据
                const momentsData = await db.moments.orderBy('timestamp').reverse().toArray();

                // 🔥【修复】只有在列表为空时才清空并重新加载所有动态
                if (existingMomentIds.size === 0) {
                    momentsList.innerHTML = '';
                    console.log('动态列表为空，加载所有动态');
                } else {
                    console.log('动态列表不为空，进行增量更新');
                }

                if (momentsData.length > 0) {
                    for (const momentData of momentsData) {
                        // 🔥【修复】检查是否已经显示过这条动态
                        if (existingMomentIds.has(momentData.id.toString())) {
                            continue; // 跳过已存在的动态
                        }
                        // 获取点赞数
                        const likesCount = await db.momentLikes.where('momentId').equals(momentData.id).count();

                        // 获取评论数
                        const commentsCount = await db.momentComments.where('momentId').equals(momentData.id).count();

                        // 获取评论列表
                        const comments = await db.momentComments.where('momentId').equals(momentData.id).toArray();
                        comments.sort((a, b) => a.timestamp - b.timestamp); // 按时间戳排序

                        // 🔥【新增】获取位置信息
                        const locationData = await db.momentLocations.where('momentId').equals(momentData.id).first();
                        const location = locationData ? locationData.locationName : '';

                        // 🔥【新增】获取提醒信息
                        const mentionData = await db.momentMentions.where('momentId').equals(momentData.id).toArray();
                        const mentions = mentionData.map(m => m.mentionedCharacterId);

                        // 🔥【新增】获取可见性信息（用于显示可见性标识）
                        const visibilityData = await db.momentVisibility.where('momentId').equals(momentData.id).first();
                        const visibility = visibilityData ? visibilityData.visibility : 'public';
                        const visibleGroups = visibilityData ? visibilityData.visibleGroups : [];

                            // 🔥【修复】验证并处理头像
                            let avatarToUse = null;
                            if (momentData.avatar && isValidAvatarUrl(momentData.avatar)) {
                                avatarToUse = momentData.avatar;
                            } else {
                                // 🔥【修复】使用await获取默认头像
                                avatarToUse = await getDefaultAvatar();
                                // 如果数据库中存储的头像无效，更新数据库记录
                                if (momentData.avatar && !isValidAvatarUrl(momentData.avatar)) {
                                    console.log(`清理动态 ${momentData.id} 的无效头像`);
                                    try {
                                        await db.moments.update(momentData.id, { avatar: avatarToUse });
                                    } catch (error) {
                                        console.error('更新动态头像失败:', error);
                                    }
                                }
                            }

                            const momentElement = createMomentElement({
                            id: momentData.id,
                                authorId: momentData.authorId, // 🔥【修复】添加authorId字段
                                nickname: momentData.nickname,
                                avatar: avatarToUse,
                                text: momentData.text,
                                images: momentData.images || [],
                                time: momentData.time,
                            timestamp: momentData.timestamp,
                            likes: likesCount,
                            comments: comments,
                            location: location, // 🔥【新增】位置信息
                            mentions: mentions, // 🔥【新增】提醒信息
                            visibility: visibility, // 🔥【新增】可见性信息
                            visibleGroups: visibleGroups // 🔥【新增】可见分组信息
                            });

                            // 🔥【修复】按时间顺序插入动态
                            const newTimestamp = momentData.timestamp;
                            let insertPosition = null;

                            // 找到正确的插入位置（按时间戳降序）
                            for (let i = 0; i < momentsList.children.length; i++) {
                                const existingElement = momentsList.children[i];
                                const existingTimestamp = parseInt(existingElement.getAttribute('data-timestamp') || '0');

                                if (newTimestamp > existingTimestamp) {
                                    insertPosition = existingElement;
                                    break;
                                }
                            }

                            // 插入到正确位置
                            if (insertPosition) {
                                momentsList.insertBefore(momentElement, insertPosition);
                            } else {
                                momentsList.appendChild(momentElement);
                            }

                            // 更新点赞显示
                        updateMomentLikeDisplay(momentData.id);

                            // 显示已有评论
                        if (comments && comments.length > 0) {
                            comments.forEach(comment => {
                                // 确保评论有time字段，如果没有就从timestamp生成
                                if (!comment.time && comment.timestamp) {
                                    comment.time = formatTime(new Date(comment.timestamp));
                                }
                                displayCommentUnderMoment(momentData.id, comment);
                                });
                            }
                    }

                        console.log('成功加载', momentsData.length, '条动态');
                } else {
                    console.log('没有找到保存的动态数据');
                }

                // 启动时间更新
                startTimeUpdater();

                console.log('成功加载', momentsData.length, '条动态');
            } catch (error) {
                console.error('加载动态失败:', error);
            } finally {
                // 🔥【修复】无论成功还是失败都要重置加载标志
                isLoadingMoments = false;
            }
        }

        // 发布动态相关变量
        let momentImages = [];
        let selectedLocation = '';
        let selectedMomentMentions = []; // 存储动态中被提醒的角色ID
        let selectedVisibility = 'public'; // 存储动态可见性设置：public, private, partial
        let selectedVisibilityGroups = []; // 存储部分可见时选择的分组ID

        // 显示发布动态界面
        function showPublishMoment() {
            showApp('publish-moment-screen');
            // 重置表单
            document.getElementById('moment-text').value = '';
            momentImages = [];
            updateMomentImagesGrid();
            // 重置位置选择
            document.getElementById('selected-location').textContent = '';
            selectedLocation = '';
            document.querySelector('.location-icon').classList.remove('active');
            // 重置提醒选择
            selectedMomentMentions = [];
            updateSelectedMomentMentionsDisplay();
            // 重置可见性选择
            selectedVisibility = 'public';
            selectedVisibilityGroups = [];
            updateSelectedVisibilityDisplay();

            // 重置发布按钮状态
            const publishBtn = document.querySelector('.publish-btn');
            if (publishBtn) {
                publishBtn.disabled = false;
                publishBtn.textContent = '发表';
            }
        }

        // 隐藏发布动态界面
        function hidePublishMoment() {
            showApp('chat-screen');
                                    // 切换回动态标签
            switchChatTab('moments-page');
            // 不需要重新加载，动态已经在数据库中
        }

        // 显示位置选择模态框
        function showLocationModal() {
            document.getElementById('location-modal').style.display = 'flex';
            // 清空输入框
            document.getElementById('location-input').value = '';
            // 聚焦到输入框
            setTimeout(() => {
                document.getElementById('location-input').focus();
            }, 100);
        }

        // 隐藏位置选择模态框
        function hideLocationModal(event) {
            if (event && event.target !== event.currentTarget) {
                return;
            }
            document.getElementById('location-modal').style.display = 'none';
        }

        // 确认位置选择
        function confirmLocation() {
            const locationInput = document.getElementById('location-input');
            const location = locationInput.value.trim();
            const locationIcon = document.querySelector('.location-icon');

            if (location) {
                selectedLocation = location;
                document.getElementById('selected-location').textContent = location;
                locationIcon.classList.add('active');
            } else {
                selectedLocation = '';
                document.getElementById('selected-location').textContent = '';
                locationIcon.classList.remove('active');
            }

            hideLocationModal();
        }

        // 处理位置输入框的回车键
        document.addEventListener('DOMContentLoaded', function() {
            const locationInput = document.getElementById('location-input');
            if (locationInput) {
                locationInput.addEventListener('keydown', function(event) {
                    if (event.key === 'Enter') {
                        confirmLocation();
                    }
                });
            }
        });

        // 显示动态提醒谁看模态框
        function showMomentMentionModal() {
            document.getElementById('mention-modal').style.display = 'flex';
            loadMomentMentionCharacters();
        }

        // 隐藏动态提醒谁看模态框
        function hideMomentMentionModal(event) {
            if (event && event.target !== event.currentTarget) {
                return;
            }
            document.getElementById('mention-modal').style.display = 'none';
        }

        // 加载可提醒的角色列表
        function loadMomentMentionCharacters() {
            const charactersList = document.getElementById('mention-characters-list');
            charactersList.innerHTML = '';

            if (!characters || characters.length === 0) {
                charactersList.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">暂无角色</div>';
                return;
            }

            characters.forEach(character => {
                const characterItem = document.createElement('div');
                characterItem.className = 'mention-character-item';
                characterItem.setAttribute('data-character-id', character.id);

                // 检查是否已选择
                if (selectedMomentMentions.includes(character.id)) {
                    characterItem.classList.add('selected');
                }

                // 获取角色头像 - 优先使用聊天窗口头像，然后是角色卡头像
                let avatarUrl = character.avatarUrl || createDefaultAvatar(character.name);

                characterItem.innerHTML = `
                    <img src="${avatarUrl}" alt="${character.name}" class="mention-character-avatar"
                         onerror="this.src='${createDefaultAvatar(character.name)}'">
                    <div class="mention-character-info">
                        <div class="mention-character-name">${character.name}</div>
                    </div>
                    <div class="mention-character-checkbox">
                        <i class="fas fa-check"></i>
                    </div>
                `;

                characterItem.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleMomentMentionCharacter(character.id);
                };
                charactersList.appendChild(characterItem);
            });
        }

        // 切换角色选择状态
        function toggleMomentMentionCharacter(characterId) {
            const index = selectedMomentMentions.indexOf(characterId);
            const characterItem = document.querySelector(`.mention-character-item[data-character-id="${characterId}"]`);

            if (index > -1) {
                // 取消选择
                selectedMomentMentions.splice(index, 1);
                characterItem.classList.remove('selected');
            } else {
                // 添加选择
                selectedMomentMentions.push(characterId);
                characterItem.classList.add('selected');
            }

            console.log('Toggle moment mention:', characterId, 'Selected mentions:', selectedMomentMentions);
        }

        // 确认提醒选择
        function confirmMomentMention() {
            updateSelectedMomentMentionsDisplay();
            hideMomentMentionModal();
        }

        // 更新已选择角色的显示
        function updateSelectedMomentMentionsDisplay() {
            const selectedMentionsContainer = document.getElementById('selected-mentions');
            const mentionIcon = document.querySelector('.mention-icon');
            selectedMentionsContainer.innerHTML = '';

            if (selectedMomentMentions.length > 0) {
                mentionIcon.classList.add('active');
                selectedMomentMentions.forEach(characterId => {
                    const character = characters.find(c => c.id === characterId);
                    if (character) {
                        const avatarImg = document.createElement('img');
                        avatarImg.src = character.avatarUrl || createDefaultAvatar(character.name);
                        avatarImg.alt = character.name;
                        avatarImg.className = 'selected-mention-avatar';
                        avatarImg.onerror = function() {
                            this.src = createDefaultAvatar(character.name);
                        };
                        selectedMentionsContainer.appendChild(avatarImg);
                    }
                });
            } else {
                mentionIcon.classList.remove('active');
            }
        }

        // 创建动态中的提醒显示
        function createMomentMentionsDisplay(mentionIds) {
            if (!mentionIds || mentionIds.length === 0) return '';

            const mentionNames = mentionIds.map(id => {
                const character = characters.find(c => c.id === id);
                return character ? character.name : '未知角色';
            }).filter(name => name !== '未知角色');

            if (mentionNames.length === 0) return '';

            return `<div class="moment-mentions">提到了：${mentionNames.join('，')}</div>`;
        }

        // 🔥【新增】创建可见性指示器
        function createVisibilityIndicator(visibility, visibleGroups) {
            if (!visibility || visibility === 'public') {
                return ''; // 公开动态不显示标识
            }

            let icon = '';
            let title = '';
            let text = '';

            switch (visibility) {
                case 'private':
                    icon = 'fas fa-lock';
                    title = '私密';
                    text = '私密';
                    break;
                case 'partial':
                    icon = 'fas fa-users';
                    title = '部分可见';
                    if (visibleGroups && visibleGroups.length > 0) {
                        const groupNames = visibleGroups.map(id => {
                            const group = characterGroups.find(g => g.id === id);
                            return group ? group.name : '未知分组';
                        }).filter(name => name !== '未知分组');
                        text = groupNames.length > 0 ? groupNames.join('、') : '部分可见';
                    } else {
                        text = '部分可见';
                    }
                    break;
                default:
                    return '';
            }

            return `<span class="moment-visibility-indicator" title="${title}">
                <i class="${icon}"></i>
                <span>${text}</span>
            </span>`;
        }

        // 显示谁可以看模态框
        function showVisibilityModal() {
            document.getElementById('visibility-modal').style.display = 'flex';
            loadVisibilityOptions();
        }

        // 隐藏谁可以看模态框
        function hideVisibilityModal(event) {
            if (event && event.target !== event.currentTarget) {
                return;
            }
            document.getElementById('visibility-modal').style.display = 'none';
        }

        // 加载可见性选项
        function loadVisibilityOptions() {
            const options = document.querySelectorAll('.visibility-option');
            options.forEach(option => {
                option.classList.remove('selected');
                if (option.dataset.value === selectedVisibility) {
                    option.classList.add('selected');
                }
                option.onclick = () => selectVisibilityOption(option.dataset.value);
            });

            // 如果选择了部分可见，显示分组选择
            if (selectedVisibility === 'partial') {
                showVisibilityGroups();
            } else {
                hideVisibilityGroups();
            }
        }

        // 选择可见性选项
        function selectVisibilityOption(value) {
            selectedVisibility = value;

            // 更新选中状态
            const options = document.querySelectorAll('.visibility-option');
            options.forEach(option => {
                option.classList.remove('selected');
                if (option.dataset.value === value) {
                    option.classList.add('selected');
                }
            });

            // 如果选择部分可见，显示分组选择
            if (value === 'partial') {
                showVisibilityGroups();
            } else {
                hideVisibilityGroups();
                selectedVisibilityGroups = []; // 清空分组选择
            }
        }

        // 显示分组选择区域
        function showVisibilityGroups() {
            const groupsSection = document.getElementById('visibility-groups-section');
            const groupsList = document.getElementById('visibility-groups-list');

            groupsSection.style.display = 'block';
            groupsList.innerHTML = '';

            // 只显示可以互动的分组（非默认分组且允许互动）
            const interactableGroups = characterGroups.filter(group =>
                !group.isDefault && group.canInteract
            );

            if (interactableGroups.length === 0) {
                groupsList.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">暂无可选择的分组</div>';
                return;
            }

            interactableGroups.forEach(group => {
                const groupItem = document.createElement('div');
                groupItem.className = 'visibility-group-item';
                groupItem.setAttribute('data-group-id', group.id);

                // 检查是否已选择
                if (selectedVisibilityGroups.includes(group.id)) {
                    groupItem.classList.add('selected');
                }

                groupItem.innerHTML = `
                    <div class="visibility-group-name">${group.name}</div>
                    <div class="visibility-group-checkbox">
                        <i class="fas fa-check"></i>
                    </div>
                `;

                groupItem.onclick = () => toggleVisibilityGroup(group.id);
                groupsList.appendChild(groupItem);
            });
        }

        // 隐藏分组选择区域
        function hideVisibilityGroups() {
            const groupsSection = document.getElementById('visibility-groups-section');
            groupsSection.style.display = 'none';
        }

        // 切换分组选择状态
        function toggleVisibilityGroup(groupId) {
            const index = selectedVisibilityGroups.indexOf(groupId);
            const groupItem = document.querySelector(`.visibility-group-item[data-group-id="${groupId}"]`);

            if (index > -1) {
                // 取消选择
                selectedVisibilityGroups.splice(index, 1);
                groupItem.classList.remove('selected');
            } else {
                // 添加选择
                selectedVisibilityGroups.push(groupId);
                groupItem.classList.add('selected');
            }
        }

        // 确认可见性选择
        function confirmVisibility() {
            updateSelectedVisibilityDisplay();
            hideVisibilityModal();
        }

        // 更新已选择可见性的显示
        function updateSelectedVisibilityDisplay() {
            const visibilityElement = document.getElementById('selected-visibility');
            const visibilityIcon = document.querySelector('.visibility-icon');

            let displayText = '';
            let isActive = false;

            switch (selectedVisibility) {
                case 'public':
                    displayText = '公开';
                    isActive = false; // 公开是默认状态，保持灰色
                    break;
                case 'private':
                    displayText = '私密';
                    isActive = true;
                    break;
                case 'partial':
                    if (selectedVisibilityGroups.length > 0) {
                        const groupNames = selectedVisibilityGroups.map(id => {
                            const group = characterGroups.find(g => g.id === id);
                            return group ? group.name : '未知分组';
                        }).filter(name => name !== '未知分组');
                        displayText = `${groupNames.join('、')}可见`;
                        isActive = true;
                    } else {
                        displayText = '部分可见';
                        isActive = true;
                    }
                    break;
            }

            visibilityElement.textContent = displayText;

            if (isActive) {
                visibilityIcon.classList.add('active');
            } else {
                visibilityIcon.classList.remove('active');
            }
        }

        // 添加图片到动态
        function addMomentImage() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*,.jpg,.jpeg,.png,.gif,.webp';
            input.multiple = true;
            input.onchange = function(event) {
                const files = Array.from(event.target.files);
                files.forEach(file => {
                    if (momentImages.length < 9) { // 最多9张图片
                        const reader = new FileReader();
                        reader.onload = async function(e) {
                            try {
                                // 压缩图片
                                const compressedImage = await compressImage(e.target.result, 800, 0.8);
                                momentImages.push(compressedImage);
                                updateMomentImagesGrid();
                            } catch (error) {
                                showToast("图片处理失败，请重试");                                console.error("压缩图片失败:", error);
                            }
                        };
                        reader.readAsDataURL(file);
                    }
                });
            };
            input.click();
        }

        // 删除图片
        function removeMomentImage(index) {
            momentImages.splice(index, 1);
            updateMomentImagesGrid();
        }

        // 更新图片网格显示
        function updateMomentImagesGrid() {
            const grid = document.getElementById('moment-images-grid');
            grid.innerHTML = '';

            momentImages.forEach((imageData, index) => {
                const imageItem = document.createElement('div');
                imageItem.className = 'moment-image-item';
                imageItem.innerHTML = `
                    <img src="${imageData}" alt="动态图片">
                    <button class="remove-image-btn" onclick="removeMomentImage(${index})">×</button>
                `;
                grid.appendChild(imageItem);
            });
        }

        // 发布动态

        // 获取默认头像 - 修复异步问题
        async function getDefaultAvatar() {
            try {
                // 🔥【修复】使用await获取动态头像，确保异步操作正确完成
                const momentsAvatar = await getMomentsImage("avatarImage");
                if (momentsAvatar && isValidAvatarUrl(momentsAvatar)) {
                    console.log('使用动态页面设置的头像');
                    return momentsAvatar;
                }

                // 尝试获取用户头像，但要验证其有效性
                if (window.userAvatar && isValidAvatarUrl(window.userAvatar)) {
                    console.log('使用全局用户头像');
                    return window.userAvatar;
                }

                // 清理无效的用户头像数据
                if (window.userAvatar && !isValidAvatarUrl(window.userAvatar)) {
                    console.log('清理无效的用户头像数据');
                    window.userAvatar = null;
                }

                // 清理无效的动态头像数据
                if (momentsAvatar && !isValidAvatarUrl(momentsAvatar)) {
                    console.log('清理无效的动态头像数据');
                    // 这里需要调用清理函数，但由于getMomentsImage的存储机制，我们先跳过
                }

                console.log('使用默认生成的头像');
                // 返回默认头像（使用CSS生成的简单头像）
                return "data:image/svg+xml;base64," + btoa(`<svg width="50" height="50" xmlns="http://www.w3.org/2000/svg"><rect width="50" height="50" fill="#f0f0f0"/><circle cx="25" cy="20" r="8" fill="#999"/><circle cx="25" cy="40" r="12" fill="#999"/></svg>`);
            } catch (error) {
                console.error('获取默认头像失败:', error);
                return "data:image/svg+xml;base64," + btoa(`<svg width="50" height="50" xmlns="http://www.w3.org/2000/svg"><rect width="50" height="50" fill="#f0f0f0"/><circle cx="25" cy="20" r="8" fill="#999"/><circle cx="25" cy="40" r="12" fill="#999"/></svg>`);
            }
        }        async function publishMoment() {
            const text = document.getElementById('moment-text').value.trim();
            const publishBtn = document.querySelector('.publish-btn');

            if (!text && momentImages.length === 0) {
                showToast('请输入文字或选择图片');
                return;
            }

            // 禁用发布按钮，防止重复提交
            publishBtn.disabled = true;
            publishBtn.textContent = '发布中...';

            // 获取当前用户昵称
            const nickname = document.getElementById('moments-username')?.textContent || '我';

            // 🔥【修复】使用await获取用户头像
            const userAvatar = await getDefaultAvatar();

            // 创建新动态
            const now = new Date();
            const newMoment = {
                id: Date.now(),
                authorId: 'user',
                nickname: nickname,
                avatar: userAvatar,
                text: text,
                images: [...momentImages],
                location: selectedLocation || '', // 添加位置信息
                mentions: [...selectedMomentMentions], // 添加提醒角色信息
                time: formatTime(now),
                timestamp: now.getTime(),
                visibility: selectedVisibility, // 🔥【新增】可见性信息
                visibleGroups: [...selectedVisibilityGroups] // 🔥【新增】可见分组信息
            };

            try {
                // 保存到数据库
                await db.moments.add(newMoment);

                // 🔥【新增】保存可见性设置到数据库
                if (selectedVisibility !== 'public' || selectedVisibilityGroups.length > 0) {
                    await db.momentVisibility.add({
                        momentId: newMoment.id,
                        visibility: selectedVisibility,
                        visibleGroups: selectedVisibilityGroups,
                        timestamp: new Date()
                    });
                }

                // 🔥【新增】保存位置信息到数据库
                if (selectedLocation) {
                    await db.momentLocations.add({
                        momentId: newMoment.id,
                        locationName: selectedLocation,
                        latitude: null, // 可以后续扩展GPS功能
                        longitude: null,
                        timestamp: new Date()
                    });
                }

                // 🔥【新增】保存提醒信息到数据库
                if (selectedMomentMentions.length > 0) {
                    for (const characterId of selectedMomentMentions) {
                        await db.momentMentions.add({
                            momentId: newMoment.id,
                            mentionedCharacterId: characterId,
                            timestamp: new Date(),
                            isRead: false
                        });
                    }
                }

                // 恢复发布按钮状态
                publishBtn.disabled = false;
                publishBtn.textContent = '发表';

                // 显示成功提示
                showToast('发布成功！');

                // 清空表单
                document.getElementById('moment-text').value = '';
                momentImages = [];
                updateMomentImagesGrid();
                // 重置位置选择
                document.getElementById('selected-location').textContent = '';
                selectedLocation = '';
                document.querySelector('.location-icon').classList.remove('active');
                // 重置提醒选择
                selectedMomentMentions = [];
                updateSelectedMomentMentionsDisplay();
                // 重置可见性选择
                selectedVisibility = 'public';
                selectedVisibilityGroups = [];
                updateSelectedVisibilityDisplay();

                // 返回动态页面
                    hidePublishMoment();

                // 🔥【修复】统一使用loadMoments来避免重复显示
                setTimeout(() => {
                    loadMoments();
                }, 100);

                // 启动时间更新器
                startTimeUpdater();

                // 延迟触发AI角色的互动
                setTimeout(() => {
                    triggerAIInteractions(newMoment.id, 'like');
                }, 1000);
                setTimeout(() => {
                    triggerAIInteractions(newMoment.id, 'comment');
                }, 3000);

            } catch (error) {
                console.error('发布动态失败:', error);
                showToast('发布失败，请重试');

                // 恢复发布按钮
                publishBtn.disabled = false;
                publishBtn.textContent = '发表';
            }
        }

        // 格式化时间
        function formatTime(date) {
            // 确保date是Date对象
            if (!date) return '未知时间';
            if (!(date instanceof Date)) {
                date = new Date(date);
            }
            if (isNaN(date.getTime())) return '无效时间';

            const now = new Date();
            const diff = now - date;

            if (diff < 60000) { // 小于1分钟
                return '刚刚';
            } else if (diff < 3600000) { // 小于1小时
                return Math.floor(diff / 60000) + '分钟前';
            } else if (diff < 86400000) { // 小于1天
                return Math.floor(diff / 3600000) + '小时前';
            } else if (diff < 604800000) { // 小于1周
                return Math.floor(diff / 86400000) + '天前';
            } else {
                return date.toLocaleDateString();
            }
        }

        // 🔥【删除】不再需要addMomentToList函数，统一使用loadMoments

        // 创建动态元素
        function createMomentElement(moment) {
            const momentDiv = document.createElement('div');
            momentDiv.className = 'moment-item';

            // 设置动态ID和时间戳
            momentDiv.setAttribute('data-moment-id', moment.id);
            if (moment.timestamp) {
                momentDiv.setAttribute('data-timestamp', moment.timestamp);
            }

            let imagesHtml = '';
            if (moment.images && moment.images.length > 0) {
                imagesHtml = `
                    <div class="moment-images">
                        ${moment.images.map(img => `<img src="${img}" alt="动态图片" onclick="previewImage('${img}')">`).join('')}
                    </div>
                `;
            }
            // 🔥【修复】正确获取角色头像
            let finalAvatar = null;
            if (moment.authorId === 'user') {
                // 用户动态：直接使用保存的头像（已在发布时正确设置）
                finalAvatar = moment.avatar;
            } else {
                // 角色动态：优先动态头像，然后角色卡头像
                finalAvatar = moment.avatar;
                if (!finalAvatar && moment.characterId) {
                    const character = characters.find(c => c.id === moment.characterId);
                    if (character && character.avatarUrl) {
                        finalAvatar = character.avatarUrl;
                    }
                }
            }

            momentDiv.innerHTML = `
                <div class="moment-avatar">
                    ${finalAvatar ?
                        `<img src="${finalAvatar}" alt="头像" style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px;" onerror="this.style.display='none'; this.parentElement.innerHTML='<div style=\\'width: 40px; height: 40px; background-color: #ddd; border-radius: 8px; display: flex; align-items: center; justify-content: center; color: #666; font-size: 14px;\\'>${moment.nickname ? moment.nickname.charAt(0) : '?'}</div>'">` :
                        `<div style="width: 40px; height: 40px; background-color: #ddd; border-radius: 8px; display: flex; align-items: center; justify-content: center; color: #666; font-size: 14px;">${moment.nickname ? moment.nickname.charAt(0) : '?'}</div>`
                    }
                </div>
                <div class="moment-content">
                    <div class="moment-username">
                        ${moment.nickname}
                    </div>
                    <div class="moment-text">${formatMomentText(moment.text)}</div>
                    ${imagesHtml}
                    ${moment.mentions && moment.mentions.length > 0 ? createMomentMentionsDisplay(moment.mentions) : ''}
                    <div class="moment-time-actions" style="margin-top: 0; padding: 8px 0; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center;">
                        <div class="moment-time-location" style="display: flex; align-items: center; gap: 4px;">
                            <div class="moment-time">${moment.time}</div>
                            ${moment.location ? `<div class="moment-location"><i class="fas fa-map-marker-alt"></i> ${moment.location}</div>` : ''}
                            ${moment.authorId === 'user' ? createVisibilityIndicator(moment.visibility, moment.visibleGroups) : ''}
                        </div>
                        <div class="moment-actions">
                            <!-- 三点按钮 -->
                            <button class="moment-more-btn" onclick="toggleMomentActions('${moment.id}')">
                                <div class="moment-more-dots">
                                    <div class="dot"></div>
                                    <div class="dot"></div>
                                </div>
                            </button>

                            <!-- 弹出的操作菜单 -->
                            <div class="moment-actions-popup" id="moment-actions-${moment.id}">
                                <button class="moment-action-btn popup-like-btn" onclick="toggleMomentLike('${moment.id}')">
                                    <i class="far fa-heart"></i>
                                    <span>赞</span>
                                </button>
                                <div class="popup-divider"></div>
                                <button class="moment-action-btn popup-comment-btn" onclick="showMomentComments('${moment.id}')">
                                    <i class="far fa-comment"></i>
                                    <span>评论</span>
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="moment-footer" style="display: none;">
                    </div>
                </div>
            `;

            // 添加长按监听器
            addLongPressListener(momentDiv, moment.id);

            // 异步检查并设置用户点赞状态
            (async () => {
                try {
                    const userLike = await db.momentLikes
                        .where('[momentId+authorId]')
                        .equals([moment.id, 'user'])
                        .first();

                    if (userLike) {
                    const likeBtn = momentDiv.querySelector('.moment-action-btn');
                    const likeIcon = likeBtn.querySelector('i');
                    likeIcon.classList.remove('far');
                    likeIcon.classList.add('fas');
                    likeBtn.classList.add('liked');
                }
                } catch (error) {
                    console.error('检查用户点赞状态失败:', error);
            }
            })();

            return momentDiv;
        }

        // 预览图片
        function previewImage(imageSrc) {
            // 创建预览遮罩
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.9);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
            `;

            const img = document.createElement('img');
            img.src = imageSrc;
            img.style.cssText = `
                max-width: 90%;
                max-height: 90%;
                object-fit: contain;
            `;

            overlay.appendChild(img);
            overlay.onclick = () => document.body.removeChild(overlay);
            document.body.appendChild(overlay);
        }

        // 注意：saveMomentsData函数已移除，现在使用Dexie数据库直接存储
        // 更新文字计数
        function updateTextCount() {
            const textarea = document.getElementById('moment-text');
            const countElement = document.getElementById('text-count');

            if (textarea && countElement) {
                const currentLength = textarea.value.length;
                const maxLength = 500;

                countElement.textContent = `${currentLength}/${maxLength}`;

                // 当接近限制时改变颜色
                if (currentLength > maxLength * 0.9) {
                    countElement.style.color = '#ff6b6b';
                } else if (currentLength > maxLength * 0.8) {
                    countElement.style.color = '#ffa500';
                } else {
                    countElement.style.color = '#999';
                }
            }
        }

        // 显示提示消息
        function showToast(message) {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.8);
                color: white;
                padding: 12px 20px;
                border-radius: 6px;
                z-index: 10000;
                font-size: 14px;
            `;
            toast.textContent = message;

            document.body.appendChild(toast);
            setTimeout(() => {
                document.body.removeChild(toast);
            }, 2000);
        }

        // 时间更新器
        let timeUpdateInterval = null;

        function startTimeUpdater() {
            // 清除已存在的定时器
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
            }

            // 立即更新一次
            updateMomentTimes();

            // 每分钟更新一次时间显示
            timeUpdateInterval = setInterval(updateMomentTimes, 60000);
        }

        function stopTimeUpdater() {
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
                timeUpdateInterval = null;
            }
        }

        function updateMomentTimes() {
            try {
                // 更新动态本身的时间
                const momentItems = document.querySelectorAll('.moment-item[data-timestamp]');

                momentItems.forEach(item => {
                    const timestamp = parseInt(item.getAttribute('data-timestamp'));
                    if (timestamp) {
                        const timeElement = item.querySelector('.moment-time');
                        if (timeElement) {
                            const newTime = formatTime(new Date(timestamp));
                            timeElement.textContent = newTime;
                        }
                    }
                });

                // 🔥【新增】更新评论区的时间显示
                const commentElements = document.querySelectorAll('.moment-comment[data-timestamp]');
                commentElements.forEach(commentElement => {
                    const timestamp = parseInt(commentElement.getAttribute('data-timestamp'));
                    if (timestamp) {
                        const timeElement = commentElement.querySelector('.comment-time');
                        if (timeElement) {
                            const newTime = formatTime(new Date(timestamp));
                            timeElement.textContent = newTime;
                        }
                    }
                });
            } catch (error) {
                console.error('更新动态时间失败:', error);
            }
        }

        // 动态选择模式相关变量
        let isSelectionMode = false;
        let selectedMoments = new Set();

        // 切换动态点赞状态
        async function toggleMomentLike(momentId) {
            if (isSelectionMode) return; // 选择模式下不响应点赞

            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;

            const likeBtn = momentElement.querySelector('.moment-action-btn');
            const likeIcon = likeBtn.querySelector('i');

            try {
            // 检查用户是否已点赞
                const existingLike = await db.momentLikes
                    .where('[momentId+authorId]')
                    .equals([parseInt(momentId), 'user'])
                    .first();

                if (existingLike) {
                // 取消点赞
                likeIcon.classList.remove('fas');
                likeIcon.classList.add('far');
                likeBtn.classList.remove('liked');
                    await db.momentLikes.delete([parseInt(momentId), 'user']);
            } else {
                // 点赞
                likeIcon.classList.add('fas');
                likeIcon.classList.remove('far');
                likeBtn.classList.add('liked');
                    await db.momentLikes.add({
                        momentId: parseInt(momentId),
                        authorId: 'user',
                    characterId: 'user',
                    name: document.getElementById('moments-username')?.textContent || '我',
                    timestamp: Date.now()
                });

                // 触发AI角色自动点赞
                triggerAIInteractions(momentId, 'like');
            }

            // 更新显示
            updateMomentLikeDisplay(momentId);
            } catch (error) {
                console.error('点赞操作失败:', error);
            }
        }

        // 显示动态评论
        function showMomentComments(momentId) {
            if (isSelectionMode) return; // 选择模式下不响应评论

            // 🔥【新版】显示底部固定评论输入框
            showBottomCommentInput(momentId);

            // 🔥【修复】移除用户点击评论时自动触发AI评论的逻辑
            // 用户点击评论按钮只是想评论，不应该触发其他AI角色也来评论
            // AI角色的自动评论应该只在动态发布时触发，而不是在用户评论时触发
        }

        // 🔥【新增】显示底部固定评论输入框
        function showBottomCommentInput(momentId, replyToNickname = null) {
            // 关闭已存在的底部输入框
            closeBottomCommentInput();

            const placeholder = replyToNickname ? `回复 ${replyToNickname}...` : '写评论...';

            // 创建底部固定输入框
            const bottomInput = document.createElement('div');
            bottomInput.id = 'bottom-comment-input';
            bottomInput.className = 'bottom-comment-input';

            bottomInput.innerHTML = `
                <div class="bottom-comment-container">
                    <input type="text"
                           placeholder="${placeholder}"
                           maxlength="200"
                           id="bottom-comment-text"
                           data-moment-id="${momentId}"
                           data-reply-to="${replyToNickname || ''}">
                    <button class="bottom-comment-send" onclick="submitBottomComment()">发送</button>
                </div>
            `;

            // 添加到页面
            document.body.appendChild(bottomInput);

            // 获取输入框元素
            const textInput = bottomInput.querySelector('#bottom-comment-text');

            // 自动聚焦
            setTimeout(() => {
                textInput.focus();
                // 调整页面滚动，避免被输入框遮挡
                window.scrollBy(0, 60);
            }, 100);

            // 回车发送
            textInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    submitBottomComment();
                }
            });

            // 点击外部关闭
            setTimeout(() => {
                document.addEventListener('click', handleBottomCommentClickOutside);
            }, 100);
        }

        // 🔥【新增】关闭底部评论输入框
        function closeBottomCommentInput() {
            const bottomInput = document.getElementById('bottom-comment-input');
            if (bottomInput) {
                bottomInput.remove();
                document.removeEventListener('click', handleBottomCommentClickOutside);
            }
        }

        // 🔥【新增】处理底部评论框外部点击
        function handleBottomCommentClickOutside(e) {
            const bottomInput = document.getElementById('bottom-comment-input');
            if (bottomInput && !bottomInput.contains(e.target)) {
                closeBottomCommentInput();
            }
        }

        // 🔥【新增】提交底部评论
        async function submitBottomComment() {
            const textInput = document.getElementById('bottom-comment-text');
            if (!textInput) return;

            const text = textInput.value.trim();
            const momentId = textInput.getAttribute('data-moment-id');
            const replyTo = textInput.getAttribute('data-reply-to');

            if (!text) {
                showToast('请输入评论内容');
                return;
            }

            // 创建评论对象
            // 🔥【修复】获取用户在动态页设置的昵称
            const nickname = document.getElementById('moments-username')?.textContent || '我';

            const comment = {
                id: Date.now(),
                nickname: nickname, // 🔥【修复】使用动态页设置的昵称
                avatar: await getDefaultAvatar(), // 🔥【修复】使用getDefaultAvatar函数
                text: text,
                time: formatTime(new Date()),
                timestamp: Date.now(),
                authorId: 'user',
                replyTo: replyTo || null
            };

            // 保存评论到动态数据
            saveCommentToMoment(momentId, comment);

            // 更新动态列表中的评论数
            updateMomentCommentCount(momentId);

            // 在动态下方显示新评论
            displayCommentUnderMoment(momentId, comment);

            // 关闭输入框
            closeBottomCommentInput();

            showToast('评论成功！');

            // 🔥【修改】处理AI回复逻辑，改为3回合限制
            if (replyTo && replyTo !== '我') {
                const conversationKey = `${momentId}-${replyTo}`;
                const currentRounds = commentConversationRounds.get(conversationKey) || 0;

                if (currentRounds < 3) {
                    commentConversationRounds.set(conversationKey, currentRounds + 1);
                    console.log(`用户回复后，${replyTo} 在动态 ${momentId} 中的对话回合次更新为: ${currentRounds + 1}/3`);

                    setTimeout(() => {
                        console.log(`开始触发 ${replyTo} 回复用户评论: "${text}"`);
                        triggerAIReplyToUser(momentId, replyTo, text);
                    }, Math.random() * 3000 + 2000);
                } else {
                    console.log(`${replyTo} 在动态 ${momentId} 中的对话已达到3回合上限，不再回复`);
                }
            } else {
                console.log(`用户发表了评论，replyTo: ${replyTo}`);

                if (!replyTo) {
                    checkAndTriggerCharacterMomentReply(momentId, text);
                }
            }
        }





        // 检查并触发角色动态的回复
        async function checkAndTriggerCharacterMomentReply(momentId, userCommentText) {
            try {
                // 获取动态信息
                const moment = await db.moments.get(parseInt(momentId));
                if (!moment || !moment.characterId || moment.characterId === 'user') {
                    console.log('不是角色发布的动态，跳过角色回复');
                    return;
                }

                // 获取发布动态的角色
                const character = characters.find(c => c.id === moment.characterId);
                if (!character) {
                    console.log(`未找到动态发布者角色: ${moment.characterId}`);
                    return;
                }

                // 🔥【修改】检查对话回合次，改为3回合限制
                const conversationKey = `${momentId}-${character.name}`;
                const currentRounds = commentConversationRounds.get(conversationKey) || 0;

                if (currentRounds >= 3) {
                    console.log(`${character.name} 在动态 ${momentId} 中的对话已达到3回合上限，不再回复`);
                    return;
                }

                console.log(`用户评论了 ${character.name} 的动态，当前对话回合次: ${currentRounds}/3，将在2-5秒后触发回复`);

                // 增加对话回合次
                commentConversationRounds.set(conversationKey, currentRounds + 1);
                console.log(`用户评论后，${character.name} 在动态 ${momentId} 中的对话回合次更新为: ${currentRounds + 1}/3`);

                // 延迟回复
                setTimeout(() => {
                    console.log(`开始触发 ${character.name} 回复用户对其动态的评论: "${userCommentText}"`);
                    triggerAIReplyToUser(momentId, character.name, userCommentText);
                }, Math.random() * 3000 + 2000); // 2-5秒后AI回复

            } catch (error) {
                console.error('检查角色动态回复失败:', error);
            }
        }

        // 在动态下方显示评论
        function displayCommentUnderMoment(momentId, comment) {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;

            // 查找或创建评论区域
            let commentsSection = momentElement.querySelector('.moment-comments-section');
            if (!commentsSection) {
                commentsSection = document.createElement('div');
                commentsSection.className = 'moment-comments-section';

                // 检查是否已有点赞区域，决定margin-top
                const likesDisplay = momentElement.querySelector('.likes-display');
                const marginTop = likesDisplay ? '0' : '0';

                commentsSection.style.cssText = `
                    margin-top: ${marginTop};
                    padding: 8px 12px;
                    background: #f8f9fa;
                    font-size: 13px;
                `;

                // 插入到正确位置：点赞区后面（如果有的话），否则在时间操作区后面
                const momentContent = momentElement.querySelector('.moment-content');
                const momentTimeActions = momentElement.querySelector('.moment-time-actions');

                if (momentContent && momentTimeActions) {
                if (likesDisplay) {
                        // 如果有点赞区，插入到点赞区后面
                    likesDisplay.parentNode.insertBefore(commentsSection, likesDisplay.nextSibling);
                    } else {
                        // 没有点赞区，插入到时间操作区后面
                    momentTimeActions.parentNode.insertBefore(commentsSection, momentTimeActions.nextSibling);
                    }
                }
            }

            // 创建评论元素
            const commentDiv = document.createElement('div');
            commentDiv.className = 'comment-item moment-comment';
            commentDiv.setAttribute('data-timestamp', comment.timestamp || Date.now());
            commentDiv.style.cssText = `
                display: flex;
                gap: 8px;
                margin-bottom: 8px;
                align-items: flex-start;
            `;

            // 🔥【修复】处理回复格式，确保角色回复用户时格式正常
            let commentText = comment.text;
            let nameFormat = comment.nickname + '：'; // 默认格式

            if (comment.replyTo) {
                // 有回复时，角色名后不加冒号，回复内容包含完整格式
                nameFormat = comment.nickname;
                commentText = `回复<span style="margin: 0 2px; color: #576b95; font-weight: 600;">${comment.replyTo}</span>: ${comment.text}`;
            }

            commentDiv.innerHTML = `
                <img src="${comment.avatar}" style="width: 24px; height: 24px; border-radius: 50%; object-fit: cover;">
                <div style="flex: 1; line-height: 1.4; cursor: pointer;" onclick="replyToMomentComment('${momentId}', '${comment.nickname}')">
                    <span style="color: #576b95; font-weight: 600;">${nameFormat}</span><span style="margin-left: 2px; color: #333;">${commentText}</span>
                    <div class="comment-time" style="color: #999; font-size: 11px; margin-top: 2px;">${comment.time}</div>
                </div>
            `;

            commentsSection.appendChild(commentDiv);
        }

        // 回复动态评论
        function replyToMomentComment(momentId, nickname) {
            // 🔥【修改】使用底部固定输入框，并设置为回复模式
            showBottomCommentInput(momentId, nickname);
        }



        // 保存评论到动态数据
        async function saveCommentToMoment(momentId, comment) {
            try {
                const commentData = {
                    id: comment.id,
                    momentId: parseInt(momentId),
                    authorId: comment.characterId || 'user',
                    nickname: comment.nickname,
                    avatar: comment.avatar,
                    text: comment.text,
                    timestamp: comment.timestamp,
                    replyTo: comment.replyTo || null
                };

                await db.momentComments.add(commentData);
                console.log('评论已保存到数据库，动态ID:', momentId);
            } catch (error) {
                console.error('保存评论失败:', error);
            }
        }

        // 更新动态评论数
        async function updateMomentCommentCount(momentId) {
            try {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;

                const commentsCount = await db.momentComments.where('momentId').equals(parseInt(momentId)).count();

                const commentBtn = momentElement.querySelectorAll('.moment-action-btn')[1];
                const commentCount = commentBtn.querySelector('span');
                commentCount.textContent = commentsCount;
            } catch (error) {
                console.error('更新评论数失败:', error);
            }
        }

        // 触发AI角色互动
        async function triggerAIInteractions(momentId, type) {
            try {
            if (!characters || characters.length === 0) return;

            // 获取当前动态信息
                const moment = await db.moments.get(parseInt(momentId));
            if (!moment) return;

                const publisherCharacterId = moment.characterId;

                // 如果是用户发的动态
                if (!publisherCharacterId || publisherCharacterId === 'user') {


                    // 🔥【新增】首先过滤出能看到这条动态的角色
                    const contactCharacters = characters.filter(char => contacts.includes(char.id));
                    const visibleCharacters = [];

                    for (const character of contactCharacters) {
                        const canSee = await checkMomentVisibilityForCharacter(parseInt(momentId), character.id);
                        if (canSee) {
                            visibleCharacters.push(character);
                        }
                    }



            if (type === 'like') {
                for (const character of visibleCharacters) {
                    if (Math.random() < 0.8) { // 80%概率点赞
                                setTimeout(async () => {
                                    await addAILikeWithPersonality(momentId, character, moment);
                                }, Math.random() * 3000 + 1000);
                    }
                }
            } else if (type === 'comment') {
                for (const character of visibleCharacters) {
                    if (Math.random() < 0.8) { // 80%概率评论
                            setTimeout(async () => {
                                await addAICommentWithPersonality(momentId, character, moment);
                                }, Math.random() * 5000 + 2000);
                    }
                }
                    }
                } else {
                    console.log('角色发布动态，同一分组下角色65%概率互动');
                    // 角色发动态：使用分组关系而不是群聊关系
                    const publisherCharacter = characters.find(c => c.id === publisherCharacterId);

                    // 🔥【新增】获取与发布者在同一分组且能看到动态的角色
                    const sameGroupCharacters = characters.filter(c =>
                        c.id !== publisherCharacterId && c.groupId === publisherCharacter.groupId
                    );

                    // 进一步过滤出能看到这条动态的角色
                    const visibleSameGroupCharacters = [];
                    for (const character of sameGroupCharacters) {
                        const canSee = await checkMomentVisibilityForCharacter(parseInt(momentId), character.id);
                        if (canSee) {
                            visibleSameGroupCharacters.push(character);
                        }
                    }

                    console.log(`同分组可见角色数量: ${visibleSameGroupCharacters.length}/${sameGroupCharacters.length}`);

                    if (type === 'like') {
                        for (const character of visibleSameGroupCharacters) {
                            if (Math.random() < 0.65) { // 🔥【提升】65%概率互动
                    setTimeout(async () => {
                                    await addAILikeWithPersonality(momentId, character, moment);
                                }, Math.random() * 3000 + 1000);
                            }
                        }
                    } else if (type === 'comment') {
                        console.log('开始处理角色评论，可见角色数量:', visibleSameGroupCharacters.length);
                        for (const character of visibleSameGroupCharacters) {
                            const randomValue = Math.random();
                            const willComment = randomValue < 0.65; // 🔥【提升】65%概率评论其他同组角色
                            console.log(`${character.name} 评论概率检查: ${randomValue.toFixed(3)} < 0.65 = ${willComment}`);

                            if (willComment) {
                                setTimeout(async () => {
                                    console.log(`${character.name} 开始生成评论...`);
                                    await addAICommentWithPersonality(momentId, character, moment);
                                }, Math.random() * 5000 + 2000);
                            } else {
                                console.log(`${character.name} 因为概率未通过，不会评论`);
                            }
                        }

                        // 🔥【移除】重复的发布者回复触发 - 现在只在其他角色评论后触发

                        // 触发同分组角色间的互动
                        setTimeout(() => {
                            // 将发布者角色也加入到互动角色列表中
                            const allInteractionCharacters = [...visibleSameGroupCharacters];
                            if (publisherCharacter) {
                                allInteractionCharacters.push(publisherCharacter);
                            }
                            triggerAiToAiInteractionWithPersonality(momentId, allInteractionCharacters);
                        }, Math.random() * 8000 + 5000);
                    }
                }
            } catch (error) {
                console.error('触发AI互动失败:', error);
            }
        }

        // 获取与指定角色在同一个群聊的其他角色
        function getCharactersInSameGroups(characterId) {
            const sameGroupCharacters = [];

            // 遍历所有群聊
            groupChats.forEach(group => {
                if (group.members && group.members.includes(characterId)) {
                    // 找到包含该角色的群聊，获取群内其他角色
                    group.members.forEach(memberId => {
                        if (memberId !== characterId && memberId !== 'user') {
                            const character = characters.find(c => c.id === memberId);
                            if (character && !sameGroupCharacters.find(c => c.id === character.id)) {
                                sameGroupCharacters.push(character);
                            }
                        }
                    });
                }
            });

            return sameGroupCharacters;
        }

        // AI角色点赞（基于人设和记忆系统）
        async function addAILikeWithPersonality(momentId, character, moment) {
            try {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;

            // 检查是否已经点赞过
                const existingLike = await db.momentLikes
                    .where('[momentId+authorId]')
                    .equals([parseInt(momentId), character.id])
                    .first();

                if (existingLike) return;

                // 基于角色人设、记忆系统和关系决定是否点赞
                const shouldLike = await shouldCharacterLikeMomentWithMemory(character, moment);
                if (!shouldLike) {
                    console.log(`${character.name} 基于人设和记忆选择不点赞这条动态`);
                    return;
                }

            // 添加点赞记录
                await db.momentLikes.add({
                    momentId: parseInt(momentId),
                    authorId: character.id,
                characterId: character.id,
                name: character.name,
                timestamp: Date.now()
            });

            // 更新界面显示
            updateMomentLikeDisplay(momentId);

            // 🔥【修复】只有用户的动态被点赞时才显示toast和推送通知
            if (moment.authorId === 'user') {
                // 显示点赞提示
                showToast(`${character.name} 赞了你的动态`);
                // 创建推送通知
                createPushNotification(character, `赞了你的动态`, 100);
            }

            // 记录到跨应用时间线
            await recordMemoryEvent(
                [character.id],
                {
                    type: 'moments',
                    id: 'moments'
                },
                'moment_like',
                `点赞了${moment.authorId === 'user' ? '用户' : moment.nickname}的动态`
            );
            } catch (error) {
                console.error('AI点赞失败:', error);
            }
        }

        // 保留原有的点赞函数作为兼容
        async function addAILike(momentId, character, moment) {
            return await addAILikeWithPersonality(momentId, character, moment);
        }

        // 基于人设和记忆系统判断角色是否会点赞这条动态
        async function shouldCharacterLikeMomentWithMemory(character, moment) {
            try {
                // 获取角色的聊天设置和记忆
                let chatSettings = null;
                try {
                    chatSettings = await db.chatSettings.get(character.id);
                } catch (error) {
                    console.error('获取聊天设置失败:', error);
                }

                const persona = chatSettings?.aiPersona || character.prompt || character.bio || `你是${character.name}。`;

                // 获取角色与动态发布者的关系记忆
                let relationshipMemory = '';
                if (moment.characterId && moment.characterId !== 'user') {
                    // 获取与其他角色的关系记忆
                    const coreMemories = await db.coreMemories
                        .where('characterId')
                        .equals(character.id)
                        .toArray();

                    const relationMemories = coreMemories.filter(memory =>
                        memory.fact && memory.fact.includes(moment.nickname)
                    );

                    if (relationMemories.length > 0) {
                        relationshipMemory = relationMemories.map(m => m.fact).join('；');
                    }
                }

                // 基于角色人设和动态内容的判断
                const characterBio = persona.toLowerCase();
                const momentText = (moment.text || '').toLowerCase();
                const momentAuthor = moment.nickname || '用户';

                // 检查是否存在负面关系记忆
                if (relationshipMemory) {
                    const negativeKeywords = ['吵架', '争执', '讨厌', '不喜欢', '敌对', '竞争', '情敌', '冲突'];
                    const hasNegativeRelation = negativeKeywords.some(keyword =>
                        relationshipMemory.toLowerCase().includes(keyword)
                    );

                    if (hasNegativeRelation) {
                        console.log(`${character.name} 与 ${momentAuthor} 存在负面关系记忆，不会点赞`);
                        return false;
                    }
                }

                // 如果角色人设中包含负面词汇，降低点赞概率
                const negativeTraits = ['冷漠', '严肃', '不善交际', '内向', '沉默'];
                const hasNegativeTraits = negativeTraits.some(trait => characterBio.includes(trait));

                if (hasNegativeTraits && Math.random() < 0.7) {
                    return false; // 70%概率不点赞
                }

                // 如果动态内容与角色兴趣相关，增加点赞概率
                const characterInterests = extractInterestsFromBio(characterBio);
                const hasRelatedContent = characterInterests.some(interest =>
                    momentText.includes(interest)
                );

                if (hasRelatedContent) {
                    return Math.random() < 0.9; // 90%概率点赞
                }

                // 如果是用户发的动态，增加点赞概率
                if (!moment.characterId || moment.characterId === 'user') {
                    return Math.random() < 0.8; // 80%概率点赞
                }

                // 默认情况
                return Math.random() < 0.7; // 70%概率点赞
            } catch (error) {
                console.error('判断角色点赞偏好失败:', error);
                return Math.random() < 0.6; // 默认60%概率
            }
        }

        // 保留原有函数作为兼容
        async function shouldCharacterLikeMoment(character, moment) {
            return await shouldCharacterLikeMomentWithMemory(character, moment);
        }

        // 从角色人设中提取兴趣关键词
        function extractInterestsFromBio(bio) {
            const interests = [];
            const interestKeywords = [
                '音乐', '电影', '读书', '运动', '游戏', '美食', '旅行', '摄影',
                '绘画', '写作', '代码', '科技', '动漫', '小说', '咖啡', '茶',
                '宠物', '花', '星空', '雨天', '阳光', '学习', '工作', '朋友'
            ];

            interestKeywords.forEach(keyword => {
                if (bio.includes(keyword)) {
                    interests.push(keyword);
                }
            });

            return interests;
        }

        // 更新动态点赞显示
        async function updateMomentLikeDisplay(momentId) {
            try {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;

                const momentLikes = await db.momentLikes.where('momentId').equals(parseInt(momentId)).toArray();

            // 更新点赞按钮数字
            const likeBtn = momentElement.querySelector('.moment-action-btn[onclick*="toggleMomentLike"]');
            if (likeBtn) {
                const likeCount = likeBtn.querySelector('span');
                if (likeCount) {
                    likeCount.textContent = momentLikes.length;
                }
            }

            // 更新或创建点赞用户名称显示
            let likesDisplay = momentElement.querySelector('.likes-display');

            if (momentLikes.length > 0) {
                if (!likesDisplay) {
                    likesDisplay = document.createElement('div');
                    likesDisplay.className = 'likes-display';

                    // 检查是否已有评论区域，如果有就不设置margin-top
                        const existingCommentsSection = momentElement.querySelector('.moment-comments-section');
                        const marginTop = existingCommentsSection ? '0' : '0';

                    likesDisplay.style.cssText = `
                        margin-top: ${marginTop};
                        padding: 8px 12px;
                        background: #f8f9fa;
                        font-size: 13px;
                        color: #666;
                        line-height: 1.4;
                    `;

                        // 插入到操作按钮下面，评论区前面（如果有的话），否则在时间操作区后面
                    const momentContent = momentElement.querySelector('.moment-content');
                    const momentTimeActions = momentElement.querySelector('.moment-time-actions');
                        const commentsSection = momentElement.querySelector('.moment-comments-section');

                    if (momentContent && momentTimeActions) {
                            if (commentsSection) {
                                // 如果已有评论区，插入到评论区前面
                                momentContent.insertBefore(likesDisplay, commentsSection);
                            } else {
                                // 没有评论区，插入到时间操作区后面
                        momentTimeActions.parentNode.insertBefore(likesDisplay, momentTimeActions.nextSibling);
                            }
                    }
                }

                // 使用和用户昵称相同颜色的空心爱心
                const likeIcon = '<svg width="14" height="14" style="margin-right: 4px; vertical-align: middle;" viewBox="0 0 24 24" fill="none" stroke="#576b95" stroke-width="2"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>';
                const names = momentLikes.map(like => like.name).join('、');
                likesDisplay.innerHTML = `${likeIcon}<span style="color: #576b95; font-weight: 600;">${names}</span>`;
                likesDisplay.style.display = 'block';
            } else if (likesDisplay) {
                likesDisplay.style.display = 'none';
                }
            } catch (error) {
                console.error('更新点赞显示失败:', error);
            }
        }

        // AI角色评论（基于人设和记忆系统）
        async function addAICommentWithPersonality(momentId, character, moment) {
            try {
                // 生成符合角色人设和记忆系统的评论
                const comments = await generateCharacterCommentWithMemory(character, moment);
                if (!comments || comments.length === 0) return;

                const randomComment = comments[Math.floor(Math.random() * comments.length)];

                const comment = {
                    id: Date.now() + Math.random(),
                    nickname: character.name,
                    avatar: character.avatarUrl,
                    text: randomComment,
                    time: formatTime(new Date()),
                    timestamp: Date.now(),
                    characterId: character.id
                };

                // 保存评论
                saveCommentToMoment(momentId, comment);

                // 更新评论数
                updateMomentCommentCount(momentId);

                // 在动态下方显示新评论
                displayCommentUnderMoment(momentId, comment);

                // 🔥【修复】只有当用户发布的动态被角色评论时，才显示评论提示和发送通知
                if (moment.authorId === 'user') {
                    showToast(`${character.name} 评论了你的动态`);
                    createPushNotification(character, `评论了你的动态：${randomComment.length > 15 ? randomComment.substring(0, 15) + '...' : randomComment}`, 200);
                }

                // 记录到跨应用时间线
                await recordMemoryEvent(
                    [character.id],
                    {
                        type: 'moments',
                        id: 'moments'
                    },
                    'moment_comment',
                    `评论了${moment.authorId === 'user' ? '用户' : moment.nickname}的动态：${randomComment}`
                );

                // 🔥【新增】如果是角色评论了其他角色的动态，触发动态发布者回复
                if (moment.characterId && moment.characterId !== 'user' && moment.characterId !== character.id) {
                    const publisherCharacter = characters.find(c => c.id === moment.characterId);
                    if (publisherCharacter) {
                        console.log(`🔔 ${character.name} 评论了 ${publisherCharacter.name} 的动态，将在30-60秒后触发发布者回复`);
                        setTimeout(async () => {
                            console.log(`🔄 检查 ${publisherCharacter.name} 是否需要回复 ${character.name} 的评论...`);
                            await triggerPublisherReplyToComments(momentId, publisherCharacter);
                        }, Math.random() * 30000 + 30000); // 30-60秒后触发回复
                    }
                }
            } catch (error) {
                console.error('AI角色评论失败:', error);
            }
        }

        // 保留原有的评论函数作为兼容
        async function addAIComment(momentId, character, moment) {
            return await addAICommentWithPersonality(momentId, character, moment);
        }

        // 🔥【新增】基于人设和记忆系统的角色间互动
        async function triggerAiToAiInteractionWithPersonality(momentId, relatedCharacters) {
            try {
                // 获取动态信息
                const moment = await db.moments.get(parseInt(momentId));
                if (!moment) return;

                // 获取该动态的所有评论
                const comments = await db.momentComments
                    .where('momentId')
                    .equals(parseInt(momentId))
                    .toArray();

                if (comments.length < 2) return; // 至少需要2条评论才能触发角色间互动

                // 获取参与评论的AI角色
                const participatingAis = [...new Set(comments
                    .filter(comment => comment.characterId && comment.characterId !== 'user')
                    .map(comment => comment.characterId)
                )];

                // 过滤出只有在同群的AI角色
                const sameGroupParticipants = participatingAis.filter(aiId =>
                    relatedCharacters.some(char => char.id === aiId)
                );

                if (sameGroupParticipants.length < 2) {
                    console.log('参与评论的同群AI角色少于2个，跳过角色间互动');
                    return;
                }

                console.log(`发现 ${sameGroupParticipants.length} 个同群AI角色参与了评论，开始角色间互动`);

                // 随机选择两个同群AI进行互动
                const aiA = sameGroupParticipants[Math.floor(Math.random() * sameGroupParticipants.length)];
                let aiB = sameGroupParticipants[Math.floor(Math.random() * sameGroupParticipants.length)];

                // 确保选择不同的AI
                while (aiB === aiA && sameGroupParticipants.length > 1) {
                    aiB = sameGroupParticipants[Math.floor(Math.random() * sameGroupParticipants.length)];
                }

                if (aiA === aiB) return;

                // 获取角色信息
                const charA = characters.find(c => c.id === aiA);
                const charB = characters.find(c => c.id === aiB);

                if (!charA || !charB) return;

                // 检查角色关系和互动概率（基于记忆系统）
                const shouldInteract = await shouldCharactersInteract(charA, charB);
                if (!shouldInteract) {
                    console.log(`${charA.name} 和 ${charB.name} 基于关系记忆选择不互动`);
                    return;
                }

                // 选择一个现有评论作为互动起点
                const targetComment = comments.find(comment =>
                    comment.characterId === aiA || comment.characterId === aiB
                );

                if (!targetComment) return;

                // 决定谁先回复谁
                const responderCharId = targetComment.characterId === aiA ? aiB : aiA;
                const targetCharId = targetComment.characterId;

                // 获取角色信息
                const responderChar = characters.find(c => c.id === responderCharId);
                const targetChar = characters.find(c => c.id === targetCharId);

                if (!responderChar || !targetChar) return;

                console.log(`${responderChar.name} 将回复 ${targetChar.name} 的评论`);

                // 生成基于记忆系统的AI间互动回复
                await generateAiToAiReplyWithMemory(momentId, targetComment, responderChar, targetChar);

            } catch (error) {
                console.error('角色间互动失败:', error);
            }
        }

        // 保留原有的角色间互动函数作为兼容
        async function triggerAiToAiInteraction(momentId, relatedCharacters) {
            return await triggerAiToAiInteractionWithPersonality(momentId, relatedCharacters);
        }

        // 🔥【新增】检查两个角色是否应该互动（基于记忆系统）
        async function shouldCharactersInteract(charA, charB) {
            try {
                // 获取角色A对角色B的记忆
                const memoriesA = await db.coreMemories
                    .where('characterId')
                    .equals(charA.id)
                    .toArray();

                const relationMemoriesA = memoriesA.filter(memory =>
                    memory.fact && memory.fact.includes(charB.name)
                );

                // 获取角色B对角色A的记忆
                const memoriesB = await db.coreMemories
                    .where('characterId')
                    .equals(charB.id)
                    .toArray();

                const relationMemoriesB = memoriesB.filter(memory =>
                    memory.fact && memory.fact.includes(charA.name)
                );

                // 检查是否存在负面关系记忆
                const allRelationMemories = [...relationMemoriesA, ...relationMemoriesB];
                const negativeKeywords = ['吵架', '争执', '讨厌', '不喜欢', '敌对', '竞争', '情敌', '冲突', '矛盾'];

                const hasNegativeRelation = allRelationMemories.some(memory =>
                    negativeKeywords.some(keyword =>
                        memory.fact.toLowerCase().includes(keyword)
                    )
                );

                if (hasNegativeRelation) {
                    // 🔥【提升】如果有负面关系，60%概率互动（可能是冷嘲热讽）
                    return Math.random() < 0.6;
                }

                // 检查是否有正面关系记忆
                const positiveKeywords = ['朋友', '喜欢', '亲密', '合作', '帮助', '支持', '关心'];
                const hasPositiveRelation = allRelationMemories.some(memory =>
                    positiveKeywords.some(keyword =>
                        memory.fact.toLowerCase().includes(keyword)
                    )
                );

                if (hasPositiveRelation) {
                    // 如果有正面关系，80%概率互动
                    return Math.random() < 0.8;
                }

                // 🔥【调整】默认情况，80%概率互动（评论区保持活跃但不过度）
                return Math.random() < 0.8;

            } catch (error) {
                console.error('检查角色互动关系失败:', error);
                return Math.random() < 0.4; // 默认40%概率
            }
        }

        // AI角色间的楼中楼互动（套用完成.html逻辑）
        async function triggerAiToAiInteractionOld(momentId, relatedCharacters) {
            try {
                // 获取动态信息
                const momentsData = JSON.parse(sessionStorage.getItem('momentsData') || '[]');
                const moment = momentsData.find(m => (m.id == momentId) || (m.timestamp == momentId));
                if (!moment || !moment.comments) return;

                const comments = moment.comments;
                if (comments.length < 2) return; // 至少需要2条评论才能触发角色间互动

                // 获取在同群的参与评论AI角色
                const participatingAis = [...new Set(comments
                    .filter(comment => comment.characterId && comment.characterId !== 'user')
                    .map(comment => comment.characterId)
                )];

                // 过滤出只有在同群的AI角色
                const sameGroupParticipants = participatingAis.filter(aiId =>
                    relatedCharacters.some(char => char.id === aiId)
                );

                if (sameGroupParticipants.length < 2) {
                    console.log('参与评论的同群AI角色少于2个，跳过角色间互动');
                    return;
                }

                console.log(`发现 ${sameGroupParticipants.length} 个同群AI角色参与了评论，开始角色间互动`);

                // 随机选择两个同群AI进行互动
                const aiA = sameGroupParticipants[Math.floor(Math.random() * sameGroupParticipants.length)];
                let aiB = sameGroupParticipants[Math.floor(Math.random() * sameGroupParticipants.length)];

                // 确保选择不同的AI
                while (aiB === aiA && sameGroupParticipants.length > 1) {
                    aiB = sameGroupParticipants[Math.floor(Math.random() * sameGroupParticipants.length)];
                }

                if (aiA === aiB) return;

                // 检查角色关系和互动概率 (40%概率，保持原有设置概率)
                if (Math.random() > 0.4) {
                    console.log('基于概率选择不进行角色间互动');
                    return;
                }

                // 选择一个现有评论作为互动起点
                const targetComment = comments.find(comment =>
                    comment.characterId === aiA || comment.characterId === aiB
                );

                if (!targetComment) return;

                // 决定谁先回复谁
                const responderCharId = targetComment.characterId === aiA ? aiB : aiA;
                const targetCharId = targetComment.characterId;

                // 获取角色信息
                const responderChar = characters.find(c => c.id === responderCharId);
                const targetChar = characters.find(c => c.id === targetCharId);

                if (!responderChar || !targetChar) return;

                console.log(`${responderChar.name} 将回复 ${targetChar.name} 的评论`);

                // 生成AI间的互动回复
                await generateAiToAiReply(momentId, targetComment, responderChar, targetChar);

            } catch (error) {
                console.error('角色间互动失败:', error);
            }
        }



        // 角色之间互动（保留原函数，但不再使用）
        function triggerCharacterInteractions(momentId, characters) {
            if (characters.length < 2) return;

            // 获取已在同一群的角色关系
            const groupRelations = getGroupRelations(characters);

            for (let i = 0; i < characters.length - 1; i++) {
                for (let j = i + 1; j < characters.length; j++) {
                    const char1 = characters[i];
                    const char2 = characters[j];

                    // 检查是否在同一个群里
                    const inSameGroup = groupRelations.some(group =>
                        group.includes(char1.id) && group.includes(char2.id)
                    );

                    if (inSameGroup && Math.random() < 0.6) {
                        addCharacterInteraction(momentId, char1, char2);
                    }
                }
            }
        }

        // 获取分组关系 - 基于角色分组而不是群聊
        function getGroupRelations(characters) {
            const groups = [];

            // 按分组ID分组角色
            const groupedCharacters = {};
            characters.forEach(character => {
                const groupId = character.groupId || 'my_friends';
                if (!groupedCharacters[groupId]) {
                    groupedCharacters[groupId] = [];
                }
                groupedCharacters[groupId].push(character.id);
            });

            // 只返回可以互动的分组（非默认分组且允许互动）
            Object.entries(groupedCharacters).forEach(([groupId, characterIds]) => {
                const group = characterGroups.find(g => g.id === groupId);

                // 只有非默认分组且允许互动的分组中的角色才能相互互动
                if (group && !group.isDefault && group.canInteract && characterIds.length >= 2) {
                    groups.push(characterIds);
                }
            });

            return groups;
        }

        // 🔥【新增】生成基于记忆系统的AI间回复
        async function generateAiToAiReplyWithMemory(momentId, targetComment, responderChar, targetChar) {
            try {
                // 🔥【新增】检查角色间互动回合限制（3回合）
                const conversationKey = `${momentId}-${responderChar.name}-${targetChar.name}`;
                const currentRounds = commentConversationRounds.get(conversationKey) || 0;

                if (currentRounds >= 3) {
                    console.log(`${responderChar.name} 与 ${targetChar.name} 在动态 ${momentId} 中的互动已达到3回合上限，不再回复`);
                    return;
                }

                // 🔥【调整】80%概率进行角色间回复
                const randomValue = Math.random();
                console.log(`🎲 ${responderChar.name} 回复 ${targetChar.name} 概率检查: ${randomValue.toFixed(3)} < 0.8 = ${randomValue < 0.8}`);

                if (randomValue >= 0.8) {
                    console.log(`🚫 ${responderChar.name} 因为概率未通过，不会回复 ${targetChar.name} 的评论`);
                    return;
                }

                // 获取动态信息
                const moment = await db.moments.get(parseInt(momentId));
                if (!moment) return;

                // 获取回复者的聊天设置和记忆
                let chatSettings = null;
                try {
                    chatSettings = await db.chatSettings.get(responderChar.id);
                } catch (error) {
                    console.error('获取聊天设置失败:', error);
                }

                const persona = chatSettings?.aiPersona || responderChar.prompt || `你是${responderChar.name}。`;

                // 获取与目标角色的关系记忆
                let relationshipMemory = '';
                const coreMemories = await db.coreMemories
                    .where('characterId')
                    .equals(responderChar.id)
                    .toArray();

                const relationMemories = coreMemories.filter(memory =>
                    memory.fact && memory.fact.includes(targetChar.name)
                );

                if (relationMemories.length > 0) {
                    relationshipMemory = '\n\n你们的关系记忆：\n' + relationMemories.map(m => m.fact).join('；');
                }

                // 🔥【新增】获取评论区上下文
                let commentsContext = '';
                try {
                    const allComments = await db.momentComments
                        .where('momentId')
                        .equals(parseInt(momentId))
                        .toArray();

                    if (allComments.length > 0) {
                        // 按时间排序
                        allComments.sort((a, b) => a.timestamp - b.timestamp);

                        // 过滤可见评论
                        const visibleComments = [];
                        for (const comment of allComments) {
                            if (comment.authorId === 'user' ||
                                comment.authorId === responderChar.id ||
                                comment.authorId === targetChar.id) {
                                visibleComments.push(comment);
                                continue;
                            }

                            // 检查是否是同组角色
                            const commentAuthor = characters.find(c => c.id === comment.authorId);
                            if (commentAuthor && areCharactersInSameGroup(responderChar, commentAuthor)) {
                                visibleComments.push(comment);
                            }
                        }

                        if (visibleComments.length > 1) { // 至少有2条评论才显示上下文
                            commentsContext = '\n\n评论区讨论上下文：\n';
                            visibleComments.forEach((comment, index) => {
                                const authorName = comment.authorId === 'user' ? '用户' : comment.nickname;
                                commentsContext += `${index + 1}. ${authorName}: ${comment.text}\n`;
                            });
                        }
                    }
                } catch (error) {
                    console.error('获取评论区上下文失败:', error);
                }

                // 获取绑定的世界书内容
                let worldBookContent = '';
                if (chatSettings?.linkedWorldBookIds && chatSettings.linkedWorldBookIds.length > 0) {
                    try {
                        const worldBooks = await Promise.all(
                            chatSettings.linkedWorldBookIds.map(id => db.worldbooks.get(id))
                        );
                        const validWorldBooks = worldBooks.filter(book => book && book.content);
                        if (validWorldBooks.length > 0) {
                            worldBookContent = '\n\n世界书内容（供参考）：\n' +
                                validWorldBooks.map(book => `${book.name}：${book.content}`).join('\n\n');
                        }
                    } catch (error) {
                        console.error('获取世界书内容失败:', error);
                    }
                }

                const systemPrompt = `你是${responderChar.name}，你的人设如下：${persona}。${worldBookContent}${relationshipMemory}${commentsContext}

在一个动态的评论区，${targetChar.name} 刚刚评论了："${targetComment.text}"

原动态内容：${moment.text}

请作为${responderChar.name}，基于你的人设、与${targetChar.name}的关系记忆以及评论区的讨论上下文，对ta的评论进行回应。

## 重要提醒：
- 如果你们的关系记忆中有负面内容（如吵架、争执、情敌等），请根据你的性格决定回应方式
- 如果关系很好，可以更加亲密和随意
- 如果关系不好，可以冷淡、讽刺或直接忽略

## 回应要求：
1. 严格按照你的人设和性格特点
2. 根据你们的关系记忆调整语气和态度
3. 回复要简洁，10-25字左右
4. 可以是：赞同、反驳、调侃、询问、补充等
5. 要符合朋友圈评论的自然风格
6. 不要使用与角色性格不符的表情符号

请生成一条自然的回复：`;

                // 调用AI API生成回复
                const { base: proxyUrl, key: apiKey, model } = apiSettings;
                if (!proxyUrl || !apiKey || !model) {
                    console.log('API配置不完整，跳过AI间互动');
                    return;
                }

                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: '请回复这条评论：' }
                ];

                const requestBody = {
                    model: model,
                    messages: messages,
                    temperature: 0.8,
                    stream: false
                };

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000);

                // 检测是否是Gemini官方API
                const isGeminiOfficial = proxyUrl.includes('generativelanguage.googleapis.com');

                let response;
                if (isGeminiOfficial) {
                    // 使用Gemini官方API格式
                    const apiUrl = `${proxyUrl}/models/${model}:generateContent?key=${apiKey}`;

                    const geminiMessages = [];
                    if (requestBody.messages[0]?.role === 'system') {
                        geminiMessages.push({
                            role: 'user',
                            parts: [{ text: requestBody.messages[0].content }]
                        });
                        geminiMessages.push({
                            role: 'model',
                            parts: [{ text: '我明白了，我会按照这些要求进行回复。' }]
                        });
                    }

                    for (let i = 1; i < requestBody.messages.length; i++) {
                        const msg = requestBody.messages[i];
                        if (msg.role === 'system') continue;

                        geminiMessages.push({
                            role: msg.role === 'user' ? 'user' : 'model',
                            parts: [{ text: msg.content }]
                        });
                    }

                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiMessages,
                            generationConfig: {
                                temperature: requestBody.temperature || 0.8
                            }
                        }),
                        signal: controller.signal
                    });
                } else {
                    // 使用OpenAI格式
                    let apiUrl;
                    if (proxyUrl.endsWith('/v1')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else if (proxyUrl.includes('/v1/')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else {
                        apiUrl = `${proxyUrl}/v1/chat/completions`;
                    }

                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal
                    });
                }

                clearTimeout(timeoutId);

                if (!response.ok) {
                    console.error(`AI间互动API调用失败 (${response.status})`);
                    return;
                }

                const data = await response.json();
                let content;

                if (isGeminiOfficial) {
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                } else {
                    content = data.choices?.[0]?.message?.content || data.message || data.text || data.response || data.content || data.result;
                }

                if (content && content.trim().length > 0) {
                    const replyText = content.trim();

                    // 创建回复评论
                    const replyComment = {
                        id: Date.now() + Math.random(),
                        nickname: responderChar.name,
                        avatar: responderChar.avatarUrl,
                        text: replyText,
                        time: formatTime(new Date()),
                        timestamp: Date.now(),
                        characterId: responderChar.id,
                        replyTo: targetChar.name
                    };

                    // 保存回复
                    await saveCommentToMoment(momentId, replyComment);

                    // 更新评论数
                    await updateMomentCommentCount(momentId);

                    // 在动态下方显示新回复
                    displayCommentUnderMoment(momentId, replyComment);

                    // 记录到跨应用时间线
                    await recordMemoryEvent(
                        [responderChar.id],
                        {
                            type: 'moments',
                            id: 'moments'
                        },
                        'ai_to_ai_reply',
                        `回复了${targetChar.name}的评论：${replyText}`
                    );

                    // 🔥【新增】更新角色间互动回合次数
                    const conversationKey = `${momentId}-${responderChar.name}-${targetChar.name}`;
                    const currentRounds = commentConversationRounds.get(conversationKey) || 0;
                    commentConversationRounds.set(conversationKey, currentRounds + 1);
                    console.log(`${responderChar.name} 与 ${targetChar.name} 在动态 ${momentId} 中的互动回合次更新为: ${currentRounds + 1}/3`);

                    console.log(`${responderChar.name} 回复了 ${targetChar.name}：${replyText}`);
                }

            } catch (error) {
                console.error('生成AI间回复失败:', error);
            }
        }

        // 保留原有的AI间回复函数作为兼容
        async function generateAiToAiReply(momentId, targetComment, responderChar, targetChar) {
            return await generateAiToAiReplyWithMemory(momentId, targetComment, responderChar, targetChar);
        }

        // 生成AI间的回复（使用新的记忆系统）
        async function generateAiToAiReplyOld(momentId, targetComment, responderChar, targetChar) {
            try {
                // 获取动态信息
                const momentsData = JSON.parse(sessionStorage.getItem('momentsData') || '[]');
                const moment = momentsData.find(m => (m.id == momentId) || (m.timestamp == momentId));
                if (!moment) return;

                const targetPersona = targetChar.prompt || '';

                // 🔥【修复】使用新的记忆系统
                const promptText = `现在在一个动态下，${targetChar.name}（人设：${targetPersona}）刚刚评论了："${targetComment.text}"。

原动态内容：${moment.text}

你要作为${responderChar.name}，基于你的人设和与${targetChar.name}的关系，对ta的评论进行回应。要求：
1. 严格按照你的人设进行回复，不能混淆角色
2. 回复要自然、符合朋友圈评论风格
3. 可以是赞同、不同观点、补充、提问或开玩笑
4. 要体现出你和${targetChar.name}之间的互动关系
5. 回复简短有趣，符合社交媒体的特点
6. 根据你的人设选择合适的语气和用词
7. 不要使用与角色性格不符的表情符号

请回复${targetChar.name}的评论：`;

                // 🔥【新增】记录跨应用时间线事件
                await recordCrossAppEvent(
                    responderChar.id,
                    'moments',
                    'ai_to_ai_reply',
                    {
                        targetCharacter: targetChar.name,
                        originalComment: targetComment.text,
                        momentContent: moment.text
                    }
                );

                // 使用新的记忆系统
                const response = await callChatAPI(promptText, responderChar);
                const replyText = Array.isArray(response) ? response[0] : response;

                if (replyText && replyText.trim()) {
                    // 创建回复评论
                    const replyComment = {
                        id: Date.now() + Math.random(),
                        nickname: responderChar.name,
                        avatar: responderChar.avatarUrl,
                        text: replyText.trim(),
                    time: formatTime(new Date()),
                    timestamp: Date.now(),
                        replyTo: targetChar.name,
                        characterId: responderChar.id
                };

                    // 保存评论
                    saveCommentToMoment(momentId, replyComment);

                    // 更新评论数
                updateMomentCommentCount(momentId);

                    // 在动态下方显示新评论
                    displayCommentUnderMoment(momentId, replyComment);

                    showToast(`${responderChar.name} 回复了 ${targetChar.name}`);
                }

            } catch (error) {
                console.error('生成AI间回复失败:', error);
            }
        }

        // AI回复用户评论（使用新的记忆系统）
        async function triggerAIReplyToUser(momentId, aiCharacterName, userCommentText) {
            try {
                console.log(`triggerAIReplyToUser被调用: momentId=${momentId}, aiCharacterName=${aiCharacterName}, userCommentText="${userCommentText}"`);

                // 找到对应的AI角色
                const character = characters.find(c => c.name === aiCharacterName);
                if (!character) {
                    console.log(`未找到角色 ${aiCharacterName}，可用角色:`, characters.map(c => c.name));
                    return;
                }

                // 获取动态信息
                const moment = await db.moments.get(parseInt(momentId));
                if (!moment) {
                    console.log(`未找到动态 ${momentId}`);
                    return;
                }

                // 🔥【修复】使用新的记忆系统，明确要求纯文本输出
                const promptText = `在一个动态下，用户刚刚回复了你的评论："${userCommentText}"。

原动态内容：${moment.text}

请作为${character.name}，基于你的人设对用户的回复做出自然的反应。要求：
1. 严格按照你的人设进行回复，保持角色一致性
2. 回复要自然、符合朋友圈评论风格，简短有趣
3. 可以是继续讨论、表达感谢、开玩笑或者分享更多想法
4. 体现出你和用户之间的友好互动
5. 根据你的人设选择合适的语气和用词
6. 不要使用与角色性格不符的表情符号

🚨 **重要格式要求**：
- 直接输出你的回复文本，不要使用JSON格式
- 不要包含任何特殊标记或格式符号
- 只输出你想说的话，10-30字左右

请回复用户的评论：`;

                // 🔥【新增】记录跨应用时间线事件
                await recordCrossAppEvent(
                    character.id,
                    'moments',
                    'reply_to_user',
                    {
                        userComment: userCommentText,
                        momentContent: moment.text
                    }
                );

                // 🔍 统计动态回复的记忆使用情况
                await logMemoryUsageStats(character, 'moments_reply_to_user');

                // 使用新的记忆系统
                const response = await callChatAPI(promptText, character);

                // 🔥【修复】正确处理AI回复格式，避免显示JSON
                let replyText;
                if (Array.isArray(response)) {
                    const firstItem = response[0];
                    if (typeof firstItem === 'string') {
                        replyText = firstItem;
                    } else if (typeof firstItem === 'object' && firstItem.content) {
                        replyText = firstItem.content;
                    } else if (typeof firstItem === 'object' && firstItem.message) {
                        replyText = firstItem.message;
                    } else {
                        replyText = String(firstItem);
                    }
                } else {
                    replyText = response;
                }

                console.log(`找到角色 ${character.name}，准备生成回复`);

                if (replyText && replyText.trim()) {
                    // 创建AI回复评论
                    const replyComment = {
                        id: Date.now() + Math.random(),
                        nickname: character.name,
                        avatar: character.avatarUrl,
                        text: replyText.trim(),
                        time: formatTime(new Date()),
                        timestamp: Date.now(),
                        replyTo: '我', // 回复用户
                        characterId: character.id
                    };

                    // 保存评论
                    saveCommentToMoment(momentId, replyComment);

                    // 更新评论数
                    updateMomentCommentCount(momentId);

                    // 在动态下方显示新评论
                    displayCommentUnderMoment(momentId, replyComment);

                    // 🔥【修改】增加对话回合次，改为3回合限制
                    const conversationKey = `${momentId}-${character.name}`;
                    const currentRounds = commentConversationRounds.get(conversationKey) || 0;
                    commentConversationRounds.set(conversationKey, currentRounds + 1);
                    console.log(`${character.name} 在动态 ${momentId} 中的对话回合次更新为: ${currentRounds + 1}/3`);

                    showToast(`${character.name} 回复了你`);

                    // 🔥【新增】为角色回复用户评论创建推送通知
                    createPushNotification(character, `回复了你：${replyText.trim().length > 15 ? replyText.trim().substring(0, 15) + '...' : replyText.trim()}`, 200);
                }

            } catch (error) {
                console.error('AI回复用户失败:', error);
            }
        }

        // 生成符合角色人设和记忆系统的评论
        async function generateCharacterCommentWithMemory(character, moment) {
            try {
                console.log(`${character.name} 开始生成评论，动态发布者: ${moment.nickname || moment.authorId}`);
                // 获取角色对应的聊天设置
                let chatSettings = null;
                try {
                    chatSettings = await db.chatSettings.get(character.id);
                } catch (error) {
                    console.error('获取聊天设置失败:', error);
                }

                const persona = chatSettings?.aiPersona || character.prompt || `你是${character.name}。`;

                // 获取绑定的世界书内容
                let worldBookContent = '';
                if (chatSettings?.linkedWorldBookIds && chatSettings.linkedWorldBookIds.length > 0) {
                    try {
                    const worldBooks = await Promise.all(
                            chatSettings.linkedWorldBookIds.map(id => db.worldbooks.get(id))
                    );
                    const validWorldBooks = worldBooks.filter(book => book && book.content);
                    if (validWorldBooks.length > 0) {
                        worldBookContent = '\n\n世界书内容（供参考）：\n' +
                            validWorldBooks.map(book => `${book.name}：${book.content}`).join('\n\n');
                    }
                    } catch (error) {
                        console.error('获取世界书内容失败:', error);
                    }
                }

                // 获取分层记忆系统内容
                let memoryContent = '';
                try {
                    // 获取核心记忆
                    const coreMemories = await db.coreMemories
                        .where('characterId')
                        .equals(character.id)
                        .toArray();

                    const recentCoreMemories = coreMemories
                        .filter(m => m.type === 'core')
                        .sort((a, b) => b.importance - a.importance)
                        .slice(0, 5);

                    if (recentCoreMemories.length > 0) {
                        memoryContent += '\n\n核心记忆（重要的长期记忆）：\n';
                        recentCoreMemories.forEach((memory, index) => {
                            memoryContent += `${index + 1}. ${memory.fact}\n`;
                        });
                    }

                    // 获取情景记忆
                    const episodicMemories = await db.episodicMemories
                        .where('characterId')
                        .equals(character.id)
                        .toArray();

                    const recentEpisodicMemories = episodicMemories
                        .sort((a, b) => b.timestamp - a.timestamp)
                        .slice(0, 3);

                    if (recentEpisodicMemories.length > 0) {
                        memoryContent += '\n\n情景记忆（最近的重要经历）：\n';
                        recentEpisodicMemories.forEach((memory, index) => {
                            memoryContent += `${index + 1}. ${memory.fact}\n`;
                        });
                    }
                } catch (error) {
                    console.error('获取记忆内容失败:', error);
                }

                // 获取工作记忆（最近的聊天记录）
                let chatContext = '';
                const characterMessages = chatMessages[character.id] || [];
                if (characterMessages.length > 0) {
                    const maxMemory = parseInt(chatSettings?.maxMemory) || 10;
                    const recentHistory = characterMessages.slice(-maxMemory);
                    chatContext = '\n\n工作记忆（最近的聊天记录）：\n' +
                        recentHistory.map(msg => {
                            if (msg.role === 'user') return `用户：${msg.content}`;
                            return `${character.name}：${msg.content}`;
                        }).join('\n');
                }

                // 分析动态内容，提取关键信息
                const momentText = moment.text || '';

                // 🔥【修复】正确获取动态发布者信息
                let momentAuthor = '用户';
                const isUserMoment = !moment.characterId || moment.characterId === 'user' || moment.authorId === 'user';

                if (!isUserMoment) {
                    // 如果是角色发布的动态，查找角色信息
                    const publisherCharacter = characters.find(c => c.id === moment.characterId || c.id === moment.authorId);
                    if (publisherCharacter) {
                        momentAuthor = publisherCharacter.name;
                    } else {
                        momentAuthor = moment.nickname || '某位朋友';
                    }
                }

                // 🔥【增强】分析角色与动态发布者的关系
                let relationshipContext = '';
                let shouldComment = true; // 默认应该评论

                // 🔥【关键修复】将关系变量定义移到外层作用域，确保在后续代码中可以访问
                let hasNegativeRelation = false;
                let hasPositiveRelation = false;
                let hasNeutralRelation = false;

                if (!isUserMoment) {
                    // 如果是其他角色发布的动态，分析关系
                    const publisherCharacter = characters.find(c => c.id === moment.characterId || c.id === moment.authorId);
                    console.log(`${character.name} 正在分析与动态发布者的关系，发布者:`, publisherCharacter?.name || '未找到');
                    if (publisherCharacter) {
                        // 🔥【重点修复】更精确的人设关系分析
                        const currentPersona = (persona || '').toLowerCase();
                        const publisherName = publisherCharacter.name.toLowerCase();

                        console.log(`🔍 分析 ${character.name} 对 ${publisherCharacter.name} 的关系:`);
                        console.log(`人设内容: ${currentPersona}`);

                        // 更精确的关系检测 - 使用更严格的匹配逻辑
                        const negativeKeywords = ['情敌', '敌人', '讨厌', '不喜欢', '竞争', '对手', '吵架', '争执', '矛盾', '仇人', '冷战', '不和', '看不惯', '警惕', '提防', '防备'];
                        const positiveKeywords = ['朋友', '好友', '闺蜜', '兄弟', '姐妹', '恋人', '喜欢', '爱', '亲密', '信任', '依赖', '关心', '在乎'];
                        const neutralKeywords = ['同学', '同事', '室友', '邻居', '认识', '同班'];

                        // 检查人设中是否在发布者名字附近出现关系词
                        const publisherIndex = currentPersona.indexOf(publisherName);
                        if (publisherIndex !== -1) {
                            // 获取发布者名字前后30个字符的上下文
                            const contextStart = Math.max(0, publisherIndex - 30);
                            const contextEnd = Math.min(currentPersona.length, publisherIndex + publisherName.length + 30);
                            const relationContext = currentPersona.substring(contextStart, contextEnd);

                            console.log(`关系上下文: ${relationContext}`);

                            hasNegativeRelation = negativeKeywords.some(keyword => relationContext.includes(keyword));
                            hasPositiveRelation = positiveKeywords.some(keyword => relationContext.includes(keyword));
                            hasNeutralRelation = neutralKeywords.some(keyword => relationContext.includes(keyword));

                            console.log(`关系分析结果: 负面=${hasNegativeRelation}, 正面=${hasPositiveRelation}, 中性=${hasNeutralRelation}`);
                        } else {
                            // 如果在人设中找不到发布者名字，则检查整个人设内容
                            console.log(`在人设中未找到发布者名字，检查整个人设内容`);
                            hasNegativeRelation = negativeKeywords.some(keyword => currentPersona.includes(keyword));
                            hasPositiveRelation = positiveKeywords.some(keyword => currentPersona.includes(keyword));
                            hasNeutralRelation = neutralKeywords.some(keyword => currentPersona.includes(keyword));

                            console.log(`全文关系分析结果: 负面=${hasNegativeRelation}, 正面=${hasPositiveRelation}, 中性=${hasNeutralRelation}`);
                        }

                        // 🔥【增强】根据不同关系类型设置不同的互动策略
                        if (hasNegativeRelation) {
                            relationshipContext = `\n\n⚠️ 重要关系提醒：根据你的人设，你与${publisherCharacter.name}存在负面关系。请根据你的性格特点决定：
1. 是否要评论（可能选择忽略或冷淡回应）
2. 如果评论，语气应该保持距离感或略带敌意
3. 不要表现得过于友好热情
4. 可以选择性地挑刺、反驳或表达不同观点`;

                            // 🔥【修复】移除重复的概率判断，因为在triggerAIInteractions中已经做过60%概率筛选
                            // shouldComment = Math.random() < 0.6; // 删除重复概率判断
                        } else if (hasPositiveRelation) {
                            relationshipContext = `\n\n💝 关系提醒：根据你的人设，你与${publisherCharacter.name}关系很好。请表现出：
1. 更加亲密和随意的语气
2. 可以开善意的玩笑或调侃
3. 表达关心和支持
4. 使用你们之间的昵称或特殊称呼`;
                            // shouldComment = Math.random() < 0.6; // 删除重复概率判断
                        } else if (hasNeutralRelation) {
                            relationshipContext = `\n\n📝 关系提醒：你与${publisherCharacter.name}是${neutralKeywords.find(k => currentPersona.includes(k))}关系。请保持：
1. 适度的礼貌和距离感
2. 不过分亲密也不冷淡
3. 符合这种关系的正常互动`;
                            // shouldComment = Math.random() < 0.6; // 删除重复概率判断
                        } else {
                            // 没有明确关系设定，保持默认行为
                            // shouldComment = Math.random() < 0.6; // 删除重复概率判断
                        }
                    }
                }

                // 如果决定不评论，直接返回空数组
                if (!shouldComment) {
                    console.log(`${character.name} 因为与${momentAuthor}的关系选择不评论这条动态`);
                    return [];
                }

                console.log(`${character.name} 决定评论这条动态，开始生成评论内容...`);

                // 🔥【新增】获取该动态的已有评论作为上下文
                let existingCommentsContext = '';
                try {
                    const existingComments = await db.momentComments
                        .where('momentId')
                        .equals(moment.id)
                        .toArray();

                    if (existingComments.length > 0) {
                        // 按时间排序
                        existingComments.sort((a, b) => a.timestamp - b.timestamp);

                        // 🔥【新增】过滤角色可见的评论（基于分组关系）
                        const visibleComments = [];
                        for (const comment of existingComments) {
                            // 用户的评论总是可见
                            if (comment.authorId === 'user') {
                                visibleComments.push(comment);
                                continue;
                            }

                            // 角色自己的评论总是可见
                            if (comment.authorId === character.id) {
                                visibleComments.push(comment);
                                continue;
                            }

                            // 检查评论者是否与当前角色在同一分组
                            if (comment.authorId) {
                                const commentAuthor = characters.find(c => c.id === comment.authorId);
                                if (commentAuthor && areCharactersInSameGroup(character, commentAuthor)) {
                                    visibleComments.push(comment);
                                }
                            }
                        }

                        if (visibleComments.length > 0) {
                            existingCommentsContext = '\n\n📝 **评论区现有讨论**：\n';
                            visibleComments.forEach((comment, index) => {
                                const authorName = comment.authorId === 'user' ? '用户' : comment.nickname;
                                existingCommentsContext += `${index + 1}. ${authorName}: ${comment.text}\n`;
                            });
                            existingCommentsContext += '\n💡 请基于以上讨论内容，发表你的观点或回应。可以：\n- 回应某个具体观点\n- 补充新的角度\n- 表达不同意见\n- 或者提出新话题\n';
                        }
                    }
                } catch (error) {
                    console.error('获取已有评论失败:', error);
                }

                // 判断评论的类型和风格
                let commentStyle = '';
                const bio = (character.bio || '').toLowerCase();

                if (bio.includes('活泼') || bio.includes('开朗') || bio.includes('外向')) {
                    commentStyle = '热情活泼，用词轻松有趣';
                } else if (bio.includes('冷静') || bio.includes('理性') || bio.includes('严谨')) {
                    commentStyle = '理性客观，表达简洁';
                } else if (bio.includes('温柔') || bio.includes('善良') || bio.includes('体贴')) {
                    commentStyle = '温暖关怀，语气柔和';
                } else if (bio.includes('幽默') || bio.includes('搞笑') || bio.includes('风趣')) {
                    commentStyle = '幽默风趣，善于调侃';
                } else if (bio.includes('内向') || bio.includes('安静') || bio.includes('害羞')) {
                    commentStyle = '简洁含蓄，不多话但真诚';
                } else {
                    commentStyle = '自然真实，符合性格';
                }

                let systemPrompt = `你是${character.name}，你的人设如下：${persona}。${worldBookContent}${memoryContent}${chatContext}${relationshipContext}${existingCommentsContext}

🎯 **当前情况分析**：
- 动态发布者：${momentAuthor}
- 动态内容："${momentText}"
- 你与${momentAuthor}的关系：${hasNegativeRelation ? '负面关系（情敌/敌对）' : hasPositiveRelation ? '正面关系（朋友/亲密）' : hasNeutralRelation ? '中性关系（同学/同事）' : '关系不明确'}

请作为${character.name}，基于你的人设、记忆、与发布者的关系以及评论区的现有讨论，对这条动态发表评论。

## 🚨 关键行为准则：
1. **人设第一**：严格按照你的人设行事，绝不违背角色设定
2. **关系敏感**：特别注意你与${momentAuthor}的关系，这决定了你的态度和语气
3. **内容理解**：仔细分析动态内容，如果是表白、炫耀、求助等特殊内容，要有相应的反应
4. **情绪一致**：你的评论情绪要与你对这个人的真实感受一致

## 🎭 角色表现要求：
- 如果你们是情敌或有矛盾：表现出警惕、冷淡、甚至略带敌意的态度
- 如果你们是好朋友：表现出关心、支持、亲密的态度
- 如果关系一般：保持礼貌但不过分热情
- 如果你不了解这个人：可以表现出好奇或保持距离

## 评论风格要求：
- ${commentStyle}
- 10-30字左右，简洁有力
- 要体现出你的真实反应和情感
- 可以是：赞美认同、善意调侃、关心询问、分享感受、提出建议等
- 如果与发布者关系不好，可以选择不评论或冷淡回应

## 角色表达要求：
1. 严格按照你的人设和性格特点
2. 用词要符合你的身份和说话习惯
3. 表达要自然，不要过于刻意
4. 根据你们的关系历史调整语气和亲密度
5. 根据动态内容选择合适的回应角度
6. 避免使用与角色性格不符的表情符号
7. 不要生硬地重复动态内容，要有自己的观点
8. 如果记忆中有相关经历，可以自然地提及

## 互动关系：
- 如果是用户发的动态：以朋友身份温馨互动
- 如果是其他角色发的动态：严格基于你们的关系记忆和人设互动

请生成一条自然、有个性、贴合你人设和关系的评论：`;

                // 🔥【调试】输出朋友圈评论生成的完整prompt
                console.log(`🔥 [朋友圈评论生成] ${character.name} 的完整Prompt:`);
                console.log('='.repeat(80));
                console.log(systemPrompt);
                console.log('='.repeat(80));

                // 构建用户消息，检查是否有图片需要识别
                let postDescription = `原动态：${momentText}`;
                let hasImages = moment.images && moment.images.length > 0;

                if (hasImages) {
                    postDescription += `\n[该动态包含${moment.images.length}张图片]`;
                }

                const userMsg = `${postDescription}\n请发表你的看法：`;

                // 检查当前模型是否支持视觉识别
                const supportsVision = isVisionModelSupported();
                let messages;

                if (hasImages && supportsVision) {
                    // 使用多模态消息格式，包含图片
                    const firstImage = moment.images[0]; // 使用第一张图片
                    console.log(`为角色 ${character.name} 使用图片识别功能评论动态`);

                    messages = [
                        { role: 'system', content: systemPrompt },
                        {
                            role: 'user',
                            content: [
                                { type: 'text', text: `原动态文字：${momentText}\n\n这条动态还包含了一张图片，请仔细观察图片内容，然后发表你的看法：` },
                                { type: 'image_url', image_url: { url: firstImage } }
                            ]
                        }
                    ];
                } else {
                    // 普通文本消息
                    if (hasImages && !supportsVision) {
                        console.log(`当前模型不支持图片识别，${character.name} 将基于文字内容评论`);
                        // 修改提示，让AI知道有图片但无法看到
                        const textOnlyMsg = `${postDescription}\n\n注意：这条动态包含图片，但由于当前模型限制，你无法看到图片内容。请基于文字部分发表你的看法，可以适当询问图片相关内容。`;
                        messages = [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: textOnlyMsg }
                        ];
                    } else {
                        // 纯文字动态
                        messages = [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: userMsg }
                        ];
                    }
                }

                // 使用完整的API调用逻辑（与聊天相同）
                const { base: proxyUrl, key: apiKey, model } = apiSettings;
                if (!proxyUrl || !apiKey || !model) {
                    console.log('API配置不完整，跳过AI评论');
                    return [];
                }

                const requestBody = {
                    model: model,
                    messages: messages,
                    temperature: 0.8,
                    stream: false
                };

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000);

                // 检测是否是Gemini官方API
                const isGeminiOfficial = proxyUrl.includes('generativelanguage.googleapis.com');

                let response;
                if (isGeminiOfficial) {
                    // 使用Gemini官方API格式
                    const apiUrl = `${proxyUrl}/models/${model}:generateContent?key=${apiKey}`;

                    // 转换消息格式为Gemini格式
                    const geminiMessages = [];

                    // 添加系统提示词作为第一条用户消息
                    if (requestBody.messages[0]?.role === 'system') {
                        geminiMessages.push({
                            role: 'user',
                            parts: [{ text: requestBody.messages[0].content }]
                        });
                        geminiMessages.push({
                            role: 'model',
                            parts: [{ text: '我明白了，我会按照这些要求进行对话。' }]
                        });
                    }

                    // 转换其他消息
                    for (let i = 1; i < requestBody.messages.length; i++) {
                        const msg = requestBody.messages[i];
                        if (msg.role === 'system') continue;

                        // 处理多模态内容（包含图片）
                        if (Array.isArray(msg.content)) {
                            const parts = [];
                            msg.content.forEach(item => {
                                if (item.type === 'text') {
                                    parts.push({ text: item.text });
                                } else if (item.type === 'image_url') {
                                    // 处理图片，需要转换格式
                                    const imageUrl = item.image_url.url;
                                    if (imageUrl.startsWith('data:')) {
                                        // Base64图片
                                        const [mimeInfo, base64Data] = imageUrl.split(',');
                                        const mimeType = mimeInfo.match(/data:([^;]+)/)?.[1] || 'image/jpeg';
                                        parts.push({
                                            inline_data: {
                                                mime_type: mimeType,
                                                data: base64Data
                                            }
                                        });
                                    } else {
                                        // URL图片，Gemini可能不支持，添加文本说明
                                        parts.push({ text: '[图片：' + imageUrl + ']' });
                                    }
                                }
                            });
                            geminiMessages.push({
                                role: msg.role === 'user' ? 'user' : 'model',
                                parts: parts
                            });
                        } else {
                            // 文本消息
                            geminiMessages.push({
                                role: msg.role === 'user' ? 'user' : 'model',
                                parts: [{ text: msg.content }]
                            });
                        }
                    }

                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiMessages,
                            generationConfig: {
                                temperature: requestBody.temperature || 0.8
                            }
                        }),
                        signal: controller.signal
                    });
                } else {
                    // 使用OpenAI格式
                    // 智能处理URL拼接
                    let apiUrl;
                    if (proxyUrl.endsWith('/v1')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else if (proxyUrl.includes('/v1/')) {
                        // 如果URL中已经包含/v1/路径，直接添加chat/completions
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else {
                        apiUrl = `${proxyUrl}/v1/chat/completions`;
                    }

                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal
                    });
                }

                clearTimeout(timeoutId);

                if (!response.ok) {
                    let errorText = await response.text();
                    console.error(`API调用失败 (${response.status}): ${errorText}`);
                    return [];
                }

                const data = await response.json();
                let content;

                if (isGeminiOfficial) {
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!content) {
                        console.log('Gemini API 响应数据:', data);
                        return [];
                    }
                } else {
                    // 解析OpenAI格式响应
                    if (data.choices && data.choices.length > 0 && data.choices[0].message) {
                        content = data.choices[0].message.content;
                    } else if (data.message) {
                        content = data.message;
                    } else if (data.text) {
                        content = data.text;
                    } else if (data.response) {
                        content = data.response;
                    } else if (data.content) {
                        content = data.content;
                    } else if (data.result) {
                        content = data.result;
                    } else {
                        // 尝试查找第一个字符串类型的值
                        for (const key in data) {
                            if (typeof data[key] === 'string' && data[key].trim()) {
                                content = data[key];
                                console.log(`AI评论API使用字段 "${key}" 作为响应内容`);
                                break;
                            }
                        }
                    }

                    if (!content) {
                        console.error('AI评论API无法解析响应，完整响应数据:', data);
                        return [];
                    }
                }

                if (content && content.trim().length > 0) {
                    return [content.trim()];
                }

                return [];

            } catch (error) {
                console.error('生成AI评论失败:', error);
                return [];
            }
        }

        // 保留原有的评论生成函数作为兼容
        async function generateCharacterComment(character, moment) {
            return await generateCharacterCommentWithMemory(character, moment);
        }


        // 🔥【新增】防重复回复的全局Map
        const publisherReplyProcessing = new Map();

        // 🔥【新增】发布者角色回复评论的逻辑
        async function triggerPublisherReplyToComments(momentId, publisherCharacter) {
            try {
                if (!publisherCharacter) return;

                // 🔥【修复】确保momentId是正确的数字类型
                const numericMomentId = typeof momentId === 'string' ? parseInt(momentId) : momentId;

                // 🔥【新增】防重复处理机制
                const processingKey = `${numericMomentId}-${publisherCharacter.id}`;
                if (publisherReplyProcessing.has(processingKey)) {
                    console.log(`⏭️ ${publisherCharacter.name} 对动态 ${numericMomentId} 的回复正在处理中，跳过重复调用`);
                    return;
                }

                // 标记为正在处理
                publisherReplyProcessing.set(processingKey, true);
                console.log(`🔍 查询动态 ${numericMomentId} 的评论...`);

                // 获取该动态的所有评论
                const comments = await db.momentComments
                    .where('momentId')
                    .equals(numericMomentId)
                    .toArray();

                if (comments.length === 0) {
                    publisherReplyProcessing.delete(processingKey);
                    return;
                }

                console.log(`🔍 检查动态 ${momentId} 的评论，发布者: ${publisherCharacter.name} (ID: ${publisherCharacter.id})`);
                console.log(`📝 找到 ${comments.length} 条评论:`, comments.map(c => `${c.nickname} (authorId: ${c.authorId})`));

                // 🔥【修复】过滤出其他角色的评论（不包括发布者自己的评论和用户评论）
                const otherCharacterComments = comments.filter(comment => {
                    const isNotPublisher = comment.authorId !== publisherCharacter.id;
                    const isNotUser = comment.authorId !== 'user';
                    const isAICharacter = comment.authorId && comment.authorId !== 'user';

                    console.log(`📋 评论筛选: ${comment.nickname} - authorId: ${comment.authorId}, 不是发布者: ${isNotPublisher}, 不是用户: ${isNotUser}, 是AI角色: ${isAICharacter}`);

                    return isNotPublisher && isNotUser && isAICharacter;
                });

                // 🔥【新增】过滤掉已经被回复过的评论
                const unrepliedComments = otherCharacterComments.filter(comment => {
                    // 检查是否已经有发布者回复这条评论
                    const hasReply = comments.some(reply =>
                        reply.authorId === publisherCharacter.id &&
                        reply.replyTo === comment.nickname
                    );

                    if (hasReply) {
                        console.log(`⏭️ ${comment.nickname} 的评论已被 ${publisherCharacter.name} 回复过，跳过`);
                    }

                    return !hasReply;
                });

                console.log(`✅ 筛选后的其他角色评论数量: ${otherCharacterComments.length}`);
                console.log(`✅ 未回复的评论数量: ${unrepliedComments.length}`);
                if (unrepliedComments.length === 0) {
                    console.log(`❌ 没有未回复的其他角色评论，${publisherCharacter.name} 无需回复`);
                    publisherReplyProcessing.delete(processingKey);
                    return;
                }

                // 🔥【提升】90%概率回复其他角色评论
                const randomValue = Math.random();
                console.log(`🎲 回复概率检查: ${randomValue.toFixed(3)} < 0.9 = ${randomValue < 0.9} (未回复评论数: ${unrepliedComments.length})`);

                if (randomValue < 0.9) {
                    const randomComment = unrepliedComments[Math.floor(Math.random() * unrepliedComments.length)];
                    console.log(`🎯 ${publisherCharacter.name} 选择回复 ${randomComment.nickname} 的评论: "${randomComment.text}"`);

                    // 生成回复
                    const replyText = await generatePublisherReply(publisherCharacter, randomComment, numericMomentId);
                    if (replyText) {
                        const reply = {
                            id: Date.now() + Math.random(),
                            nickname: publisherCharacter.name,
                            avatar: publisherCharacter.avatarUrl,
                            text: replyText,
                            time: formatTime(new Date()),
                            timestamp: Date.now(),
                            characterId: publisherCharacter.id,
                            replyTo: randomComment.nickname
                        };

                        // 保存回复
                        await saveCommentToMoment(numericMomentId, reply);

                        // 更新评论数
                        await updateMomentCommentCount(numericMomentId);

                        // 在动态下方显示新回复
                        displayCommentUnderMoment(numericMomentId, reply);

                        console.log(`✅ ${publisherCharacter.name} 成功回复了 ${randomComment.nickname} 的评论: "${replyText}"`);

                        // 🔥【新增】记录跨应用时间线事件
                        await recordCrossAppEvent(
                            publisherCharacter.id,
                            'moments',
                            'ai_to_ai_reply',
                            {
                                repliedTo: randomComment.nickname,
                                replyContent: replyText,
                                originalComment: randomComment.text
                            }
                        );

                        // 🔥【修复】触发被回复角色的再次回复，实现多轮互动
                        const repliedCharacter = characters.find(c => c.name === randomComment.nickname);
                        if (repliedCharacter && repliedCharacter.id !== publisherCharacter.id) {
                            console.log(`🔄 ${publisherCharacter.name} 回复了 ${repliedCharacter.name}，将在30-60秒后触发 ${repliedCharacter.name} 的再次回复`);
                            setTimeout(async () => {
                                console.log(`🔄 检查 ${repliedCharacter.name} 是否需要回复 ${publisherCharacter.name} 的回复...`);
                                await generateAiToAiReplyWithMemory(numericMomentId, reply, repliedCharacter, publisherCharacter);
                            }, Math.random() * 30000 + 30000); // 30-60秒后触发回复
                        }
                    } else {
                        console.log(`❌ ${publisherCharacter.name} 生成回复失败`);
                    }
                } else {
                    console.log(`🚫 ${publisherCharacter.name} 因为概率未通过，不会回复其他角色的评论`);
                }
            } catch (error) {
                console.error('发布者回复评论失败:', error);
            } finally {
                // 🔥【新增】清除处理标记
                const processingKey = `${typeof momentId === 'string' ? parseInt(momentId) : momentId}-${publisherCharacter?.id}`;
                publisherReplyProcessing.delete(processingKey);
                console.log(`🧹 清除处理标记: ${processingKey}`);
            }
        }

        // 🔥【新增】生成发布者对评论的回复
        async function generatePublisherReply(publisherCharacter, originalComment, momentId) {
            try {
                // 获取动态信息
                const moment = await db.moments.get(parseInt(momentId));
                if (!moment) return '';

                // 获取角色的聊天设置和记忆
                let chatSettings = null;
                try {
                    chatSettings = await db.chatSettings.get(publisherCharacter.id);
                } catch (error) {
                    console.error('获取聊天设置失败:', error);
                }

                const persona = chatSettings?.aiPersona || publisherCharacter.prompt || `你是${publisherCharacter.name}。`;

                // 获取与评论者的关系记忆
                let relationshipMemory = '';
                const coreMemories = await db.coreMemories
                    .where('characterId')
                    .equals(publisherCharacter.id)
                    .toArray();

                const relationMemories = coreMemories.filter(memory =>
                    memory.fact && memory.fact.includes(originalComment.nickname)
                );

                if (relationMemories.length > 0) {
                    relationshipMemory = '\n\n你们的关系记忆：\n' + relationMemories.map(m => m.fact).join('；');
                }

                // 🔥【新增】获取评论区上下文
                let commentsContext = '';
                try {
                    const allComments = await db.momentComments
                        .where('momentId')
                        .equals(parseInt(momentId))
                        .toArray();

                    if (allComments.length > 1) { // 至少有2条评论才显示上下文
                        // 按时间排序
                        allComments.sort((a, b) => a.timestamp - b.timestamp);

                        // 过滤可见评论（发布者可以看到所有评论）
                        commentsContext = '\n\n评论区讨论情况：\n';
                        allComments.forEach((comment, index) => {
                            const authorName = comment.authorId === 'user' ? '用户' : comment.nickname;
                            commentsContext += `${index + 1}. ${authorName}: ${comment.text}\n`;
                        });
                    }
                } catch (error) {
                    console.error('获取评论区上下文失败:', error);
                }

                const systemPrompt = `你是${publisherCharacter.name}，你的人设如下：${persona}。${relationshipMemory}${commentsContext}

你刚刚发布了一条动态："${moment.text}"

${originalComment.nickname} 评论说："${originalComment.text}"

请作为动态的发布者，基于评论区的讨论情况和你与评论者的关系，对这条评论进行回复。

## 回复要求：
1. 回复要符合你的人设和性格
2. 根据你与评论者的关系调整语气（如果记忆中有负面关系，可以冷淡或不回复）
3. 回复要简洁，10-20字左右
4. 可以是：感谢、回应、调侃、询问等
5. 要体现出作为动态发布者的身份
6. 可以考虑评论区的整体讨论氛围

请生成一条自然的回复：`;

                // 调用AI API生成回复
                const { base: proxyUrl, key: apiKey, model } = apiSettings;
                if (!proxyUrl || !apiKey || !model) {
                    console.log('API配置不完整，跳过发布者回复');
                    return '';
                }

                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: '请回复这条评论：' }
                ];

                const requestBody = {
                    model: model,
                    messages: messages,
                    temperature: 0.8,
                    stream: false
                };

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000);

                // 检测是否是Gemini官方API
                const isGeminiOfficial = proxyUrl.includes('generativelanguage.googleapis.com');

                let response;
                if (isGeminiOfficial) {
                    // 使用Gemini官方API格式
                    const apiUrl = `${proxyUrl}/models/${model}:generateContent?key=${apiKey}`;

                    const geminiMessages = [];
                    if (requestBody.messages[0]?.role === 'system') {
                        geminiMessages.push({
                            role: 'user',
                            parts: [{ text: requestBody.messages[0].content }]
                        });
                        geminiMessages.push({
                            role: 'model',
                            parts: [{ text: '我明白了，我会按照这些要求进行回复。' }]
                        });
                    }

                    for (let i = 1; i < requestBody.messages.length; i++) {
                        const msg = requestBody.messages[i];
                        if (msg.role === 'system') continue;

                        geminiMessages.push({
                            role: msg.role === 'user' ? 'user' : 'model',
                            parts: [{ text: msg.content }]
                        });
                    }

                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiMessages,
                            generationConfig: {
                                temperature: requestBody.temperature || 0.8
                            }
                        }),
                        signal: controller.signal
                    });
                } else {
                    // 使用OpenAI格式
                    let apiUrl;
                    if (proxyUrl.endsWith('/v1')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else if (proxyUrl.includes('/v1/')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else {
                        apiUrl = `${proxyUrl}/v1/chat/completions`;
                    }

                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal
                    });
                }

                clearTimeout(timeoutId);

                if (!response.ok) {
                    console.error(`发布者回复API调用失败 (${response.status})`);
                    return '';
                }

                const data = await response.json();
                let content;

                if (isGeminiOfficial) {
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                } else {
                    content = data.choices?.[0]?.message?.content || data.message || data.text || data.response || data.content || data.result;
                }

                if (content && content.trim().length > 0) {
                    return content.trim();
                }

                return '';

            } catch (error) {
                console.error('生成发布者回复失败:', error);
                return '';
            }
        }

        // 生成角色间互动评论 - 使用完整的AI聊天逻辑
        async function generateCharacterInteraction(char1, char2, momentId) {
            try {
                // 获取动态和之前的评论上下文
                const momentsData = JSON.parse(sessionStorage.getItem('momentsData') || '[]');
                const moment = momentsData.find(m => (m.id == momentId) || (m.timestamp == momentId));
                if (!moment) return '';

                // 获取角色对应的聊天设置
                let chatSettings1 = null;
                let chatSettings2 = null;
                try {
                    chatSettings1 = await db.chatSettings.get(char1.id);
                    chatSettings2 = await db.chatSettings.get(char2.id);
                } catch (error) {
                    console.error('获取聊天设置失败:', error);
                }

                // 获取char2的最新评论作为上下文
                const char2Comments = (moment.comments || []).filter(c => c.characterId === char2.id);
                const latestChar2Comment = char2Comments[char2Comments.length - 1];

                // 构建对话上下文
                let conversationContext = `用户发布了动态：${moment.text}\n`;
                if (latestChar2Comment) {
                    conversationContext += `${char2.name}评论说：${latestChar2Comment.text}\n`;
                }

                // 使用完整的AI人设和记忆系统
                const persona1 = chatSettings1?.aiPersona || char1.prompt || `你是${char1.name}。`;

                // 获取历史聊天记录
                const maxMemory = parseInt(chatSettings1?.maxMemory) || 10;
                const char1Messages = chatMessages[char1.id] || [];
                const recentMessages = char1Messages.slice(-maxMemory);

                let chatSummary = '';
                if (recentMessages.length > 0) {
                    chatSummary = '你和用户最近的聊天记录（供参考）：\n';
                    chatSummary += recentMessages.map(msg => {
                        if (msg.role === 'user') return `用户：${msg.content}`;
                        if (msg.role === 'assistant') return `${char1.name}：${msg.content}`;
                        return '';
                    }).filter(line => line).join('\n');
                }

                // 获取挂载的世界书内容
                let worldBookContent = '';
                if (chatSettings1?.linkedWorldBookIds && chatSettings1.linkedWorldBookIds.length > 0) {
                    try {
                    const worldBooks = await Promise.all(
                            chatSettings1.linkedWorldBookIds.map(async id => {
                                try {
                                    return await db.worldbooks.get(id);
                                } catch (error) {
                                    console.error('获取世界书失败:', error);
                                    return null;
                                }
                            })
                    );
                    const validWorldBooks = worldBooks.filter(book => book && book.content);
                    if (validWorldBooks.length > 0) {
                        worldBookContent = '\n\n世界书内容（供参考）：\n' +
                            validWorldBooks.map(book => `${book.name}：${book.content}`).join('\n\n');
                    }
                    } catch (error) {
                        console.error('获取世界书内容失败:', error);
                    }
                }

                let systemPrompt = `你是${char1.name}，你的人设如下：${persona1}。${worldBookContent}${chatSummary}\n\n`;
                systemPrompt += `这是一个楼中楼讨论，请基于以下对话上下文，继续参与讨论。要符合你的人设，回复要简短有趣。`;
                if (chatSettings2?.aiPersona) {
                    systemPrompt += ` （${char2.name}的设定：${chatSettings2.aiPersona}）`;
                }
                systemPrompt += `\n\n要求：
1. 回复要符合朋友圈评论的风格，简短、自然
2. 严格按照你的人设来选择是否使用表情符号，不要使用与角色性格不符的emoji
3. 不要过于正式或客套，要像真实的朋友一样互动`;

                // 构建消息
                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: conversationContext }
                ];

                // 使用完整的API调用逻辑（与聊天相同）
                const { base: proxyUrl, key: apiKey, model } = apiSettings;
                if (!proxyUrl || !apiKey || !model) {
                    console.log('API配置不完整，跳过角色互动');
                    return '';
                }

                const requestBody = {
                    model: model,
                    messages: messages,
                    temperature: 0.8,
                    stream: false
                };

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000);

                // 检测是否是Gemini官方API
                const isGeminiOfficial = proxyUrl.includes('generativelanguage.googleapis.com');

                let response;
                if (isGeminiOfficial) {
                    // 使用Gemini官方API格式
                    const apiUrl = `${proxyUrl}/models/${model}:generateContent?key=${apiKey}`;

                    const geminiMessages = [];
                    if (requestBody.messages[0]?.role === 'system') {
                        geminiMessages.push({
                            role: 'user',
                            parts: [{ text: requestBody.messages[0].content }]
                        });
                        geminiMessages.push({
                            role: 'model',
                            parts: [{ text: '我明白了，我会按照这些要求进行对话。' }]
                        });
                    }

                    for (let i = 1; i < requestBody.messages.length; i++) {
                        const msg = requestBody.messages[i];
                        if (msg.role === 'system') continue;

                        geminiMessages.push({
                            role: msg.role === 'user' ? 'user' : 'model',
                            parts: [{ text: msg.content }]
                        });
                    }

                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiMessages,
                            generationConfig: {
                                temperature: requestBody.temperature || 0.8
                            }
                        }),
                        signal: controller.signal
                    });
                } else {
                    // 修复：智能处理URL拼接
                    let apiUrl;
                    if (proxyUrl.endsWith('/v1')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else if (proxyUrl.includes('/v1/')) {
                        // 如果URL中已经包含/v1/路径，直接添加chat/completions
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else {
                        apiUrl = `${proxyUrl}/v1/chat/completions`;
                    }

                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal
                    });
                }

                clearTimeout(timeoutId);

                if (!response.ok) {
                    let errorText = await response.text();
                    console.error(`角色互动API调用失败 (${response.status}): ${errorText}`);
                    return '';
                }

                const data = await response.json();
                let content;

                if (isGeminiOfficial) {
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!content) {
                        console.log('Gemini API 响应数据:', data);
                        return '';
                    }
                } else {
                    // 解析OpenAI格式响应
                    if (data.choices && data.choices.length > 0 && data.choices[0].message) {
                        content = data.choices[0].message.content;
                    } else if (data.message) {
                        content = data.message;
                    } else if (data.text) {
                        content = data.text;
                    } else if (data.response) {
                        content = data.response;
                    } else if (data.content) {
                        content = data.content;
                    } else if (data.result) {
                        content = data.result;
                    } else {
                        // 尝试查找第一个字符串类型的值
                        for (const key in data) {
                            if (typeof data[key] === 'string' && data[key].trim()) {
                                content = data[key];
                                console.log(`角色互动API使用字段 "${key}" 作为响应内容`);
                                break;
                            }
                        }
                    }

                    if (!content) {
                        console.error('角色互动API无法解析响应，完整响应数据:', data);
                return '';
                    }
                }

                return content ? content.trim() : '';

            } catch (error) {
                console.error('生成角色互动失败:', error);
                return '';
            }
        }



        // 长按选择功能
        function addLongPressListener(element, momentId) {
            let pressTimer = null;
            let startY = 0;
            let moved = false;

            const startPress = (e) => {
                if (isSelectionMode) return;

                startY = e.touches ? e.touches[0].clientY : e.clientY;
                moved = false;

                pressTimer = setTimeout(() => {
                    if (!moved) {
                        enterSelectionMode();
                        selectMoment(momentId);
                    }
                }, 500); // 500ms长按
            };

            const endPress = () => {
                clearTimeout(pressTimer);
                pressTimer = null;
            };

            const movePress = (e) => {
                const currentY = e.touches ? e.touches[0].clientY : e.clientY;
                if (Math.abs(currentY - startY) > 10) {
                    moved = true;
                    endPress();
                }
            };

            element.addEventListener('touchstart', startPress);
            element.addEventListener('touchend', endPress);
            element.addEventListener('touchmove', movePress);
            element.addEventListener('mousedown', startPress);
            element.addEventListener('mouseup', endPress);
            element.addEventListener('mousemove', movePress);
        }

        // 进入选择模式
        function enterSelectionMode() {
            isSelectionMode = true;
            selectedMoments.clear();

            // 显示选择模式UI
            showSelectionModeUI();

            // 添加选择框到所有动态
            const momentItems = document.querySelectorAll('.moment-item');
            momentItems.forEach(item => {
                const checkbox = document.createElement('div');
                checkbox.className = 'moment-checkbox';
                checkbox.innerHTML = '<i class="far fa-circle"></i>';
                checkbox.onclick = (e) => {
                    e.stopPropagation();
                    const momentId = item.getAttribute('data-moment-id');
                    toggleMomentSelection(momentId);
                };
                item.appendChild(checkbox);
                item.classList.add('selection-mode');
            });
        }

        // 退出选择模式
        function exitSelectionMode() {
            isSelectionMode = false;
            selectedMoments.clear();

            // 隐藏选择模式UI
            hideSelectionModeUI();

            // 移除选择框
            const checkboxes = document.querySelectorAll('.moment-checkbox');
            checkboxes.forEach(checkbox => checkbox.remove());

            const momentItems = document.querySelectorAll('.moment-item');
            momentItems.forEach(item => {
                item.classList.remove('selection-mode', 'selected');
            });
        }

        // 显示选择模式UI
        function showSelectionModeUI() {
            const selectionBar = document.createElement('div');
            selectionBar.className = 'selection-bar';
            selectionBar.innerHTML = `
                <div class="selection-actions">
                    <button class="cancel-btn" data-action="cancel">取消</button>
                    <span class="selection-count">已选择 0 条动态</span>
                    <button class="delete-btn" data-action="delete" disabled>删除</button>
                </div>
            `;

            // 🔥【修复】使用事件委托绑定点击事件，避免内联onclick问题
            selectionBar.onclick = function(e) {
                const action = e.target.dataset.action;
                if (action === 'cancel') {
                    exitSelectionMode();
                } else if (action === 'delete' && !e.target.disabled) {
                    deleteSelectedMoments();
                }
            };

            const momentsPage = document.getElementById('moments-page');
            momentsPage.insertBefore(selectionBar, momentsPage.firstChild);
        }

        // 隐藏选择模式UI
        function hideSelectionModeUI() {
            const selectionBar = document.querySelector('.selection-bar');
            if (selectionBar) {
                selectionBar.remove();
            }
        }

        // 切换动态选择状态
        function toggleMomentSelection(momentId) {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;

            const checkbox = momentElement.querySelector('.moment-checkbox i');
            if (!checkbox) return;

            if (selectedMoments.has(momentId)) {
                selectedMoments.delete(momentId);
                checkbox.className = 'far fa-circle';
                momentElement.classList.remove('selected');
            } else {
                selectedMoments.add(momentId);
                checkbox.className = 'fas fa-check-circle';
                momentElement.classList.add('selected');
            }

            updateSelectionUI();
        }

        // 选择动态
        function selectMoment(momentId) {
            if (!selectedMoments.has(momentId)) {
                toggleMomentSelection(momentId);
            }
        }

        // 更新选择UI
        function updateSelectionUI() {
            const countSpan = document.querySelector('.selection-count');
            const deleteBtn = document.querySelector('.selection-bar .delete-btn');

            if (countSpan) {
                countSpan.textContent = `已选择 ${selectedMoments.size} 条动态`;
            }

            if (deleteBtn) {
                deleteBtn.disabled = selectedMoments.size === 0;
            }
        }

        // 删除选中的动态
        async function deleteSelectedMoments() {
            if (selectedMoments.size === 0) return;

            if (!confirm(`确定要删除 ${selectedMoments.size} 条动态吗？`)) {
                return;
            }

            try {
                // 🔥【修复】从数据库中删除 - 先检查是否存在再删除
                for (const momentId of selectedMoments) {
                    try {
                        // 先查找动态是否存在
                        const moment = await db.moments.get(parseInt(momentId));
                        if (moment) {
                            // 删除动态
                            await db.moments.delete(parseInt(momentId));
                            console.log(`✓ 成功删除动态 ${momentId} (ID: ${moment.id})`);
                        } else {
                            console.warn(`⚠️ 动态 ${momentId} 不存在，可能已被删除`);
                        }

                        // 删除相关点赞（尝试不同ID格式）
                        const numericId = parseInt(momentId);
                        await db.momentLikes.where('momentId').equals(numericId).delete();
                        await db.momentLikes.where('momentId').equals(momentId).delete();

                        // 删除相关评论（尝试不同ID格式）
                        await db.momentComments.where('momentId').equals(numericId).delete();
                        await db.momentComments.where('momentId').equals(momentId).delete();

                    } catch (error) {
                        console.error(`删除动态 ${momentId} 失败:`, error);
                        throw error; // 重新抛出错误以便上层处理
                    }

                    // 清理对话回合次记录
                    for (const [key, value] of commentConversationRounds.entries()) {
                        if (key.startsWith(`${momentId}-`)) {
                            commentConversationRounds.delete(key);
                        }
                    }
            }

            // 从DOM中移除
            selectedMoments.forEach(momentId => {
                const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
                if (momentElement) {
                    momentElement.remove();
                }
            });

                // 清理可能存在的sessionStorage缓存数据
                try {
                    const sessionMomentsData = sessionStorage.getItem('momentsData');
                    if (sessionMomentsData) {
                        const momentsArray = JSON.parse(sessionMomentsData);
                        const filteredMoments = momentsArray.filter(moment =>
                            !selectedMoments.has(moment.id.toString()) &&
                            !selectedMoments.has(moment.timestamp?.toString())
                        );
                        sessionStorage.setItem('momentsData', JSON.stringify(filteredMoments));
                    }
                } catch (error) {
                    console.warn('清理sessionStorage动态数据时出错:', error);
                }

            showToast(`已删除 ${selectedMoments.size} 条动态`);

            // 退出选择模式
            exitSelectionMode();

                // 强制重新加载动态列表，确保删除生效
                setTimeout(() => {
                    loadMoments();
                }, 500);

            } catch (error) {
                console.error('删除动态失败:', error);
                showToast('删除失败，请重试');
            }
        }

        // 强制清理指定动态的所有相关数据
        async function forceCleanMoment(momentId) {
            try {
                const numericId = parseInt(momentId);
                console.log(`开始彻底清理动态: ${momentId}`);

                // 1. 从IndexedDB删除（尝试多种ID格式）
                let deleted = false;
                const possibleIds = [momentId, numericId, String(momentId), Number(momentId)];

                for (const id of possibleIds) {
                    try {
                        await db.moments.delete(id);
                        console.log(`✓ 删除动态成功，使用ID: ${id} (类型: ${typeof id})`);
                        deleted = true;
                        break;
                    } catch (error) {
                        console.log(`删除ID ${id} 失败: ${error.message}`);
                    }
                }

                if (!deleted) {
                    await db.moments.where('id').equals(momentId).delete();
                }

                // 删除相关数据（尝试不同格式）
                await db.momentLikes.where('momentId').equals(numericId).delete();
                await db.momentLikes.where('momentId').equals(momentId).delete();
                await db.momentComments.where('momentId').equals(numericId).delete();
                await db.momentComments.where('momentId').equals(momentId).delete();

                // 2. 清理对话回合次记录
                for (const [key, value] of commentConversationRounds.entries()) {
                    if (key.startsWith(`${momentId}-`)) {
                        commentConversationRounds.delete(key);
                    }
                }

                // 3. 从DOM移除
                const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
                if (momentElement) {
                    momentElement.remove();
                }

                // 4. 清理sessionStorage缓存
                const sessionMomentsData = sessionStorage.getItem('momentsData');
                if (sessionMomentsData) {
                    const momentsArray = JSON.parse(sessionMomentsData);
                    const filteredMoments = momentsArray.filter(moment =>
                        moment.id != momentId &&
                        moment.timestamp != momentId &&
                        moment.id.toString() !== momentId.toString()
                    );
                    sessionStorage.setItem('momentsData', JSON.stringify(filteredMoments));
                }

                console.log(`动态 ${momentId} 清理完成`);
                return true;
            } catch (error) {
                console.error('强制清理动态失败:', error);
                return false;
            }
        }

        // 清理所有有问题的动态（修复工具）
        async function cleanupCorruptedMoments() {
            if (!confirm('这将清理所有可能有问题的动态数据，确定继续吗？')) {
                return;
            }

            try {
                let cleanupCount = 0;

                // 获取所有动态
                const allMoments = await db.moments.toArray();

                for (const moment of allMoments) {
                    // 检查动态是否有无效的头像数据
                    if (moment.avatar && !isValidAvatarUrl(moment.avatar)) {
                        console.log(`发现无效头像的动态: ${moment.id}`);

                        // 修复头像或删除动态
                        const shouldDelete = confirm(`动态 "${moment.text?.substring(0, 30)}..." 包含无效头像数据，是否删除此动态？\n点击"取消"将修复头像数据。`);

                        if (shouldDelete) {
                            await forceCleanMoment(moment.id);
                            cleanupCount++;
                        } else {
                            // 修复头像
                            await db.moments.update(moment.id, { avatar: getDefaultAvatar() });
                        }
                    }
                }

                if (cleanupCount > 0) {
                    showToast(`已清理 ${cleanupCount} 条有问题的动态`);
                    // 重新加载动态列表
                    loadMoments();
                } else {
                    showToast('没有发现需要清理的动态');
                }

            } catch (error) {
                console.error('清理损坏动态失败:', error);
                showToast('清理失败，请重试');
            }
        }

        // 更换动态封面图片
        function changeCoverImage() {
            const input = document.createElement("input");
            input.type = "file";
            input.accept = "image/*,.jpg,.jpeg,.png,.gif,.webp";
            input.onchange = async function(e) {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedImage = await compressImage(file, 1200, 0.8);

                        const coverImage = document.getElementById("cover-image");
                        const coverPlaceholder = document.getElementById("cover-placeholder");

                        if (coverImage && coverPlaceholder) {
                            coverImage.src = compressedImage;
                            coverImage.classList.remove("hide");
                            coverPlaceholder.classList.add("hide");
                        }

                        saveMomentsImage("coverImage", compressedImage);
                        showToast("封面已更新！", "success");
                    } catch (error) {
                        console.error("处理封面图片失败:", error);
                        showToast("封面更新失败！", "error");
                    }
                }
            };
            input.click();
        }

        // 更换动态头像
        function changeAvatarImage(event) {
            event.stopPropagation();

            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*,.jpg,.jpeg,.png,.gif,.webp';
            input.onchange = async function(e) {
                const file = e.target.files[0];
                if (file) {
                    try {
                        // 压缩头像图片
                        const compressedImage = await compressImage(file, 400, 0.9);

                        const avatar = document.getElementById('moments-avatar');
                        const avatarIcon = avatar.querySelector('.moments-avatar-icon');

                        avatar.style.backgroundImage = `url(${compressedImage})`;
                        avatarIcon.style.display = 'none';

                        // 保存压缩后的图片
                        saveMomentsImage('avatarImage', compressedImage);

                        showToast('头像已更新！', 'success');
                    } catch (error) {
                        console.error('处理头像图片失败:', error);
                        showToast('头像更新失败！', 'error');
                    }
                }
            };
            input.click();
        }

        // 🔥【修复】加载动态图片设置（异步版本）
        async function loadMomentsImages() {
            try {
                // 加载封面图片
                const savedCover = await getMomentsImage('coverImage');
                if (savedCover) {
                    const coverImage = document.getElementById('cover-image');
                    const coverPlaceholder = document.getElementById('cover-placeholder');

                    if (coverImage && coverPlaceholder) {
                        coverImage.src = savedCover;
                        coverImage.classList.remove('hide');
                        coverPlaceholder.classList.add('hide');
                    }
                }

                // 加载头像图片
                const savedAvatar = await getMomentsImage('avatarImage');
                if (savedAvatar) {
                    const avatar = document.getElementById('moments-avatar');
                    const avatarIcon = avatar?.querySelector('.moments-avatar-icon');

                    if (avatar) {
                        avatar.style.backgroundImage = `url(${savedAvatar})`;
                        if (avatarIcon) {
                            avatarIcon.style.display = 'none';
                        }
                    }
                }

                // 加载用户名
                const savedUsername = await getMomentsImage('username');
                if (savedUsername) {
                    const usernameElement = document.getElementById('moments-username');
                    if (usernameElement) {
                        usernameElement.textContent = savedUsername;
                    }
                }

                console.log('动态图片加载完成');
            } catch (error) {
                console.error('加载动态图片失败:', error);
            }
        }

        // 🔥【新增】切换动态操作菜单显示
        function toggleMomentActions(momentId) {
            const popup = document.getElementById(`moment-actions-${momentId}`);
            const allPopups = document.querySelectorAll('.moment-actions-popup');

            // 隐藏所有其他弹出菜单
            allPopups.forEach(p => {
                if (p.id !== `moment-actions-${momentId}`) {
                    p.style.display = 'none';
                }
            });

            // 切换当前菜单显示状态
            if (popup.style.display === 'none' || popup.style.display === '') {
                popup.style.display = 'flex';
            } else {
                popup.style.display = 'none';
            }
        }

        // 🔥【新增】点击其他地方时隐藏所有弹出菜单
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.moment-actions')) {
                const allPopups = document.querySelectorAll('.moment-actions-popup');
                allPopups.forEach(popup => {
                    popup.style.display = 'none';
                });
            }
        });

        // 更改用户名
        function changeUsername(event) {
            event.stopPropagation();

            const currentUsername = document.getElementById('moments-username').textContent;
            const newUsername = prompt('请输入您的昵称:', currentUsername);

            if (newUsername !== null && newUsername.trim() !== '') {
                const usernameElement = document.getElementById('moments-username');
                usernameElement.textContent = newUsername.trim();

                // 保存用户名
                saveMomentsImage('username', newUsername.trim());

                showToast('昵称已更新！', 'success');
            }
        }

        // 压缩图片
        function compressImage(fileOrDataUrl, maxWidth = 800, quality = 0.8) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();

                img.onload = function() {
                    // 计算压缩后的尺寸
                    let { width, height } = img;
                    if (width > maxWidth) {
                        height = (height * maxWidth) / width;
                        width = maxWidth;
                    }

                    canvas.width = width;
                    canvas.height = height;

                    // 绘制压缩后的图片
                    ctx.drawImage(img, 0, 0, width, height);

                    // 转换为base64，降低质量以减少大小
                    const compressedData = canvas.toDataURL('image/jpeg', quality);
                    resolve(compressedData);
                };

                // 判断输入类型：File对象还是base64字符串
                if (typeof fileOrDataUrl === 'string') {
                    // 如果是base64字符串，直接使用
                    img.src = fileOrDataUrl;
                } else {
                    // 如果是File对象，创建URL
                    img.src = URL.createObjectURL(fileOrDataUrl);
                }
            });
        }

        // 🔥【修复】保存动态图片（使用IndexedDB持久化存储）
        async function saveMomentsImage(imageType, imageData) {
            try {
                // 压缩图片数据以节省存储空间
                let compressedData = imageData;
                if (imageData.startsWith('data:image/')) {
                    try {
                        compressedData = await compressImage(imageData, 800, 0.8);
                    } catch (error) {
                        console.warn('图片压缩失败，使用原图:', error);
                    }
                }

                // 保存到IndexedDB
                await db.globalSettings.put({
                    id: `moments_${imageType}`,
                    type: 'moments_setting',
                    data: compressedData
                });

                console.log(`动态图片已保存到数据库: ${imageType}`);
            } catch (error) {
                console.error('保存动态图片失败:', error);
                // 如果数据库保存失败，回退到sessionStorage
                try {
                    sessionStorage.setItem(`moments_${imageType}`, imageData);
                    console.log(`动态图片已保存到会话存储: ${imageType}`);
                } catch (sessionError) {
                    // 如果sessionStorage也满了，只在内存中保存
                    window.momentsImages = window.momentsImages || {};
                    window.momentsImages[imageType] = imageData;
                    console.log(`动态图片已保存到内存: ${imageType}`);
                }
            }
        }

        // 🔥【修复】获取动态图片（从IndexedDB获取）
        async function getMomentsImage(imageType) {
            try {
                // 先从IndexedDB获取
                const dbData = await db.globalSettings.get(`moments_${imageType}`);
                if (dbData && dbData.data) {
                    return dbData.data;
                }

                // 兼容性：从sessionStorage获取
                const sessionData = sessionStorage.getItem(`moments_${imageType}`);
                if (sessionData) {
                    // 如果从sessionStorage获取到数据，迁移到IndexedDB
                    await saveMomentsImage(imageType, sessionData);
                    return sessionData;
                }

                // 最后从内存获取
                if (window.momentsImages && window.momentsImages[imageType]) {
                    return window.momentsImages[imageType];
                }

                return null;
            } catch (error) {
                console.error('获取动态图片失败:', error);
                // 回退到sessionStorage
                try {
                    return sessionStorage.getItem(`moments_${imageType}`);
                } catch (sessionError) {
                    return null;
                }
            }
        }

        // 🔥【新增】数据完整性检查函数
        function validateDataIntegrity(data, dataType) {
            if (!data) return false;

            switch (dataType) {
                case 'characters':
                    return Array.isArray(data) && data.every(char =>
                        char && char.id && char.name &&
                        char.name !== '张三' && char.name !== '李四'
                    );
                case 'chatMessages':
                    return Array.isArray(data) && data.every(msg =>
                        msg && msg.id && msg.characterId
                    );
                case 'chatSettings':
                    return Array.isArray(data) && data.every(setting =>
                        setting && setting.id && setting.chatId
                    );
                default:
                    return Array.isArray(data) ? data.length > 0 : !!data;
            }
        }

        // 🔥【新增】安全的数据保存函数，防止数据丢失
        async function safeDataSave(tableName, data, operation = 'replace') {
            if (!data || (Array.isArray(data) && data.length === 0)) {
                console.warn(`⚠️ ${tableName} 数据为空，拒绝保存以防止数据丢失`);
                return false;
            }

            // 数据完整性检查
            if (!validateDataIntegrity(data, tableName)) {
                console.error(`❌ ${tableName} 数据完整性检查失败，拒绝保存`);
                throw new Error(`${tableName} 数据不完整或包含异常数据`);
            }

            try {
                const table = db[tableName];
                if (!table) {
                    throw new Error(`表 ${tableName} 不存在`);
                }

                // 使用事务进行原子操作
                await db.transaction('rw', table, async () => {
                    if (operation === 'replace') {
                        await table.clear();
                        if (Array.isArray(data)) {
                            await table.bulkPut(data);
                        } else {
                            await table.put(data);
                        }
                    } else if (operation === 'add') {
                        if (Array.isArray(data)) {
                            await table.bulkAdd(data);
                        } else {
                            await table.add(data);
                        }
                    }
                });

                const count = Array.isArray(data) ? data.length : 1;
                console.log(`✅ 安全保存了 ${count} 条 ${tableName} 数据`);
                return true;
            } catch (error) {
                console.error(`❌ 保存 ${tableName} 数据失败:`, error);
                throw error;
            }
        }

        // 重置数据库（如果出现schema错误）
        async function resetDatabase() {
            try {
                await db.delete();
                console.log('数据库已重置');
                location.reload(); // 重新加载页面
            } catch (error) {
                console.error('重置数据库失败:', error);
            }
        }

        // 🎮【新增】游戏跨应用记忆记录函数
        async function recordGameEvent(characterId, eventType, gameData) {
            try {
                await recordCrossAppEvent(
                    characterId,
                    'game',
                    eventType,
                    {
                        id: `game_${Date.now()}`,
                        type: 'game_session',
                        gameName: gameData.gameName,
                        action: eventType,
                        result: gameData.result,
                        score: gameData.score,
                        chatContent: gameData.chatContent,
                        timestamp: Date.now()
                    }
                );
                console.log(`🎮 已记录游戏事件: ${eventType} - ${gameData.gameName}`);
            } catch (error) {
                console.error('记录游戏事件失败:', error);
            }
        }

        // 🎮【新增】游戏聊天记录函数
        async function recordGameChat(characterId, sender, message, gameContext) {
            try {
                await recordCrossAppEvent(
                    characterId,
                    'game',
                    'game_chat',
                    {
                        id: `game_chat_${Date.now()}`,
                        type: 'game_chat',
                        sender: sender,
                        content: message,
                        gameName: gameContext.gameName,
                        gameState: gameContext.gameState,
                        timestamp: Date.now()
                    }
                );
                console.log(`🎮 已记录游戏聊天: ${sender} - ${message.substring(0, 30)}...`);
            } catch (error) {
                console.error('记录游戏聊天失败:', error);
            }
        }



        // 🎮【保留】开始游戏函数（暂时保留，后续会移到聊天工具栏）
        function startGame(gameName) {
            // 这个函数将在后续步骤中移动到聊天工具栏的游戏功能中
            alert('🎮 游戏功能已移至聊天界面\n\n请在聊天界面的工具栏中点击游戏按钮来开始游戏！');
        }

                // 切换全屏显示
        function togglePhoneBorder() {
            const phoneScreen = document.getElementById('phone-screen');
            const toggle = document.getElementById('phone-border-toggle');
            const body = document.body;

            if (toggle.checked) {
                // 开启全屏显示 - 适应浏览器屏幕
                phoneScreen.classList.add('fullscreen-mode');
                body.classList.add('fullscreen-mode');
            } else {
                // 恢复默认手机屏幕样式
                phoneScreen.classList.remove('fullscreen-mode');
                body.classList.remove('fullscreen-mode');
            }

            // 保存设置到localStorage
            localStorage.setItem('phoneBorderEnabled', toggle.checked);

            // 显示提示
            const message = toggle.checked ? '全屏显示已开启！' : '全屏显示已关闭！';
            showToast(message, 'success');
        }

        // 显示屏幕尺寸选择
        function showScreenSizeOptions() {
            showApp('screen-size-screen');
        }

        // 改变屏幕尺寸
        function changeScreenSize(width, height, name) {
            const phoneScreen = document.getElementById('phone-screen');

            // 应用新尺寸
            phoneScreen.style.width = width + 'px';
            phoneScreen.style.height = height + 'px';

            // 更新外观设置中的显示文本
            const currentSizeDesc = document.getElementById('current-screen-size');
            if (currentSizeDesc) {
                currentSizeDesc.textContent = `当前：${width}×${height} (${name})`;
            }

            // 更新选中状态
            document.querySelectorAll('.size-option .check-icon').forEach(icon => {
                icon.style.display = 'none';
            });
            document.querySelectorAll('.size-option').forEach(option => {
                option.style.backgroundColor = '';
            });

            // 显示当前选中项的勾选图标
            const currentOption = event.target.closest('.size-option');
            if (currentOption) {
                const checkIcon = currentOption.querySelector('.check-icon');
                if (checkIcon) {
                    checkIcon.style.display = 'block';
                } else {
                    // 如果没有勾选图标，创建一个
                    const newCheckIcon = document.createElement('i');
                    newCheckIcon.className = 'fas fa-check check-icon';
                    newCheckIcon.style.display = 'block';
                    currentOption.appendChild(newCheckIcon);
                }
                currentOption.style.backgroundColor = 'rgba(0, 123, 255, 0.1)';
            }

            // 保存到localStorage
            localStorage.setItem('screenSize', JSON.stringify({width, height, name}));

            // 显示提示
            showToast(`屏幕尺寸已切换为${name}！`, 'success');

            // 延迟一点再返回，让用户看到选择效果
            setTimeout(() => {
                showApp('appearance-screen');
            }, 300);
        }

        // 加载屏幕尺寸设置
        function loadScreenSize() {
            const saved = localStorage.getItem('screenSize');
            if (saved) {
                const {width, height, name} = JSON.parse(saved);
                const phoneScreen = document.getElementById('phone-screen');
                phoneScreen.style.width = width + 'px';
                phoneScreen.style.height = height + 'px';

                const currentSizeDesc = document.getElementById('current-screen-size');
                if (currentSizeDesc) {
                    currentSizeDesc.textContent = `当前：${width}×${height} (${name})`;
                }
            }
        }

        // 更新状态栏图标
        function updateStatusIcon() {
            const input = document.getElementById('status-icon-input');
            const icon = input.value.trim() || '';

            // 更新CSS变量
            document.documentElement.style.setProperty('--status-icon', `"${icon}"`);

            // 保存到本地存储
            localStorage.setItem('statusIcon', icon);
        }

        // 重置状态栏图标
        function resetStatusIcon() {
            const input = document.getElementById('status-icon-input');
            input.value = '';
            updateStatusIcon();
        }

        // 🔥【新增】切换主屏幕字体下拉菜单
        function toggleHomeFontDropdown() {
            const dropdown = document.getElementById('home-font-dropdown');
            const selector = document.querySelector('.home-font-selector');

            if (dropdown.style.display === 'none' || !dropdown.style.display) {
                dropdown.style.display = 'block';
                selector.classList.add('open');

                // 添加点击外部关闭功能
                setTimeout(() => {
                    document.addEventListener('click', closeHomeFontDropdown);
                }, 0);
            } else {
                dropdown.style.display = 'none';
                selector.classList.remove('open');
                document.removeEventListener('click', closeHomeFontDropdown);
            }
        }

        // 🔥【新增】关闭主屏幕字体下拉菜单
        function closeHomeFontDropdown(event) {
            const dropdown = document.getElementById('home-font-dropdown');
            const selector = document.querySelector('.home-font-selector');

            if (!selector.contains(event.target)) {
                dropdown.style.display = 'none';
                selector.classList.remove('open');
                document.removeEventListener('click', closeHomeFontDropdown);
            }
        }

        // 🔥【修改】选择主屏幕字体颜色
        function selectHomeFont(color) {
            // 更新body的data属性
            document.body.setAttribute('data-home-font', color);

            // 更新下拉菜单显示和选中状态
            updateHomeFontSelector(color);
            updateHomeFontDropdown(color);

            // 保存到本地存储
            localStorage.setItem('homeFontColor', color);

            // 关闭下拉菜单
            const dropdown = document.getElementById('home-font-dropdown');
            const selector = document.querySelector('.home-font-selector');
            dropdown.style.display = 'none';
            selector.classList.remove('open');
            document.removeEventListener('click', closeHomeFontDropdown);

            // 显示提示
            const colorNames = {
                'black': '黑色',
                'white': '白色'
            };
            showToast(`主屏幕字体颜色已设置为${colorNames[color]}`, 'success');
        }

        // 🔥【新增】更新主屏幕字体选择器显示
        function updateHomeFontSelector(activeColor) {
            const colorNames = {
                'black': '黑色',
                'white': '白色'
            };

            const currentText = document.getElementById('current-home-font-text');
            if (currentText) {
                currentText.textContent = colorNames[activeColor] || '黑色';
            }
        }

        // 🔥【新增】更新主屏幕字体下拉菜单选中状态
        function updateHomeFontDropdown(activeColor) {
            const options = document.querySelectorAll('.home-font-option');
            options.forEach(option => {
                option.classList.remove('selected');
                if (option.onclick.toString().includes(`'${activeColor}'`)) {
                    option.classList.add('selected');
                }
            });
        }

        // 🔥【保留兼容性】设置主屏幕字体颜色（保留旧函数名以防其他地方调用）
        function setHomeFontColor(color) {
            selectHomeFont(color);
        }

        // 🔥【废弃】更新主屏幕字体颜色按钮状态（保留以防报错，但不再使用）
        function updateHomeFontColorButtons(activeColor) {
            // 这个函数已被 updateHomeFontSelector 和 updateHomeFontDropdown 替代
            // 保留空函数以防其他地方调用时报错
        }

        // 🔥【新增】切换时钟样式下拉菜单
        function toggleClockStyleDropdown() {
            const dropdown = document.getElementById('clock-style-dropdown');
            const selector = document.querySelector('.clock-style-selector');

            if (dropdown.style.display === 'none' || !dropdown.style.display) {
                dropdown.style.display = 'block';
                selector.classList.add('open');

                // 点击其他地方关闭下拉菜单
                setTimeout(() => {
                    document.addEventListener('click', closeClockStyleDropdown);
                }, 0);
            } else {
                dropdown.style.display = 'none';
                selector.classList.remove('open');
                document.removeEventListener('click', closeClockStyleDropdown);
            }
        }

        // 🔥【新增】关闭时钟样式下拉菜单
        function closeClockStyleDropdown(event) {
            const dropdown = document.getElementById('clock-style-dropdown');
            const selector = document.querySelector('.clock-style-selector');

            if (!selector.contains(event.target)) {
                dropdown.style.display = 'none';
                selector.classList.remove('open');
                document.removeEventListener('click', closeClockStyleDropdown);
            }
        }

        // 🔥【新增】选择时钟样式
        function selectClockStyle(style) {
            // 更新body的data属性
            document.body.setAttribute('data-clock-style', style);

            // 更新选择器显示文本
            updateClockStyleSelector(style);

            // 更新下拉菜单选中状态
            updateClockStyleDropdown(style);

            // 保存到本地存储
            localStorage.setItem('clockStyle', style);

            // 关闭下拉菜单
            const dropdown = document.getElementById('clock-style-dropdown');
            const selector = document.querySelector('.clock-style-selector');
            dropdown.style.display = 'none';
            selector.classList.remove('open');
            document.removeEventListener('click', closeClockStyleDropdown);

            // 显示提示
            const styleNames = {
                'default': '默认样式',
                'bold': '粗体样式',
                'compact': '紧凑样式',
                'modern': '现代样式'
            };
            showToast(`时间日期样式已设置为${styleNames[style]}`, 'success');
        }

        // 🔥【新增】更新时钟样式选择器显示
        function updateClockStyleSelector(activeStyle) {
            const styleNames = {
                'default': '默认',
                'bold': '粗体',
                'compact': '紧凑',
                'modern': '现代'
            };

            const currentText = document.getElementById('current-clock-style-text');
            if (currentText) {
                currentText.textContent = styleNames[activeStyle] || '默认';
            }
        }

        // 🔥【新增】更新下拉菜单选中状态
        function updateClockStyleDropdown(activeStyle) {
            const options = document.querySelectorAll('.clock-style-option');
            options.forEach((option, index) => {
                const styles = ['default', 'bold', 'compact', 'modern'];
                if (styles[index] === activeStyle) {
                    option.classList.add('selected');
                } else {
                    option.classList.remove('selected');
                }
            });
        }

        // 🔥【新增】加载保存的时钟样式设置
        function loadClockStyleSetting() {
            const savedStyle = localStorage.getItem('clockStyle') || 'default';
            document.body.setAttribute('data-clock-style', savedStyle);
            updateClockStyleSelector(savedStyle);
            updateClockStyleDropdown(savedStyle);
        }

        // 🔥【修改】加载主屏幕字体颜色设置
        function loadHomeFontColorSetting() {
            const saved = localStorage.getItem('homeFontColor') || 'black'; // 默认黑色
            document.body.setAttribute('data-home-font', saved);
            updateHomeFontSelector(saved);
            updateHomeFontDropdown(saved);
        }

        // 加载状态栏图标设置
        function loadStatusIconSetting() {
            const saved = localStorage.getItem('statusIcon');
            const input = document.getElementById('status-icon-input');
            const icon = saved || '';

            if (input) {
                input.value = icon;
            }

            // 应用设置
            document.documentElement.style.setProperty('--status-icon', `"${icon}"`);
        }

        // 加载全屏显示设置
        function loadPhoneBorderSetting() {
            const saved = localStorage.getItem('phoneBorderEnabled');
            const toggle = document.getElementById('phone-border-toggle');

            // 默认关闭全屏显示
            const enabled = saved !== null ? saved === 'true' : false;

            if (toggle) {
                toggle.checked = enabled;
            }

            // 应用设置
            const phoneScreen = document.getElementById('phone-screen');
            const body = document.body;

            if (enabled) {
                // 开启全屏显示 - 适应浏览器屏幕
                phoneScreen.classList.add('fullscreen-mode');
                body.classList.add('fullscreen-mode');
            } else {
                // 恢复默认手机屏幕样式
                phoneScreen.classList.remove('fullscreen-mode');
                body.classList.remove('fullscreen-mode');
            }
        }

        // 添加Toast提示函数
        function showToast(message, type = 'info') {
            // 创建toast元素
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background-color: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 500;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                opacity: 0;
                transition: opacity 0.3s ease;
                backdrop-filter: blur(10px);
                -webkit-backdrop-filter: blur(10px);
            `;
            toast.textContent = message;

            document.body.appendChild(toast);

            // 显示toast
            setTimeout(() => {
                toast.style.opacity = '1';
            }, 10);

            // 3秒后自动隐藏
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, 3000);
        }

        // 文本截断函数
        function truncateText(text, maxLength = 50) {
    // --- 新增的安全检查 ---
    let textStr = '';
    if (typeof text === 'string') {
        textStr = text;
    } else if (text && typeof text === 'object') {
        // 如果收到了一个对象，可能是[object Object]问题的根源，
        // 我们不再让它崩溃，而是显示一个通用占位符。
        console.warn("truncateText 函数收到了一个对象，已自动处理:", text);
        return '[多媒体消息]';
    } else {
        // 对于其他意外情况 (如 null 或 undefined)，返回空字符串。
        return '';
    }
    // --- 安全检查结束 ---

    // 现在 textStr 保证是一个字符串，后续代码可以安全执行
            const plainText = textStr.replace(/<[^>]*>/g, '');
            const cleanText = plainText.replace(/\s+/g, ' ').trim();

            if (cleanText.length <= maxLength) {
                return cleanText;
            }

            return cleanText.substring(0, maxLength) + '...';
        }

        // 添加单个消息并应用动画效果
        function addMessageWithAnimation(message, characterId) {
            const messagesContainer = document.getElementById('api-chat-messages');
            if (!messagesContainer || !currentChatCharacter || characterId !== currentChatCharacter.id) return;

            // 🔥【新增】播放接收消息音效（仅对AI消息）
            if (message.sender === 'received' && !message.isUser) {
                SoundManager.play(SoundManager.TYPES.MESSAGE_RECEIVED, characterId);
            }

            const chatSettings = getCurrentChatSettings();

            // 处理系统消息
            if (message.sender === 'system') {
                // 🔥【修复】处理拉黑系统消息 - 显示为居中的系统提示
                if (message.isBlockedMessage) {
                    const centerContainer = document.createElement('div');
                    centerContainer.style.display = 'flex';
                    centerContainer.style.justifyContent = 'center';
                    centerContainer.style.margin = '4px 0';
                    centerContainer.dataset.messageId = message.id;

                    const systemContainer = document.createElement('div');
                    systemContainer.className = 'system-message';
                    systemContainer.textContent = message.content || '消息已发出，但被对方拒收了';

                    centerContainer.appendChild(systemContainer);
                    messagesContainer.appendChild(centerContainer);
                    return;
                }

                let systemElement;

                if (message.isPoke) {
                    const systemContainer = document.createElement('div');
                    systemContainer.className = 'poke-system-container';
                    const systemMessage = document.createElement('div');
                    systemMessage.className = 'poke-system-message';
                    systemMessage.textContent = message.content;
                    systemContainer.appendChild(systemMessage);
                    systemElement = systemContainer;
                } else if (message.type === 'system_notification') {
                    // 🔥【新增】处理AI选歌等系统通知
                    const centerContainer = document.createElement('div');
                    centerContainer.style.display = 'flex';
                    centerContainer.style.justifyContent = 'center';
                    centerContainer.style.margin = '4px 0';
                    centerContainer.dataset.messageId = message.id;

                    const notificationElement = document.createElement('div');
                    notificationElement.className = 'system-notification';
                    notificationElement.style.cssText = `
                        color: #999;
                        font-size: 12px;
                        padding: 4px 8px;
                        background: rgba(0,0,0,0.05);
                        border-radius: 12px;
                        max-width: 80%;
                        text-align: center;
                    `;

                    notificationElement.textContent = message.content;

                    centerContainer.appendChild(notificationElement);
                    systemElement = centerContainer;
                } else if (message.type === 'recalled_message') {
                    const centerContainer = document.createElement('div');
                    centerContainer.style.display = 'flex';
                    centerContainer.style.justifyContent = 'center';
                    centerContainer.style.margin = '4px 0';
                    centerContainer.dataset.messageId = message.id;

                    const recallElement = document.createElement('div');
                    recallElement.className = 'recalled-message';

                    const lines = message.content.split('\n');
                    const mainText = lines[0];
                    const originalText = lines[1];

                    recallElement.textContent = mainText;

                    if (originalText && originalText.startsWith('原文：')) {
                        const originalDiv = document.createElement('div');
                        originalDiv.className = 'original-text';
                        originalDiv.textContent = originalText;
                        recallElement.appendChild(originalDiv);
                    }

                    centerContainer.appendChild(recallElement);
                    systemElement = centerContainer;
                    addMessageLongPressListener(centerContainer, message.id);
                } else {
                    const centerContainer = document.createElement('div');
                    centerContainer.style.display = 'flex';
                    centerContainer.style.justifyContent = 'center';
                    centerContainer.style.margin = '4px 0';

                    const systemContainer = document.createElement('div');
                    // 🔥【美化】检查是否为好友添加成功消息，应用特殊样式
                    if (message.isFriendAddedMessage) {
                        systemContainer.className = 'friend-added-system-message';
                    } else {
                        systemContainer.className = 'system-message';
                    }
                    systemContainer.textContent = message.content;

                    centerContainer.appendChild(systemContainer);
                    systemElement = centerContainer;
                }

                // 为系统消息添加滑入动画
                systemElement.style.opacity = '0';
                systemElement.style.transform = 'translateY(20px)';

                messagesContainer.appendChild(systemElement);

                // 触发动画
                requestAnimationFrame(() => {
                    systemElement.classList.add('message-slide-in');
                });

                return;
            }

            // 创建普通消息容器
            let messageContainer = document.createElement('div');
            const isEmojiOnly = message.isEmoji && !message.content;
            messageContainer.className = `message-container ${message.sender}${chatSettings.hideAvatars ? ' no-avatar' : ''}${isEmojiOnly ? ' emoji-only' : ''}`;
            messageContainer.dataset.messageId = message.id;

            if (message.sender === 'received') {
                // ==== 群聊支持 ====
                let character = characters.find(c => c.id === characterId);
                let isGroup = false;
                let group = null;
                if (!character) {
                    group = groupChats.find(g => g.id === characterId);
                    if (group) {
                        isGroup = true;
                    }
                }

                let displayAvatar = '';
                let displayName = '';
                let color = '#4CAF50';

                if (isGroup && group) {
                    // 群聊：根据消息的senderId或name查找成员
                    let member = null;
                    console.log('🔍 [addMessageWithAnimation] 群聊消息处理 - senderId:', message.senderId, 'name:', message.name);
                    console.log('🔍 [addMessageWithAnimation] 群成员列表:', group.members);
                    console.log('🔍 [addMessageWithAnimation] 完整消息对象:', message);

                    // 🔥【调试】特别检查表情包消息
                    if (message.isEmoji) {
                        console.log('🔍 [addMessageWithAnimation-表情包] 检测到表情包消息:', {
                            senderId: message.senderId,
                            name: message.name,
                            image: message.image,
                            emojiDescription: message.emojiDescription
                        });
                    }

                    if (message.senderId) {
                        member = group.members.find(m => m.id === message.senderId);
                        console.log('🔍 [addMessageWithAnimation] 通过senderId找到成员:', member);
                    } else if (message.name) {
                        member = group.members.find(m => m.name === message.name);
                        console.log('🔍 [addMessageWithAnimation] 通过name找到成员:', member);
                    }

                    // 🔥【修复】确保群聊表情包消息正确显示发送者（addMessageWithAnimation版本）
                    if (member) {
                        displayAvatar = member.avatarUrl || '';
                        displayName = member.name;
                        color = member.color || '#4CAF50';
                    } else {
                        // 如果没找到成员，使用消息中的name作为显示名称
                        displayAvatar = '';
                        displayName = message.name || '群成员';
                        color = '#4CAF50';
                        console.warn('🔍 [addMessageWithAnimation] 未找到群成员，使用消息name:', message.name);
                    }

                    console.log('🔍 [addMessageWithAnimation] 最终头像:', displayAvatar, '显示名:', displayName);
                } else if (character) {
                    // 单聊
                    displayAvatar = chatSettings.aiChatAvatar || character.avatarUrl;
                    displayName = chatSettings.aiChatNickname || character.name;
                    color = character.color || '#4CAF50';
                } else {
                    // 兜底，防止报错
                    displayAvatar = '';
                    displayName = '未知';
                    color = '#4CAF50';
                }

                // 🔥【新增】获取气泡样式 - 群聊中使用成员专属颜色
                let bubbleColor = chatSettings.aiBubbleColor || '#f0f0f0';

                // 如果是群聊且有成员专属颜色设置，使用成员专属颜色
                if (isGroup && group && message.senderId && chatSettings.memberBubbleColors) {
                    const memberColor = chatSettings.memberBubbleColors[message.senderId];
                    if (memberColor) {
                        bubbleColor = memberColor;
                    }
                }

                const bubbleOpacity = chatSettings.aiBubbleOpacity || '1';
                const textColor = isLightColor(bubbleColor) ? '#333' : '#fff';
                const bubblePadding = chatSettings.bubblePadding || '12';

                // 处理特殊消息类型
                let messageContent = '';

                if (message.type === 'voice_message') {
                    // AI语音消息直接创建voice-message-container结构，不需要在这里创建messageContent
                    messageContent = '';
                } else if (message.type === 'user_photo') {
                    // 🔥【修复】角色发送的"伪照片" - 使用与用户相同的结构
                    const photoDesc = message.photoDescription || message.content || '角色发送的照片';
                    messageContent = `
                        <div class="dreamy-photo-container" onclick="togglePhotoText(this, '${photoDesc.replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')">
                            <div class="dreamy-photo">
                                <div class="photo-misty-bg"></div>
                                <div class="photo-badge">
                                    <i class="fas fa-image"></i>
                                </div>
                                <div class="sparkle-container">
                                    <div class="sparkle sparkle-1">✨</div>
                                    <div class="sparkle sparkle-2">⭐</div>
                                    <div class="sparkle sparkle-3">✨</div>
                                    <div class="sparkle sparkle-4">⭐</div>
                                    <div class="sparkle sparkle-5">💫</div>
                                </div>
                                <div class="photo-text-overlay" style="display: none;">
                                    <div class="photo-description">${photoDesc}</div>
                                </div>
                            </div>
                        </div>
                    `;
                } else if (message.type === 'ai_image') {
                    // AI生成的图片 - 使用星星emoji卡片样式
                    const imageDesc = message.imageDescription || message.content || 'AI描述的图片';
                    messageContent = `
                        <div class="dreamy-photo-container" onclick="togglePhotoText(this, '${imageDesc.replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')">
                            <div class="dreamy-photo">
                                <div class="photo-misty-bg"></div>
                                <div class="photo-badge">
                                    <i class="fas fa-image"></i>
                                </div>
                                <div class="sparkle-container">
                                    <div class="sparkle sparkle-1">✨</div>
                                    <div class="sparkle sparkle-2">⭐</div>
                                    <div class="sparkle sparkle-3">✨</div>
                                    <div class="sparkle sparkle-4">⭐</div>
                                    <div class="sparkle sparkle-5">💫</div>
                                </div>
                                <div class="photo-text-overlay" style="display: none;">
                                    <div class="photo-description">${imageDesc}</div>
                                </div>
                            </div>
                        </div>
                    `;
                } else if (message.type === 'location') {
                    // 🔥【修复】角色发送的位置消息 - 使用与用户相同的结构
                    const locationName = message.locationName || message.name || '未知位置';
                    messageContent = `
                        <div class="location-card" onclick="showLocationDetail('${locationName}')">
                            <div class="location-card-header">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
                                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                </svg>
                                ${locationName}
                            </div>
                            <div class="location-card-map">
                                <div class="map-background"></div>
                                <div class="map-roads">
                                    <div class="road road-horizontal" style="top: 35%; width: 100%;"></div>
                                    <div class="road road-vertical" style="left: 40%; height: 100%;"></div>
                                    <div class="road road-horizontal" style="top: 65%; width: 70%; left: 30%;"></div>
                                </div>
                                <div class="map-buildings">
                                    <div class="building" style="top: 20%; left: 10%; width: 15px; height: 15px;"></div>
                                    <div class="building" style="top: 45%; left: 60%; width: 12px; height: 12px;"></div>
                                    <div class="building" style="top: 70%; left: 15%; width: 18px; height: 18px;"></div>
                                </div>
                                <div class="map-marker" style="top: 50%; left: 50%;"></div>
                            </div>
                        </div>
                    `;
                } else if (message.type === 'transfer') {
                    // 转账消息
                    const isUser = message.role === 'user';
                    const heartIcon = isUser ? '💕' : '💖';
                    const titleText = isUser ? '你发起的转账' : '收到转账';
                    let cardClass = '';
                    let statusHtml = '';
                    let clickHandler = '';

                    if (message.status === 'accepted') {
                        statusHtml = `<div class="transfer-status">${isUser ? '对方已收款' : '已收款'}</div>`;
                        cardClass = 'accepted';
                    } else if (message.status === 'rejected') {
                        statusHtml = `<div class="transfer-status">${isUser ? '对方已退回' : '已退回'}</div>`;
                        cardClass = 'rejected';
                    } else if (!isUser) {
                        // AI发来的转账且未处理，添加点击处理
                        clickHandler = `onclick="showTransferConfirmDialog(${JSON.stringify(message).replace(/"/g, '&quot;')})"`;
                    }

                    messageContent = `
                        <div class="transfer-message-container received">
                            <div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}" ${clickHandler}>
                                <div class="transfer-title">${heartIcon} ${titleText}</div>
                                <div class="transfer-amount">¥ ${Number(message.amount).toFixed(2)}</div>
                                <div class="transfer-note">${message.note || '转账'}</div>
                                ${statusHtml}
                            </div>
                        </div>
                    `;
                } else if (message.type === 'friend_request') {
                    // 🔥【新增】AI主动发送的好友申请(第三处)
                    let actionsHtml;
                    if (message.friendRequestProcessed) {
                        // 已处理的好友申请，显示处理结果
                        const resultText = message.friendRequestAccepted ? '已同意' : '已拒绝';
                        const resultClass = message.friendRequestAccepted ? 'accepted' : 'rejected';
                        actionsHtml = `<div class="friend-request-result ${resultClass}">${resultText}</div>`;
                    } else {
                        // 未处理的好友申请，显示按钮
                        actionsHtml = `
                            <button class="friend-request-btn accept" onclick="handleAIFriendRequest('${currentChatCharacter?.id}', true, '${message.id}')">同意</button>
                            <button class="friend-request-btn reject" onclick="handleAIFriendRequest('${currentChatCharacter?.id}', false, '${message.id}')">拒绝</button>
                        `;
                    }

                    messageContent = `
                        <div class="friend-request-container">
                            <div class="friend-request-card">
                                <div class="friend-request-title">好友申请</div>
                                <div class="friend-request-message-section">
                                    <div class="friend-request-message-label">对方留言</div>
                                    <div class="friend-request-message-content">${message.message || '想和你重新做朋友'}</div>
                                </div>
                                <div class="friend-request-actions">
                                    ${actionsHtml}
                                </div>
                            </div>
                        </div>
                    `;
                } else if (message.type === 'payment_request') {
                    // AI不能发起代付请求，显示为普通消息
                    messageContent = `<div class="message-bubble">${message.content || '代付请求'}</div>`;
                } else if (message.type === 'order_confirmation') {
                    // 🛒【新增】处理AI的订单确认（第三处）
                    messageContent = generateAIOrderConfirmationContent(message);
                } else {
                    const chatMode = chatSettings.chatMode || 'online';

                    // 🔥【修复】处理多模态消息格式
                    let processedContent;
                    if (typeof message.content === 'string') {
                        processedContent = message.content;
                    } else if (Array.isArray(message.content) && message.content.length > 0) {
                        // 多模态消息格式：[{type: 'text', text: '内容'}]
                        const firstItem = message.content[0];
                        if (firstItem && firstItem.type === 'text' && firstItem.text) {
                            processedContent = firstItem.text;
                        } else {
                            processedContent = '[多媒体消息]';
                        }
                    } else if (message.content && typeof message.content === 'object') {
                        // 约定或纪念日对象
                        if (message.content.name && typeof message.content.name === 'string') {
                            if (message.content.type === 'create_appointment') {
                                processedContent = `创建了约定：${message.content.name}`;
                            } else if (message.content.type === 'create_anniversary') {
                                processedContent = `创建了纪念日：${message.content.name}`;
                            } else {
                                processedContent = `提及了：${message.content.name}`;
                            }
                        } else {
                            // 其他对象类型
                            processedContent = message.content.message || message.content.text || '[多媒体消息]';
                        }
                    } else {
                        processedContent = String(message.content || '');
                    }

                    if (chatMode === 'offline') {
                        processedContent = processOfflineContent(processedContent);
                    }

                    // 处理@内容
                    processedContent = processMentions(processedContent);

                    // 如果有引用消息，在内容前添加引用显示
                    if (message.replyTo) {
                        messageContent = generateReplyHTML(message.replyTo) + processedContent;
                    } else {
                    messageContent = processedContent;
                    }
                }

                let avatarHtml = '';
                if (!chatSettings.hideAvatars) {
                    avatarHtml = generateAvatarHtml({
                        avatarUrl: displayAvatar,
                        backgroundColor: color,
                        displayName: displayName,
                        chatSettings: chatSettings,
                        onClick: character ? `pokeCharacter('${character.id}')` : '',
                        title: character ? '戳一戳' : displayName
                    });
                }

                const transparentBubbleColor = convertColorWithOpacity(bubbleColor, bubbleOpacity);

                let bubbleHtml = '';
                if (message.type === 'transfer' || message.type === 'ai_image' || message.type === 'user_photo' || message.type === 'location' || message.type === 'voice_message' || message.type === 'friend_request' || message.type === 'payment_request') {
                    // 转账消息、AI图片消息、照片卡片、位置信息、语音消息、好友申请和代付请求不需要气泡包裹
                    bubbleHtml = messageContent;
                } else {
                    // 普通消息用气泡包裹
                    bubbleHtml = `
                    <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                        ${messageContent}
                        ${message.image && (!message.type || message.isEmoji) ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}

                    </div>
                `;
                }

          // 🔥【修复】群聊昵称显示 （第三个渲染函数版本）- 特别处理语音消息、转账消息、照片卡片和位置信息
          if (isGroup && group && displayName !== '群成员') {
    messageContainer.classList.add('group-message-item');
    const senderNameHtml = `<div class="sender-name">${displayName}</div>`;

    if (message.type === 'voice_message' || message.type === 'transfer' || message.type === 'ai_image' || message.type === 'user_photo' || message.type === 'location' || message.type === 'friend_request' || message.type === 'order_confirmation' || message.type === 'payment_request') {
        // 🔥【修复】对于语音消息、转账消息、AI图片消息、照片卡片、位置信息、好友申请、订单确认和代付请求，昵称需要在容器外部
    messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    } else {
        // 普通消息的处理（包括表情包消息）
        messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    }
} else {
                messageContainer.innerHTML = avatarHtml + bubbleHtml;
}

                // 🔥【修复】如果是语音消息，按照renderChatMessages的结构创建，但要保留群聊昵称
                if (message.type === 'voice_message') {
                    // 过滤掉括号中的描述性内容，保留实际说话内容
                    const cleanVoiceContent = message.content.replace(/\([^)]*\)\s*/g, '').trim();
                    const duration = message.duration || Math.max(1, Math.ceil(cleanVoiceContent.length / 8));
                    const durationFormatted = duration < 60 ? `0:${String(duration).padStart(2, '0')}''` : `${Math.floor(duration/60)}:${String(duration%60).padStart(2, '0')}''`;

                    const voiceMessageHTML = `
                        <div class="voice-message-container received">
                            <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                                <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${cleanVoiceContent}">
                                    <div class="voice-wave">
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                    </div>
                                    <div class="voice-duration">${durationFormatted}</div>

                                </div>
                            </div>
                            <div class="voice-text-content">${cleanVoiceContent}</div>
                        </div>
                    `;

                    // 🔥【修复】保留群聊昵称显示
                    if (isGroup && group && displayName !== '群成员') {
                        const senderNameHtml = `<div class="sender-name">${displayName}</div>`;
                        messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${voiceMessageHTML}</div>`;
                    } else {
                    messageContainer.innerHTML = avatarHtml + voiceMessageHTML;
                    }
                }
            } else {
                // 用户消息
                let myDisplayAvatar = chatSettings.myChatAvatar;

                if (!myDisplayAvatar && chatSettings.selectedIdentityId) {
                    const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                    if (selectedPersona && selectedPersona.avatarUrl) {
                        myDisplayAvatar = selectedPersona.avatarUrl;
                    }
                }

                const myBubbleColor = chatSettings.myBubbleColor || '#007AFF';
                const myBubbleOpacity = chatSettings.myBubbleOpacity || '1';
                const myTextColor = isLightColor(myBubbleColor) ? '#333' : '#fff';
                const myBubblePadding = chatSettings.bubblePadding || '12';

                const transparentMyBubbleColor = convertColorWithOpacity(myBubbleColor, myBubbleOpacity);

                let myBubbleHtml = '';
                if (message.type === 'voice') {
                    const duration = message.duration || Math.max(1, Math.ceil(message.content.length / 8));

                    myBubbleHtml = `
                        <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                            <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${message.content}">
                                <div class="voice-wave">
                                    <div class="wave-bar"></div>
                                    <div class="wave-bar"></div>
                                    <div class="wave-bar"></div>
                                    <div class="wave-bar"></div>
                                    <div class="wave-bar"></div>
                                </div>
                                <div class="voice-duration">${duration}"</div>

                            </div>
                        </div>
                    `;
                } else if (message.type === 'location') {
                    // 位置消息
                    myBubbleHtml = `
                        <div class="location-card" onclick="showLocationDetail('${message.locationName}')">
                            <div class="location-title">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
                                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                </svg>
                                ${message.locationName}
                            </div>
                            <div class="location-card-map">
                                ${generateRealisticMapHTML()}
                            </div>
                        </div>
                    `;
                } else if (message.type === 'transfer') {
                    // 用户转账消息
                    let cardClass = '';
                    let statusHtml = '';

                    if (message.status === 'accepted') {
                        statusHtml = `<div class="transfer-status">对方已收款</div>`;
                        cardClass = 'accepted';
                    } else if (message.status === 'rejected') {
                        statusHtml = `<div class="transfer-status">对方已退回</div>`;
                        cardClass = 'rejected';
                    }

                    myBubbleHtml = `
                        <div class="transfer-message-container sent">
                            <div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}">
                                <div class="transfer-title">💕 你发起的转账</div>
                                <div class="transfer-amount">¥ ${Number(message.amount).toFixed(2)}</div>
                                <div class="transfer-note">${message.note || '转账'}</div>
                                ${statusHtml}
                            </div>
                        </div>
                    `;
                } else if (message.type === 'friend_request') {
                    // 🔥【新增】用户发送的好友申请(离线模式)
                    myBubbleHtml = `
                        <div class="friend-request-container">
                            <div class="friend-request-card">
                                <div class="friend-request-title">好友申请</div>
                                <div class="friend-request-message">${message.message || '想和你重新做朋友'}</div>
                                <div class="friend-request-status">已发送</div>
                            </div>
                        </div>
                    `;
                } else if (message.type === 'order_confirmation') {
                    // 购物小票消息，直接使用内容，不包裹气泡
                    myBubbleHtml = message.content;
                } else {
                    // 🔥【修复】处理多模态消息或普通文本消息 (第三个渲染函数版本)
                    let messageContentStr = '';
                    if (Array.isArray(message.content)) {
                        // 新的多模态格式
                        const textPart = message.content.find(p => p.type === 'text');
                        const imagePart = message.content.find(p => p.type === 'image_url');

                        let baseContent = textPart?.text || '';
                        // 处理@内容
                        baseContent = processMentions(baseContent);

                        // 如果有引用消息，在内容前添加引用显示
                        if (message.replyTo) {
                            messageContentStr = generateReplyHTML(message.replyTo) + baseContent;
                        } else {
                            messageContentStr = baseContent;
                        }

                        // 如果有图片，添加图片显示
                        if (imagePart?.image_url?.url) {
                            if (messageContentStr) {
                                messageContentStr += '<br>';
                            }
                            messageContentStr += `<img src="${imagePart.image_url.url}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${imagePart.image_url.url}')">`;
                        }
                    } else {
                        // 普通文本消息或旧格式
                        let baseContent = message.content;
                        // 处理@内容
                        baseContent = processMentions(baseContent);

                        // 如果有引用消息，在内容前添加引用显示
                        if (message.replyTo) {
                            messageContentStr = generateReplyHTML(message.replyTo) + baseContent;
                        } else {
                            messageContentStr = baseContent;
                        }
                    }

                    myBubbleHtml = `
                    <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                        ${messageContentStr}
                        ${message.image && !Array.isArray(message.content) ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}
                    </div>
                `;
                }

                let myAvatarHtml = '';
                if (!chatSettings.hideAvatars) {
                    myAvatarHtml = generateAvatarHtml({
                        avatarUrl: myDisplayAvatar,
                        backgroundColor: '#007AFF',
                        displayName: '',
                        chatSettings: chatSettings
                    });
                }

                messageContainer.innerHTML = myBubbleHtml + myAvatarHtml;

                // 如果是语音消息，按照renderChatMessages的结构创建
                if (message.type === 'voice') {
                    // 创建完整的语音消息HTML，和renderChatMessages保持一致
                    const voiceMessageHTML = `
                        <div class="voice-message-container sent">
                            <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                                <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${message.content}">
                                    <div class="voice-wave">
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                    </div>
                                    <div class="voice-duration">${message.duration || Math.max(1, Math.ceil(message.content.length / 8))}"</div>

                                </div>
                            </div>
                            <div class="voice-text-content">${message.content}</div>
                        </div>
                    `;

                    messageContainer.innerHTML = voiceMessageHTML + myAvatarHtml;
                }

                // 如果是位置消息，按照renderChatMessages的结构创建
                if (message.type === 'location') {
                    // 创建完整的位置消息HTML，确保不被包装在气泡中
                    const locationMessageHTML = `
                        <div class="location-card" onclick="showLocationDetail('${message.locationName}')">
                            <div class="location-title">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
                                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                </svg>
                                ${message.locationName}
                            </div>
                            <div class="location-card-map">
                                ${generateRealisticMapHTML()}
                            </div>
                        </div>
                    `;

                    messageContainer.innerHTML = locationMessageHTML + myAvatarHtml;
                }
            }

            // 添加滑入动画效果 - 简单自然的滑入
            messageContainer.style.opacity = '0';
            messageContainer.style.transform = 'translateY(20px)';

            messagesContainer.appendChild(messageContainer);

            // 🔥【新增】为气泡戳样式添加真实的三角形元素
            addBubbleTail(messageContainer, message);

            // 触发滑入动画
            requestAnimationFrame(() => {
                messageContainer.classList.add('message-slide-in');
            });

            // 🔥【新增】检查拉黑状态并添加指示器
            addBlockedIndicatorToMessage(messageContainer, message, characterId);

            // 添加长按监听器
            addMessageLongPressListener(messageContainer, message.id);

            // 添加右键菜单功能
            const bubble = messageContainer.querySelector('.message-bubble');
            if (bubble) {
                bubble.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showMessageMenu(message.id, e);
                });

                bubble.onclick = (e) => {
                    if (e.target.tagName === 'IMG' && e.target.classList.contains('message-image')) {
                        showImage(e.target.src);
                    }
                };
            }

            // 🔥【新增】如果是AI消息，调整心率
            if (message.sender === 'received' && typeof message.content === 'string') {
                adjustHeartrateForMessage(message.content, false);
            }

            // 滚动到底部
            setTimeout(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }, 100);
        }

        // 将颜色和透明度转换为rgba格式
        function convertColorWithOpacity(color, opacity) {
            // 检查参数有效性
            if (!color || typeof color !== 'string') {
                return 'rgba(0, 0, 0, 0)'; // 返回透明黑色作为默认值
            }

            // 如果颜色已经是rgba格式，直接返回
            if (color.startsWith('rgba')) {
                return color;
            }

            // 如果是十六进制颜色，转换为rgba
            if (color.startsWith('#')) {
                const hex = color.slice(1);
                const r = parseInt(hex.substring(0, 2), 16);
                const g = parseInt(hex.substring(2, 4), 16);
                const b = parseInt(hex.substring(4, 6), 16);
                return `rgba(${r}, ${g}, ${b}, ${opacity})`;
            }

            // 如果是rgb格式，转换为rgba
            if (color.startsWith('rgb(')) {
                const rgbValues = color.match(/\d+/g);
                return `rgba(${rgbValues[0]}, ${rgbValues[1]}, ${rgbValues[2]}, ${opacity})`;
            }

            // 如果是颜色名称，尝试转换（简单实现）
            const colorMap = {
                'red': '255, 0, 0',
                'green': '0, 128, 0',
                'blue': '0, 0, 255',
                'white': '255, 255, 255',
                'black': '0, 0, 0',
                'gray': '128, 128, 128',
                'yellow': '255, 255, 0',
                'cyan': '0, 255, 255',
                'magenta': '255, 0, 255'
            };

            if (colorMap[color.toLowerCase()]) {
                return `rgba(${colorMap[color.toLowerCase()]}, ${opacity})`;
            }

            // 如果无法识别，返回原色加透明度（作为备用）
            return color;
        }

        // 字体大小设置功能
        function changeFontSize(size) {
            const fontSize = parseInt(size);

            // 更新预览文字
            const preview = document.getElementById('font-size-preview');
            const valueDisplay = document.getElementById('font-size-value');

            if (preview) {
                preview.style.fontSize = fontSize + 'px';
            }

            if (valueDisplay) {
                valueDisplay.textContent = fontSize + 'px';
            }

            // 创建或更新全局字体大小CSS变量
            document.documentElement.style.setProperty('--global-font-size', fontSize + 'px');

            // 应用到聊天消息
            applyFontSizeToMessages(fontSize);

            // 应用到社交动态
            applyFontSizeToMoments(fontSize);

            // 如果当前有聊天角色，重新渲染消息以确保新字体大小生效
            if (currentChatCharacter && typeof renderChatMessages === 'function') {
                setTimeout(() => {
                    renderChatMessages(currentChatCharacter.id);
                }, 100);
            }

            // 保存设置
            localStorage.setItem('globalFontSize', fontSize);

            // 显示成功提示
            showToast('字号设置已保存并应用！', 'success');
        }

        // 字距设置功能
        function changeLetterSpacing(spacing) {
            const letterSpacing = parseFloat(spacing);

            // 更新预览文字
            const preview = document.getElementById('font-size-preview');
            const valueDisplay = document.getElementById('letter-spacing-value');

            if (preview) {
                preview.style.letterSpacing = letterSpacing + 'px';
            }

            if (valueDisplay) {
                // 根据数值显示对应的文字描述
                let description;
                if (letterSpacing < -0.2) {
                    description = '很紧凑';
                } else if (letterSpacing < 0.2) {
                    description = '标准';
                } else if (letterSpacing < 0.8) {
                    description = '舒适';
                } else if (letterSpacing < 1.5) {
                    description = '宽松';
                } else {
                    description = '很宽松';
                }
                valueDisplay.textContent = `${description} (${letterSpacing}px)`;
            }

            // 创建或更新全局字距CSS变量
            document.documentElement.style.setProperty('--global-letter-spacing', letterSpacing + 'px');

            // 应用到聊天消息
            applyLetterSpacingToMessages(letterSpacing);

            // 应用到社交动态
            applyLetterSpacingToMoments(letterSpacing);

            // 如果当前有聊天角色，重新渲染消息以确保新字距生效
            if (currentChatCharacter && typeof renderChatMessages === 'function') {
                setTimeout(() => {
                    renderChatMessages(currentChatCharacter.id);
                }, 100);
            }

            // 保存设置
            localStorage.setItem('globalLetterSpacing', letterSpacing);

            // 显示成功提示
            showToast('字距设置已保存并应用！', 'success');
        }

        function applyFontSizeToMessages(fontSize) {
            // 应用到所有聊天消息，使用!important强制覆盖内联样式
            const messageBubbles = document.querySelectorAll('.message-bubble');
            messageBubbles.forEach(bubble => {
                bubble.style.setProperty('font-size', fontSize + 'px', 'important');
            });

            // 应用到聊天输入框
            const chatInput = document.getElementById('api-chat-input');
            if (chatInput) {
                chatInput.style.fontSize = fontSize + 'px';
            }
        }

        function applyFontSizeToMoments(fontSize) {
            // 应用到微博动态内容
            const postContents = document.querySelectorAll('.post-content');
            postContents.forEach(content => {
                content.style.fontSize = fontSize + 'px';
            });

            // 应用到微博输入框
            const weiboTextarea = document.getElementById('weibo-text');
            if (weiboTextarea) {
                weiboTextarea.style.fontSize = fontSize + 'px';
            }
        }

        function applyLetterSpacingToMessages(letterSpacing) {
            // 应用到所有聊天消息
            const messageBubbles = document.querySelectorAll('.message-bubble');
            messageBubbles.forEach(bubble => {
                bubble.style.setProperty('letter-spacing', letterSpacing + 'px', 'important');
            });

            // 应用到聊天输入框
            const chatInput = document.getElementById('api-chat-input');
            if (chatInput) {
                chatInput.style.letterSpacing = letterSpacing + 'px';
            }
        }

        function applyLetterSpacingToMoments(letterSpacing) {
            // 应用到微博动态内容
            const postContents = document.querySelectorAll('.post-content');
            postContents.forEach(content => {
                content.style.letterSpacing = letterSpacing + 'px';
            });

            // 应用到微博输入框
            const weiboTextarea = document.getElementById('weibo-text');
            if (weiboTextarea) {
                weiboTextarea.style.letterSpacing = letterSpacing + 'px';
            }
        }

        function toggleAutoScale() {
            const toggle = document.getElementById('auto-scale-toggle');
            const isEnabled = toggle.checked;

            // 保存自动缩放设置
            localStorage.setItem('autoScaleFont', isEnabled);

            if (isEnabled) {
                // 根据屏幕尺寸自动调整字体
                autoAdjustFontSize();
                showToast('字体自动缩放已开启！', 'success');
            } else {
                showToast('字体自动缩放已关闭！', 'success');
            }
        }

        function autoAdjustFontSize() {
            const phoneScreen = document.getElementById('phone-screen');
            if (!phoneScreen) return;

            const screenWidth = parseInt(phoneScreen.style.width) || 350;

            // 根据屏幕宽度计算推荐字体大小
            let recommendedSize = 15; // 默认大小

            if (screenWidth <= 320) {
                recommendedSize = 13; // 小屏幕用小字体
            } else if (screenWidth <= 350) {
                recommendedSize = 14;
            } else if (screenWidth <= 375) {
                recommendedSize = 15;
            } else if (screenWidth <= 390) {
                recommendedSize = 16;
            } else {
                recommendedSize = 17; // 大屏幕用大字体
            }

            // 更新滑块和应用字体大小
            const slider = document.getElementById('font-size-slider');
            if (slider) {
                slider.value = recommendedSize;
                changeFontSize(recommendedSize);
            }
        }

        function loadFontSizeSettings() {
            // 加载字体大小设置
            const savedSize = localStorage.getItem('globalFontSize');
            const fontSize = savedSize ? parseInt(savedSize) : 15;

            const slider = document.getElementById('font-size-slider');
            const preview = document.getElementById('font-size-preview');
            const valueDisplay = document.getElementById('font-size-value');

            if (slider) {
                slider.value = fontSize;
            }

            if (preview) {
                preview.style.fontSize = fontSize + 'px';
            }

            if (valueDisplay) {
                valueDisplay.textContent = fontSize + 'px';
            }

            // 应用字体大小
            document.documentElement.style.setProperty('--global-font-size', fontSize + 'px');

            // 加载字距设置
            const savedSpacing = localStorage.getItem('globalLetterSpacing');
            const letterSpacing = savedSpacing ? parseFloat(savedSpacing) : 0;

            const spacingSlider = document.getElementById('letter-spacing-slider');
            const spacingValueDisplay = document.getElementById('letter-spacing-value');

            if (spacingSlider) {
                spacingSlider.value = letterSpacing;
            }

            if (preview) {
                preview.style.letterSpacing = letterSpacing + 'px';
            }

            if (spacingValueDisplay) {
                // 根据数值显示对应的文字描述
                let description;
                if (letterSpacing < -0.2) {
                    description = '很紧凑';
                } else if (letterSpacing < 0.2) {
                    description = '标准';
                } else if (letterSpacing < 0.8) {
                    description = '舒适';
                } else if (letterSpacing < 1.5) {
                    description = '宽松';
                } else {
                    description = '很宽松';
                }
                spacingValueDisplay.textContent = `${description} (${letterSpacing}px)`;
            }

            // 应用字距
            document.documentElement.style.setProperty('--global-letter-spacing', letterSpacing + 'px');

            // 延迟应用，确保DOM元素已经加载
            setTimeout(() => {
                applyFontSizeToMessages(fontSize);
                applyFontSizeToMoments(fontSize);
                applyLetterSpacingToMessages(letterSpacing);
                applyLetterSpacingToMoments(letterSpacing);
            }, 500);

            // 加载自动缩放设置
            const autoScale = localStorage.getItem('autoScaleFont');
            const autoScaleToggle = document.getElementById('auto-scale-toggle');
            if (autoScaleToggle) {
                autoScaleToggle.checked = autoScale === 'true';
            }
        }

        // 🔥【新增】全局自定义字体功能
        let globalFontSettings = {
            fontUrl: '',
            fontName: '',
            isApplied: false
        };

        // 预览全局字体
        function previewGlobalFont() {
            const fontUrl = document.getElementById('global-font-url').value.trim();
            if (!fontUrl) {
                showFontStatus('请输入字体链接', 'error');
                return;
            }

            showFontStatus('正在加载字体预览...', 'info');

            // 清除之前的预览字体
            const existingPreview = document.getElementById('global-font-preview');
            if (existingPreview) {
                existingPreview.remove();
            }

            // 判断字体类型并加载
            if (isCSSFontUrl(fontUrl)) {
                loadCSSFontPreview(fontUrl);
            } else if (isFontFileUrl(fontUrl)) {
                loadFontFilePreview(fontUrl);
            } else {
                showFontStatus('不支持的字体格式，请使用CSS链接或字体文件链接', 'error');
            }
        }

        // 应用全局字体
        function applyGlobalFont() {
            const fontUrl = document.getElementById('global-font-url').value.trim();
            if (!fontUrl) {
                showFontStatus('请输入字体链接', 'error');
                return;
            }

            // 清除之前的字体
            const existingFont = document.getElementById('global-custom-font');
            if (existingFont) {
                existingFont.remove();
            }

            showFontStatus('正在应用字体...', 'info');

            // 判断字体类型并应用
            if (isCSSFontUrl(fontUrl)) {
                applyCSSFont(fontUrl);
            } else if (isFontFileUrl(fontUrl)) {
                applyFontFile(fontUrl);
            } else {
                showFontStatus('不支持的字体格式，请使用CSS链接或字体文件链接', 'error');
            }
        }

        // 重置全局字体
        function resetGlobalFont() {
            // 清除字体样式
            const existingFont = document.getElementById('global-custom-font');
            if (existingFont) {
                existingFont.remove();
            }

            const existingPreview = document.getElementById('global-font-preview');
            if (existingPreview) {
                existingPreview.remove();
            }

            // 🔥【新增】清除全局字体覆盖样式
            const existingGlobalStyle = document.getElementById('global-font-override');
            if (existingGlobalStyle) {
                existingGlobalStyle.remove();
            }

            // 🔥【新增】重置body字体为默认
            document.body.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';

            // 清空输入框
            document.getElementById('global-font-url').value = '';

            // 重置设置
            globalFontSettings = {
                fontUrl: '',
                fontName: '',
                isApplied: false
            };

            // 清除本地存储
            localStorage.removeItem('globalCustomFont');

            showFontStatus('字体已重置为系统默认', 'success');
        }

        // 判断是否为CSS字体链接
        function isCSSFontUrl(url) {
            return url.includes('fonts.googleapis.com') ||
                   url.includes('fonts.google.com') ||
                   url.endsWith('.css') ||
                   url.includes('fontsapi') ||
                   url.includes('zeoseven.com') ||
                   url.includes('css');
        }

        // 判断是否为字体文件链接
        function isFontFileUrl(url) {
            return url.endsWith('.ttf') ||
                   url.endsWith('.otf') ||
                   url.endsWith('.woff') ||
                   url.endsWith('.woff2');
        }

        // 加载CSS字体预览
        function loadCSSFontPreview(fontUrl) {
            const link = document.createElement('link');
            link.id = 'global-font-preview';
            link.rel = 'stylesheet';
            link.href = fontUrl;
            link.crossOrigin = 'anonymous';

            link.onload = function() {
                console.log('🎨 CSS字体预览加载成功');

                // 等待一下让CSS完全加载
                setTimeout(() => {
                    // 尝试提取字体名称
                    let fontName = extractFontNameFromCSS(fontUrl);

                    // 🔥【新增】尝试从加载的CSS中动态提取真实字体名称
                    try {
                        const sheets = document.styleSheets;
                        for (let i = sheets.length - 1; i >= 0; i--) {
                            const sheet = sheets[i];
                            if (sheet.href === fontUrl) {
                                try {
                                    const rules = sheet.cssRules || sheet.rules;
                                    for (let j = 0; j < rules.length; j++) {
                                        const rule = rules[j];
                                        if (rule.type === CSSRule.FONT_FACE_RULE && rule.style.fontFamily) {
                                            fontName = rule.style.fontFamily.replace(/['"]/g, '');
                                            console.log('🎨 从CSS中提取到真实字体名称:', fontName);
                                            break;
                                        }
                                    }
                                } catch (e) {
                                    console.log('🎨 无法读取CSS规则，使用默认名称');
                                }
                                break;
                            }
                        }
                    } catch (e) {
                        console.log('🎨 CSS解析失败，使用默认名称');
                    }

                    // 应用预览样式
                    const previewText = document.getElementById('font-size-preview');
                    if (previewText) {
                        previewText.style.fontFamily = `'${fontName}', sans-serif`;
                    }

                    showFontStatus(`字体预览已加载：${fontName}`, 'success');
                }, 500);
            };

            link.onerror = function() {
                showFontStatus('字体CSS加载失败，请检查链接是否正确', 'error');
            };

            document.head.appendChild(link);
        }

        // 加载字体文件预览
        function loadFontFilePreview(fontUrl) {
            const fontName = 'GlobalPreviewFont_' + Date.now();
            const style = document.createElement('style');
            style.id = 'global-font-preview';

            // 根据文件扩展名确定格式
            let format = 'truetype';
            if (fontUrl.endsWith('.woff')) format = 'woff';
            if (fontUrl.endsWith('.woff2')) format = 'woff2';
            if (fontUrl.endsWith('.otf')) format = 'opentype';

            style.textContent = `
                @font-face {
                    font-family: '${fontName}';
                    src: url('${fontUrl}') format('${format}');
                    font-display: swap;
                }
            `;

            document.head.appendChild(style);

            // 等待字体加载
            setTimeout(() => {
                const previewText = document.getElementById('font-size-preview');
                if (previewText) {
                    previewText.style.fontFamily = `'${fontName}', sans-serif`;
                }
                showFontStatus(`字体预览已加载：${fontName}`, 'success');
            }, 500);
        }

        // 应用CSS字体
        function applyCSSFont(fontUrl) {
            const link = document.createElement('link');
            link.id = 'global-custom-font';
            link.rel = 'stylesheet';
            link.href = fontUrl;
            link.crossOrigin = 'anonymous';

            link.onload = function() {
                console.log('🎨 CSS字体加载成功，开始应用');

                // 等待一下让CSS完全加载
                setTimeout(() => {
                    let fontName = extractFontNameFromCSS(fontUrl);

                    // 🔥【新增】尝试从加载的CSS中动态提取真实字体名称
                    try {
                        const sheets = document.styleSheets;
                        for (let i = sheets.length - 1; i >= 0; i--) {
                            const sheet = sheets[i];
                            if (sheet.href === fontUrl) {
                                try {
                                    const rules = sheet.cssRules || sheet.rules;
                                    for (let j = 0; j < rules.length; j++) {
                                        const rule = rules[j];
                                        if (rule.type === CSSRule.FONT_FACE_RULE && rule.style.fontFamily) {
                                            fontName = rule.style.fontFamily.replace(/['"]/g, '');
                                            console.log('🎨 从CSS中提取到真实字体名称:', fontName);
                                            break;
                                        }
                                    }
                                } catch (e) {
                                    console.log('🎨 无法读取CSS规则，使用默认名称');
                                }
                                break;
                            }
                        }
                    } catch (e) {
                        console.log('🎨 CSS解析失败，使用默认名称');
                    }

                    applyFontToElements(fontName);

                    // 保存设置
                    globalFontSettings = {
                        fontUrl: fontUrl,
                        fontName: fontName,
                        isApplied: true
                    };
                    localStorage.setItem('globalCustomFont', JSON.stringify(globalFontSettings));

                    showFontStatus(`字体已应用：${fontName}`, 'success');
                }, 500);
            };

            link.onerror = function() {
                showFontStatus('字体CSS加载失败，请检查链接是否正确', 'error');
            };

            document.head.appendChild(link);
        }

        // 应用字体文件
        function applyFontFile(fontUrl) {
            const fontName = 'GlobalCustomFont_' + Date.now();
            const style = document.createElement('style');
            style.id = 'global-custom-font';

            // 根据文件扩展名确定格式
            let format = 'truetype';
            if (fontUrl.endsWith('.woff')) format = 'woff';
            if (fontUrl.endsWith('.woff2')) format = 'woff2';
            if (fontUrl.endsWith('.otf')) format = 'opentype';

            style.textContent = `
                @font-face {
                    font-family: '${fontName}';
                    src: url('${fontUrl}') format('${format}');
                    font-display: swap;
                }
            `;

            document.head.appendChild(style);

            // 等待字体加载后应用
            setTimeout(() => {
                applyFontToElements(fontName);

                // 保存设置
                globalFontSettings = {
                    fontUrl: fontUrl,
                    fontName: fontName,
                    isApplied: true
                };
                localStorage.setItem('globalCustomFont', JSON.stringify(globalFontSettings));

                showFontStatus(`字体已应用：${fontName}`, 'success');
            }, 500);
        }

        // 从CSS链接提取字体名称
        function extractFontNameFromCSS(fontUrl) {
            // 从Google Fonts URL提取字体名称
            if (fontUrl.includes('fonts.googleapis.com') || fontUrl.includes('fonts.google.com')) {
                const match = fontUrl.match(/family=([^&:]+)/);
                if (match) {
                    return decodeURIComponent(match[1].replace(/\+/g, ' '));
                }
            }

            // 从zeoseven.com字体API提取（这个API通常是ChillKai字体）
            if (fontUrl.includes('zeoseven.com')) {
                return 'ChillKai';
            }

            // 从其他CSS链接尝试提取
            if (fontUrl.includes('fontsapi')) {
                return 'CustomFont';
            }

            return 'CustomFont';
        }

        // 应用字体到页面元素
        function applyFontToElements(fontName) {
            console.log('🎨 开始应用全局字体:', fontName);

            // 🔥【关键修复】直接修改body的字体，这样会影响所有子元素
            document.body.style.fontFamily = `'${fontName}', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`;

            // 🔥【新增】创建全局CSS规则，确保所有元素都使用新字体
            const existingGlobalStyle = document.getElementById('global-font-override');
            if (existingGlobalStyle) {
                existingGlobalStyle.remove();
            }

            const globalStyle = document.createElement('style');
            globalStyle.id = 'global-font-override';
            globalStyle.textContent = `
                /* 🔥【修复】只对文字内容应用字体，不影响图标 */
                body {
                    font-family: '${fontName}', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif !important;
                }

                /* 特别针对手机界面的文字部分，排除图标 */
                .header .header-title,
                .app-title,
                .setting-label,
                .setting-desc,
                .app-icon .label,
                .message-bubble .content,
                .chat-input,
                .form-input,
                .form-textarea,
                .form-button,
                .list-item .item-title,
                .list-item .item-content,
                .post-content,
                .diary-content,
                .forum-post-content,
                .font-size-preview-text,
                #main-time,
                #main-date,
                .settings-item-left,
                .chat-list-item .name,
                .chat-list-item .last-msg,
                .contact-item .contact-name,
                .contact-item .contact-desc,
                .modal-title,
                .modal-body,
                .btn,
                button:not(.icon-only),
                input,
                textarea,
                select,
                /* 🔥【新增】日记相关元素 */
                #today-diary-content,
                #single-diary-content,
                #diary-preview-content,
                .diary-mode-content,
                .diary-settings-content {
                    font-family: '${fontName}', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif !important;
                }

                /* 🔥【重要】确保图标字体不被覆盖 */
                .fas, .far, .fab, .fal, .fad,
                i[class*="fa-"],
                .icon-bg,
                .app-icon .icon-bg,
                .back-btn,
                .action-btn,
                .settings-icon,
                [class*="icon-"]:not(.app-icon) {
                    font-family: "Font Awesome 6 Free", "Font Awesome 6 Pro", "Font Awesome 5 Free", "Font Awesome 5 Pro", FontAwesome !important;
                }
            `;
            document.head.appendChild(globalStyle);

            console.log('✅ 全局字体已应用到所有元素');
        }

        // 显示字体状态
        function showFontStatus(message, type) {
            const statusElement = document.getElementById('global-font-status');
            const statusText = statusElement.querySelector('.font-status-text');

            statusElement.className = `font-status ${type}`;
            statusText.textContent = message;
            statusElement.style.display = 'block';

            // 3秒后隐藏成功和信息状态
            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    statusElement.style.display = 'none';
                }, 3000);
            }
        }

        // 加载保存的全局字体设置
        function loadGlobalFontSettings() {
            const saved = localStorage.getItem('globalCustomFont');
            if (saved) {
                try {
                    globalFontSettings = JSON.parse(saved);
                    if (globalFontSettings.fontUrl) {
                        // 恢复输入框内容
                        const fontUrlInput = document.getElementById('global-font-url');
                        if (fontUrlInput) {
                            fontUrlInput.value = globalFontSettings.fontUrl;
                        }

                        // 重新应用字体
                        if (globalFontSettings.isApplied) {
                            if (isCSSFontUrl(globalFontSettings.fontUrl)) {
                                applyCSSFont(globalFontSettings.fontUrl);
                            } else if (isFontFileUrl(globalFontSettings.fontUrl)) {
                                applyFontFile(globalFontSettings.fontUrl);
                            }
                        }
                    }
                } catch (error) {
                    console.error('加载全局字体设置失败:', error);
                }
            }
        }

        // 工具栏功能
        function triggerVoiceMessage() {
            showToast('语音功能开发中...', 'info');
            // 这里可以添加语音录制功能
        }

        // 聊天界面拍照功能 - 文字描述图片发送给AI
        async function openCamera() {
            if (!currentChatCharacter) {
                showToast('请先选择一个聊天对象', 'error');
                return;
            }

            const description = await showCustomPrompt("发送照片", "请用文字描述您要发送的照片：");
            if (description && description.trim()) {
                const msg = {
                    id: Date.now().toString(),
                    sender: 'sent',
                    type: 'user_photo',
                    content: description.trim(),
                    timestamp: Date.now(),
                    photoDescription: description.trim() // 保存原始描述用于点击查看
                };

                // 添加到聊天记录
                if (!chatMessages[currentChatCharacter.id]) {
                    chatMessages[currentChatCharacter.id] = [];
                }
                chatMessages[currentChatCharacter.id].push(msg);
                // 🔥【优化】照片分享使用高效保存
                try {
                    await saveChatMessagesImmediate([currentChatCharacter.id]);
                    console.log('✅ [高效照片分享] 消息已保存到数据库');
                } catch (error) {
                    console.error('照片分享消息保存失败，回退到全量保存:', error);
                    await saveChatMessages();
                }

                // 刷新界面
                renderChatMessages(currentChatCharacter.id);
                renderMessageList();

                showToast('照片已发送', 'success');
            }
        }

        function openTransfer() {
            // 检查是否有当前聊天角色
            if (!currentChatCharacter) {
                showToast('请先选择聊天对象', 'warning');
                return;
            }

            // 显示转账对话框
            document.getElementById('transfer-modal').classList.add('visible');
        }

        // 通话状态变量
        let isInCall = false;
        let callTimer = null;
        let callStartTime = null;
        let callDuration = 0;
        let isMuted = false;
        let isSpeakerOn = false;
        let currentCallCharacter = null;

        // 🔥【新增】视频通话状态变量
        let isInVideoCall = false;
        let videoCallTimer = null;
        let videoCallStartTime = null;
        let videoCallDuration = 0;
        let isVideoMuted = false;
        let isVideoCameraOff = false;
        let currentVideoCallCharacter = null;

        // 生成消息ID函数
        function generateMessageId() {
            return Date.now().toString() + Math.floor(Math.random() * 1000).toString();
        }

        // 添加消息到聊天记录
        async function addMessageToChat(message) {
            if (!currentChatCharacter) return;

            const characterId = currentChatCharacter.id;
            if (!chatMessages[characterId]) {
                chatMessages[characterId] = [];
            }

            chatMessages[characterId].push(message);

            // 🔥【高效保存】直接添加单条消息到数据库，避免全量重写
            try {
                const stableId = `${characterId}_${message.id}_${chatMessages[characterId].length - 1}`;
                await db.chatMessages.add({
                    id: stableId,
                    characterId: characterId,
                    timestamp: message.timestamp,
                    messageOrder: chatMessages[characterId].length - 1,
                    originalMessageId: message.id,
                    messageData: message
                });
                console.log('✅ [高效通话消息] 单条消息已保存到数据库');
            } catch (error) {
                console.error('通话消息单条保存失败，回退到批量保存:', error);
                saveChatMessages(); // 🔥【修复】不传入characterId，避免强制同步
            }

            // 更新聊天界面
            renderChatMessages(characterId);
        }

        function makeCall() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'error');
                return;
            }

            // 检查是否为群聊
            if (currentChatCharacter.isGroup) {
                showToast('群聊不支持电话通话', 'error');
                return;
            }

            // 🔥【新增】播放拨出通话音效
            SoundManager.play(SoundManager.TYPES.OUTGOING_CALL, currentChatCharacter?.id);

            // 检查角色主动拨打电话开关，用户主动拨打时不受此限制
            const currentChatSettings = getCurrentChatSettings();
            console.log('📞 用户主动拨打电话，开关状态:', currentChatSettings.aiCallEnabled);

            currentCallCharacter = currentChatCharacter;

            // 设置通话界面
            const avatarSrc = currentCallCharacter.avatar || currentCallCharacter.avatarUrl || 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="50" fill="lightgray"/><text x="50" y="60" font-size="30" text-anchor="middle" fill="gray">头像</text></svg>';
            document.getElementById('call-avatar-img').src = avatarSrc;
            document.getElementById('call-name').textContent = currentCallCharacter.name;
            document.getElementById('call-status').textContent = '正在通话中...';
            document.getElementById('call-timer').textContent = '00:00';

            // 清空通话消息容器
            document.getElementById('call-message-container').innerHTML = '';

            // 显示通话界面
            showApp('phone-call-screen');

            // 开始计时
            startCallTimer();

            // 设置通话状态
            isInCall = true;

            // 发送系统消息到聊天记录
            const callStartMessage = {
                id: generateMessageId(),
                sender: 'system',
                content: `${currentCallCharacter.name}已接通语音电话`,
                timestamp: Date.now(),
                type: 'call_record',
                callType: 'outgoing',
                callStatus: 'started'
            };

            addMessageToChat(callStartMessage);

            // 用户主动拨打电话时不自动添加角色回应，等待用户先说话
            // 设置标志，表明这是用户主动拨打的电话
            window.isUserInitiatedCall = true;
        }

        // 角色主动拨打电话
        async function initiateAICall(character, callReason) {
            if (isInCall) return; // 如果已经在通话中，不再发起

            currentCallCharacter = character;
            isInCall = true;

            // 🔥【修复】立即显示系统提示和播放铃声，不等待AI生成开场白
            const incomingCallMessage = {
                id: generateMessageId(),
                sender: 'system',
                content: `${character.name}正在呼叫你`,
                timestamp: Date.now(),
                type: 'call_record',
                callType: 'incoming',
                callStatus: 'ringing'
            };
            addMessageToChat(incomingCallMessage);

            // 🔥【新增】播放来电音效
            SoundManager.play(SoundManager.TYPES.INCOMING_CALL, character?.id);

            // 🔥【新增】记住当前显示的界面，以便拒绝来电时恢复
            const allApps = document.querySelectorAll('.app-screen');
            let currentVisibleApp = null;
            allApps.forEach(app => {
                if (app.style.display === 'flex' || app.style.display === 'block') {
                    currentVisibleApp = app.id;
                }
            });
            // 如果没有找到可见的应用，检查是否在主屏幕
            if (!currentVisibleApp) {
                const clockContainer = document.getElementById('clock-container');
                const homeGrid = document.getElementById('home-grid');
                if (clockContainer && clockContainer.style.display !== 'none' &&
                    homeGrid && homeGrid.style.display !== 'none') {
                    currentVisibleApp = 'home-screen';
                }
            }
            // 保存当前界面状态
            window.previousScreenBeforeCall = currentVisibleApp || 'api-chat-screen';

            // 🔥【恢复】先生成角色的开场白，再显示来电界面
            let characterGreeting = '';
            try {
                const prompt = `你是${character.name}，刚刚决定给用户打电话。

请生成一句简短自然的开场白，说明你为什么要打这个电话：
- 要符合你的性格特点
- 像真实通话开始时的自然表达
- 1句话即可，不要超过20字
- 直接说话，不要任何格式标记

例如：
- "我想和你聊聊今天的事情"
- "有个好消息想告诉你"
- "想听到你的声音"

请只回复开场白内容：`;

                const response = await callChatAPI(prompt, character);

                // 🔥【关键修复】使用parseAiResponse解析开场白
                const parsedMessages = await parseAiResponse(response);
                console.log('🔔 开场白AI回复解析结果:', parsedMessages);

                if (Array.isArray(parsedMessages) && parsedMessages.length > 0) {
                    // 找到第一条纯文本消息
                    const firstTextMessage = parsedMessages.find(msg => typeof msg === 'string');
                    if (firstTextMessage) {
                        characterGreeting = firstTextMessage.trim();
                    } else {
                        // 如果没有纯文本，尝试提取对象中的内容
                        const firstMessage = parsedMessages[0];
                        if (typeof firstMessage === 'object' && firstMessage.content) {
                            characterGreeting = firstMessage.content.trim();
                        }
                    }
                } else if (typeof response === 'string') {
                    // 备用：如果解析失败，清理原始字符串
                    characterGreeting = cleanCallResponse(response).trim();
                }

                if (!characterGreeting || characterGreeting.length > 30) {
                    characterGreeting = callReason || '想和你通话...';
                }
            } catch (error) {
                console.error('生成角色开场白失败:', error);
                characterGreeting = callReason || '想和你通话...';
            }

            // 设置来电显示界面
            const avatarSrc = character.avatar || character.avatarUrl || 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="50" fill="lightgray"/><text x="50" y="60" font-size="30" text-anchor="middle" fill="gray">头像</text></svg>';
            document.getElementById('incoming-call-avatar').src = avatarSrc;
            document.getElementById('incoming-call-name').textContent = character.name;
            document.getElementById('incoming-call-text').textContent = characterGreeting;

            // 🔥【保存开场白供接听后使用】
            window.aiCallGreeting = characterGreeting;

            // 添加振铃动画
            document.getElementById('incoming-call-avatar').classList.add('ringing-animation');

            // 显示来电界面
            showApp('incoming-call-screen');

            // 播放来电铃声（如果需要）
            // playRingtone();

            // 🔥【删除】系统消息已在前面发送，避免重复

            // 如果30秒内没有接听，自动挂断
            setTimeout(() => {
                if (document.getElementById('incoming-call-screen').style.display !== 'none') {
                    rejectCall();
                }
            }, 30000);
        }

        // 🔥【新增】角色主动发起视频通话
        async function initiateAIVideoCall(character, callReason) {
            if (isInVideoCall) return; // 如果已经在视频通话中，不再发起

            currentVideoCallCharacter = character;
            isInVideoCall = true;

            // 🔥【修复】立即显示系统提示和播放铃声，不等待AI生成开场白
            const incomingVideoCallMessage = {
                id: generateMessageId(),
                sender: 'system',
                content: `${character.name}正在呼叫你`,
                timestamp: Date.now(),
                type: 'call_record',
                callType: 'incoming_video',
                callStatus: 'ringing'
            };
            addMessageToChat(incomingVideoCallMessage);

            // 🔥【新增】播放来电音效
            SoundManager.play(SoundManager.TYPES.INCOMING_CALL, character?.id);

            // 🔥【新增】记住当前显示的界面，以便拒绝来电时恢复
            const allApps = document.querySelectorAll('.app-screen');
            let currentVisibleApp = null;
            allApps.forEach(app => {
                if (app.style.display === 'flex' || app.style.display === 'block') {
                    currentVisibleApp = app.id;
                }
            });
            // 如果没有找到可见的应用，检查是否在主屏幕
            if (!currentVisibleApp) {
                const clockContainer = document.getElementById('clock-container');
                const homeGrid = document.getElementById('home-grid');
                if (clockContainer && clockContainer.style.display !== 'none' &&
                    homeGrid && homeGrid.style.display !== 'none') {
                    currentVisibleApp = 'home-screen';
                }
            }
            // 保存当前界面状态
            window.previousScreenBeforeVideoCall = currentVisibleApp || 'api-chat-screen';

            // 生成角色的开场白
            let characterGreeting = '';
            try {
                const prompt = `你是${character.name}，刚刚决定给用户打视频电话。

请生成一句简短自然的开场白，说明你为什么要打这个视频电话：
- 要符合你的性格特点
- 像真实视频通话开始时的自然表达
- 1句话即可，不要超过20字
- 直接说话，不要任何格式标记

例如：
- "想看看你在做什么"
- "有个好消息想和你分享"
- "想看到你的笑容"

请只回复开场白内容：`;

                const response = await callChatAPI(prompt, character);

                // 使用parseAiResponse解析开场白
                const parsedMessages = await parseAiResponse(response);
                console.log('🔔 视频通话开场白AI回复解析结果:', parsedMessages);

                if (Array.isArray(parsedMessages) && parsedMessages.length > 0) {
                    // 找到第一条纯文本消息
                    const firstTextMessage = parsedMessages.find(msg => typeof msg === 'string');
                    if (firstTextMessage) {
                        characterGreeting = firstTextMessage.trim();
                    } else {
                        // 如果没有纯文本，尝试提取对象中的内容
                        const firstMessage = parsedMessages[0];
                        if (typeof firstMessage === 'object' && firstMessage.content) {
                            characterGreeting = firstMessage.content.trim();
                        }
                    }
                } else if (typeof response === 'string') {
                    // 备用：如果解析失败，清理原始字符串
                    characterGreeting = cleanCallResponse(response).trim();
                }

                if (!characterGreeting || characterGreeting.length > 30) {
                    characterGreeting = callReason || '想和你视频聊聊...';
                }
            } catch (error) {
                console.error('生成角色视频通话开场白失败:', error);
                characterGreeting = callReason || '想和你视频聊聊...';
            }

            // 设置视频来电显示界面
            const avatarSrc = character.avatar || character.avatarUrl || 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="50" fill="lightgray"/><text x="50" y="60" font-size="30" text-anchor="middle" fill="gray">头像</text></svg>';
            document.getElementById('incoming-video-call-avatar').src = avatarSrc;
            document.getElementById('incoming-video-call-name').textContent = character.name;
            document.getElementById('incoming-video-call-text').textContent = characterGreeting;

            // 🔥【保存开场白供接听后使用】
            window.aiVideoCallGreeting = characterGreeting;

            // 添加振铃动画
            document.getElementById('incoming-video-call-avatar').classList.add('ringing-animation');

            // 显示视频来电界面
            showApp('incoming-video-call-screen');

            // 🔥【删除】系统消息已在前面发送，避免重复

            // 如果30秒内没有接听，自动挂断
            setTimeout(() => {
                if (document.getElementById('incoming-video-call-screen').style.display !== 'none') {
                    rejectVideoCall();
                }
            }, 30000);
        }

        // 🔥【新增】接受视频来电
        function acceptVideoCall() {
            // 🔥【新增】停止来电铃声
            SoundManager.stopSound(SoundManager.TYPES.INCOMING_CALL);

            // 停止振铃动画
            document.getElementById('incoming-video-call-avatar').classList.remove('ringing-animation');

            // 隐藏视频来电界面
            hideApp('incoming-video-call-screen');

            // 获取通话形象设置
            const videoAvatarSettings = getVideoAvatarSettings();

            // 设置视频通话界面
            const characterAvatarSrc = videoAvatarSettings.characterAvatar || currentVideoCallCharacter.avatar || currentVideoCallCharacter.avatarUrl || 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="50" fill="lightgray"/><text x="50" y="60" font-size="30" text-anchor="middle" fill="gray">头像</text></svg>';
            const userAvatarSrc = videoAvatarSettings.userAvatar || 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="50" fill="lightblue"/><text x="50" y="60" font-size="30" text-anchor="middle" fill="white">你</text></svg>';

            document.getElementById('video-call-character-avatar').src = characterAvatarSrc;
            document.getElementById('video-call-user-avatar').src = userAvatarSrc;
            document.getElementById('video-call-name').textContent = currentVideoCallCharacter.name;
            document.getElementById('video-call-status').textContent = '视频通话中...';
            document.getElementById('video-call-timer').textContent = '00:00';

            // 清空浮现消息容器
            const messageContainer = document.getElementById('video-call-floating-messages');
            if (messageContainer) {
                messageContainer.innerHTML = '';
            }

            // 显示视频通话界面
            showApp('video-call-screen');

            // 开始计时
            startVideoCallTimer();

            // 设置通话状态
            isInVideoCall = true;
            isVideoMuted = false;
            isVideoCameraOff = false;

            // 更新按钮状态
            updateVideoCallButtons();

            // 发送系统消息到聊天记录
            const videoCallAcceptedMessage = {
                id: generateMessageId(),
                sender: 'system',
                content: `你已接通${currentVideoCallCharacter.name}的视频通话`,
                timestamp: Date.now(),
                type: 'call_record',
                callType: 'incoming',
                callStatus: 'accepted'
            };

            addMessageToChat(videoCallAcceptedMessage);

            // 如果有保存的开场白，显示它
            if (window.aiVideoCallGreeting) {
                setTimeout(() => {
                    addVideoCallMessage(window.aiVideoCallGreeting, 'received');
                    window.aiVideoCallGreeting = null; // 清除保存的开场白
                }, 1000);
            }

            // 🔥【新增】清除保存的界面状态，因为已经接听了视频电话
            window.previousScreenBeforeVideoCall = null;
        }

        // 🔥【新增】拒绝视频来电
        function rejectVideoCall() {
            // 🔥【新增】停止来电铃声
            SoundManager.stopSound(SoundManager.TYPES.INCOMING_CALL);

            // 停止振铃动画
            document.getElementById('incoming-video-call-avatar').classList.remove('ringing-animation');

            // 隐藏视频来电界面
            hideApp('incoming-video-call-screen');

            // 🔥【修复】恢复到来电前的界面
            const previousScreen = window.previousScreenBeforeVideoCall;
            if (previousScreen && previousScreen !== 'home-screen') {
                showApp(previousScreen);
            } else if (previousScreen === 'home-screen') {
                // 如果之前在主屏幕，则显示主屏幕组件
                const clockContainer = document.getElementById('clock-container');
                const homeGrid = document.getElementById('home-grid');
                const dockBar = document.getElementById('dock-bar');
                if (clockContainer) clockContainer.style.display = 'block';
                if (homeGrid) homeGrid.style.display = 'grid';
                if (dockBar) dockBar.style.display = 'block';
            } else {
                // 默认返回到聊天界面
                showApp('api-chat-screen');
            }

            // 发送系统消息到聊天记录
            const videoCallRejectedMessage = {
                id: generateMessageId(),
                sender: 'system',
                content: `已拒绝${currentVideoCallCharacter.name}的视频来电`,
                timestamp: Date.now(),
                type: 'call_record',
                callType: 'incoming',
                callStatus: 'rejected'
            };

            addMessageToChat(videoCallRejectedMessage);

            currentVideoCallCharacter = null;
            window.aiVideoCallGreeting = null; // 清除保存的开场白
            // 清除保存的界面状态
            window.previousScreenBeforeVideoCall = null;
        }

        // 接受来电
        function acceptCall() {
            // 🔥【新增】停止来电铃声
            SoundManager.stopSound(SoundManager.TYPES.INCOMING_CALL);

            // 停止振铃动画
            document.getElementById('incoming-call-avatar').classList.remove('ringing-animation');

            // 隐藏来电界面
            hideApp('incoming-call-screen');

            // 设置通话界面
            const avatarSrc = currentCallCharacter.avatar || currentCallCharacter.avatarUrl || 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="50" fill="lightgray"/><text x="50" y="60" font-size="30" text-anchor="middle" fill="gray">头像</text></svg>';
            document.getElementById('call-avatar-img').src = avatarSrc;
            document.getElementById('call-name').textContent = currentCallCharacter.name;
            document.getElementById('call-status').textContent = '正在通话中...';
            document.getElementById('call-timer').textContent = '00:00';

            // 清空通话消息容器
            document.getElementById('call-message-container').innerHTML = '';

            // 显示通话界面
            showApp('phone-call-screen');

            // 开始计时
            startCallTimer();

            // 设置通话状态
            isInCall = true;

            // 发送系统消息到聊天记录
            const callAcceptedMessage = {
                id: generateMessageId(),
                sender: 'system',
                content: `你已接通${currentCallCharacter.name}的语音电话`,
                timestamp: Date.now(),
                type: 'call_record',
                callType: 'incoming',
                callStatus: 'accepted'
            };

            addMessageToChat(callAcceptedMessage);

            // 🔥【修复】使用AI生成的开场白或默认问候
            setTimeout(() => {
                let initialResponse = window.aiCallGreeting || getRandomCallGreeting(currentCallCharacter.name);
                addCallMessage(initialResponse, 'received');
                // 清理开场白缓存
                window.aiCallGreeting = null;
            }, 1000);

            // 🔥【新增】清除保存的界面状态，因为已经接听了电话
            window.previousScreenBeforeCall = null;
        }

        // 拒绝来电
        function rejectCall() {
            // 🔥【新增】停止来电铃声
            SoundManager.stopSound(SoundManager.TYPES.INCOMING_CALL);

            // 停止振铃动画
            document.getElementById('incoming-call-avatar').classList.remove('ringing-animation');

            // 隐藏来电界面
            hideApp('incoming-call-screen');

            // 🔥【修复】恢复到来电前的界面
            const previousScreen = window.previousScreenBeforeCall;
            if (previousScreen && previousScreen !== 'home-screen') {
                showApp(previousScreen);
            } else if (previousScreen === 'home-screen') {
                // 如果之前在主屏幕，则显示主屏幕组件
                const clockContainer = document.getElementById('clock-container');
                const homeGrid = document.getElementById('home-grid');
                const dockBar = document.getElementById('dock-bar');
                if (clockContainer) clockContainer.style.display = 'block';
                if (homeGrid) homeGrid.style.display = 'grid';
                if (dockBar) dockBar.style.display = 'block';
            } else {
                // 默认返回到聊天界面
                showApp('api-chat-screen');
            }

            // 发送系统消息到聊天记录
            const callRejectedMessage = {
                id: generateMessageId(),
                sender: 'system',
                content: `已拒绝${currentCallCharacter.name}的来电`,
                timestamp: Date.now(),
                type: 'call_record',
                callType: 'incoming',
                callStatus: 'rejected'
            };

            addMessageToChat(callRejectedMessage);

            currentCallCharacter = null;
            // 清除保存的界面状态
            window.previousScreenBeforeCall = null;
        }

        // 结束通话
        function endCall() {
            if (!isInCall) return;

            // 停止计时
            stopCallTimer();

            // 隐藏通话界面
            hideApp('phone-call-screen');

            // 返回聊天界面
            showApp('api-chat-screen');

            // 发送系统消息到聊天记录
            const formattedDuration = formatCallDuration(callDuration);
            const callEndedMessage = {
                id: generateMessageId(),
                sender: 'system',
                content: `语音电话已结束，通话时长 ${formattedDuration}`,
                timestamp: Date.now(),
                type: 'call_record',
                callType: 'ended',
                callStatus: 'completed',
                duration: formattedDuration
            };

            addMessageToChat(callEndedMessage);

            // 重置通话状态
            isInCall = false;
            isMuted = false;
            isSpeakerOn = false;

            currentCallCharacter = null;
        }

        // 静音/取消静音
        function toggleMute() {
            isMuted = !isMuted;
            const muteBtn = document.getElementById('mute-btn');

            if (isMuted) {
                muteBtn.classList.add('muted');
                muteBtn.innerHTML = '<i class="fas fa-microphone-slash"></i>';
                showToast('已静音', 'info');
            } else {
                muteBtn.classList.remove('muted');
                muteBtn.innerHTML = '<i class="fas fa-microphone"></i>';
                showToast('已取消静音', 'info');
            }
        }

        // 扬声器开关
        function toggleSpeaker() {
            isSpeakerOn = !isSpeakerOn;
            const speakerBtn = document.getElementById('speaker-btn');

            if (isSpeakerOn) {
                speakerBtn.classList.add('active');
                showToast('已开启扬声器', 'info');
            } else {
                speakerBtn.classList.remove('active');
                showToast('已关闭扬声器', 'info');
            }
        }

        // 开始通话计时器
        function startCallTimer() {
            callStartTime = new Date();
            callDuration = 0;

            callTimer = setInterval(() => {
                callDuration = Math.floor((new Date() - callStartTime) / 1000);
                document.getElementById('call-timer').textContent = formatCallDuration(callDuration);
            }, 1000);
        }

        // 停止通话计时器
        function stopCallTimer() {
            if (callTimer) {
                clearInterval(callTimer);
                callTimer = null;
            }
        }

        // 格式化通话时长
        function formatCallDuration(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        // 在通话界面发送消息
        function sendCallMessage() {
            const input = document.getElementById('call-input');
            if (!input) {
                console.error('找不到通话输入框元素');
                return;
            }

            const message = input.value.trim();

            if (!message) return;

            // 添加用户消息到通话界面
            addCallMessage(message, 'sent');

            // 清空输入框
            input.value = '';

            // 显示AI正在说话的指示器
            const typingIndicator = showCallTypingIndicator();

            // 根据通话类型决定是否回复
            if (currentCallCharacter) {
                setTimeout(async () => {
                    try {
                        // 🔥【修复】构建更好的语音通话提示词
                        const prompt = `你是${currentCallCharacter.name}，正在与用户进行语音通话。
用户刚说："${message}"

请用简短自然的口语方式回复，就像真实的电话对话一样：
- 直接说话，不要任何描述性文字
- 保持自然的语音对话风格
- 回复要简洁，1-2句话即可
- 符合你的性格设定

请只回复对话内容，不要JSON格式，不要其他格式：`;

                        try {
                            const response = await callChatAPI(prompt, currentCallCharacter);

                            // 移除输入指示器
                            hideCallTypingIndicator(typingIndicator);

                            // 🔥【关键修复】使用parseAiResponse解析回复，显示所有文本消息
                            const parsedMessages = await parseAiResponse(response);
                            console.log('🔔 通话AI回复解析结果:', parsedMessages);

                            let hasValidMessage = false;
                            if (Array.isArray(parsedMessages) && parsedMessages.length > 0) {
                                // 遍历所有消息，显示每一条文本消息
                                for (const msg of parsedMessages) {
                                    let replyText = '';
                                    if (typeof msg === 'string') {
                                        replyText = msg.trim();
                                    } else if (typeof msg === 'object' && msg.content) {
                                        replyText = msg.content.trim();
                                    }

                                    if (replyText) {
                                        addCallMessage(replyText, 'received');
                                        hasValidMessage = true;
                                        // 添加短暂延迟，让多条消息分开显示
                                        await new Promise(resolve => setTimeout(resolve, 300));
                                    }
                                }
                            }

                            // 如果没有有效消息，使用备用回复
                            if (!hasValidMessage) {
                                if (typeof response === 'string') {
                                    const cleanedText = cleanCallResponse(response);
                                    if (cleanedText) {
                                        addCallMessage(cleanedText, 'received');
                                    } else {
                                        addCallMessage(getRandomCallResponse(), 'received');
                                    }
                                } else {
                                    addCallMessage(getRandomCallResponse(), 'received');
                                }
                            }

                        } catch (error) {
                            console.error('获取AI回复失败:', error);
                            hideCallTypingIndicator(typingIndicator);
                            addCallMessage(getRandomCallResponse(), 'received');
                        }

                    } catch (error) {
                        console.error('通话回复错误:', error);
                        hideCallTypingIndicator(typingIndicator);
                        addCallMessage('我明白了', 'received');
                    }
                }, 1000 + Math.random() * 1000);
            }
        }

        // 添加消息到通话界面
        function addCallMessage(message, type) {
            const container = document.getElementById('call-message-container');
            const messageElement = document.createElement('div');
            messageElement.className = `call-message ${type}`;
            messageElement.textContent = message;

            container.appendChild(messageElement);
            container.scrollTop = container.scrollHeight;

            // 🔥【修复】同时添加到聊天记录，但标记为通话消息
            if (currentChatCharacter && currentChatCharacter.id) {
                const callMessage = {
                    id: generateMessageId(),
                    sender: type === 'sent' ? 'sent' : 'received',  // 修复：使用正确的sender格式
                    content: message,
                    timestamp: Date.now(),
                    isCallMessage: true,
                    type: 'call_message'  // 添加特殊类型标记
                };

                if (!chatMessages[currentChatCharacter.id]) {
                    chatMessages[currentChatCharacter.id] = [];
                }

                chatMessages[currentChatCharacter.id].push(callMessage);
                saveChatMessages();
            }
        }

        // 🔥【新增】显示AI正在说话的指示器
        function showCallTypingIndicator() {
            const container = document.getElementById('call-message-container');
            const typingIndicator = document.createElement('div');
            typingIndicator.className = 'call-typing-indicator';
            typingIndicator.innerHTML = `
                <div class="call-typing-dots">
                    <div class="call-typing-dot"></div>
                    <div class="call-typing-dot"></div>
                    <div class="call-typing-dot"></div>
                </div>
            `;

            container.appendChild(typingIndicator);
            container.scrollTop = container.scrollHeight;

            return typingIndicator;
        }

        // 🔥【新增】隐藏AI正在说话的指示器
        function hideCallTypingIndicator(indicator) {
            if (indicator && indicator.parentNode) {
                indicator.parentNode.removeChild(indicator);
            }
        }

        // 🔥【新增】显示视频通话打字指示器
        function showVideoCallTypingIndicator() {
            const container = document.getElementById('video-call-floating-messages');
            if (!container) {
                console.error('找不到视频通话消息容器元素');
                return null;
            }

            const typingIndicator = document.createElement('div');
            typingIndicator.className = 'floating-message-bubble received video-typing-indicator';
            typingIndicator.innerHTML = `
                <div class="video-typing-dots">
                    <div class="video-typing-dot"></div>
                    <div class="video-typing-dot"></div>
                    <div class="video-typing-dot"></div>
                </div>
            `;

            container.appendChild(typingIndicator);

            // 🔥【修复】确保打字指示器能够正确滚动
            requestAnimationFrame(() => {
                container.scrollTop = container.scrollHeight;
            });

            return typingIndicator;
        }

        // 🔥【新增】隐藏视频通话打字指示器
        function hideVideoCallTypingIndicator(indicator) {
            if (indicator && indicator.parentNode) {
                indicator.parentNode.removeChild(indicator);
            }
        }

        // 🔥【简化】清理通话回复文本 - 因为已经用parseAiResponse处理JSON格式
        function cleanCallResponse(text) {
            if (!text) return '';

            console.log('🧹 原始文本:', text);

            // 基础清理：移除多余空格和换行
            text = text.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();

            // 移除常见的描述性前缀
            text = text.replace(/^(角色说|我说|回复|答案|回答)[:：]\s*/i, '');

            // 移除括号中的描述性内容
            text = text.replace(/\([^)]*\)/g, '');
            text = text.replace(/【[^】]*】/g, '');
            text = text.replace(/\[[^\]]*\]/g, '');

            // 如果文本以标点符号开头，移除它
            text = text.replace(/^[，。！？；：,.!?;:\s]*/, '');

            console.log('🧹 清理后文本:', text);

            // 验证清理结果
            if (!text || text.length < 2) {
                console.log('🧹 文本无效，使用备用回复');
                return getRandomCallResponse();
            }

            // 如果文本太长，截取前面部分
            if (text.length > 60) {
                text = text.substring(0, 60) + '...';
            }

            return text;
        }

        // 随机通话问候语
        function getRandomCallGreeting(characterName) {
            const greetings = [
                `你好，我是${characterName}，很高兴能和你通话。`,
                `嗨，终于能听到你的声音了！`,
                `喂，你好啊，听得到我说话吗？`,
                `你好，谢谢你接我电话。`,
                `嗨，很高兴能和你通话。`
            ];

            return greetings[Math.floor(Math.random() * greetings.length)];
        }

        // 随机通话回复（备用）
        function getRandomCallResponse() {
            const responses = [
                '嗯，我明白了。',
                '好的，我知道了。',
                '是的，你说得对。',
                '我觉得这个想法不错。',
                '嗯，有道理。',
                '哦，真的吗？',
                '我明白你的意思了。',
                '这样啊，我懂了。',
                '确实如此。',
                '我同意你的看法。'
            ];

            return responses[Math.floor(Math.random() * responses.length)];
        }

        // 检测是否应该触发AI主动拨打电话
        function checkForAICallTrigger(userMessage, aiResponse) {
            // 获取当前聊天设置
            const currentChatSettings = getCurrentChatSettings();

            // 如果未启用AI主动拨打电话功能，直接返回
            if (!currentChatSettings.aiCallEnabled) {
                console.log('🔔 AI主动拨打电话功能未开启，角色不会主动拨打电话');
                return false;
            }

            // 如果已经在通话中，不再触发
            if (isInCall || isInVideoCall) {
                console.log('🔔 当前正在通话中，不触发新的来电');
                return false;
            }

            // 确保有当前聊天角色且不是群聊
            if (!currentChatCharacter || currentChatCharacter.isGroup) {
                console.log('🔔 没有当前聊天角色或为群聊，无法触发来电');
                return false;
            }

            // 通话相关关键词
            const callKeywords = ['通话', '电话', '视频', '语音', '打给你', '想听', '想看', '聊天', '说话', '打电话', '来电', '接电话'];

            // 检查用户消息和AI回复中是否包含通话关键词
            const userMessageHasCallKeyword = callKeywords.some(keyword => userMessage.includes(keyword));
            const aiResponseHasCallKeyword = callKeywords.some(keyword => aiResponse.includes(keyword));

            console.log('🔔 检查AI主动拨打触发条件:', {
                userMessage: userMessage.substring(0, 50) + '...',
                aiResponse: aiResponse.substring(0, 50) + '...',
                userHasKeyword: userMessageHasCallKeyword,
                aiHasKeyword: aiResponseHasCallKeyword,
                characterName: currentChatCharacter.name
            });

            // 基于角色人设和对话内容决定触发概率
            let triggerProbability = 0;

            // 1. 基础概率：如果对话中提到通话相关内容
            if (userMessageHasCallKeyword || aiResponseHasCallKeyword) {
                triggerProbability = 0.15; // 基础15%概率

                // 如果双方都提到通话，提升概率
                if (userMessageHasCallKeyword && aiResponseHasCallKeyword) {
                    triggerProbability = 0.35;
                }
            }

            // 2. 根据角色性格调整概率
            const characterBio = (currentChatCharacter.bio || '').toLowerCase();
            if (characterBio.includes('主动') || characterBio.includes('外向') || characterBio.includes('热情') ||
                characterBio.includes('活泼') || characterBio.includes('开朗') || characterBio.includes('积极')) {
                triggerProbability += 0.1;
            }

            // 3. 根据对话情感调整概率
            const emotionalKeywords = ['想你', '想见你', '想和你', '喜欢你', '爱你', '想聊', '想说', '想分享'];
            const hasEmotionalContent = emotionalKeywords.some(keyword =>
                userMessage.includes(keyword) || aiResponse.includes(keyword)
            );
            if (hasEmotionalContent) {
                triggerProbability += 0.1;
            }

            // 4. 随机因素：即使没有明显触发条件，也有小概率触发（模拟角色突然想打电话）
            if (triggerProbability === 0 && Math.random() < 0.03) {
                triggerProbability = 0.03;
                console.log('🔔 角色突然想要打电话（随机触发）');
            }

            // 限制最大概率
            triggerProbability = Math.min(triggerProbability, 0.5);

            if (triggerProbability > 0 && Math.random() < triggerProbability) {
                console.log('🔔 AI主动拨打电话被触发！概率:', triggerProbability);

                // 从AI回复中提取通话理由，如果没有则生成默认理由
                let callReason = extractCallReason(aiResponse);
                if (!callReason || callReason.includes('想和你聊聊天')) {
                    // 根据角色性格生成更个性化的理由
                    const personalizedReasons = [
                        '突然想听听你的声音',
                        '有话想和你说',
                        '想和你聊聊天',
                        '想通过电话和你交流',
                        '觉得打电话会更有意思'
                    ];
                    callReason = personalizedReasons[Math.floor(Math.random() * personalizedReasons.length)];
                }

                // 延迟1-4秒后触发来电，让对话更自然
                const delay = 1000 + Math.random() * 3000;
                console.log(`🔔 将在${Math.round(delay/1000)}秒后发起来电，理由: ${callReason}`);

                setTimeout(() => {
                    console.log('🔔 开始发起AI来电');
                    initiateAICall(currentChatCharacter, callReason);
                }, delay);

                return true;
            } else {
                console.log('🔔 AI主动拨打未触发，概率:', triggerProbability);
            }

            return false;
        }

        // 从AI回复中提取通话理由
        function extractCallReason(aiResponse) {
            // 默认理由
            let defaultReasons = [
                '想和你聊聊天',
                '有事情想告诉你',
                '想听听你的声音',
                '想和你说说话'
            ];

            // 尝试从回复中提取一个合理的句子作为理由
            const sentences = aiResponse.split(/[。！？.!?]/);
            const validSentences = sentences.filter(s => {
                const trimmed = s.trim();
                return trimmed.length > 5 && trimmed.length < 20 && !trimmed.includes('我');
            });

            if (validSentences.length > 0) {
                return validSentences[Math.floor(Math.random() * validSentences.length)].trim();
            }

            return defaultReasons[Math.floor(Math.random() * defaultReasons.length)];
        }

        function openVideoCall() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'error');
                return;
            }

            // 检查是否为群聊
            if (currentChatCharacter.isGroup) {
                showToast('群聊不支持视频通话', 'error');
                return;
            }

            // 🔥【新增】播放拨出通话音效
            SoundManager.play(SoundManager.TYPES.OUTGOING_CALL, currentChatCharacter?.id);

            currentVideoCallCharacter = currentChatCharacter;

            // 获取通话形象设置
            const videoAvatarSettings = getVideoAvatarSettings();

            // 设置视频通话界面
            const characterAvatarSrc = videoAvatarSettings.characterAvatar || currentVideoCallCharacter.avatar || currentVideoCallCharacter.avatarUrl || 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="50" fill="lightgray"/><text x="50" y="60" font-size="30" text-anchor="middle" fill="gray">头像</text></svg>';
            const userAvatarSrc = videoAvatarSettings.userAvatar || 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="50" fill="lightblue"/><text x="50" y="60" font-size="30" text-anchor="middle" fill="white">你</text></svg>';

            document.getElementById('video-call-character-avatar').src = characterAvatarSrc;
            document.getElementById('video-call-user-avatar').src = userAvatarSrc;
            document.getElementById('video-call-name').textContent = currentVideoCallCharacter.name;
            document.getElementById('video-call-status').textContent = '视频通话中...';
            document.getElementById('video-call-timer').textContent = '00:00';

            // 清空浮现消息容器
            const messageContainer = document.getElementById('video-call-floating-messages');
            if (messageContainer) {
                messageContainer.innerHTML = '';
            }

            // 显示视频通话界面
            showApp('video-call-screen');

            // 开始计时
            startVideoCallTimer();

            // 设置通话状态
            isInVideoCall = true;
            isVideoMuted = false;
            isVideoCameraOff = false;

            // 更新按钮状态
            updateVideoCallButtons();

            // 发送系统消息到聊天记录
            const videoCallStartMessage = {
                id: generateMessageId(),
                sender: 'system',
                content: `${currentVideoCallCharacter.name}已接通视频通话`,
                timestamp: Date.now(),
                type: 'call_record',
                callType: 'outgoing',
                callStatus: 'started'
            };

            addMessageToChat(videoCallStartMessage);

            // 用户主动拨打视频通话时不自动添加角色回应，等待用户先说话
            window.isUserInitiatedVideoCall = true;
        }

        // 🔥【新增】视频通话相关函数
        function startVideoCallTimer() {
            videoCallStartTime = new Date();
            videoCallDuration = 0;

            videoCallTimer = setInterval(() => {
                videoCallDuration = Math.floor((new Date() - videoCallStartTime) / 1000);
                document.getElementById('video-call-timer').textContent = formatCallDuration(videoCallDuration);
            }, 1000);
        }

        function stopVideoCallTimer() {
            if (videoCallTimer) {
                clearInterval(videoCallTimer);
                videoCallTimer = null;
            }
        }

        function endVideoCall() {
            if (!isInVideoCall) return;

            // 停止计时
            stopVideoCallTimer();

            // 隐藏视频通话界面
            hideApp('video-call-screen');

            // 返回聊天界面
            showApp('api-chat-screen');

            // 发送系统消息到聊天记录
            const formattedDuration = formatCallDuration(videoCallDuration);
            const videoCallEndedMessage = {
                id: generateMessageId(),
                sender: 'system',
                content: `视频通话已结束，通话时长 ${formattedDuration}`,
                timestamp: Date.now(),
                type: 'call_record',
                callType: 'ended',
                callStatus: 'completed',
                duration: formattedDuration
            };

            addMessageToChat(videoCallEndedMessage);

            // 重置视频通话状态
            isInVideoCall = false;
            isVideoMuted = false;
            isVideoCameraOff = false;

            currentVideoCallCharacter = null;
            window.isUserInitiatedVideoCall = false;
        }

        function toggleVideoMute() {
            isVideoMuted = !isVideoMuted;
            updateVideoCallButtons();

            const muteBtn = document.getElementById('video-mute-btn');
            if (isVideoMuted) {
                showToast('已静音', 'info');
            } else {
                showToast('已取消静音', 'info');
            }
        }

        function toggleVideoCamera() {
            isVideoCameraOff = !isVideoCameraOff;
            updateVideoCallButtons();

            const userWindow = document.querySelector('.video-call-user-window');
            if (isVideoCameraOff) {
                userWindow.style.background = '#333';
                userWindow.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: white; font-size: 12px;"><i class="fas fa-video-slash"></i></div>';
                showToast('摄像头已关闭', 'info');
            } else {
                const userAvatarSettings = getVideoAvatarSettings();
                const userAvatarSrc = userAvatarSettings.userAvatar || 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="50" fill="lightblue"/><text x="50" y="60" font-size="30" text-anchor="middle" fill="white">你</text></svg>';
                userWindow.style.background = '';
                userWindow.innerHTML = `<img id="video-call-user-avatar" src="${userAvatarSrc}" alt="用户通话形象" class="user-video-avatar">`;
                showToast('摄像头已开启', 'info');
            }
        }

        function updateVideoCallButtons() {
            const muteBtn = document.getElementById('video-mute-btn');
            const cameraBtn = document.getElementById('video-camera-btn');

            if (muteBtn) {
                if (isVideoMuted) {
                    muteBtn.classList.add('muted');
                    muteBtn.innerHTML = '<i class="fas fa-microphone-slash"></i>';
                } else {
                    muteBtn.classList.remove('muted');
                    muteBtn.innerHTML = '<i class="fas fa-microphone"></i>';
                }
            }

            if (cameraBtn) {
                if (isVideoCameraOff) {
                    cameraBtn.classList.add('camera-off');
                    cameraBtn.innerHTML = '<i class="fas fa-video-slash"></i>';
                } else {
                    cameraBtn.classList.remove('camera-off');
                    cameraBtn.innerHTML = '<i class="fas fa-video"></i>';
                }
            }
        }



        function sendVideoCallMessage() {
            const input = document.getElementById('video-call-input');
            if (!input) {
                console.error('找不到视频通话输入框元素');
                return;
            }

            const message = input.value.trim();

            if (!message) return;

            // 添加用户消息到视频通话界面
            addVideoCallMessage(message, 'sent');

            // 清空输入框
            input.value = '';

            // 显示AI正在回复的指示器
            const typingIndicator = showVideoCallTypingIndicator();

            // 根据通话类型决定是否回复
            if (currentVideoCallCharacter) {
                setTimeout(async () => {
                    try {
                        // 构建视频通话提示词
                        const prompt = `你是${currentVideoCallCharacter.name}，正在与用户进行视频通话。
用户刚说："${message}"

请回复，可以包含对话和描写：
- 说话的部分用「」符号包裹，如：「你好，听得到我说话吗？」
- 可以加入动作描写、神态描写、场景描写等，让视频通话更生动
- 每次回复不要超过300字
- 保持自然的视频对话风格
- 符合你的角色设定

直接回复内容，不要任何格式标记：`;

                        const response = await callChatAPI(prompt, currentVideoCallCharacter);

                        if (response && response.trim()) {
                            // 移除打字指示器
                            hideVideoCallTypingIndicator(typingIndicator);

                            // 解析AI回复并显示 - 使用与语音通话相同的逻辑
                            const parsedMessages = await parseAiResponse(response);
                            console.log('🔔 视频通话AI回复解析结果:', parsedMessages);

                            let hasValidMessage = false;
                            if (Array.isArray(parsedMessages) && parsedMessages.length > 0) {
                                // 遍历所有消息，显示每一条文本消息
                                for (const msg of parsedMessages) {
                                    let replyText = '';
                                    if (typeof msg === 'string') {
                                        replyText = msg.trim();
                                    } else if (typeof msg === 'object' && msg.content) {
                                        replyText = msg.content.trim();
                                    }

                                    if (replyText) {
                                        addVideoCallMessage(replyText, 'received');
                                        hasValidMessage = true;
                                        // 添加短暂延迟，让多条消息分开显示
                                        await new Promise(resolve => setTimeout(resolve, 300));
                                    }
                                }
                            }

                            if (!hasValidMessage) {
                                const cleanResponse = cleanCallResponse(response);
                                if (cleanResponse && cleanResponse.trim()) {
                                    addVideoCallMessage(cleanResponse.trim(), 'received');
                                } else {
                                    addVideoCallMessage(getRandomCallResponse(), 'received');
                                }
                            }
                        } else {
                            hideVideoCallTypingIndicator(typingIndicator);
                            addVideoCallMessage(getRandomCallResponse(), 'received');
                        }

                    } catch (error) {
                        console.error('视频通话回复错误:', error);
                        hideVideoCallTypingIndicator(typingIndicator);
                        addVideoCallMessage('我明白了', 'received');
                    }
                }, 1000 + Math.random() * 1000);
            }
        }

        function addVideoCallMessage(message, type) {
            const container = document.getElementById('video-call-floating-messages');
            if (!container) {
                console.error('找不到视频通话消息容器元素');
                return;
            }

            // 创建浮现消息气泡
            const messageElement = document.createElement('div');
            messageElement.className = `floating-message-bubble ${type}`;
            messageElement.textContent = message;

            // 直接添加消息到容器
            container.appendChild(messageElement);

            // 🔥【修复】确保消息能够正确滚动
            // 使用 requestAnimationFrame 确保DOM更新后再滚动
            requestAnimationFrame(() => {
                container.scrollTop = container.scrollHeight;
            });

            // 同时添加到聊天记录，但标记为视频通话消息
            if (currentVideoCallCharacter && currentVideoCallCharacter.id) {
                const videoCallMessage = {
                    id: generateMessageId(),
                    sender: type === 'sent' ? 'sent' : 'received',
                    content: message,
                    timestamp: Date.now(),
                    type: 'call_message'
                };

                addMessageToChat(videoCallMessage);
            }
        }



        // 🔥【新增】视频通话形象设置相关函数
        function showVideoAvatarModal() {
            // 加载当前设置
            const settings = getVideoAvatarSettings();

            // 更新预览图片
            const characterPreview = document.getElementById('character-video-avatar-preview');
            const userPreview = document.getElementById('user-video-avatar-preview');
            const characterPlaceholder = document.getElementById('character-avatar-placeholder');
            const userPlaceholder = document.getElementById('user-avatar-placeholder');

            if (settings.characterAvatar) {
                characterPreview.src = settings.characterAvatar;
                characterPreview.style.display = 'block';
                characterPlaceholder.style.display = 'none';
            } else {
                characterPreview.style.display = 'none';
                characterPlaceholder.style.display = 'flex';
            }

            if (settings.userAvatar) {
                userPreview.src = settings.userAvatar;
                userPreview.style.display = 'block';
                userPlaceholder.style.display = 'none';
            } else {
                userPreview.style.display = 'none';
                userPlaceholder.style.display = 'flex';
            }

            document.getElementById('video-avatar-modal').style.display = 'flex';
        }

        function hideVideoAvatarModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('video-avatar-modal').style.display = 'none';
        }

        function changeCharacterVideoAvatar() {
            document.getElementById('character-video-avatar-input').click();
        }

        function changeUserVideoAvatar() {
            document.getElementById('user-video-avatar-input').click();
        }

        function handleCharacterVideoAvatarChange(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const preview = document.getElementById('character-video-avatar-preview');
                    const placeholder = document.getElementById('character-avatar-placeholder');

                    preview.src = e.target.result;
                    preview.style.display = 'block';
                    placeholder.style.display = 'none';
                };
                reader.readAsDataURL(file);
            }
        }

        function handleUserVideoAvatarChange(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const preview = document.getElementById('user-video-avatar-preview');
                    const placeholder = document.getElementById('user-avatar-placeholder');

                    preview.src = e.target.result;
                    preview.style.display = 'block';
                    placeholder.style.display = 'none';
                };
                reader.readAsDataURL(file);
            }
        }

        function saveVideoAvatarSettings() {
            const characterPreview = document.getElementById('character-video-avatar-preview');
            const userPreview = document.getElementById('user-video-avatar-preview');

            const settings = {
                characterAvatar: characterPreview.style.display === 'block' ? characterPreview.src : null,
                userAvatar: userPreview.style.display === 'block' ? userPreview.src : null
            };

            // 保存到localStorage
            if (currentChatCharacter && currentChatCharacter.id) {
                const key = `videoAvatarSettings_${currentChatCharacter.id}`;
                localStorage.setItem(key, JSON.stringify(settings));
                showToast('通话形象设置已保存', 'success');
            }

            hideVideoAvatarModal();
        }

        function getVideoAvatarSettings() {
            if (!currentChatCharacter || !currentChatCharacter.id) {
                return { characterAvatar: null, userAvatar: null };
            }

            const key = `videoAvatarSettings_${currentChatCharacter.id}`;
            const saved = localStorage.getItem(key);

            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (error) {
                    console.error('解析视频通话形象设置失败:', error);
                }
            }

            return { characterAvatar: null, userAvatar: null };
        }

        // 🔥【新增】更新视频通话形象设置的显示状态
        function updateVideoAvatarSettingVisibility() {
            const videoAvatarSetting = document.getElementById('video-avatar-setting');
            if (videoAvatarSetting) {
                // 只在单聊时显示视频通话形象设置
                if (currentChatCharacter && !currentChatCharacter.isGroup) {
                    videoAvatarSetting.style.display = 'flex';  // 使用flex而不是block
                } else {
                    videoAvatarSetting.style.display = 'none';
                }
            }
        }

        function shareLocation() {
            if (!currentChatCharacter) {
                alert('请先选择一个角色');
                return;
            }

            // 重置输入框
            document.getElementById('location-address').value = '';
            document.getElementById('map-location-display').textContent = '请输入位置名称';

            // 随机化地图显示
            randomizeMapPosition();

            // 加载历史记录
            renderLocationHistory();

            // 显示模态框
            document.getElementById('chat-location-modal').style.display = 'flex';
        }

        function hideChatLocationModal() {
            document.getElementById('chat-location-modal').style.display = 'none';
        }

        function setLocationAddress(address) {
            document.getElementById('location-address').value = address;
            document.getElementById('map-location-display').textContent = address;

            // 生成随机坐标
            const lat = (39.8 + Math.random() * 0.4).toFixed(4);
            const lng = (116.2 + Math.random() * 0.4).toFixed(4);
            document.querySelector('.map-coordinates').textContent = `${lng}°E, ${lat}°N`;
        }

        function randomizeMapPosition() {
            const marker = document.getElementById('location-marker');
            const buildings = document.querySelectorAll('.building');

            // 随机移动标记位置
            const newTop = 20 + Math.random() * 60; // 20% - 80%
            const newLeft = 20 + Math.random() * 60; // 20% - 80%
            marker.style.top = newTop + '%';
            marker.style.left = newLeft + '%';

            // 随机移动建筑物
            buildings.forEach(building => {
                const top = Math.random() * 85; // 0% - 85%
                const left = Math.random() * 85; // 0% - 85%
                building.style.top = top + '%';
                building.style.left = left + '%';
            });

            // 更新坐标
            const lat = (39.8 + Math.random() * 0.4).toFixed(4);
            const lng = (116.2 + Math.random() * 0.4).toFixed(4);
            document.querySelector('.map-coordinates').textContent = `${lng}°E, ${lat}°N`;
        }

        // 生成逼真的地图HTML内容
        function generateRealisticMapHTML() {
            return `
                <div class="map-background"></div>
                <!-- 弯曲河流 -->
                <div class="river" style="top: 5%; left: 60%; width: 20px; height: 3px; transform: rotate(35deg);"></div>
                <div class="river-curve" style="top: 12%; left: 72%; width: 18px; height: 3px; transform: rotate(15deg);"></div>
                <div class="river" style="top: 18%; left: 80%; width: 16px; height: 3px; transform: rotate(-5deg);"></div>
                <div class="river-curve" style="top: 22%; left: 85%; width: 15px; height: 3px; transform: rotate(-25deg);"></div>
                <div class="river" style="top: 55%; left: 2%; width: 22px; height: 3px; transform: rotate(-10deg);"></div>
                <div class="river-curve" style="top: 62%; left: 18%; width: 20px; height: 3px; transform: rotate(8deg);"></div>
                <div class="river" style="top: 68%; left: 32%; width: 18px; height: 3px; transform: rotate(25deg);"></div>
                <!-- 公园绿地 -->
                <div class="park" style="top: 20%; left: 65%; width: 18px; height: 15px;"></div>
                <div class="park" style="top: 45%; left: 10%; width: 22px; height: 18px;"></div>
                <!-- 道路 -->
                <div class="map-roads">
                    <div class="road road-horizontal" style="top: 35%; width: 100%;"></div>
                    <div class="road road-vertical" style="left: 40%; height: 100%;"></div>
                    <div class="road road-horizontal" style="top: 65%; width: 70%; left: 30%;"></div>
                </div>
                <!-- 建筑物 -->
                <div class="map-buildings">
                    <div class="building house" style="top: 15%; left: 20%; width: 12px; height: 10px;"></div>
                    <div class="building office" style="top: 25%; left: 45%; width: 8px; height: 16px;"></div>
                    <div class="building shop" style="top: 50%; left: 50%; width: 14px; height: 8px;"></div>
                    <div class="building house" style="top: 70%; left: 75%; width: 10px; height: 8px;"></div>
                    <div class="building office" style="top: 8%; left: 85%; width: 6px; height: 12px;"></div>
                </div>
                <!-- 树木 -->
                <div class="tree big" style="top: 25%; left: 15%; width: 6px; height: 6px;"></div>
                <div class="tree small" style="top: 55%; left: 25%; width: 4px; height: 4px;"></div>
                <div class="tree big" style="top: 10%; left: 70%; width: 5px; height: 5px;"></div>
                <div class="tree small" style="top: 75%; left: 85%; width: 3px; height: 3px;"></div>
                <div class="tree small" style="top: 40%; left: 80%; width: 4px; height: 4px;"></div>
                <!-- 位置标记 -->
                <div class="map-marker">
                    <div class="marker-pin">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                            <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                        </svg>
                    </div>
                </div>
            `;
        }

        // 历史地点管理
        let locationHistory = JSON.parse(localStorage.getItem('locationHistory') || '[]');

        function saveLocationHistory() {
            localStorage.setItem('locationHistory', JSON.stringify(locationHistory));
        }

        function addToLocationHistory(locationName) {
            if (!locationName.trim()) return;

            // 移除重复项
            locationHistory = locationHistory.filter(name => name !== locationName);
            // 添加到开头
            locationHistory.unshift(locationName);
            // 限制最多保存10个
            if (locationHistory.length > 10) {
                locationHistory = locationHistory.slice(0, 10);
            }

            saveLocationHistory();
            renderLocationHistory();
        }

        function removeFromLocationHistory(locationName) {
            locationHistory = locationHistory.filter(name => name !== locationName);
            saveLocationHistory();
            renderLocationHistory();
        }

        function renderLocationHistory() {
            const container = document.getElementById('location-history-items');
            if (!container) return;

            if (locationHistory.length === 0) {
                container.innerHTML = '<div class="location-history-empty">暂无历史记录</div>';
                return;
            }

            container.innerHTML = locationHistory.map(location =>
                `<div class="location-history-item" data-location="${location}">
                    <span class="location-text">${location}</span>
                    <span class="delete-btn" data-location="${location}" title="删除">×</span>
                </div>`
            ).join('');

            // 🔥【修复】使用事件委托绑定点击事件，避免内联onclick问题
            container.onclick = function(e) {
                const locationItem = e.target.closest('.location-history-item');
                if (!locationItem) return;

                const location = locationItem.dataset.location;

                if (e.target.classList.contains('delete-btn')) {
                    // 点击删除按钮
                    e.stopPropagation();
                    confirmDeleteLocation(location);
                } else {
                    // 点击位置项
                    setLocationAddress(location);
                }
            };
        }

        // 长按删除处理
        let touchTimer = null;
        let touchedElement = null;

        function handleLocationTouchStart(event, location) {
            touchedElement = event.target;
            touchTimer = setTimeout(() => {
                confirmDeleteLocation(location);
            }, 800); // 800ms长按
        }

        function handleLocationTouchEnd(event) {
            if (touchTimer) {
                clearTimeout(touchTimer);
                touchTimer = null;
            }
            if (touchedElement) {
                touchedElement.classList.remove('deleting');
                touchedElement = null;
            }
        }

        function confirmDeleteLocation(location) {
            if (touchedElement) {
                touchedElement.classList.add('deleting');
            }

            if (confirm(`确定要删除位置"${location}"吗？`)) {
                removeFromLocationHistory(location);
                showToast('位置已删除', 'success');
            } else if (touchedElement) {
                touchedElement.classList.remove('deleting');
            }
        }

        function sendLocationMessage() {
            const address = document.getElementById('location-address').value.trim();
            if (!address) {
                alert('请输入位置名称');
                return;
            }

            // 添加到历史记录
            addToLocationHistory(address);

            // 创建位置消息
            const locationMessage = {
                id: Date.now().toString(),
                sender: 'sent',
                type: 'location',
                locationName: address,
                coordinates: document.querySelector('.map-coordinates').textContent,
                content: `[用户分享了位置信息：${address}，坐标：${document.querySelector('.map-coordinates').textContent}]`,
                timestamp: Date.now()
            };

            console.log('🗺️ 创建位置消息:', locationMessage);

            // 🔥【调试】检查消息数据
            if (!locationMessage.locationName || !locationMessage.coordinates) {
                console.error('❌ 位置消息数据不完整:', {
                    locationName: locationMessage.locationName,
                    coordinates: locationMessage.coordinates
                });
                alert('位置信息不完整，请重试');
                return;
            }

            // 添加到聊天记录
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            chatMessages[currentChatCharacter.id].push(locationMessage);

            // 保存到数据库
            saveChatMessages();

            // 使用动画添加消息而不是重新渲染整个列表
            addMessageWithAnimation(locationMessage, currentChatCharacter.id);

            // 设置为待回复消息
            pendingUserMessage = locationMessage;

            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = '点击获取AI回复';
            }

            // 更新联系人列表
            renderMessageList();

            // 关闭模态框
            hideChatLocationModal();

            showToast('位置已分享', 'success');
        }

        // 更新已存在的位置卡片地图
        function updateExistingLocationMaps() {
            const locationMaps = document.querySelectorAll('.location-card-map');
            locationMaps.forEach(mapElement => {
                // 检查是否需要更新（没有新的地图元素）
                if (!mapElement.querySelector('.river')) {
                    mapElement.innerHTML = generateRealisticMapHTML();
                }
            });
        }

        // 监听位置输入框的变化
        document.addEventListener('DOMContentLoaded', function() {
            const locationInput = document.getElementById('location-address');
            if (locationInput) {
                locationInput.addEventListener('input', function() {
                    const value = this.value.trim();
                    if (value) {
                        document.getElementById('map-location-display').textContent = value;

                        // 生成随机坐标
                        const lat = (39.8 + Math.random() * 0.4).toFixed(4);
                        const lng = (116.2 + Math.random() * 0.4).toFixed(4);
                        document.querySelector('.map-coordinates').textContent = `${lng}°E, ${lat}°N`;
                    } else {
                        document.getElementById('map-location-display').textContent = '请输入位置名称';
                    }
                });
            }

            // 点击模态框背景关闭
            document.getElementById('chat-location-modal')?.addEventListener('click', (e) => {
                if (e.target === document.getElementById('chat-location-modal')) {
                    hideChatLocationModal();
                }
            });

            // 定期更新现有的位置卡片地图
            setInterval(updateExistingLocationMaps, 1000);
        });

        // 显示位置详情
        function showLocationDetail(locationName) {
            alert(`🗺️ ${locationName}`);
        }

        // 📊 数据管理相关函数

        // 计算存储空间使用情况
        async function calculateStorageUsage() {
            try {
                let chatSize = 0, characterSize = 0, settingsSize = 0, emojiSize = 0;

                const [chatData, charData, settingsData, emojiData] = await Promise.all([
                    db.chatMessages.toArray(),
                    db.characters.toArray(),
                    db.chatSettings.toArray(),
                    db.customEmojis.toArray()
                ]);

                chatSize = JSON.stringify(chatData).length;
                characterSize = JSON.stringify(charData).length;
                settingsSize = JSON.stringify(settingsData).length;
                emojiSize = JSON.stringify(emojiData).length;
                const total = chatSize + characterSize + settingsSize + emojiSize;

                // 更新显示
                const formatBytes = (bytes) => {
                    if (bytes === 0) return '0 B';
                    const k = 1024;
                    const sizes = ['B', 'KB', 'MB', 'GB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                };

                if (document.getElementById('chat-storage-size')) {
                    document.getElementById('chat-storage-size').textContent = formatBytes(chatSize);
                    document.getElementById('character-storage-size').textContent = formatBytes(characterSize);
                    document.getElementById('settings-storage-size').textContent = formatBytes(settingsSize);
                    document.getElementById('emoji-storage-size').textContent = formatBytes(emojiSize);
                    document.getElementById('total-storage-size').textContent = formatBytes(total);
                }
            } catch (error) {
                console.error('计算存储失败:', error);
            }
        }

        // 🔥【新增】浏览器兼容性诊断函数
        function diagnoseBrowserCompatibility() {
            console.log('🔍 浏览器兼容性诊断报告:');
            console.log('浏览器信息:', {
                userAgent: navigator.userAgent,
                vendor: navigator.vendor,
                platform: navigator.platform
            });
            console.log('数据状态:', {
                charactersCount: characters.length,
                contactsCount: contacts.length,
                chatMessagesKeys: Object.keys(chatMessages).length,
                charactersData: characters.slice(0, 2), // 只显示前2个角色的数据
                contactsData: contacts.slice(0, 10) // 只显示前10个联系人ID
            });
            console.log('DOM状态:', {
                messageListExists: !!document.getElementById('message-list'),
                messageItemsCount: document.querySelectorAll('.message-item').length
            });
            console.log('IndexedDB状态:', {
                dbVersion: db.verno,
                dbTables: db.tables.map(t => t.name)
            });
        }

        // 🔥【新增】强制修复数据不一致问题
        async function forceFixDataConsistency() {
            try {
                console.log('🔧 开始强制修复数据一致性...');
                showToast('正在修复数据一致性...', 'info');

                // 1. 重新加载所有基础数据
                await Promise.all([
                    loadCharacters(),
                    loadChatMessages()
                ]);

                // 2. 智能修复联系人列表
                if (characters.length > 0 && contacts.length === 0) {
                    // 检查是否有聊天记录
                    const chatCharacterIds = Object.keys(chatMessages).filter(id =>
                        characters.some(char => char.id === id)
                    );

                    if (chatCharacterIds.length > 0) {
                        contacts = chatCharacterIds;
                        await saveContacts();
                        console.log(`🔧 从聊天记录恢复了 ${contacts.length} 个联系人`);
                    } else {
                        console.log('🔧 无聊天记录，保持联系人为空');
                    }
                } else {
                    console.log('🔧 联系人状态正常，无需修复');
                }

                // 3. 重新渲染界面
                renderMessageList();
                renderContactList();

                console.log('✅ 数据一致性修复完成');
                showToast('数据一致性修复完成', 'success');

            } catch (error) {
                console.error('❌ 数据一致性修复失败:', error);
                showToast('数据一致性修复失败', 'error');
            }
        }

        // 🔥【新增】全局调试工具 - 暴露给控制台使用
        window.debugTools = {
            // 诊断浏览器兼容性
            diagnose: diagnoseBrowserCompatibility,

            // 强制修复数据一致性
            fix: forceFixDataConsistency,

            // 查看当前数据状态
            showData: function() {
                console.log('📊 当前数据状态:');
                console.log('角色数据:', characters);
                console.log('联系人数据:', contacts);
                console.log('聊天消息:', chatMessages);
                console.log('DOM状态:', {
                    messageItems: document.querySelectorAll('.message-item').length,
                    contactItems: document.querySelectorAll('.contact-item').length
                });
            },

            // 重新渲染界面
            rerender: function() {
                console.log('🔄 重新渲染界面...');
                renderMessageList();
                renderContactList();
                renderCharacterList();
                console.log('✅ 重新渲染完成');
            },

            // 清理并重新加载数据
            reload: async function() {
                console.log('🔄 重新加载所有数据...');
                await Promise.all([
                    loadCharacters(),
                    loadContacts(),
                    loadChatMessages()
                ]);
                this.rerender();
                console.log('✅ 数据重新加载完成');
            },

            // 🔥【新增】测试删除对话功能
            testDeleteConversation: function() {
                console.log('🧪 测试删除对话功能...');
                console.log('删除前状态:', {
                    charactersCount: characters.length,
                    contactsCount: contacts.length,
                    contacts: [...contacts]
                });

                if (contacts.length > 0) {
                    const testId = contacts[0];
                    console.log(`🧪 模拟删除对话: ${testId}`);

                    // 模拟删除操作
                    const index = contacts.indexOf(testId);
                    if (index > -1) {
                        contacts.splice(index, 1);
                        saveContacts();
                        this.rerender();

                        console.log('删除后状态:', {
                            contactsCount: contacts.length,
                            contacts: [...contacts]
                        });
                        console.log('✅ 删除测试完成，刷新页面验证是否会重新出现');
                    }
                } else {
                    console.log('⚠️ 没有对话可以测试删除');
                }
            }
        };

        // 在控制台显示调试工具使用说明
        console.log('🛠️ 调试工具已加载！在控制台中使用以下命令:');
        console.log('debugTools.diagnose() - 诊断浏览器兼容性');
        console.log('debugTools.fix() - 智能修复数据一致性问题（不会恢复已删除的对话）');
        console.log('debugTools.showData() - 查看当前数据状态');
        console.log('debugTools.rerender() - 重新渲染界面');
        console.log('debugTools.reload() - 重新加载所有数据');
        console.log('debugTools.testDeleteConversation() - 测试删除对话功能');
        console.log('💡 注意：修复功能只会恢复有聊天记录但缺少联系人的对话，不会恢复用户主动删除的对话');

        // 🔥【优化】导出所有数据 - 针对大数据量和Safari内存限制优化
        async function exportAllData() {
            try {
                // 🔥【Safari优化】检查是否为Safari浏览器
                const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

                if (isSafari && isMobile) {
                    showToast('检测到Safari移动版，使用优化模式...', 'info');
                } else {
                    showToast('正在导出数据...', 'info');
                }

                // 🔥【内存检查】尝试估算可用内存
                let memoryInfo = null;
                if ('memory' in performance) {
                    memoryInfo = performance.memory;
                    console.log('🧠 内存信息:', {
                        used: Math.round(memoryInfo.usedJSHeapSize / 1024 / 1024) + 'MB',
                        total: Math.round(memoryInfo.totalJSHeapSize / 1024 / 1024) + 'MB',
                        limit: Math.round(memoryInfo.jsHeapSizeLimit / 1024 / 1024) + 'MB'
                    });
                }

                // 🔥【调试】检查数据库版本和表是否存在
                console.log('🔍 数据库版本:', db.verno);
                console.log('🔍 数据库表列表:', db.tables.map(t => t.name));

                // 🔥【内存优化】分批加载数据，避免一次性加载过多数据导致内存溢出
                showToast('正在分析数据大小...', 'info');

                // 🔥【内存优化】分批加载数据，避免Safari内存溢出
                const exportData = {
                    version: '6.1', // 🔥【更新版本号】优化大数据量导出
                    exportTime: new Date().toISOString()
                };

                // 🔥【预检查】先检查最大的表（聊天消息）的大小
                try {
                    const chatMessageCount = await db.chatMessages.count();
                    const groupMessageCount = await db.groupChatMessages.count();
                    const totalMessages = chatMessageCount + groupMessageCount;

                    console.log(`📊 消息数量统计: 聊天消息 ${chatMessageCount} 条, 群聊消息 ${groupMessageCount} 条, 总计 ${totalMessages} 条`);

                    // 🔥【智能建议】如果消息数量过多，建议使用轻量级导出
                    if (totalMessages > 10000) {
                        const useLight = confirm(
                            `检测到大量消息数据 (${totalMessages} 条)\n\n` +
                            `为避免导出失败，建议使用轻量级导出。\n\n` +
                            `轻量级导出包含：角色、消息、记忆系统、世界书、论坛等核心数据\n` +
                            `不包含：动态、表情包、音乐等扩展数据\n\n` +
                            `点击"确定"使用轻量级导出\n` +
                            `点击"取消"继续完整导出（可能失败）`
                        );

                        if (useLight) {
                            await exportLightweightData();
                            return;
                        }
                    }
                } catch (preCheckError) {
                    console.warn('⚠️ 预检查失败，继续正常导出:', preCheckError);
                }

                // 🔥【分批处理】定义数据表加载顺序，优先加载小表
                const tableLoadOrder = [
                    // 第一批：小表（配置和设置）
                    { name: 'characters', label: '角色' },
                    { name: 'chatSettings', label: '聊天设置' },
                    { name: 'contacts', label: '联系人' },
                    { name: 'personas', label: '用户面具' },
                    { name: 'characterGroups', label: '角色分组' },
                    { name: 'groupChats', label: '群聊' },
                    { name: 'worldbooks', label: '世界书' },
                    { name: 'apiSettings', label: 'API设置' },
                    { name: 'globalSettings', label: '全局设置' },
                    { name: 'wallpapers', label: '壁纸' },
                    { name: 'appIcons', label: '应用图标' },
                    { name: 'anniversaries', label: '纪念日' },
                    { name: 'diarySettings', label: '日记设置' },

                    // 第二批：中等表
                    { name: 'worldbookEntries', label: '世界书条目' },
                    { name: 'customEmojis', label: '自定义表情' },
                    { name: 'recentEmojis', label: '最近表情' },
                    { name: 'groupChatMembers', label: '群聊成员' },
                    { name: 'moments', label: '动态' },
                    { name: 'momentLikes', label: '动态点赞' },
                    { name: 'momentComments', label: '动态评论' },
                    { name: 'characterDiaries', label: '角色日记' },
                    { name: 'innerThoughts', label: '心声' },

                    // 第三批：论坛相关
                    { name: 'forums', label: '论坛' },
                    { name: 'forumPosts', label: '论坛帖子' },
                    { name: 'forumReplies', label: '论坛回复' },
                    { name: 'forumFavorites', label: '论坛收藏' },
                    { name: 'replyLikes', label: '回复点赞' },
                    { name: 'forumPostImages', label: '论坛图片' },
                    { name: 'forumMountedWorldbooks', label: '论坛世界书' },

                    // 第四批：记忆系统（可能较大）
                    { name: 'workingMemory', label: '工作记忆' },
                    { name: 'episodicMemory', label: '情节记忆' },
                    { name: 'episodicMemories', label: '情景记忆' },
                    { name: 'memorySummaries', label: '记忆总结' },
                    { name: 'memoryEvents', label: '记忆事件' },
                    { name: 'coreMemory', label: '核心记忆' },
                    { name: 'coreMemories', label: '核心记忆库' },
                    { name: 'crossAppTimeline', label: '时间线' },

                    // 第五批：其他系统
                    { name: 'blacklist', label: '拉黑列表' },
                    { name: 'blockedCharacters', label: '被拉黑角色' },
                    { name: 'friendRequests', label: '好友申请' },
                    { name: 'characterStatus', label: '角色状态' },
                    { name: 'offlineHistoryRecords', label: '线下记录' },
                    { name: 'offlineUISettings', label: '线下界面设置' },
                    { name: 'offlinePresets', label: '线下预设' },
                    { name: 'musicPlaylist', label: '音乐播放列表' },
                    { name: 'musicCovers', label: '音乐封面' },

                    // 🔥【新增】短信应用独立数据
                    { name: 'smsContacts', label: '短信联系人' },
                    { name: 'smsMessages', label: '短信消息' },

                    // 最后：最大的表（聊天消息和群聊消息）
                    { name: 'chatMessages', label: '聊天消息' },
                    { name: 'groupChatMessages', label: '群聊消息' }
                ];

                let loadedTables = 0;
                const totalTables = tableLoadOrder.length;

                // 🔥【分批加载】逐个加载数据表
                for (const tableInfo of tableLoadOrder) {
                    try {
                        showToast(`正在加载 ${tableInfo.label}... (${loadedTables + 1}/${totalTables})`, 'info');

                        // 检查表是否存在
                        if (db[tableInfo.name]) {
                            const data = await db[tableInfo.name].toArray();
                            exportData[tableInfo.name] = data;
                            console.log(`✅ 加载 ${tableInfo.label}: ${data.length} 条记录`);
                        } else {
                            console.warn(`⚠️ 表 ${tableInfo.name} 不存在，跳过`);
                            exportData[tableInfo.name] = [];
                        }

                        loadedTables++;

                        // 🔥【内存管理】每加载几个表就强制垃圾回收
                        if (loadedTables % 5 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 100)); // 给浏览器一些时间
                        }

                    } catch (error) {
                        console.error(`❌ 加载 ${tableInfo.label} 失败:`, error);
                        exportData[tableInfo.name] = [];
                    }
                }

                showToast('正在生成导出文件...', 'info');

                // 显示导出统计
                const stats = [];
                // 基础数据统计
                if (exportData.characters?.length) stats.push(`角色: ${exportData.characters.length}个`);
                if (exportData.chatMessages?.length) stats.push(`消息: ${exportData.chatMessages.length}条`);
                if (exportData.personas?.length) stats.push(`面具: ${exportData.personas.length}个`);
                if (exportData.contacts?.length) stats.push(`联系人: ${exportData.contacts.length}个`);
                // 表情包系统
                if (exportData.customEmojis?.length) stats.push(`表情: ${exportData.customEmojis.length}个`);
                if (exportData.recentEmojis?.length) stats.push(`最近表情: ${exportData.recentEmojis.length}个`);
                // 世界书系统
                if (exportData.worldbooks?.length) stats.push(`世界书: ${exportData.worldbooks.length}个`);
                if (exportData.worldbookEntries?.length) stats.push(`世界书条目: ${exportData.worldbookEntries.length}条`);
                // 群聊系统
                if (exportData.groupChats?.length) {
                    stats.push(`群聊: ${exportData.groupChats.length}个`);

                    // 🔥【修复】统计群聊消息数量 - 从chatMessages中筛选群聊消息
                    let groupChatMessageCount = 0;
                    if (exportData.chatMessages?.length && exportData.groupChats?.length) {
                        const groupChatIds = exportData.groupChats.map(g => g.id);
                        groupChatMessageCount = exportData.chatMessages.filter(msg =>
                            groupChatIds.includes(msg.characterId)
                        ).length;
                    }
                    if (groupChatMessageCount > 0) {
                        stats.push(`群聊消息: ${groupChatMessageCount}条`);
                    }

                    // 🔥【修复】统计群聊成员数量 - 从群聊对象的members属性中统计
                    let groupMemberCount = 0;
                    if (exportData.groupChats?.length) {
                        exportData.groupChats.forEach(group => {
                            if (group.members && Array.isArray(group.members)) {
                                groupMemberCount += group.members.length;
                            }
                        });
                    }
                    if (groupMemberCount > 0) {
                        stats.push(`群聊成员: ${groupMemberCount}个`);
                    }
                }
                // 动态系统
                if (exportData.moments?.length) stats.push(`动态: ${exportData.moments.length}条`);
                if (exportData.momentComments?.length) stats.push(`动态评论: ${exportData.momentComments.length}条`);
                // 记忆系统 - 🔥【新增】完整的记忆系统统计
                if (exportData.workingMemory?.length) stats.push(`工作记忆: ${exportData.workingMemory.length}条`);
                if (exportData.episodicMemory?.length) stats.push(`情节记忆: ${exportData.episodicMemory.length}条`);
                if (exportData.episodicMemories?.length) stats.push(`情景记忆: ${exportData.episodicMemories.length}条`);
                if (exportData.memorySummaries?.length) stats.push(`记忆总结: ${exportData.memorySummaries.length}条`);
                if (exportData.memoryEvents?.length) stats.push(`记忆事件: ${exportData.memoryEvents.length}条`);
                if (exportData.coreMemory?.length) stats.push(`核心记忆: ${exportData.coreMemory.length}条`);
                if (exportData.coreMemories?.length) stats.push(`核心记忆库: ${exportData.coreMemories.length}条`);
                if (exportData.crossAppTimeline?.length) stats.push(`时间线: ${exportData.crossAppTimeline.length}条`);
                // 拉黑和好友系统 - 🔥【新增】完整的拉黑系统统计
                if (exportData.blacklist?.length) stats.push(`拉黑列表: ${exportData.blacklist.length}条`);
                if (exportData.blockedCharacters?.length) stats.push(`被拉黑角色: ${exportData.blockedCharacters.length}个`);
                if (exportData.friendRequests?.length) stats.push(`好友申请: ${exportData.friendRequests.length}条`);
                if (exportData.characterStatus?.length) stats.push(`角色状态: ${exportData.characterStatus.length}条`);
                // 日记系统 - 🔥【新增】角色日记统计
                if (exportData.characterDiaries?.length) stats.push(`角色日记: ${exportData.characterDiaries.length}条`);
                // 线下模式
                if (exportData.offlineHistoryRecords?.length) stats.push(`线下记录: ${exportData.offlineHistoryRecords.length}条`);
                if (exportData.offlinePresets?.length) stats.push(`线下预设: ${exportData.offlinePresets.length}个`);
                // 音乐系统
                if (exportData.musicPlaylist?.length) stats.push(`音乐: ${exportData.musicPlaylist.length}首`);
                // 设置数据
                if (exportData.chatSettings?.length) stats.push(`聊天设置: ${exportData.chatSettings.length}个`);
                if (exportData.wallpapers?.length) stats.push(`壁纸: ${exportData.wallpapers.length}个`);
                // 纪念日系统 - 🔥【新增】纪念日统计
                if (exportData.anniversaries?.length) stats.push(`纪念日: ${exportData.anniversaries.length}个`);
                // 日记设置 - 🔥【新增】日记设置统计
                if (exportData.diarySettings?.length) stats.push(`日记设置: ${exportData.diarySettings.length}个`);
                // 心声系统 - 🔥【新增】心声统计
                if (exportData.innerThoughts?.length) stats.push(`心声: ${exportData.innerThoughts.length}条`);
                // 🔥【新增】论坛功能统计
                if (exportData.forums?.length) stats.push(`论坛: ${exportData.forums.length}个`);
                if (exportData.forumPosts?.length) stats.push(`论坛帖子: ${exportData.forumPosts.length}条`);
                if (exportData.forumReplies?.length) stats.push(`论坛回复: ${exportData.forumReplies.length}条`);
                if (exportData.forumFavorites?.length) stats.push(`论坛收藏: ${exportData.forumFavorites.length}条`);
                if (exportData.replyLikes?.length) stats.push(`回复点赞: ${exportData.replyLikes.length}条`);
                if (exportData.forumPostImages?.length) stats.push(`论坛图片: ${exportData.forumPostImages.length}张`);
                if (exportData.forumMountedWorldbooks?.length) stats.push(`论坛世界书: ${exportData.forumMountedWorldbooks.length}个`);

                console.log('导出数据统计:', stats.join(', '));

                // 🔥【内存优化】使用分块JSON序列化，避免大数据量导致内存溢出
                try {
                    showToast('正在序列化数据...', 'info');

                    // 🔥【检查数据大小】估算内存使用
                    const estimatedSize = JSON.stringify(exportData).length;
                    console.log(`📊 估算数据大小: ${(estimatedSize / 1024 / 1024).toFixed(2)} MB`);

                    let dataStr;
                    if (estimatedSize > 50 * 1024 * 1024) { // 如果超过50MB
                        showToast('数据量较大，使用优化序列化...', 'info');
                        // 🔥【分块序列化】对于大数据，使用更节省内存的方式
                        dataStr = JSON.stringify(exportData, null, 1); // 使用更小的缩进
                    } else {
                        dataStr = JSON.stringify(exportData, null, 2);
                    }

                    showToast('正在创建下载文件...', 'info');

                    // 🔥【分块创建Blob】避免一次性创建大Blob
                    const chunkSize = 1024 * 1024; // 1MB chunks
                    const chunks = [];

                    for (let i = 0; i < dataStr.length; i += chunkSize) {
                        chunks.push(dataStr.slice(i, i + chunkSize));
                        if (chunks.length % 10 === 0) {
                            // 每10个chunk给浏览器一些时间
                            await new Promise(resolve => setTimeout(resolve, 10));
                        }
                    }

                    const dataBlob = new Blob(chunks, { type: 'application/json' });
                    const url = URL.createObjectURL(dataBlob);

                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `完整备份_${new Date().toISOString().split('T')[0]}.json`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                    // 🔥【内存清理】延迟释放URL，给下载一些时间
                    setTimeout(() => {
                        URL.revokeObjectURL(url);
                    }, 5000);

                } catch (serializationError) {
                    console.error('❌ 序列化失败:', serializationError);
                    throw new Error(`数据序列化失败: ${serializationError.message}`);
                }

                const statsText = stats.length > 0 ? `\n${stats.join('\n')}` : '';
                showToast(`导出成功！${statsText}`, 'success');
            } catch (error) {
                console.error('❌ 完整导出失败:', error);

                // 🔥【降级处理】如果完整导出失败，提供轻量级导出选项
                const fallbackChoice = confirm(
                    `完整导出失败: ${error.message}\n\n` +
                    `这可能是因为数据量过大导致的内存不足。\n\n` +
                    `是否尝试轻量级导出？\n` +
                    `（包含核心数据：角色、消息、记忆系统、世界书、论坛等）`
                );

                if (fallbackChoice) {
                    try {
                        await exportLightweightData();
                    } catch (fallbackError) {
                        console.error('❌ 轻量级导出也失败:', fallbackError);
                        showToast('导出失败，请尝试清理浏览器缓存后重试', 'error');
                    }
                } else {
                    showToast('导出已取消', 'warning');
                }
            }
        }

        // 🔥【新增】轻量级导出功能 - 包含核心数据和记忆系统
        async function exportLightweightData() {
            try {
                showToast('正在进行轻量级导出...', 'info');

                const coreData = {
                    version: '6.1-lite',
                    exportTime: new Date().toISOString(),
                    exportType: 'lightweight',

                    // 核心角色和聊天数据
                    characters: await db.characters.toArray(),
                    chatMessages: await db.chatMessages.toArray(),
                    chatSettings: await db.chatSettings.toArray(),
                    personas: await db.personas.toArray(),
                    contacts: await db.contacts.toArray(),

                    // 🔥【修复】群聊系统数据
                    groupChats: await db.groupChats.toArray(),
                    groupChatMessages: await db.groupChatMessages.toArray(),
                    groupChatMembers: await db.groupChatMembers.toArray(),

                    // 🔥【新增】短信应用独立数据
                    smsContacts: await db.smsContacts.toArray(),
                    smsMessages: await db.smsMessages.toArray(),

                    // 世界书系统
                    worldbooks: await db.worldbooks.toArray(),
                    worldbookEntries: await db.worldbookEntries.toArray(),

                    // 🔥【重要】记忆系统 - 完整保留
                    workingMemory: await db.workingMemory.toArray(),
                    episodicMemory: await db.episodicMemory.toArray(),
                    episodicMemories: await db.episodicMemories.toArray(),
                    memorySummaries: await db.memorySummaries.toArray(),
                    memoryEvents: await db.memoryEvents.toArray(),
                    coreMemory: await db.coreMemory.toArray(),
                    coreMemories: await db.coreMemories.toArray(),
                    crossAppTimeline: await db.crossAppTimeline.toArray(),

                    // 论坛核心数据
                    forums: await db.forums.toArray(),
                    forumPosts: await db.forumPosts.toArray(),
                    forumReplies: await db.forumReplies.toArray(),
                    forumFavorites: await db.forumFavorites.toArray(),

                    // 角色相关重要数据
                    characterGroups: await db.characterGroups.toArray(),
                    characterDiaries: await db.characterDiaries.toArray(),
                    innerThoughts: await db.innerThoughts.toArray(),

                    // 基础设置
                    apiSettings: await db.apiSettings.toArray(),
                    globalSettings: await db.globalSettings.toArray(),

                    // 纪念日（用户重要数据）
                    anniversaries: await db.anniversaries.toArray(),

                    // 日记设置（用户个性化设置）
                    diarySettings: await db.diarySettings.toArray()
                };

                const dataStr = JSON.stringify(coreData, null, 1);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);

                const link = document.createElement('a');
                link.href = url;
                link.download = `轻量级备份_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                setTimeout(() => URL.revokeObjectURL(url), 3000);

                // 统计导出的数据
                const stats = [];
                if (coreData.characters?.length) stats.push(`角色: ${coreData.characters.length}个`);
                if (coreData.chatMessages?.length) stats.push(`消息: ${coreData.chatMessages.length}条`);
                if (coreData.workingMemory?.length || coreData.episodicMemory?.length || coreData.coreMemory?.length) {
                    const memoryCount = (coreData.workingMemory?.length || 0) +
                                      (coreData.episodicMemory?.length || 0) +
                                      (coreData.coreMemory?.length || 0) +
                                      (coreData.episodicMemories?.length || 0) +
                                      (coreData.coreMemories?.length || 0);
                    stats.push(`记忆: ${memoryCount}条`);
                }
                if (coreData.worldbooks?.length) stats.push(`世界书: ${coreData.worldbooks.length}个`);
                if (coreData.forums?.length) stats.push(`论坛: ${coreData.forums.length}个`);

                const statsText = stats.length > 0 ? `\n${stats.join(', ')}` : '';
                showToast(`轻量级导出成功！${statsText}`, 'success');

            } catch (error) {
                console.error('❌ 轻量级导出失败:', error);
                throw error;
            }
        }

        // 显示清理选项
        function showCleanupOptions() {
            // 先计算各类数据的大小
            let offlineBackupSize = 0;
            let customBackgroundSize = 0;

            Object.keys(localStorage).forEach(key => {
                const size = (localStorage.getItem(key) || '').length;
                if (key.startsWith('offlineUISettings_') && key.includes('window_')) {
                    offlineBackupSize += size;
                } else if (key === 'diary-custom-background') {
                    customBackgroundSize += size;
                }
            });

            const formatSize = (bytes) => {
                if (bytes < 1024) return bytes + 'B';
                if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + 'KB';
                return (bytes / (1024 * 1024)).toFixed(1) + 'MB';
            };

            const options = [
                `1. 删除空聊天记录`,
                `2. 压缩所有图片 (头像/背景/聊天图片/表情包)`,
                `3. 清理线下模式备份 (${formatSize(offlineBackupSize)}) ⭐推荐`,
                `4. 删除自定义背景 (${formatSize(customBackgroundSize)})`
            ];

            const choice = prompt(`选择清理项目：\n${options.join('\n')}\n\n输入数字（逗号分隔），推荐选择3：`);
            if (choice) executeCleanupOptions(choice);
        }

        // 执行清理
        async function executeCleanupOptions(choice) {
            const selections = choice.split(',').map(s => parseInt(s.trim())).filter(n => n >= 1 && n <= 4);
            if (!selections.length) return;

            showToast('清理中...', 'info');
            let count = 0;
            let freedSpace = 0;

            for (const option of selections) {
                switch (option) {
                    case 1:
                        // 删除空聊天记录
                        Object.keys(chatMessages).forEach(id => {
                            if (!chatMessages[id]?.length) {
                                delete chatMessages[id];
                                count++;
                            }
                        });
                        break;
                    case 2:
                        // 压缩所有图片
                        const compressResult = await compressAllImagesEnhanced();
                        count += compressResult.count;
                        freedSpace += compressResult.savedSpace;
                        break;
                    case 3:
                        // 清理线下模式备份（最重要的清理项）
                        for (let i = localStorage.length - 1; i >= 0; i--) {
                            const key = localStorage.key(i);
                            if (key?.startsWith('offlineUISettings_') && key.includes('window_')) {
                                freedSpace += (localStorage.getItem(key) || '').length;
                                localStorage.removeItem(key);
                                count++;
                            }
                        }
                        break;
                    case 4:
                        // 删除自定义背景
                        const bgKey = 'diary-custom-background';
                        if (localStorage.getItem(bgKey)) {
                            freedSpace += (localStorage.getItem(bgKey) || '').length;
                            localStorage.removeItem(bgKey);
                            count++;

                            // 同时清理角色特定的自定义背景
                            for (let i = localStorage.length - 1; i >= 0; i--) {
                                const key = localStorage.key(i);
                                if (key?.includes('-custom-background')) {
                                    freedSpace += (localStorage.getItem(key) || '').length;
                                    localStorage.removeItem(key);
                                    count++;
                                }
                            }
                        }
                        break;
                }
            }

            await saveChatSettings();
            // 🔥【优化】存储清理使用高效保存
            try {
                const activeCharacterIds = Object.keys(chatMessages).filter(id =>
                    chatMessages[id] && chatMessages[id].length > 0);
                await saveChatMessagesImmediate(activeCharacterIds);
                console.log('✅ [高效存储清理] 消息已保存到数据库');
            } catch (error) {
                console.error('存储清理保存失败，回退到全量保存:', error);
                await saveChatMessages();
            }
            calculateStorageUsage();

            const formatSize = (bytes) => {
                if (bytes < 1024) return bytes + 'B';
                if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + 'KB';
                return (bytes / (1024 * 1024)).toFixed(1) + 'MB';
            };

            showToast(`清理完成！处理 ${count} 项，释放 ${formatSize(freedSpace)} 空间`, 'success');
        }

        // 压缩图片（原版，保持兼容性）
        async function compressAllImages() {
            const formatSize = (bytes) => {
                if (bytes < 1024) return bytes + 'B';
                if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + 'KB';
                return (bytes / (1024 * 1024)).toFixed(1) + 'MB';
            };

            const result = await compressAllImagesEnhanced();
            showToast(`压缩完成！处理 ${result.count} 张图片，节省 ${formatSize(result.savedSpace)} 空间`, 'success');
        }

        // 增强版图片压缩函数
        async function compressAllImagesEnhanced() {
            let count = 0;
            let savedSpace = 0;

            const formatSize = (bytes) => {
                if (bytes < 1024) return bytes + 'B';
                if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + 'KB';
                return (bytes / (1024 * 1024)).toFixed(1) + 'MB';
            };

            try {
                // 1. 压缩角色头像
                for (const char of characters) {
                    if (char.avatarUrl?.length > 30000) { // 降低阈值，压缩更多图片
                        const originalSize = char.avatarUrl.length;
                        char.avatarUrl = await compressImage(char.avatarUrl, 120, 0.7); // 更高压缩
                        savedSpace += originalSize - char.avatarUrl.length;
                        count++;
                    }
                }
                await saveCharacters();

                // 2. 压缩聊天设置中的头像
                for (const id of Object.keys(chatSettings)) {
                    const settings = chatSettings[id];
                    if (settings?.aiChatAvatar?.length > 30000) {
                        const originalSize = settings.aiChatAvatar.length;
                        settings.aiChatAvatar = await compressImage(settings.aiChatAvatar, 120, 0.7);
                        savedSpace += originalSize - settings.aiChatAvatar.length;
                        count++;
                    }
                    if (settings?.myChatAvatar?.length > 30000) {
                        const originalSize = settings.myChatAvatar.length;
                        settings.myChatAvatar = await compressImage(settings.myChatAvatar, 120, 0.7);
                        savedSpace += originalSize - settings.myChatAvatar.length;
                        count++;
                    }
                }
                await saveChatSettings();

                // 3. 压缩自定义背景
                for (let i = localStorage.length - 1; i >= 0; i--) {
                    const key = localStorage.key(i);
                    if (key?.includes('-custom-background') || key === 'diary-custom-background') {
                        const bgData = localStorage.getItem(key);
                        if (bgData && bgData.length > 50000) { // 背景图片通常更大
                            const originalSize = bgData.length;
                            const compressedBg = await compressImage(bgData, 800, 0.8); // 背景保持较高质量
                            localStorage.setItem(key, compressedBg);
                            savedSpace += originalSize - compressedBg.length;
                            count++;
                        }
                    }
                }

                // 4. 压缩聊天记录中的图片
                for (const characterId of Object.keys(chatMessages)) {
                    const messages = chatMessages[characterId] || [];
                    let messagesChanged = false;

                    for (const message of messages) {
                        // 压缩消息中的图片
                        if (message.image && message.image.length > 30000) {
                            const originalSize = message.image.length;
                            message.image = await compressImage(message.image, 400, 0.8);
                            savedSpace += originalSize - message.image.length;
                            count++;
                            messagesChanged = true;
                        }

                        // 压缩多模态消息中的图片
                        if (Array.isArray(message.content)) {
                            for (const part of message.content) {
                                if (part.type === 'image_url' && part.image_url?.url?.length > 30000) {
                                    const originalSize = part.image_url.url.length;
                                    part.image_url.url = await compressImage(part.image_url.url, 400, 0.8);
                                    savedSpace += originalSize - part.image_url.url.length;
                                    count++;
                                    messagesChanged = true;
                                }
                            }
                        }
                    }

                    if (messagesChanged) {
                        await saveChatMessages(characterId);
                    }
                }

                // 5. 压缩表情包（如果存储在localStorage中）
                for (let i = localStorage.length - 1; i >= 0; i--) {
                    const key = localStorage.key(i);
                    if (key?.includes('emoji') || key?.includes('sticker')) {
                        const emojiData = localStorage.getItem(key);
                        if (emojiData && emojiData.length > 20000) {
                            try {
                                const originalSize = emojiData.length;
                                const compressedEmoji = await compressImage(emojiData, 200, 0.8);
                                localStorage.setItem(key, compressedEmoji);
                                savedSpace += originalSize - compressedEmoji.length;
                                count++;
                            } catch (e) {
                                // 如果不是图片数据，跳过
                                continue;
                            }
                        }
                    }
                }

                calculateStorageUsage();

                return { count, savedSpace };

            } catch (error) {
                console.error('图片压缩过程中出错:', error);
                return { count, savedSpace };
            }
        }

        // 调试用：列出所有角色ID和名称，帮助识别幽灵角色
        async function debugListAllCharacters() {
            try {
                console.log('=== 所有角色数据 ===');

                // 1. 数据库中的角色
                const dbChars = await db.characters.toArray();
                console.log('数据库角色表:', dbChars.map(c => `${c.name} (ID: ${c.id})`));

                // 2. 内存中的角色
                if (window.characters) {
                    console.log('内存角色列表:', window.characters.map(c => `${c.name} (ID: ${c.id})`));
                }

                // 3. 联系人列表
                if (window.contacts) {
                    console.log('联系人ID列表:', window.contacts);
                }

                // 4. 动态评论中的角色
                const comments = await db.momentComments.toArray();
                const commentAuthors = [...new Set(comments.map(c => `${c.nickname} (ID: ${c.authorId})`))];
                console.log('动态评论中的角色:', commentAuthors);

                // 5. 动态点赞中的角色
                const likes = await db.momentLikes.toArray();
                const likeAuthors = [...new Set(likes.map(l => `${l.name} (ID: ${l.authorId})`))];
                console.log('动态点赞中的角色:', likeAuthors);

                return {dbChars, comments, likes};
            } catch (error) {
                console.error('调试失败:', error);
            }
        }

        // 调试用：精确删除指定ID的角色数据
        async function debugDeleteCharacterById(characterId) {
            if (!characterId) {
                console.log('用法: debugDeleteCharacterById("角色ID")');
                return;
            }

            try {
                console.log(`开始删除角色ID: ${characterId}`);
                let deleteCount = 0;

                // 1. 从动态评论中删除
                const comments = await db.momentComments.where('authorId').equals(characterId).toArray();
                for (const comment of comments) {
                    await db.momentComments.delete(comment.id);
                    deleteCount++;
                    console.log(`删除评论: ${comment.nickname} - ${comment.text}`);
                }

                // 2. 从动态点赞中删除
                const likes = await db.momentLikes.where('authorId').equals(characterId).toArray();
                for (const like of likes) {
                    await db.momentLikes.delete([like.momentId, like.authorId]);
                    deleteCount++;
                    console.log(`删除点赞: ${like.name}`);
                }

                // 3. 从其他表中删除
                const chatMsgs = await db.chatMessages.where('characterId').equals(characterId).toArray();
                for (const msg of chatMsgs) {
                    await db.chatMessages.delete(msg.id);
                    deleteCount++;
                }

                const chatSets = await db.chatSettings.toArray();
                for (const setting of chatSets) {
                    if (setting.characterId === characterId) {
                        await db.chatSettings.delete(setting.id);
                        deleteCount++;
                    }
                }

                await db.characters.delete(characterId);
                deleteCount++;

                // 4. 从内存数组中删除
                if (window.contacts) {
                    window.contacts = window.contacts.filter(id => id !== characterId);
                    await saveContacts();
                }
                if (window.characters) {
                    window.characters = window.characters.filter(char => char.id !== characterId);
                }

                console.log(`删除完成！共删除 ${deleteCount} 条相关数据`);

                // 刷新界面
                if (window.renderContactList) window.renderContactList();
                if (window.renderMessageList) window.renderMessageList();

            } catch (error) {
                console.error('删除失败:', error);
            }
        }

        // 强制删除指定角色（用于清理幽灵角色）
        async function forceDeleteCharacter() {
            const characterName = prompt('输入要强制删除的角色名称（如：方回）：');
            if (!characterName || !characterName.trim()) return;

            try {
                showToast(`正在强制删除角色 "${characterName}"...`, 'info');
                let deleteCount = 0;

                // 1. 从动态评论中删除
                const comments = await db.momentComments.toArray();
                for (const comment of comments) {
                    if (comment.nickname === characterName || (comment.authorId && comment.authorId.includes(characterName))) {
                        await db.momentComments.delete(comment.id);
                        deleteCount++;
                        console.log(`删除评论：${comment.nickname} - ${comment.text}`);
                    }
                }

                // 2. 从动态点赞中删除
                const likes = await db.momentLikes.toArray();
                for (const like of likes) {
                    if (like.name === characterName || (like.authorId && like.authorId.includes(characterName))) {
                        await db.momentLikes.delete([like.momentId, like.authorId]);
                        deleteCount++;
                        console.log(`删除点赞：${like.name}`);
                    }
                }

                // 3. 从聊天消息中删除
                const chatMsgs = await db.chatMessages.toArray();
                for (const msg of chatMsgs) {
                    if (msg.characterId && msg.characterId.includes(characterName)) {
                        await db.chatMessages.delete(msg.id);
                        deleteCount++;
                    }
                }

                // 4. 从聊天设置中删除
                const chatSets = await db.chatSettings.toArray();
                for (const setting of chatSets) {
                    if (setting.characterId && setting.characterId.includes(characterName)) {
                        await db.chatSettings.delete(setting.id);
                        deleteCount++;
                    }
                }

                // 5. 从characters表中删除
                const chars = await db.characters.toArray();
                for (const char of chars) {
                    if (char.name === characterName || char.id.includes(characterName)) {
                        await db.characters.delete(char.id);
                        deleteCount++;
                        console.log(`删除角色：${char.name} (${char.id})`);
                    }
                }

                // 6. 从联系人列表中删除
                if (window.contacts) {
                    window.contacts = window.contacts.filter(id => !id.includes(characterName));
                    await saveContacts();
                }

                // 7. 清理内存中的数据
                if (window.characters) {
                    window.characters = window.characters.filter(char => char.name !== characterName);
                }
                if (window.chatMessages) {
                    Object.keys(window.chatMessages).forEach(key => {
                        if (key.includes(characterName)) {
                            delete window.chatMessages[key];
                        }
                    });
                }
                if (window.chatSettings) {
                    Object.keys(window.chatSettings).forEach(key => {
                        if (key.includes(characterName)) {
                            delete window.chatSettings[key];
                        }
                    });
                }

                // 刷新界面
                if (window.renderContactList) window.renderContactList();
                if (window.renderMessageList) window.renderMessageList();

                showToast(`强制删除完成！共删除 ${deleteCount} 条相关数据`, 'success');
                console.log(`强制删除角色 "${characterName}" 完成，删除了 ${deleteCount} 条记录`);

            } catch (error) {
                console.error('强制删除失败:', error);
                showToast('强制删除失败: ' + error.message, 'error');
            }
        }

        // 清理孤立联系人和重复数据
        async function cleanupOrphanedContacts() {
            try {
                showToast('正在清理孤立数据...', 'info');

                let cleanupCount = 0;

                // 1. 清理联系人列表中不存在的角色ID
                const validCharacterIds = characters.map(char => char.id);
                const originalContactsLength = contacts.length;
                contacts = contacts.filter(contactId => {
                    const isValid = validCharacterIds.includes(contactId);
                    if (!isValid) cleanupCount++;
                    return isValid;
                });

                // 2. 从数据库中清理孤立的联系人记录
                const dbContacts = await db.contacts.toArray();
                for (const contact of dbContacts) {
                    if (!validCharacterIds.includes(contact.characterId)) {
                        await db.contacts.delete(contact.id);
                        cleanupCount++;
                    }
                }

                // 3. 清理聊天消息中不存在角色的记录
                const chatMessageKeys = Object.keys(chatMessages);
                for (const characterId of chatMessageKeys) {
                    if (!validCharacterIds.includes(characterId)) {
                        delete chatMessages[characterId];
                        cleanupCount++;
                    }
                }

                // 4. 清理数据库中孤立的聊天消息
                const dbChatMessages = await db.chatMessages.toArray();
                for (const msgRecord of dbChatMessages) {
                    if (!validCharacterIds.includes(msgRecord.characterId)) {
                        await db.chatMessages.delete(msgRecord.id);
                        cleanupCount++;
                    }
                }

                // 5. 清理聊天设置中不存在角色的记录
                const chatSettingsKeys = Object.keys(chatSettings);
                for (const characterId of chatSettingsKeys) {
                    if (!validCharacterIds.includes(characterId)) {
                        delete chatSettings[characterId];
                        cleanupCount++;
                    }
                }

                // 6. 清理数据库中孤立的聊天设置
                const dbChatSettings = await db.chatSettings.toArray();
                for (const setting of dbChatSettings) {
                    if (!validCharacterIds.includes(setting.characterId)) {
                        await db.chatSettings.delete(setting.id);
                        cleanupCount++;
                    }
                }

                // 7. 清理动态评论中不存在角色的记录
                const dbMomentComments = await db.momentComments.toArray();
                for (const comment of dbMomentComments) {
                    // 清理authorId不在角色列表中且不是用户的评论
                    if (comment.authorId !== 'user' && !validCharacterIds.includes(comment.authorId)) {
                        await db.momentComments.delete(comment.id);
                        cleanupCount++;
                        console.log(`删除了孤立评论：${comment.nickname}(${comment.authorId})`);
                    }
                }

                // 8. 清理动态点赞中不存在角色的记录
                const dbMomentLikes = await db.momentLikes.toArray();
                for (const like of dbMomentLikes) {
                    // 清理authorId不在角色列表中且不是用户的点赞
                    if (like.authorId !== 'user' && !validCharacterIds.includes(like.authorId)) {
                        await db.momentLikes.delete([like.momentId, like.authorId]);
                        cleanupCount++;
                        console.log(`删除了孤立点赞：${like.name}(${like.authorId})`);
                    }
                }

                // 9. 保存清理后的数据
                await Promise.all([
                    saveContacts(),
                    saveChatMessages(),
                    saveChatSettings()
                ]);

                // 10. 重新渲染界面
                renderContactList();
                renderMessageList();

                showToast(`清理完成！共清理了 ${cleanupCount} 条孤立数据`, 'success');

                console.log('清理结果:', {
                    有效角色数: validCharacterIds.length,
                    清理前联系人数: originalContactsLength,
                    清理后联系人数: contacts.length,
                    总清理项目: cleanupCount
                });

            } catch (error) {
                console.error('清理孤立数据失败:', error);
                showToast('清理失败: ' + error.message, 'error');
            }
        }

        // 清空所有数据
        async function clearAllData() {
            const confirm = prompt('警告：将删除所有数据且无法恢复！\n输入"清空所有数据"确认：');
            if (confirm !== '清空所有数据') return;

            try {
                showToast('清空中...', 'info');

                // 🔥【修复】清空所有数据库表
                await Promise.all([
                    // 基础数据表
                    db.characters.clear(),
                    db.contacts.clear(),
                    db.chatMessages.clear(),

                    // 用户面具系统
                    db.personas.clear(),

                    // 表情包系统
                    db.customEmojis.clear(),
                    db.recentEmojis.clear(),

                    // 世界书系统
                    db.worldbooks.clear(),
                    db.worldbookEntries.clear(),

                    // 群聊系统
                    db.characterGroups.clear(),
                    db.groupChats.clear(),
                    db.groupChatMessages.clear(),
                    db.groupChatMembers.clear(),

                    // 动态系统
                    db.moments.clear(),
                    db.momentLikes.clear(),
                    db.momentComments.clear(),
                    db.momentVisibility.clear(),
                    db.momentLocations.clear(),
                    db.momentMentions.clear(),

                    // 记忆系统
                    db.workingMemory.clear(),
                    db.episodicMemory.clear(),
                    db.episodicMemories.clear(),
                    db.memorySummaries.clear(),
                    db.memoryEvents.clear(),
                    db.coreMemory.clear(),
                    db.coreMemories.clear(),
                    db.crossAppTimeline.clear(),

                    // 拉黑和好友系统
                    db.blacklist.clear(),
                    db.blockedCharacters.clear(),
                    db.friendRequests.clear(),
                    db.characterStatus.clear(),

                    // 日记系统
                    db.characterDiaries.clear(),
                    db.diarySettings.clear(),

                    // 线下模式系统
                    db.offlineHistoryRecords.clear(),
                    db.offlineUISettings.clear(),
                    db.offlinePresets.clear(),

                    // 音乐播放器系统
                    db.musicPlaylist.clear(),
                    db.musicCovers.clear(),

                    // 设置和配置
                    db.apiSettings.clear(),
                    db.globalSettings.clear(),
                    db.wallpapers.clear(),
                    db.appIcons.clear(),
                    db.chatSettings.clear(),

                    // 心声系统
                    db.innerThoughts.clear(),

                    // 论坛功能相关表
                    db.forums.clear(),
                    db.forumPosts.clear(),
                    db.forumReplies.clear(),
                    db.forumFavorites.clear(),
                    db.replyLikes.clear(),
                    db.forumPostImages.clear(),
                    db.forumMountedWorldbooks.clear(),

                    // 短信应用独立数据表
                    db.smsContacts.clear(),
                    db.smsMessages.clear(),

                    // 纪念日和约定系统
                    db.anniversaries.clear(),
                    db.appointments.clear(),

                    // 足迹功能
                    db.characterFootprints.clear(),
                    db.footprintActivities.clear(),

                    // 表情包库功能
                    db.emojiLibraries.clear(),
                    db.emojiLibraryItems.clear(),

                    // 音效系统
                    db.soundSettings.clear(),
                    db.characterSounds.clear(),

                    // 自定义主题系统
                    db.globalThemes.clear(),
                    db.chatThemes.clear(),
                    db.themeSettings.clear(),

                    // 窗口隔离聊天设置
                    db.windowChatSettings.clear()
                ]);

                // 🔥【修复】重置内存中的全局变量
                characters = [];
                chatMessages = {};
                chatSettings = {};
                customEmojis = [];
                contacts = [];
                groupChats = [];
                characterGroups = [];
                currentChatCharacter = null;
                currentGroupChat = null;

                // 重置其他全局变量
                if (typeof personas !== 'undefined') personas = [];
                if (typeof worldbooks !== 'undefined') worldbooks = [];
                if (typeof musicPlaylist !== 'undefined') musicPlaylist = [];
                if (typeof smsMessages !== 'undefined') smsMessages = {};
                if (typeof anniversaries !== 'undefined') anniversaries = [];
                if (typeof appointments !== 'undefined') appointments = [];

                // 🔥【修复】清理localStorage中的所有应用数据
                for (let i = localStorage.length - 1; i >= 0; i--) {
                    const key = localStorage.key(i);
                    // 清除所有应用相关数据，但保留基础设置
                    if (key && (
                        key.startsWith('chatSettings_') ||
                        key.startsWith('contacts') ||
                        key.startsWith('characters') ||
                        key.startsWith('chatMessages') ||
                        key.startsWith('groupChats') ||
                        key.startsWith('characterGroups') ||
                        key.startsWith('personas') ||
                        key.startsWith('customEmojis') ||
                        key.startsWith('worldbooks') ||
                        key.startsWith('moments') ||
                        key.startsWith('musicPlaylist') ||
                        key.startsWith('smsMessages') ||
                        key.startsWith('anniversaries') ||
                        key.startsWith('appointments') ||
                        key.startsWith('forums') ||
                        key.startsWith('diarySettings_') ||
                        key.startsWith('offlineUISettings_') ||
                        key.startsWith('offlinePresets') ||
                        key.startsWith('footprints_') ||
                        key.startsWith('emojiLibraries') ||
                        key.startsWith('soundSettings') ||
                        key.startsWith('globalCustomTheme') ||
                        key.startsWith('chatTheme_') ||
                        key.startsWith('selectedTheme') ||
                        key.startsWith('windowChatSettings_')
                    )) {
                        localStorage.removeItem(key);
                    }
                }

                // 🔥【修复】刷新所有相关界面
                renderCharacterList();
                renderMessageList();
                renderContactList();
                calculateStorageUsage();

                // 清空动态列表
                const momentsList = document.getElementById('moments-list');
                if (momentsList) momentsList.innerHTML = '';

                // 清空群聊列表
                const groupChatsList = document.getElementById('group-chats-list');
                if (groupChatsList) groupChatsList.innerHTML = '';

                // 清空音乐播放列表
                const musicList = document.getElementById('music-list');
                if (musicList) musicList.innerHTML = '';

                // 清空论坛列表
                const forumsList = document.getElementById('forums-list');
                if (forumsList) forumsList.innerHTML = '';

                // 重置当前聊天状态
                const chatContent = document.getElementById('chat-content');
                if (chatContent) chatContent.innerHTML = '';

                // 重置应用标题
                const appTitle = document.querySelector('.app-title');
                if (appTitle) appTitle.textContent = '聊天';

                showToast('已清空所有数据', 'success');
                console.log('✅ 所有数据已清空，包括角色、聊天记录、群聊、动态、论坛、音乐、面具、世界书等所有应用数据');

                // 返回主界面
                setTimeout(() => {
                    hideApp('data-management-screen');
                    hideApp('settings-screen');
                    showApp('chat-screen');
                }, 2000);
            } catch (error) {
                console.error('清空数据失败:', error);
                showToast('清空失败: ' + error.message, 'error');
            }
        }

        // 重复函数已删除

        // 转账相关变量
        let currentTransferMsg = null;

        // 处理用户发送给AI的转账 - 简化版本，类似代付处理
        async function processUserTransfer(userTransferMsg, aiMessages, characterId) {
            console.log('🚀 [转账处理] 开始处理AI对转账的回复:', {
                userTransferMsg,
                aiMessages,
                characterId
            });

            if (!userTransferMsg || !characterId) {
                console.log('❌ [转账处理] 退出：缺少必要参数');
                return;
            }

            // 🔥【改进】分析AI回复，支持JSON指令和关键词两种方式
            let transferAction = null;
            let fullAiResponse = '';

            // 首先检查是否有明确的JSON指令
            for (const msgData of aiMessages) {
                if (typeof msgData === 'object' && msgData.type === 'transfer_action') {
                    transferAction = msgData.action; // 'accept' 或 'reject'
                    console.log('🔥 [转账处理] 检测到明确的转账指令:', msgData);
                    break;
                }

                // 同时收集文本内容用于关键词分析
                if (typeof msgData === 'string') {
                    fullAiResponse += msgData + ' ';
                } else if (typeof msgData === 'object' && msgData.content) {
                    fullAiResponse += msgData.content + ' ';
                }
            }
            fullAiResponse = fullAiResponse.trim().toLowerCase();
            console.log('🔥 [转账处理] AI完整回复内容:', fullAiResponse);

            // 检测AI是否接受转账
            const acceptKeywords = [
                '收下了', '收下', '收款', '接受', '确认收款', '已收款',
                '收到了', '收到', '收了', '要了', '拿了', '接收了', '接收',
                '谢谢', '感谢', '多谢', '太好了', '好的', '可以', '行'
            ];

            // 检测AI是否拒绝转账
            const rejectKeywords = [
                '退回', '拒绝', '不收', '不要', '不需要', '不能收',
                '退给你', '不用给', '算了', '自己留着', '我不要',
                '拿着', '留着', '不用', '不行', '不可以'
            ];

            // 🔥【改进】如果没有明确指令，则使用关键词匹配
            let isAccepted = false;
            let isRejected = false;
            let matchedKeywords = [];

            if (transferAction) {
                // 有明确指令，直接使用
                isAccepted = (transferAction === 'accept');
                isRejected = (transferAction === 'reject');
                console.log('🔥 [转账处理] 使用明确指令:', { transferAction, isAccepted, isRejected });
            } else {
                // 没有明确指令，使用关键词匹配
                console.log('🔥 [转账处理] 未检测到明确指令，使用关键词匹配');

                // 检查接受关键词
                for (const keyword of acceptKeywords) {
                    if (fullAiResponse.includes(keyword)) {
                        isAccepted = true;
                        matchedKeywords.push(`接受:${keyword}`);
                    }
                }

                // 检查拒绝关键词
                for (const keyword of rejectKeywords) {
                    if (fullAiResponse.includes(keyword)) {
                        isRejected = true;
                        matchedKeywords.push(`拒绝:${keyword}`);
                    }
                }

                console.log('🔥 [转账处理] 关键词检测结果:', {
                    isAccepted,
                    isRejected,
                    matchedKeywords,
                    fullAiResponse: fullAiResponse.substring(0, 100) + '...'
                });
            }

            // 更新转账状态
            if (isAccepted && !isRejected) {
                // AI接受转账
                userTransferMsg.status = 'accepted';
                console.log('🔥 [转账处理] AI接受转账，更新状态为已接受');

                // 🔥【关键修复】立即更新内存中的消息状态，避免重复处理
                const messages = chatMessages[characterId] || [];
                const transferIndex = messages.findIndex(msg =>
                    msg.timestamp === userTransferMsg.timestamp && msg.type === 'transfer');
                if (transferIndex !== -1) {
                    messages[transferIndex].status = 'accepted';
                }

                // 更新界面显示
                updateTransferDisplay(userTransferMsg.timestamp, 'accepted');

            } else if (isRejected) {
                // AI拒绝转账
                userTransferMsg.status = 'rejected';
                console.log('🔥 [转账处理] AI拒绝转账，更新状态为已拒绝');

                // 🔥【关键修复】立即更新内存中的消息状态，避免重复处理
                const messages = chatMessages[characterId] || [];
                const transferIndex = messages.findIndex(msg =>
                    msg.timestamp === userTransferMsg.timestamp && msg.type === 'transfer');
                if (transferIndex !== -1) {
                    messages[transferIndex].status = 'rejected';
                }

                // 更新界面显示
                updateTransferDisplay(userTransferMsg.timestamp, 'rejected');
            }

            // 保存更新后的消息
            if (isAccepted || isRejected) {
                try {
                    // 🔥【修复】使用单条消息保存，避免强制同步
                    const messages = chatMessages[characterId] || [];
                    const transferMessage = messages.find(msg =>
                        msg.timestamp === userTransferMsg.timestamp && msg.type === 'transfer');

                    if (transferMessage) {
                        const stableId = `${characterId}_transfer_${transferMessage.timestamp}_${Math.random().toString(36).substr(2, 9)}`;
                        await db.chatMessages.put({
                            id: stableId,
                            characterId: characterId,
                            messageData: transferMessage
                        });
                        console.log('🔥 [转账处理] 转账状态已保存到数据库');
                    }
                } catch (error) {
                    console.error('🔥 [转账处理] 保存转账状态失败:', error);
                }

                // 🔥【新增】添加系统消息提示
                const actionText = isAccepted ? '已收款' : '已退回';
                const characterName = currentChatCharacter?.name || '角色';
                const systemMsg = {
                    id: Date.now().toString(),
                    sender: 'system',
                    content: `${characterName}${actionText} ¥${Number(userTransferMsg.amount).toFixed(2)}`,
                    timestamp: Date.now()
                };

                // 🔥【修复】获取消息数组并添加系统消息
                const messages = chatMessages[characterId] || [];
                messages.push(systemMsg);
                chatMessages[characterId] = messages;

                // 保存系统消息
                try {
                    const systemStableId = `${characterId}_system_${systemMsg.timestamp}_${Math.random().toString(36).substr(2, 9)}`;
                    await db.chatMessages.add({
                        id: systemStableId,
                        characterId: characterId,
                        messageData: systemMsg
                    });
                    console.log('🔥 [转账处理] 系统消息已保存到数据库');
                } catch (error) {
                    console.error('🔥 [转账处理] 保存系统消息失败:', error);
                }

                // 重新渲染聊天界面以显示系统消息
                renderChatMessages(characterId);
            }
        }

        // 🔥【新增】更新转账卡片显示状态
        function updateTransferDisplay(transferTimestamp, status) {
            console.log('🔥 [转账界面更新] 更新转账卡片显示:', { transferTimestamp, status });

            // 🔥【调试】查看页面中所有的转账卡片
            const allTransferCards = document.querySelectorAll('[data-transfer-id]');
            console.log('🔥 [转账界面更新] 页面中的所有转账卡片:', Array.from(allTransferCards).map(card => ({
                id: card.getAttribute('data-transfer-id'),
                element: card
            })));

            // 查找对应的转账卡片
            const transferCard = document.querySelector(`[data-transfer-id="${transferTimestamp}"]`);
            if (!transferCard) {
                console.log('🔥 [转账界面更新] 未找到转账卡片，重新渲染聊天界面');
                // 如果找不到卡片，重新渲染聊天界面
                if (currentChatCharacter) {
                    renderChatMessages(currentChatCharacter.id);
                }
                return;
            }

            // 移除旧的状态类
            transferCard.classList.remove('accepted', 'rejected');

            // 添加新的状态类
            transferCard.classList.add(status);

            // 更新状态文本
            let statusHtml = '';
            if (status === 'accepted') {
                statusHtml = `<div class="transfer-status">已收款</div>`;
            } else if (status === 'rejected') {
                statusHtml = `<div class="transfer-status">已退回</div>`;
            }

            // 查找并更新状态显示区域
            const existingStatus = transferCard.querySelector('.transfer-status');
            if (existingStatus) {
                existingStatus.outerHTML = statusHtml;
            } else if (statusHtml) {
                // 如果没有状态区域，添加到卡片末尾
                transferCard.insertAdjacentHTML('beforeend', statusHtml);
            }

            // 移除点击处理器（如果有的话）
            transferCard.removeAttribute('onclick');

            console.log('🔥 [转账界面更新] 转账卡片状态已更新');
        }

        // 转账相关函数
        async function sendTransfer() {
            const amount = parseFloat(document.getElementById('transfer-amount').value);
            const note = document.getElementById('transfer-note').value.trim();

            if (!amount || amount <= 0) {
                showToast('请输入有效的转账金额', 'warning');
                return;
            }

            if (amount > 1000000000) {
                showToast('转账金额不能超过10亿元', 'warning');
                return;
            }

            // 创建转账消息 - 修复数据结构和设置pendingUserMessage
            const transferMessage = {
                id: Date.now().toString(),
                sender: 'sent',  // 修复：使用 sender 而不是 role
                type: 'transfer',
                amount: amount,
                note: note || '转账',
                timestamp: Date.now()
            };

            // 添加到聊天记录
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            const messages = chatMessages[currentChatCharacter.id];
            messages.push(transferMessage);

            // 🔥【修复】用户发送转账使用单条保存，避免强制同步
            try {
                const stableId = `${currentChatCharacter.id}_transfer_${transferMessage.timestamp}_${Math.random().toString(36).substr(2, 9)}`;
                await db.chatMessages.add({
                    id: stableId,
                    characterId: currentChatCharacter.id,
                    messageData: transferMessage
                });
                console.log('✅ [高效用户转账] 消息已保存到数据库');
            } catch (error) {
                console.error('用户转账消息保存失败，回退到全量保存:', error);
                await saveChatMessages();
            }

            // 使用动画添加消息而不是重新渲染整个列表
            addMessageWithAnimation(transferMessage, currentChatCharacter.id);

            // 🔥 【关键修复】设置为待回复消息，让AI能看到转账
            pendingUserMessage = transferMessage;

            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = '点击获取AI回复';
            }

            // 更新联系人列表
            renderMessageList();

            // 关闭转账对话框
            document.getElementById('transfer-modal').classList.remove('visible');

            // 清空输入框
            document.getElementById('transfer-amount').value = '';
            document.getElementById('transfer-note').value = '';

            showToast('转账已发送', 'success');
        }

        function showTransferConfirmDialog(transferMsg) {
            if (!transferMsg || transferMsg.status) return;

            const modal = document.getElementById('transfer-confirm-modal');
            const amountEl = modal.querySelector('.transfer-confirm-amount');
            const noteEl = modal.querySelector('.transfer-confirm-note');

            // 设置转账信息
            amountEl.textContent = `¥ ${Number(transferMsg.amount).toFixed(2)}`;
            noteEl.textContent = `备注：${transferMsg.note || '无'}`;

            // 存储当前处理的转账信息
            currentTransferMsg = transferMsg;

            // 显示对话框
            modal.classList.add('visible');
        }

        async function acceptTransfer() {
            if (!currentTransferMsg || !currentChatCharacter) return;

            // 在聊天记录中找到对应的转账消息并更新状态
            const messages = chatMessages[currentChatCharacter.id] || [];
            const transferIndex = messages.findIndex(msg =>
                msg.timestamp === currentTransferMsg.timestamp && msg.type === 'transfer');

            if (transferIndex !== -1) {
                // 更新转账状态
                messages[transferIndex].status = 'accepted';

                // 更新界面显示
                updateTransferDisplay(currentTransferMsg.timestamp, 'accepted');

                // 保存状态
                try {
                    // 🔥【修复】使用单条消息保存，避免强制同步
                    const stableId = `${currentChatCharacter.id}_transfer_${currentTransferMsg.timestamp}_${Math.random().toString(36).substr(2, 9)}`;
                    await db.chatMessages.put({
                        id: stableId,
                        characterId: currentChatCharacter.id,
                        messageData: messages[transferIndex]
                    });
                    console.log('✅ [手动确认收款] 消息已保存到数据库');
                } catch (error) {
                    console.error('确认收款保存失败:', error);
                }

                // 🔥【新增】添加系统消息提示
                const systemMsg = {
                    id: Date.now().toString(),
                    sender: 'system',
                    content: `你已确认收款 ¥${Number(currentTransferMsg.amount).toFixed(2)}`,
                    timestamp: Date.now()
                };

                messages.push(systemMsg);

                // 保存系统消息
                try {
                    const systemStableId = `${currentChatCharacter.id}_system_${systemMsg.timestamp}_${Math.random().toString(36).substr(2, 9)}`;
                    await db.chatMessages.add({
                        id: systemStableId,
                        characterId: currentChatCharacter.id,
                        messageData: systemMsg
                    });
                    console.log('✅ [手动确认收款] 系统消息已保存到数据库');
                } catch (error) {
                    console.error('手动确认收款系统消息保存失败:', error);
                }

                // 重新渲染聊天界面以显示系统消息
                renderChatMessages(currentChatCharacter.id);
            }

            // 关闭对话框
            document.getElementById('transfer-confirm-modal').classList.remove('visible');
            currentTransferMsg = null;

            showToast('已确认收款', 'success');
        }

        async function rejectTransfer() {
            if (!currentTransferMsg || !currentChatCharacter) return;

            // 在聊天记录中找到对应的转账消息并更新状态
            const messages = chatMessages[currentChatCharacter.id] || [];
            const transferIndex = messages.findIndex(msg =>
                msg.timestamp === currentTransferMsg.timestamp && msg.type === 'transfer');

            if (transferIndex !== -1) {
                // 更新转账状态
                messages[transferIndex].status = 'rejected';

                // 更新界面显示
                updateTransferDisplay(currentTransferMsg.timestamp, 'rejected');

                // 保存状态
                try {
                    // 🔥【修复】使用单条消息保存，避免强制同步
                    const stableId = `${currentChatCharacter.id}_transfer_${currentTransferMsg.timestamp}_${Math.random().toString(36).substr(2, 9)}`;
                    await db.chatMessages.put({
                        id: stableId,
                        characterId: currentChatCharacter.id,
                        messageData: messages[transferIndex]
                    });
                    console.log('✅ [手动拒绝转账] 消息已保存到数据库');
                } catch (error) {
                    console.error('拒绝转账保存失败:', error);
                }

                // 🔥【新增】添加系统消息提示
                const systemMsg = {
                    id: Date.now().toString(),
                    sender: 'system',
                    content: `你已退回 ¥${Number(currentTransferMsg.amount).toFixed(2)}`,
                    timestamp: Date.now()
                };

                messages.push(systemMsg);

                // 保存系统消息
                try {
                    const systemStableId = `${currentChatCharacter.id}_system_${systemMsg.timestamp}_${Math.random().toString(36).substr(2, 9)}`;
                    await db.chatMessages.add({
                        id: systemStableId,
                        characterId: currentChatCharacter.id,
                        messageData: systemMsg
                    });
                    console.log('✅ [手动拒绝转账] 系统消息已保存到数据库');
                } catch (error) {
                    console.error('手动拒绝转账系统消息保存失败:', error);
                }

                // 重新渲染聊天界面以显示系统消息
                renderChatMessages(currentChatCharacter.id);
            }

            // 关闭对话框
            document.getElementById('transfer-confirm-modal').classList.remove('visible');
            currentTransferMsg = null;

            showToast('已退回转账', 'success');
        }

        // 监听app显示事件
        const originalShowApp = window.showApp;
        if (originalShowApp) {
            window.showApp = function(appId) {
                originalShowApp(appId);
                if (appId === 'data-management-screen') calculateStorageUsage();
            };
        }

        // 显示定时发布时间设置模态框
        function showScheduleTimesModal() {
            if (!currentChatCharacter) return;

            const chatSettings = getCurrentChatSettings();
            const scheduleTimes = chatSettings.scheduledMomentsTimes || [];

            const container = document.getElementById('schedule-times-modal-container');
            container.innerHTML = '';

            // 渲染已有时间点
            scheduleTimes.forEach((time, index) => {
                const timeItem = document.createElement('div');
                timeItem.className = 'schedule-time-item';
                timeItem.style.cssText = `
                    display: flex;
                    align-items: center;
                    margin-bottom: 10px;
                    gap: 10px;
                `;
                timeItem.innerHTML = `
                    <input type="time" value="${time}" onchange="updateScheduleTime(${index}, this.value)"
                           style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 6px;">
                    <button onclick="removeScheduleTime(${index})"
                            style="padding: 8px 12px; background: #ff3b30; color: white; border: none; border-radius: 6px; cursor: pointer;">×</button>
                `;
                container.appendChild(timeItem);
            });

            showModal('schedule-times-modal');
        }

        // 添加定时发布时间点
        function addScheduleTime() {
            if (!currentChatCharacter) return;

            const chatSettings = getCurrentChatSettings();
            if (!chatSettings.scheduledMomentsTimes) {
                chatSettings.scheduledMomentsTimes = [];
            }

            if (chatSettings.scheduledMomentsTimes.length >= 10) {
                alert('最多只能设置10个时间点');
                return;
            }

            chatSettings.scheduledMomentsTimes.push('09:00');
            saveCurrentChatSettings(chatSettings);
            showScheduleTimesModal(); // 重新渲染
        }

        // 更新定时发布时间点
        function updateScheduleTime(index, newTime) {
            if (!currentChatCharacter) return;

            const chatSettings = getCurrentChatSettings();
            if (chatSettings.scheduledMomentsTimes && chatSettings.scheduledMomentsTimes[index] !== undefined) {
                chatSettings.scheduledMomentsTimes[index] = newTime;
                saveCurrentChatSettings(chatSettings);
            }
        }

        // 移除定时发布时间点
        function removeScheduleTime(index) {
            if (!currentChatCharacter) return;

            const chatSettings = getCurrentChatSettings();
            if (chatSettings.scheduledMomentsTimes && chatSettings.scheduledMomentsTimes[index] !== undefined) {
                chatSettings.scheduledMomentsTimes.splice(index, 1);
                saveCurrentChatSettings(chatSettings);
                showScheduleTimesModal(); // 重新渲染
            }
        }

        // 保存定时发布设置
        function saveScheduleTimes() {
            if (!currentChatCharacter) return;

            const container = document.getElementById('schedule-times-modal-container');
            const timeInputs = container.querySelectorAll('input[type="time"]');
            const times = Array.from(timeInputs).map(input => input.value).filter(time => time);

            const chatSettings = getCurrentChatSettings();
            chatSettings.scheduledMomentsTimes = times;
            saveCurrentChatSettings(chatSettings);

            updateScheduleTimesDisplay();
            hideModal('schedule-times-modal');

            // 重新初始化全局动态发布系统以应用新设置
            setTimeout(async () => {
                try {
                    await initGlobalMomentsSystem();
                    console.log('✅ 定时发布设置已更新');
                } catch (error) {
                    console.error('❌ 更新定时发布设置失败:', error);
                }
            }, 500);

            showToast(`已保存 ${times.length} 个定时发布时间点`, 'success');
        }

        // 更新定时发布时间显示
        function updateScheduleTimesDisplay() {
            if (!currentChatCharacter) return;

            const chatSettings = getCurrentChatSettings();
            const scheduleTimes = chatSettings.scheduledMomentsTimes || [];
            const displayElement = document.getElementById('schedule-times-display');

            if (scheduleTimes.length === 0) {
                displayElement.textContent = '未设置';
            } else if (scheduleTimes.length === 1) {
                displayElement.textContent = `1个时间点 (${scheduleTimes[0]})`;
            } else {
                displayElement.textContent = `${scheduleTimes.length}个时间点`;
            }
        }

        // 测试发布动态
        async function testPublishMoment() {
            if (!currentChatCharacter) {
                alert('请先选择一个角色');
                return;
            }

            const button = document.querySelector('button[onclick="testPublishMoment()"]');
            const originalText = button.textContent;
            button.textContent = '发布中...';
            button.disabled = true;

            try {
                await triggerBackgroundMomentsTest(currentChatCharacter.id);
                showToast('测试动态发布成功！', 'success');
            } catch (error) {
                console.error('测试发布失败:', error);
                showToast('测试发布失败', 'error');
            } finally {
                button.textContent = originalText;
                button.disabled = false;
            }
        }

        // 初始化定时发布系统
        function initScheduledMomentsSystem() {
            if (!currentChatCharacter) return;

            const chatSettings = getCurrentChatSettings();
            if (!chatSettings.scheduledMomentsEnabled || !chatSettings.scheduledMomentsTimes?.length) {
                return;
            }

            // 为每个设定时间创建定时器
            chatSettings.scheduledMomentsTimes.forEach(time => {
                if (!time) return;

                const [hours, minutes] = time.split(':').map(Number);
                const now = new Date();
                const scheduledTime = new Date();

                scheduledTime.setHours(hours, minutes, 0, 0);

                // 如果时间已过，设置为明天
                if (scheduledTime <= now) {
                    scheduledTime.setDate(scheduledTime.getDate() + 1);
                }

                const delay = scheduledTime.getTime() - now.getTime();

                setTimeout(() => {
                    // 执行定时发布
                    triggerBackgroundMoments(currentChatCharacter.id);

                    // 设置每24小时重复执行
                    setInterval(() => {
                        triggerBackgroundMoments(currentChatCharacter.id);
                    }, 24 * 60 * 60 * 1000);
                }, delay);
            });
        }

        // 🔥【新增】推送通知功能
        // 🔥【新增】通知队列和单个通知管理
        let notificationQueue = [];
        let currentNotification = null;
        let isProcessingQueue = false;

        // 🔥【修复】创建推送通知 - 改为队列方式，单个显示
        function createPushNotification(character, messageData, delay = 0) {
            // 🔥【新增】播放推送通知音效
            setTimeout(() => {
                SoundManager.play(SoundManager.TYPES.NOTIFICATION, character?.id);
            }, delay);

            // 🔥【修复】检查用户是否在和该角色的聊天界面 - 更精确的判断

            // 方法1：检查主屏幕是否可见
            const phoneScreen = document.getElementById('phone-screen');
            const isOnMainScreen = phoneScreen && window.getComputedStyle(phoneScreen).display !== 'none';

            // 方法2：检查聊天界面是否可见
            const chatScreen = document.getElementById('api-chat-screen');
            const isChatVisible = chatScreen && window.getComputedStyle(chatScreen).display !== 'none';

            // 方法3：检查用户是否在和该角色聊天
            const isChattingWithThisCharacter = isChatVisible && currentChatCharacter && currentChatCharacter.id === character.id;

            console.log('🔔 [推送通知] 检查界面状态:', {
                mainScreenVisible: isOnMainScreen,
                chatScreenVisible: isChatVisible,
                currentChatCharacter: currentChatCharacter?.name,
                messageFromCharacter: character.name,
                isChattingWithThisCharacter: isChattingWithThisCharacter,
                shouldShowNotification: isOnMainScreen && !isChattingWithThisCharacter
            });

            // 🔥【修复】纪念日和约定通知应该总是显示，无论在哪个界面
            // 检查消息内容是否是纪念日或约定相关的通知
            const isAnniversaryNotification = typeof messageData === 'string' &&
                (messageData.includes('创建了纪念日') || messageData.includes('创建了约定') ||
                 messageData.includes('创建了特别的日子') || messageData.includes('记录了生日') ||
                 messageData.includes('创建了关系纪念日') || messageData.includes('和你约定了') ||
                 messageData.includes('许下承诺') || messageData.includes('约定和你见面') ||
                 messageData.includes('约定了活动') || messageData.includes('约定了约会') ||
                 messageData.includes('提醒：') || messageData.includes('今天是') ||
                 messageData.includes('🎉') || messageData.includes('📝') || messageData.includes('📅') || messageData.includes('⏰'));

            if (isAnniversaryNotification) {
                // 纪念日/约定通知总是显示，无论用户在哪里，包括正在和该角色聊天
                console.log('🔔 [推送通知] 纪念日/约定通知，无条件显示');
                // 直接跳过所有条件检查，强制显示
            } else {
                // 普通消息通知的原有逻辑
                if (!isOnMainScreen || isChattingWithThisCharacter) {
                    console.log('🔔 [推送通知] 用户不在主屏幕或正在和该角色聊天，不显示推送');
                    return;
                }
            }

            // 添加到队列
            notificationQueue.push({
                character,
                messageData,
                delay
            });

            console.log('🔔 [推送通知] 添加通知到队列，当前队列长度:', notificationQueue.length);

            // 开始处理队列
            processNotificationQueue();
        }

        // 🔥【新增】处理通知队列
        function processNotificationQueue() {
            if (isProcessingQueue || notificationQueue.length === 0) {
                return;
            }

            isProcessingQueue = true;
            console.log('🔔 [推送通知] 开始处理队列，剩余通知数:', notificationQueue.length);

            const processNext = () => {
                if (notificationQueue.length === 0) {
                    isProcessingQueue = false;
                    console.log('🔔 [推送通知] 队列处理完成');
                    return;
                }

                const { character, messageData, delay } = notificationQueue.shift();

                setTimeout(() => {
                    showSingleNotification(character, messageData);

                    // 🔥【修复】增加通知间隔到2.6秒，确保用户有足够时间看完当前通知
                    setTimeout(() => {
                        processNext();
                    }, 2600);
                }, delay);
            };

            processNext();
        }

        // 🔥【新增】显示单个通知
        function showSingleNotification(character, messageData) {
            console.log('🔔 [推送通知] 显示单个通知，角色:', character.name);

            const container = document.getElementById('notification-container');
            if (!container) {
                console.error('🔔 [推送通知] 找不到通知容器!');
                return;
            }

            // 如果有现有通知，先移除
            if (currentNotification) {
                hideNotification(currentNotification, true);
            }

            // 创建通知元素
            const notification = document.createElement('div');
            notification.className = 'push-notification';
            currentNotification = notification;

            // 生成通知内容
            let notificationText = '';
            let notificationType = 'message';
            let senderName = character.name;
            let isGroupMessage = false;
            let groupSenderName = '';

            if (typeof messageData === 'string') {
                notificationText = messageData;
            } else if (typeof messageData === 'object') {
                // 🔥【修复】处理群聊消息格式
                if (messageData.name && messageData.message) {
                    // 群聊消息格式: {name: "角色名", message: "消息内容"}
                    isGroupMessage = true;
                    groupSenderName = messageData.name;
                    // 🔥【关键修复】群聊推送标题显示群聊名字，内容显示"角色名：消息"
                    senderName = `[群聊]${character.name}`;

                    if (typeof messageData.message === 'string') {
                        notificationText = `${groupSenderName}：${messageData.message}`;
                    } else if (typeof messageData.message === 'object' && messageData.message.type) {
                        // 群聊中的特殊消息类型
                        switch (messageData.message.type) {
                            case 'transfer':
                                notificationText = `${groupSenderName}：向你转账了 ¥${messageData.message.amount}`;
                                notificationType = 'transfer';
                                break;
                            case 'voice_message':
                                notificationText = `${groupSenderName}：[语音消息]`;
                                notificationType = 'voice';
                                break;
                            default:
                                notificationText = `${groupSenderName}：${messageData.message.content || '[消息]'}`;
                        }
                    } else {
                        notificationText = `${groupSenderName}：${String(messageData.message)}`;
                    }
                } else if (messageData.type) {
                    // 普通的特殊消息类型
                    switch (messageData.type) {
                        case 'transfer':
                            notificationText = `向你转账了 ¥${messageData.amount}`;
                            notificationType = 'transfer';
                            break;
                        case 'voice_message':
                            notificationText = '[语音消息]';
                            notificationType = 'voice';
                            break;
                        case 'ai_image':
                            notificationText = '[图片]';
                            notificationType = 'image';
                            break;
                        case 'emoji':
                            notificationText = `发送了表情包：${messageData.description}`;
                            notificationType = 'emoji';
                            break;
                        default:
                            notificationText = messageData.content || '[消息]';
                    }
                } else {
                    notificationText = messageData.content || messageData.message || '[消息]';
                }
            }

            // 限制通知文本长度
            if (notificationText.length > 25) {
                notificationText = notificationText.substring(0, 25) + '...';
            }

            // 生成时间
            const now = new Date();
            const timeString = now.toLocaleTimeString('zh-CN', {
                hour: '2-digit',
                minute: '2-digit'
            });

            // 设置通知HTML
            notification.innerHTML = `
                <img class="notification-avatar" src="${character.avatarUrl || character.avatar || createDefaultAvatar(character.name)}" alt="${senderName}">
                <div class="notification-content">
                    <div class="notification-title">${senderName}</div>
                    <div class="notification-message">${notificationText}</div>
                </div>
                <div class="notification-time">${timeString}</div>
            `;

            // 点击通知打开聊天
            notification.onclick = () => {
                console.log('🔔 [推送通知] 用户点击了推送通知，跳转到聊天界面');

                // 🔥【新增】检查是否是短信推送通知
                const isSMSNotification = notificationText.startsWith('[短信]');
                // 🔥【新增】检查是否是日记推送通知
                const isDiaryNotification = notificationText.startsWith('[日记]');

                // 如果有角色信息，确保切换到对应角色
                if (character && character.id) {
                    console.log('🔔 [推送通知] 切换到角色:', character.name, character.id, '是否为短信:', isSMSNotification, '是否为日记:', isDiaryNotification);

                    if (isSMSNotification) {
                        // 🔥【新增】短信推送通知跳转到短信聊天界面
                        window.currentSMSCharacter = character;
                        updateSMSChatHeader(character);
                        renderSMSMessages(character.id);

                        // 切换到短信聊天界面
                        showApp('sms-chat-screen');
                        console.log('🔔 [短信推送通知] 跳转到短信聊天界面完成');
                    } else if (isDiaryNotification) {
                        // 🔥【新增】日记推送通知跳转到日记界面
                        currentChatCharacter = character;

                        // 切换到聊天界面
                        showApp('api-chat-screen');

                        // 延迟打开日记界面，确保聊天界面已加载
                        setTimeout(() => {
                            showDiary();
                        }, 100);

                        console.log('🔔 [日记推送通知] 跳转到日记界面完成');
                    } else {
                        // 🔥【保持原有逻辑】普通聊天推送通知跳转到聊天界面
                        currentChatCharacter = character;
                        // 更新聊天界面标题
                        const chatTitle = document.getElementById('api-chat-title');
                        if (chatTitle) {
                            // 🔥【修复】群聊标题显示成员数量
                            let displayTitle = character.name;
                            if (character.isGroup && character.members) {
                                const memberCount = character.members.length + 1; // +1 包括用户自己
                                displayTitle = `${character.name}（${memberCount}）`;
                            }
                            chatTitle.textContent = displayTitle;
                            // 🔥【新增】清除正在输入状态并保存新的原始标题
                            chatTitle.classList.remove('typing-status');
                            chatTitle.dataset.originalTitle = displayTitle;
                        }
                        // 渲染该角色的聊天记录
                        renderChatMessages(character.id);

                        // 切换到聊天界面
                        showApp('api-chat-screen');
                        console.log('🔔 [推送通知] 跳转到聊天界面完成');
                    }
                }

                // 移除通知
                hideNotification(notification);
            };

            // 添加到容器
            container.appendChild(notification);

            // 显示动画
            setTimeout(() => {
                notification.classList.add('show');
            }, 50);

            // 🔥【修复】自动隐藏 - 增加显示时长
            setTimeout(() => {
                if (currentNotification === notification) {
                    hideNotification(notification);
                }
            }, 2300);
        }

        function hideNotification(notification, immediate = false) {
            if (notification && notification.parentNode) {
                notification.classList.remove('show');
                notification.classList.add('hide');

                // 如果是当前通知，清除引用
                if (currentNotification === notification) {
                    currentNotification = null;
                }

                const removeDelay = immediate ? 0 : 250;
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, removeDelay);
            }
        }

        // 🔥【新增】为动态互动创建推送通知
        function createMomentInteractionNotification(character, interactionType, momentText) {
            let notificationText = '';
            switch (interactionType) {
                case 'like':
                    notificationText = `赞了你的动态`;
                    break;
                case 'comment':
                    notificationText = `评论了你的动态`;
                    break;
                default:
                    notificationText = `与你的动态互动了`;
            }

            createPushNotification(character, notificationText);
        }

        // 🔥【新增】短信专用推送通知函数
        function createSMSPushNotification(character, messageText, delay = 0) {
            // 🔥【新增】播放推送通知音效
            setTimeout(() => {
                SoundManager.play(SoundManager.TYPES.NOTIFICATION, character?.id);
            }, delay);

            // 🔥【关键】检查用户是否在和该角色的短信聊天界面
            const phoneScreen = document.getElementById('phone-screen');
            const isOnMainScreen = phoneScreen && window.getComputedStyle(phoneScreen).display !== 'none';

            const smsScreen = document.getElementById('sms-chat-screen');
            const isSMSVisible = smsScreen && window.getComputedStyle(smsScreen).display !== 'none';

            const isChattingWithThisCharacter = isSMSVisible && window.currentSMSCharacter && window.currentSMSCharacter.id === character.id;

            console.log('🔔 [短信推送通知] 检查界面状态:', {
                mainScreenVisible: isOnMainScreen,
                smsScreenVisible: isSMSVisible,
                currentSMSCharacter: window.currentSMSCharacter?.name,
                messageFromCharacter: character.name,
                isChattingWithThisCharacter: isChattingWithThisCharacter,
                shouldShowNotification: isOnMainScreen && !isChattingWithThisCharacter
            });

            // 🔥【关键】只有当用户不在和该角色的短信聊天界面时才显示推送
            if (!isOnMainScreen || isChattingWithThisCharacter) {
                console.log('🔔 [短信推送通知] 用户不在主屏幕或正在和该角色短信聊天，不显示推送');
                return;
            }

            // 🔥【新增】为短信消息添加[短信]标识
            const smsNotificationText = `[短信] ${messageText}`;

            // 复用现有的推送通知系统
            createPushNotification(character, smsNotificationText, delay);
        }

        // 🔥【新增】页面卸载时标记当前聊天为已读
        window.addEventListener('beforeunload', function() {
            // 如果用户正在聊天界面，标记当前聊天的消息为已读
            if (currentChatCharacter) {
                markAsRead(currentChatCharacter.id);
                console.log('🔥 [页面卸载] 标记当前聊天为已读:', currentChatCharacter.name);
            } else {
                // 🔥【新增】如果currentChatCharacter为空，尝试从sessionStorage恢复
                const savedChatId = sessionStorage.getItem('currentChatCharacterId');
                if (savedChatId) {
                    markAsRead(savedChatId);
                    console.log('🔥 [页面卸载] 从sessionStorage恢复并标记聊天为已读:', savedChatId);
                }
            }
            // 清除保存的聊天状态
            sessionStorage.removeItem('currentChatCharacterId');
        });

        // 🔥【新增】页面隐藏时也标记当前聊天为已读（处理移动端切换应用的情况）
        document.addEventListener('visibilitychange', function() {
            if (document.hidden && currentChatCharacter) {
                markAsRead(currentChatCharacter.id);
                console.log('🔥 [页面隐藏] 标记当前聊天为已读:', currentChatCharacter.name);
            }
        });

        // 🔥【新增】页面失去焦点时也标记当前聊天为已读（处理切换标签页的情况）
        window.addEventListener('blur', function() {
            if (currentChatCharacter) {
                markAsRead(currentChatCharacter.id);
                console.log('🔥 [页面失焦] 标记当前聊天为已读:', currentChatCharacter.name);
            }
        });

        // 初始化转账功能事件监听器
        document.addEventListener('DOMContentLoaded', function() {
            // 添加转账相关事件监听器
            document.getElementById('transfer-cancel-btn')?.addEventListener('click', () => {
                document.getElementById('transfer-modal').classList.remove('visible');
            });

            document.getElementById('transfer-confirm-btn')?.addEventListener('click', sendTransfer);
            document.getElementById('transfer-accept-btn')?.addEventListener('click', acceptTransfer);
            document.getElementById('transfer-reject-btn')?.addEventListener('click', rejectTransfer);

            // 点击模态框背景关闭
            document.getElementById('transfer-modal')?.addEventListener('click', (e) => {
                if (e.target === document.getElementById('transfer-modal')) {
                    document.getElementById('transfer-modal').classList.remove('visible');
                }
            });

            document.getElementById('transfer-confirm-modal')?.addEventListener('click', (e) => {
                if (e.target === document.getElementById('transfer-confirm-modal')) {
                    document.getElementById('transfer-confirm-modal').classList.remove('visible');
                    currentTransferMsg = null;
                }
            });
        });

        // 群聊相关函数
        function updateGroupChatInfo() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;

            // 更新群聊头像预览
            const groupAvatarPreview = document.getElementById('group-avatar-preview');
            if (groupAvatarPreview) {
                if (currentChatCharacter.avatarUrl) {
                    groupAvatarPreview.src = currentChatCharacter.avatarUrl;
                } else {
                    // 使用默认的群聊头像 - 创建一个简单的Canvas头像
                    const canvas = document.createElement('canvas');
                    canvas.width = 40;
                    canvas.height = 40;
                    const ctx = canvas.getContext('2d');

                    // 绘制蓝色圆形背景
                    ctx.beginPath();
                    ctx.arc(20, 20, 20, 0, 2 * Math.PI);
                    ctx.fillStyle = '#4a84c1';
                    ctx.fill();

                    // 绘制白色"群"字
                    ctx.fillStyle = 'white';
                    ctx.font = '18px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('群', 20, 20);

                    groupAvatarPreview.src = canvas.toDataURL();
                }
            }

            // 更新群聊名称显示
            const groupNameDisplay = document.getElementById('group-name-display');
            if (groupNameDisplay) {
                groupNameDisplay.textContent = currentChatCharacter.name || '群聊名称';
            }

            // 更新群成员数量显示
            const groupMemberCountDisplay = document.getElementById('group-member-count-display');
            if (groupMemberCountDisplay) {
                const memberCount = currentChatCharacter.members ? currentChatCharacter.members.length : 0;
                // 群成员数量 = 角色数量 + 1个用户
                const totalMemberCount = memberCount + 1;
                groupMemberCountDisplay.textContent = `${totalMemberCount}名成员`;
            }

            // 更新群公告显示
            const groupDescriptionDisplay = document.getElementById('group-description-display');
            if (groupDescriptionDisplay) {
                groupDescriptionDisplay.textContent = currentChatCharacter.description || '群公告：点击设置群公告';
            }

            // 更新我在群里的昵称 - 使用当前选择的面具名称作为默认值
            const currentMyGroupNickname = document.getElementById('current-my-group-nickname');
            if (currentMyGroupNickname) {
                let defaultNickname = '未选择';

        // --- 新增代码开始 ---
        const chatSettings = getCurrentChatSettings();
        const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
        // --- 新增代码结束 ---

                // 如果用户选择了面具，使用面具名称
        if (selectedPersona && selectedPersona.name) { // <--- 修改这里
            defaultNickname = selectedPersona.name;
                }

        // 优先显示用户在群聊中自己设置的昵称，如果没有，则显示创建群聊时选择的身份昵称
        currentMyGroupNickname.textContent = chatSettings.myChatNickname || defaultNickname;
            }

            // 渲染群成员网格
            renderGroupMembersGrid();
        }

        function changeGroupAvatar() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;

            const tempInput = document.createElement('input');
            tempInput.type = 'file';
            tempInput.accept = 'image/*,.jpg,.jpeg,.png,.gif,.webp';
            tempInput.style.display = 'none';
            document.body.appendChild(tempInput);

            tempInput.onchange = function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = async function(event) {
                        // 更新当前群聊角色的头像
                        currentChatCharacter.avatarUrl = event.target.result;

                        // 如果是群聊，需要更新群聊数据
                        if (groupChats) {
                            const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                            if (groupIndex !== -1) {
                                groupChats[groupIndex].avatarUrl = event.target.result;
                                await saveGroupChats(groupChats);
                            }
                        }

                        // 更新UI显示
                        updateGroupChatInfo();

                        // 🔥【修复】群聊标题显示成员数量
                        let displayTitle = currentChatCharacter.name;
                        if (currentChatCharacter.members) {
                            const memberCount = currentChatCharacter.members.length + 1; // +1 包括用户自己
                            displayTitle = `${currentChatCharacter.name}（${memberCount}）`;
                        }
                        const chatTitle = document.getElementById('api-chat-title');
                        if (chatTitle) {
                            chatTitle.textContent = displayTitle;
                            // 🔥【新增】清除正在输入状态并保存新的原始标题
                            chatTitle.classList.remove('typing-status');
                            chatTitle.dataset.originalTitle = displayTitle;
                        }

                        // 更新头像显示
                        const chatAvatarElement = document.querySelector('#api-chat-screen .message-avatar img');
                        if (chatAvatarElement) {
                            chatAvatarElement.src = event.target.result;
                        }

                        // 更新消息列表和联系人列表中的群聊头像
                        renderContactList();
                        renderMessageList();

                        document.body.removeChild(tempInput);
                    };
                    reader.readAsDataURL(e.target.files[0]);
                } else {
                    document.body.removeChild(tempInput);
                }
            };

            tempInput.click();
        }

        function changeGroupName() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;

            const newName = prompt('请输入新的群聊名称:', currentChatCharacter.name);
            if (newName && newName.trim() !== '') {
                const trimmedName = newName.trim();

                // 更新当前群聊角色的名称
                currentChatCharacter.name = trimmedName;

                // 如果是群聊，需要更新群聊数据
                if (groupChats) {
                    const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                    if (groupIndex !== -1) {
                        groupChats[groupIndex].name = trimmedName;
                        saveGroupChats(groupChats);
                    }
                }

                // 更新UI显示
                updateGroupChatInfo();

                // 🔥【修复】群聊标题显示成员数量
                let displayTitle = trimmedName;
                if (currentChatCharacter.members) {
                    const memberCount = currentChatCharacter.members.length + 1; // +1 包括用户自己
                    displayTitle = `${trimmedName}（${memberCount}）`;
                }
                const chatTitle = document.getElementById('api-chat-title');
                if (chatTitle) {
                    chatTitle.textContent = displayTitle;
                    // 🔥【新增】清除正在输入状态并保存新的原始标题
                    chatTitle.classList.remove('typing-status');
                    chatTitle.dataset.originalTitle = displayTitle;
                }
                renderContactList();
                renderMessageList();
            }
        }

// --- 请从这里开始复制，替换掉旧的 showGroupChatMemberSelection 和 renderGroupMembersGrid 函数 ---

// 5. 显示群成员选择 (已修正版本)
function showGroupChatMemberSelection(personaId) {
    console.log('✅ 第二个showGroupChatMemberSelection被调用，接收到的personaId:', personaId);

    // 立即将personaId存储到全局变量中，确保不会丢失
    window.currentGroupPersonaId = personaId;

    // 重置表单
    document.getElementById('group-chat-name').value = '';
    selectedGroupMembers = [];

    const membersContainer = document.getElementById('group-chat-members');
    membersContainer.innerHTML = '';

    if (characters.length < 2) {
        membersContainer.innerHTML = '<p class="empty-mount-chats">至少需要2个角色才能创建群聊</p>';
    } else {
        characters.forEach(character => {
            const memberItem = document.createElement('div');
            memberItem.className = 'group-member-item';
            memberItem.onclick = () => toggleGroupMemberSelection(character.id);
            // 关键修复：重新添加了显示角色简介的HTML代码
            memberItem.innerHTML = `
                <div class="group-member-checkbox" id="checkbox-${character.id}"></div>
                <div class="message-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url('${character.avatarUrl}'); background-size: cover; background-position: center;` : ''}">
                    ${character.avatarUrl ? '' : character.name.charAt(0)}
                </div>
                <div class="chat-option-text">
                    <div class="chat-option-title">${character.name}</div>
                    <div class="chat-option-desc">${truncateText(character.bio || '暂无简介', 80)}</div>
                </div>`;
            membersContainer.appendChild(memberItem);
        });
    }

    // 将 personaId 附加到创建按钮上
    console.log('✅ 在第二个位置绑定创建按钮，personaId:', personaId);
    const createBtn = document.getElementById('group-chat-modal').querySelector('.modal-primary');
    createBtn.onclick = () => {
        console.log('✅ 第二个位置的创建群聊按钮被点击，直接使用参数personaId:', personaId);
        createGroupChat(personaId);
    }; // 绑定带参数的创建函数

    showModal('group-chat-modal');
}


// 渲染群成员网格 (已修正版本)
        function renderGroupMembersGrid() {
            const groupMembersGrid = document.getElementById('group-members-grid');
            if (!groupMembersGrid || !currentChatCharacter || !currentChatCharacter.isGroup) return;

            // 清空现有内容
            groupMembersGrid.innerHTML = '';

    // --- 关键修复：正确获取并显示用户在当前群聊中的身份 ---
    const chatSettings = getCurrentChatSettings(); // 获取当前群聊的专属设置
    const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);

            let userName = '用户';
            let userAvatar = '';

    if (selectedPersona) {
        // 优先使用群聊设置里为“我”单独设置的昵称和头像
        userName = chatSettings.myChatNickname || selectedPersona.name;
        userAvatar = chatSettings.myChatAvatar || selectedPersona.avatarUrl;
    }

    // 添加用户自己（排在第一位）
    const userItem = document.createElement('div');
    userItem.className = 'member-item user-member';
    userItem.onclick = () => changeMyGroupAvatar();
            userItem.innerHTML = `
                <img class="member-avatar" src="${userAvatar || createDefaultAvatar(userName)}" alt="${userName}">
                <div class="member-name">${userName}</div>
            `;
            groupMembersGrid.appendChild(userItem);
    // --- 修复结束 ---

            // 然后添加群内现有角色
            if (currentChatCharacter.members && currentChatCharacter.members.length > 0) {
                currentChatCharacter.members.forEach(member => {
                    const memberItem = document.createElement('div');
                    memberItem.className = 'member-item';

                    memberItem.innerHTML = `
                        <div class="member-avatar-wrapper">
                            <img class="member-avatar clickable-avatar"
                                 src="${member.avatarUrl || createDefaultAvatar(member.name)}"
                                 alt="${member.name}"
                                 onclick="changeMemberAvatar('${member.id}', event)"
                                 title="点击更换${member.name}的头像">
                            <div class="avatar-hover-hint">
                                <i class="fas fa-camera"></i>
                            </div>
                        </div>
                        <div class="member-name">${member.name}</div>
                    `;
                    groupMembersGrid.appendChild(memberItem);
                });
            }

            // 添加邀请按钮
            const addMemberBtn = document.createElement('div');
            addMemberBtn.className = 'member-item add-member';
            addMemberBtn.onclick = () => addGroupMember();
            addMemberBtn.innerHTML = `
                <div class="member-avatar add-avatar">
                    <i class="fas fa-plus"></i>
                </div>
                <div class="member-name">邀请</div>
            `;
            groupMembersGrid.appendChild(addMemberBtn);

            // 只要群内有角色成员就显示移除按钮
            if (currentChatCharacter.members && currentChatCharacter.members.length > 0) {
                const removeMemberBtn = document.createElement('div');
                removeMemberBtn.className = 'member-item remove-member';
                removeMemberBtn.onclick = () => removeGroupMember();
                removeMemberBtn.innerHTML = `
                    <div class="member-avatar remove-avatar">
                        <i class="fas fa-minus"></i>
                    </div>
                    <div class="member-name">移除</div>
                `;
                groupMembersGrid.appendChild(removeMemberBtn);
            }
        }

// --- 请复制到这里结束 ---

        // 显示成员详情
        function showMemberProfile(member) {
            alert(`👤 群成员信息\n\n昵称：${member.name}\n角色ID：${member.id}\n\n点击头像可以查看角色详细信息`);
        }

        // 显示用户自己的资料
        function showUserProfile() {
            let userName = '用户';
            let userInfo = '群聊成员';

            if (currentChatCharacter.myNickname) {
                userName = currentChatCharacter.myNickname;
                userInfo = `群昵称：${currentChatCharacter.myNickname}`;
            }

            alert(`👤 我的信息\n\n昵称：${userName}\n身份：${userInfo}\n\n这是你自己在群聊中的信息`);
        }

        // 创建默认头像
        function createDefaultAvatar(name) {
            const canvas = document.createElement('canvas');
            canvas.width = 50;
            canvas.height = 50;
            const ctx = canvas.getContext('2d');

            // 随机背景颜色
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF'];
            const bgColor = colors[name.charCodeAt(0) % colors.length];

            // 绘制圆形背景
            ctx.beginPath();
            ctx.arc(25, 25, 25, 0, 2 * Math.PI);
            ctx.fillStyle = bgColor;
            ctx.fill();

            // 绘制文字
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(name.charAt(0), 25, 25);

            return canvas.toDataURL();
        }

        function showGroupMembers() {
            alert('👥 群成员管理功能开发中...\n\n将支持以下功能：\n• 查看群成员列表\n• 设置群管理员\n• 管理群成员权限\n• 禁言/踢出群聊');
        }

        async function changeMyGroupNickname() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;

    const chatSettings = getCurrentChatSettings();
    const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);

    const currentNickname = chatSettings.myChatNickname || (selectedPersona ? selectedPersona.name : '用户');
    const newNickname = prompt('请输入我在本群的昵称:', currentNickname);

    if (newNickname && newNickname.trim() !== '' && newNickname.trim() !== currentNickname) {
                const trimmedNickname = newNickname.trim();

        // 1. 更新当前群聊设置中的昵称
        chatSettings.myChatNickname = trimmedNickname;
        await saveCurrentChatSettings(chatSettings);

        // 2. 创建并添加系统消息
        const systemMessage = {
            id: 'system_' + Date.now(),
            sender: 'system',
            content: `你已将群昵称修改为 "${trimmedNickname}"`,
            timestamp: Date.now()
        };

        if (!chatMessages[currentChatCharacter.id]) {
            chatMessages[currentChatCharacter.id] = [];
        }
        chatMessages[currentChatCharacter.id].push(systemMessage);
        // 🔥【优化】群昵称修改使用高效保存
        try {
            await saveChatMessagesImmediate([currentChatCharacter.id]);
            console.log('✅ [高效群昵称修改] 消息已保存到数据库');
        } catch (error) {
            console.error('群昵称修改消息保存失败，回退到全量保存:', error);
            await saveChatMessages();
        }

        // 3. 更新UI
        updateGroupChatInfo(); // 这会刷新设置页面的显示
        renderChatMessages(currentChatCharacter.id); // 刷新聊天界面显示系统消息

        showToast('群昵称修改成功！', 'success');
    }
}
// --- 新增函数 ---
async function changeMyGroupAvatar() {
    if (!currentChatCharacter) return;

    // 创建一个临时的文件输入框
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*,.jpg,.jpeg,.png,.gif,.webp';
    input.style.display = 'none';

    // 当用户选择了文件后
    input.onchange = async (e) => {
        if (!e.target.files || !e.target.files[0]) return;

        const file = e.target.files[0];
        const reader = new FileReader();

        reader.onload = async (event) => {
            const newAvatarUrl = event.target.result;

            // 1. 更新当前群聊设置中的头像
            const chatSettings = getCurrentChatSettings();
            chatSettings.myChatAvatar = newAvatarUrl;
            await saveCurrentChatSettings(chatSettings);

            // 2. 创建并添加系统消息
            const systemMessage = {
                id: 'system_' + Date.now(),
                sender: 'system',
                content: `你更换了新头像`,
                timestamp: Date.now()
            };

            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            chatMessages[currentChatCharacter.id].push(systemMessage);
            // 🔥【优化】群头像更换使用高效保存
            try {
                await saveChatMessagesImmediate([currentChatCharacter.id]);
                console.log('✅ [高效群头像更换] 消息已保存到数据库');
            } catch (error) {
                console.error('群头像更换消息保存失败，回退到全量保存:', error);
                await saveChatMessages();
            }

            // 3. 更新UI
            updateGroupChatInfo(); // 刷新设置页面的成员列表
            renderChatMessages(currentChatCharacter.id); // 刷新聊天界面显示新头像和系统消息

            showToast('群头像更换成功！', 'success');
        };

        reader.readAsDataURL(file);
        document.body.removeChild(input); // 清理临时的input元素
    };

    document.body.appendChild(input);
    input.click(); // 弹出文件选择窗口
        }

        // 编辑群公告
        function editGroupDescription() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            showGroupNoticeModal();
        }

        // 显示群公告编辑模态框
        function showGroupNoticeModal() {
            const modal = document.getElementById('group-notice-modal');
            const textarea = document.getElementById('group-notice-content');
            const charCount = document.getElementById('notice-char-current');

            // 设置当前群公告内容
            const currentDescription = currentChatCharacter?.description || '';
            textarea.value = currentDescription;
            charCount.textContent = currentDescription.length;

            // 监听字符数变化
            textarea.addEventListener('input', updateNoticeCharCount);

            modal.style.display = 'flex';
            setTimeout(() => textarea.focus(), 100);
        }

        // 隐藏群公告编辑模态框
        function hideGroupNoticeModal() {
            const modal = document.getElementById('group-notice-modal');
            const textarea = document.getElementById('group-notice-content');

            // 移除事件监听器
            textarea.removeEventListener('input', updateNoticeCharCount);

            modal.style.display = 'none';
        }

        // 更新字符计数
        function updateNoticeCharCount() {
            const textarea = document.getElementById('group-notice-content');
            const charCount = document.getElementById('notice-char-current');
            charCount.textContent = textarea.value.length;

            // 如果超过限制，变色提示
            if (textarea.value.length > 500) {
                charCount.style.color = '#ff3b30';
            } else if (textarea.value.length > 450) {
                charCount.style.color = '#ff9500';
            } else {
                charCount.style.color = '#007AFF';
            }
        }

        // 保存群公告
        function saveGroupNotice() {
            const textarea = document.getElementById('group-notice-content');
            const newDescription = textarea.value.trim();

            if (newDescription.length > 500) {
                alert('群公告内容不能超过500字');
                return;
            }

                // 更新当前群聊角色的描述
            currentChatCharacter.description = newDescription;

                // 如果是群聊，需要更新群聊数据
                if (groupChats) {
                    const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                    if (groupIndex !== -1) {
                    groupChats[groupIndex].description = newDescription;
                        saveGroupChats(groupChats);
                    }
                }

                // 更新UI显示
                updateGroupChatInfo();
            hideGroupNoticeModal();

            // 显示成功提示
            showToast('✅ 群公告保存成功', 'success');
        }

        // 添加群成员 - 从现有角色中选择
        function addGroupMember() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;

            // 获取所有角色列表
            if (!characters || characters.length === 0) {
                alert('暂无可邀请的角色，请先创建角色');
                return;
            }

            // 过滤掉已经在群里的角色
            const currentMemberIds = currentChatCharacter.members ? currentChatCharacter.members.map(m => m.id) : [];
            const availableCharacters = characters.filter(char => !currentMemberIds.includes(char.id));

            if (availableCharacters.length === 0) {
                alert('所有角色都已经在群里了');
                return;
            }

            // 创建美观的选择界面
            showCharacterSelectionModal(availableCharacters, '邀请群成员', '请选择要邀请进群的角色：', (selectedCharacter) => {
                // 添加到群成员列表
                if (!currentChatCharacter.members) {
                    currentChatCharacter.members = [];
                }
                currentChatCharacter.members.push({
                    id: selectedCharacter.id,
                    name: selectedCharacter.name,
                    avatarUrl: selectedCharacter.avatarUrl
                });

                // 保存群聊数据
                if (groupChats) {
                    const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                    if (groupIndex !== -1) {
                        groupChats[groupIndex].members = currentChatCharacter.members;
                        saveGroupChats(groupChats);
                    }
                }

                // 🔥【新增】添加系统提示消息，让AI知道有新成员加入
                const systemMessage = {
                    id: Date.now().toString(),
                    content: `${selectedCharacter.name} 加入了群聊`,
                    timestamp: Date.now(),
                    sender: 'system',
                    type: 'system_notification'
                };

                // 保存系统消息到聊天记录
                if (!chatMessages[currentChatCharacter.id]) {
                    chatMessages[currentChatCharacter.id] = [];
                }
                chatMessages[currentChatCharacter.id].push(systemMessage);
                saveChatMessages();

                // 更新UI
                updateGroupChatInfo();
                renderChatMessages(currentChatCharacter.id); // 刷新聊天界面显示系统消息

                // 🔥【新增】更新聊天界面标题显示成员数量
                const chatTitle = document.getElementById('api-chat-title');
                if (chatTitle) {
                    let displayTitle = currentChatCharacter.name;
                    const memberCount = currentChatCharacter.members.length + 1; // +1 包括用户自己
                    displayTitle = `${displayTitle}（${memberCount}）`;
                    chatTitle.textContent = displayTitle;
                    // 🔥【新增】清除正在输入状态并保存新的原始标题
                    chatTitle.classList.remove('typing-status');
                    chatTitle.dataset.originalTitle = displayTitle;
                }

                showToast(`✅ ${selectedCharacter.name} 已加入群聊`, 'success');
            });
        }

        // 移除群成员
        function removeGroupMember() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup || !currentChatCharacter.members) return;

            if (currentChatCharacter.members.length <= 1) {
                alert('群聊至少需要保留一个角色成员（不包括用户自己）');
                return;
            }

            // 创建美观的选择界面
            showCharacterSelectionModal(currentChatCharacter.members, '移除群成员', '请选择要移出群聊的成员：', (selectedMember) => {
                if (confirm(`确定要将 ${selectedMember.name} 移出群聊吗？`)) {
                    // 从群成员列表中移除
                    const memberIndex = currentChatCharacter.members.findIndex(m => m.id === selectedMember.id);
                    if (memberIndex !== -1) {
                        currentChatCharacter.members.splice(memberIndex, 1);

                        // 🔥【新增】添加系统提示消息，让AI知道有成员退出
                        const systemMessage = {
                            id: Date.now().toString(),
                            content: `${selectedMember.name} 退出了群聊`,
                            timestamp: Date.now(),
                            sender: 'system',
                            type: 'system_notification'
                        };

                        // 保存系统消息到聊天记录
                        if (!chatMessages[currentChatCharacter.id]) {
                            chatMessages[currentChatCharacter.id] = [];
                        }
                        chatMessages[currentChatCharacter.id].push(systemMessage);
                        saveChatMessages();

                        // 保存群聊数据
                        if (groupChats) {
                            const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                            if (groupIndex !== -1) {
                                groupChats[groupIndex].members = currentChatCharacter.members;
                                saveGroupChats(groupChats);
                            }
                        }

                        // 更新UI
                        updateGroupChatInfo();
                        renderChatMessages(currentChatCharacter.id); // 刷新聊天界面显示系统消息

                        // 🔥【新增】更新聊天界面标题显示成员数量
                        const chatTitle = document.getElementById('api-chat-title');
                        if (chatTitle) {
                            let displayTitle = currentChatCharacter.name;
                            const memberCount = currentChatCharacter.members.length + 1; // +1 包括用户自己
                            displayTitle = `${displayTitle}（${memberCount}）`;
                            chatTitle.textContent = displayTitle;
                            // 🔥【新增】清除正在输入状态并保存新的原始标题
                            chatTitle.classList.remove('typing-status');
                            chatTitle.dataset.originalTitle = displayTitle;
                        }

                        showToast(`✅ ${selectedMember.name} 已被移出群聊`, 'success');
                    }
                }
            });
        }

        // 群公告功能
        function showGroupNotice() {
            const notice = currentChatCharacter?.description || '暂无群公告';
            alert(`📢 群公告\n\n${notice}\n\n点击群信息卡片的公告区域可以编辑群公告`);
        }





        // 显示角色选择模态框
        function showCharacterSelectionModal(characterList, title, description, onSelect) {
            const modalHTML = `
                <div class="modal character-selection-modal" id="character-selection-modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 class="modal-title">${title}</h3>
                            <button class="modal-close" onclick="hideCharacterSelectionModal()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p class="selection-description">${description}</p>
                            <div class="character-selection-grid" id="character-selection-grid">
                                ${characterList.map(char => `
                                    <div class="character-selection-item" data-character-id="${char.id}">
                                        <div class="character-selection-avatar">
                                            <img src="${char.avatarUrl || createDefaultAvatar(char.name)}" alt="${char.name}">
                                        </div>
                                        <div class="character-selection-info">
                                            <div class="character-selection-name">${char.name}</div>
                                            <div class="character-selection-bio">${(char.description || char.bio || '暂无简介').substring(0, 30)}${(char.description || char.bio || '').length > 30 ? '...' : ''}</div>
                                        </div>
                                        <div class="character-selection-check">
                                            <i class="fas fa-check"></i>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-secondary" onclick="hideCharacterSelectionModal()">取消</button>
                            <button class="modal-primary" id="confirm-selection-btn" onclick="confirmCharacterSelection()" disabled>确定</button>
                        </div>
                    </div>
                </div>
            `;

            const existingModal = document.getElementById('character-selection-modal');
            if (existingModal) {
                existingModal.remove();
            }

            document.body.insertAdjacentHTML('beforeend', modalHTML);

            window.characterSelectionCallback = onSelect;
            window.selectedCharacterId = null;

            document.querySelectorAll('.character-selection-item').forEach(item => {
                item.addEventListener('click', function() {
                    document.querySelectorAll('.character-selection-item').forEach(i => i.classList.remove('selected'));
                    this.classList.add('selected');
                    window.selectedCharacterId = this.dataset.characterId;
                    document.getElementById('confirm-selection-btn').disabled = false;
                });
            });
        }

        // 隐藏角色选择模态框
        function hideCharacterSelectionModal() {
            const modal = document.getElementById('character-selection-modal');
            if (modal) {
                modal.remove();
            }
            window.characterSelectionCallback = null;
            window.selectedCharacterId = null;
        }

        // 确认角色选择
        function confirmCharacterSelection() {
            if (!window.selectedCharacterId || !window.characterSelectionCallback) return;

            const allCharacters = [...characters, ...(currentChatCharacter.members || [])];
            const selectedCharacter = allCharacters.find(char => char.id === window.selectedCharacterId);

            if (selectedCharacter) {
                window.characterSelectionCallback(selectedCharacter);
                hideCharacterSelectionModal();
            }
        }

        // 🔥【新增】群成员头像更换功能
        function changeMemberAvatar(memberId, event) {
            event.stopPropagation(); // 阻止事件冒泡

            const member = currentChatCharacter.members.find(m => m.id === memberId);
            if (!member) return;

            // 显示头像更换模态框
            showMemberAvatarModal(member);
        }

        // 🔥【新增】显示群成员头像更换模态框
        function showMemberAvatarModal(member) {
            const modal = document.getElementById('member-avatar-modal');
            const preview = document.getElementById('member-avatar-preview');
            const memberName = document.getElementById('member-avatar-name');
            const uploadInput = document.getElementById('member-avatar-upload');

            // 设置当前成员信息
            window.currentEditingMember = member;
            memberName.textContent = member.name;
            preview.src = member.avatarUrl || createDefaultAvatar(member.name);

            // 重置文件输入
            uploadInput.value = '';

            modal.style.display = 'flex';
        }

        // 🔥【新增】隐藏群成员头像更换模态框
        function hideMemberAvatarModal() {
            const modal = document.getElementById('member-avatar-modal');
            modal.style.display = 'none';
            window.currentEditingMember = null;
        }

        // 🔥【新增】处理群成员头像上传
        function handleMemberAvatarUpload() {
            const uploadInput = document.getElementById('member-avatar-upload');
            uploadInput.click();
        }

        // 🔥【新增】保存群成员头像
        function saveMemberAvatar() {
            if (!window.currentEditingMember) return;

            const preview = document.getElementById('member-avatar-preview');
            const newAvatarUrl = preview.src;

            // 更新群成员头像
            const memberIndex = currentChatCharacter.members.findIndex(m => m.id === window.currentEditingMember.id);
            if (memberIndex !== -1) {
                currentChatCharacter.members[memberIndex].avatarUrl = newAvatarUrl;

                // 同时更新全局角色列表中的头像
                const characterIndex = characters.findIndex(c => c.id === window.currentEditingMember.id);
                if (characterIndex !== -1) {
                    characters[characterIndex].avatarUrl = newAvatarUrl;
                    saveCharacters(characters);
                }

                // 保存群聊数据
                if (groupChats) {
                    const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                    if (groupIndex !== -1) {
                        groupChats[groupIndex].members = currentChatCharacter.members;
                        saveGroupChats(groupChats);
                    }
                }

                // 🔥【新增】在群聊消息中添加头像更换提示
                addAvatarChangeMessage(window.currentEditingMember.name);

                // 更新UI
                updateGroupChatInfo();
                renderGroupMembersGrid();
                refreshChatMessages(); // 刷新聊天消息显示新头像

                showToast(`✅ ${window.currentEditingMember.name} 的头像已更新`, 'success');
            }

            hideMemberAvatarModal();
        }

        // 🔥【新增】添加头像更换系统消息
        function addAvatarChangeMessage(memberName) {
            if (!currentChatCharacter || !chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }

            const systemMessage = {
                id: 'system_' + Date.now(),
                sender: 'system',
                content: `${memberName} 更换了头像`,
                timestamp: Date.now(),
                isSystem: true
            };

            chatMessages[currentChatCharacter.id].push(systemMessage);
            saveChatMessages();

            // 刷新聊天界面
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }
        }

        // 🔥【新增】刷新聊天消息以显示新头像
        function refreshChatMessages() {
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }
        }

        // 🔥【新增】重置群成员头像为默认
        function resetMemberAvatar() {
            if (!window.currentEditingMember) return;

            const preview = document.getElementById('member-avatar-preview');
            const defaultAvatar = createDefaultAvatar(window.currentEditingMember.name);
            preview.src = defaultAvatar;
        }

        // 🔥【新增】数据恢复检查和修复功能
        async function checkAndFixChatHistory() {
            try {
                console.log('开始检查聊天历史数据...');

                // 检查IndexedDB中的数据
                const dbMessages = await db.chatMessages.toArray();
                const memoryMessages = chatMessages;

                console.log('IndexedDB中的消息数:', dbMessages.length);
                console.log('内存中的聊天数:', Object.keys(memoryMessages).length);

                // 检查是否有localStorage的备份数据
                const localStorageBackup = localStorage.getItem('chatMessages');
                if (localStorageBackup) {
                    try {
                        const backupData = JSON.parse(localStorageBackup);
                        console.log('找到localStorage备份数据');

                        // 比较数据时间戳，选择最新的
                        let shouldUseBackup = false;
                        let newerMessagesCount = 0;

                        for (const [characterId, messages] of Object.entries(backupData)) {
                            if (messages && messages.length > 0) {
                                const latestBackupTime = Math.max(...messages.map(m => m.timestamp || 0));
                                const currentMessages = memoryMessages[characterId] || [];
                                const latestCurrentTime = currentMessages.length > 0 ?
                                    Math.max(...currentMessages.map(m => m.timestamp || 0)) : 0;

                                if (latestBackupTime > latestCurrentTime) {
                                    console.log(`角色 ${characterId} 的备份数据更新 (备份:${new Date(latestBackupTime)}, 当前:${new Date(latestCurrentTime)})`);
                                    shouldUseBackup = true;
                                    newerMessagesCount += messages.length - currentMessages.length;
                                }
                            }
                        }

                        if (shouldUseBackup) {
                            const confirmRestore = confirm(`检测到localStorage中有更新的聊天记录！\n\n发现 ${newerMessagesCount} 条更新的消息\n\n是否恢复这些数据？`);
                            if (confirmRestore) {
                                // 恢复数据
                                Object.assign(chatMessages, backupData);
                                // 🔥【优化】数据恢复使用高效保存
                                try {
                                    const restoredCharacterIds = Object.keys(backupData);
                                    await saveChatMessagesImmediate(restoredCharacterIds);
                                    console.log('✅ [高效数据恢复] 消息已保存到数据库');
                                } catch (error) {
                                    console.error('数据恢复保存失败，回退到全量保存:', error);
                                    await saveChatMessages();
                                }

                                // 重新渲染当前聊天
                                if (currentChatCharacter) {
                                    renderChatMessages(currentChatCharacter.id);
                                }

                                showToast(`已恢复 ${newerMessagesCount} 条消息！`, 'success');
                                return true;
                            }
                        }
                    } catch (e) {
                        console.error('解析备份数据失败:', e);
                    }
                }

                // 检查是否有异常的时间戳（未来时间或过老时间）
                let fixedCount = 0;
                const now = Date.now();
                const oneWeekAgo = now - (7 * 24 * 60 * 60 * 1000);

                for (const [characterId, messages] of Object.entries(chatMessages)) {
                    if (messages && Array.isArray(messages)) {
                        for (let i = 0; i < messages.length; i++) {
                            const msg = messages[i];
                            if (!msg.timestamp || msg.timestamp > now || msg.timestamp < oneWeekAgo) {
                                // 修复异常时间戳
                                const correctedTime = now - (messages.length - i) * 60000; // 按顺序递减1分钟
                                console.log(`修复消息时间戳: ${msg.timestamp} -> ${correctedTime}`);
                                msg.timestamp = correctedTime;
                                fixedCount++;
                            }
                        }

                        // 重新排序消息
                        messages.sort((a, b) => a.timestamp - b.timestamp);
                    }
                }

                if (fixedCount > 0) {
                    // 🔥【优化】时间戳修复使用高效保存
                    try {
                        const fixedCharacterIds = Object.keys(chatMessages).filter(id =>
                            chatMessages[id] && chatMessages[id].length > 0);
                        await saveChatMessagesImmediate(fixedCharacterIds);
                        console.log('✅ [高效时间戳修复] 消息已保存到数据库');
                    } catch (error) {
                        console.error('时间戳修复保存失败，回退到全量保存:', error);
                        await saveChatMessages();
                    }
                    showToast(`修复了 ${fixedCount} 条消息的时间戳`, 'info');
                }

                return false;
            } catch (error) {
                console.error('检查聊天历史失败:', error);
                return false;
            }
        }

        // 显示提示消息
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.textContent = message;

            toast.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
                color: white;
                padding: 12px 24px;
                border-radius: 25px;
                font-size: 14px;
                z-index: 10000;
                opacity: 0;
                transition: all 0.3s ease;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            `;

            document.body.appendChild(toast);

            setTimeout(() => {
                toast.style.opacity = '1';
                toast.style.transform = 'translateX(-50%) translateY(10px)';
            }, 100);

            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(-50%) translateY(-10px)';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, 3000);
        }

        // 文本截断函数
        function truncateText(text, maxLength = 80) {
            // 🔥【修复】确保text是字符串类型
            if (text === null || text === undefined) {
                return '';
            }

            // 如果不是字符串，转换为字符串
            if (typeof text !== 'string') {
                text = String(text);
            }

            if (!text || text.length <= maxLength) return text;

            // 按行分割文本
            const lines = text.split('\n');
            let result = '';
            let lineCount = 0;

            for (const line of lines) {
                // 限制最多显示3行
                if (lineCount >= 3) break;

                if (result.length + line.length + 1 <= maxLength) {
                    result += (result ? '\n' : '') + line;
                    lineCount++;
                } else {
                    // 如果这一行会超出长度限制，截断并添加省略号
                    const remaining = maxLength - result.length - 1;
                    if (remaining > 10) { // 确保有足够空间显示有意义的内容
                        result += (result ? '\n' : '') + line.substring(0, remaining - 3) + '...';
                    } else if (!result) {
                        // 如果是第一行就超长，直接截断
                        result = line.substring(0, maxLength - 3) + '...';
                    } else {
                        // 否则在当前结果后加省略号
                        result += '...';
                    }
                    break;
                }
            }

            return result;
        }

        // 🔥【新增】消息列表多选删除功能

        // 进入消息列表多选模式
        function enterMessageListMultiSelectMode(conversationId) {
            console.log('触发长按多选模式，对话ID:', conversationId); // 调试信息
            isMessageListMultiSelectMode = true;
            selectedConversations = [conversationId]; // 将触发长按的对话添加到选中列表
            renderMessageList(); // 重新渲染列表以显示多选界面
            showToast('已进入多选模式，可以选择多个对话进行删除', 'info');
        }

        // 退出消息列表多选模式
        function exitMessageListMultiSelectMode() {
            isMessageListMultiSelectMode = false;
            selectedConversations = [];

            renderMessageList(); // 重新渲染列表恢复正常状态
        }

        // 切换对话选择状态
        function toggleConversationSelection(conversationId) {
            const index = selectedConversations.indexOf(conversationId);
            if (index > -1) {
                selectedConversations.splice(index, 1);
            } else {
                selectedConversations.push(conversationId);
            }
            renderMessageList(); // 重新渲染以更新选择状态
        }

        // 删除选中的对话
        async function deleteSelectedConversations() {
            if (selectedConversations.length === 0) {
                showToast('请先选择要删除的对话', 'error');
                return;
            }

            const count = selectedConversations.length;
            const confirmText = `确定要删除选中的 ${count} 个对话吗？\n\n删除后将清空对话的所有聊天记录和专属设置，此操作不可恢复。`;

            if (confirm(confirmText)) {
                try {
                    // 使用 for...of 循环来确保异步操作一个接一个完成
                    for (const conversationId of selectedConversations) {
                        // 1. 删除聊天消息
                    if (chatMessages[conversationId]) {
                        delete chatMessages[conversationId];
                    }

                        // 2. [核心修复] 从数据库中删除此对话的设置
                        await db.chatSettings.delete(conversationId);
                        //    同时从内存中也删除，保持同步
                        if (chatSettings[conversationId]) {
                            delete chatSettings[conversationId];
                        }

                        // 2.1 [额外修复] 删除localStorage中的备份设置
                        localStorage.removeItem(`chatSettings_${conversationId}`);

                        // 2.2 [彻底修复] 删除角色对象中的背景设置
                        const character = characters.find(c => c.id === conversationId);
                        if (character) {
                            character.background = null;
                            // 这里不需要立即保存，后面会统一保存
                        }

                        // 3. 🔥【修复】区分单聊和群聊的删除逻辑
                        const groupIndex = groupChats.findIndex(g => g.id === conversationId);
                        if (groupIndex > -1) {
                            // 如果是群聊，从群聊列表中删除
                            groupChats.splice(groupIndex, 1);
                        } else {
                            // 如果是单聊，从联系人列表中移除 (这代表移除了一个"活跃对话")
                            const contactIndex = contacts.indexOf(conversationId);
                            if (contactIndex > -1) {
                                contacts.splice(contactIndex, 1);
                            }
                        }
                    }

                    // 4. 异步保存所有更改
                    await Promise.all([
                        saveChatMessages(),
                        saveGroupChats(),
                        saveContacts()
                        // 🔥【修复】不再需要保存 characters，因为我们没有修改角色本身
                    ]);

                    // 5. 退出多选模式并刷新UI
                    exitMessageListMultiSelectMode(); // 这个函数内部会调用 renderMessageList()

                showToast(`✅ 已删除 ${count} 个对话`, 'success');

                } catch (error) {
                    console.error("删除对话时出错:", error);
                    showToast('删除失败，请检查控制台错误信息', 'error');
                }
            }
        }

        // --- 论坛功能 ---

        let currentForumId = null;
        let worldEvent = null; // 用于存储"搞个大新闻"的事件

        // 【升级】处理用户投票的函数 (支持单选/多选)
        async function handlePollVote(optionElement, optionId) {
            const pollElement = optionElement.closest('.forum-poll');
            if (!pollElement) return;

            const pollType = pollElement.dataset.pollType || 'single';
            const postId = window.currentPostId;

            if (pollType === 'single') {
                // --- 单选逻辑 ---
                const userVotedOption = localStorage.getItem(`poll_voted_${postId}`);
                if (pollElement.classList.contains('voted') || (userVotedOption && userVotedOption !== 'null')) {
                    showToast('您已经投过票了', 'info');
                    return;
                }

                if (!postId) return;

                // 立即更新UI，让用户看到自己的选择
                optionElement.classList.add('user-voted');
                pollElement.classList.add('voted');

                try {
                    const post = await db.forumPosts.get(postId);
                    if (!post) return;

                    // 确保使用统一的optionId提取逻辑
                    let finalOptionId = optionId;
                    if (!finalOptionId) {
                        const textContent = optionElement.querySelector('.option-text')?.textContent || '';
                        finalOptionId = textContent.replace(/\s+/g, '_').toLowerCase();
                    }

                    // 初始化投票数据结构
                    if (!post.pollData) {
                        post.pollData = { totalVotes: 0, options: {} };
                    }
                    if (!post.pollData.options[finalOptionId]) {
                        post.pollData.options[finalOptionId] = 0;
                    }

                    // 更新票数
                    post.pollData.options[finalOptionId]++;
                    post.pollData.totalVotes++;

                    // 保存回数据库
                    await db.forumPosts.put(post);
                    updatePollUI(postId, post.pollData);

                    // 保存投票记录
                    const optionText = optionElement.querySelector('.option-text')?.textContent || '';
                    saveVoteRecord(postId, finalOptionId, optionText, post.title);

                    showToast('投票成功！', 'success');
                } catch (error) {
                    console.error("单选投票失败:", error);
                    showToast('投票失败，请重试', 'error');
                }

            } else if (pollType === 'multiple') {
                // --- 多选逻辑 ---
                const isSelected = optionElement.dataset.selected === 'true';
                optionElement.dataset.selected = !isSelected;

                // 更新选中状态的视觉效果
                if (!isSelected) {
                    optionElement.classList.add('user-voted');
                } else {
                    optionElement.classList.remove('user-voted');
                }
            }
        }

        // 【新增】提交多选投票的函数
        async function submitMultipleChoiceVote(submitButton) {
            const pollElement = submitButton.closest('.forum-poll');
            const postId = window.currentPostId;
            const selectedOptions = pollElement.querySelectorAll('.poll-option[data-selected="true"]');

            if (selectedOptions.length === 0) {
                showToast('请至少选择一个选项', 'info');
                return;
            }

            // 检查是否已经投过票
            const userVotedOption = localStorage.getItem(`poll_voted_${postId}`);
            if (pollElement.classList.contains('voted') || (userVotedOption && userVotedOption !== 'null')) {
                showToast('您已经投过票了', 'info');
                return;
            }

            submitButton.disabled = true;
            submitButton.textContent = '正在提交...';

            try {
                const post = await db.forumPosts.get(postId);
                if (!post) return;

                if (!post.pollData) {
                    post.pollData = { totalVotes: 0, options: {} };
                }

                let userVotedOptions = [];

                selectedOptions.forEach(option => {
                    const onclickAttr = option.getAttribute('onclick');
                    let optionId = '';

                    // 提取option ID
                    const patterns = [
                        /'([^']+)'/,
                        /"([^"]+)"/,
                        /handlePollVote\([^,]+,\s*['"]([^'"]+)['"]\)/
                    ];

                    for (const pattern of patterns) {
                        const match = onclickAttr.match(pattern);
                        if (match && match[1]) {
                            optionId = match[1];
                            break;
                        }
                    }

                    if (optionId) {
                        userVotedOptions.push(optionId);
                        if (!post.pollData.options[optionId]) {
                            post.pollData.options[optionId] = 0;
                        }
                        post.pollData.options[optionId]++;
                        post.pollData.totalVotes++;
                    }
                });

                await db.forumPosts.put(post);

                // 保存多选记录
                saveVoteRecord(postId, JSON.stringify(userVotedOptions), `${userVotedOptions.length}个选项`, post.title);

                pollElement.classList.add('voted');
                updatePollUI(postId, post.pollData);
                showToast('投票成功！', 'success');

            } catch (error) {
                console.error("多选投票失败:", error);
                showToast('投票失败，请重试', 'error');
                submitButton.disabled = false;
                submitButton.textContent = '投票';
            }
        }

        // 【升级】更新投票UI的函数 - 支持实时进度条
        function updatePollUI(postId, pollData) {
            const pollElement = document.querySelector(`.post-full-body .forum-poll`);
            if (!pollElement) {
                return;
            }

            const totalVotes = pollData.totalVotes || 0;
            const options = pollElement.querySelectorAll('.poll-option');

            // 检查用户是否已投过票
            const userVotedOption = localStorage.getItem(`poll_voted_${postId}`);
            if (userVotedOption && userVotedOption !== 'null') {
                pollElement.classList.add('voted');
            }

            options.forEach((option, index) => {
                // 提取选项ID
                const onclickAttr = option.getAttribute('onclick');
                let optionId = '';

                if (onclickAttr) {
                    const patterns = [
                        /'([^']+)'/,
                        /"([^"]+)"/,
                        /handlePollVote\([^,]+,\s*['"]([^'"]+)['"]\)/
                    ];

                    for (const pattern of patterns) {
                        const match = onclickAttr.match(pattern);
                        if (match && match[1]) {
                            optionId = match[1];
                            break;
                        }
                    }
                }

                if (!optionId) {
                    const textContent = option.querySelector('.option-text')?.textContent || '';
                    optionId = textContent.replace(/\s+/g, '_').toLowerCase();
                    if (!onclickAttr) {
                        option.setAttribute('onclick', `handlePollVote(this, '${optionId}')`);
                    }
                }

                // 🔥【新增】为每个选项动态创建进度条
                if (!option.querySelector('.result-bar-bg')) {
                    // 确保选项有相对定位
                    option.style.position = 'relative';

                    // 创建进度条背景
                    const resultBg = document.createElement('div');
                    resultBg.className = 'result-bar-bg';

                    // 创建进度条
                    const resultBar = document.createElement('div');
                    resultBar.className = 'result-bar';

                    resultBg.appendChild(resultBar);
                    option.insertBefore(resultBg, option.firstChild);
                }

                // 获取票数
                let votes = pollData.options[optionId] || 0;
                if (votes === 0 && Object.keys(pollData.options).length > 0) {
                    const textContent = option.querySelector('.option-text')?.textContent || '';
                    for (const [key, value] of Object.entries(pollData.options)) {
                        if (key.includes(textContent.toLowerCase()) || textContent.toLowerCase().includes(key)) {
                            votes = value;
                            optionId = key;
                            break;
                        }
                    }
                }

                const percentage = totalVotes > 0 ? ((votes / totalVotes) * 100).toFixed(1) : 0;

                // 高亮用户投票的选项
                if (userVotedOption && userVotedOption !== 'null') {
                    try {
                        const votedOptions = JSON.parse(userVotedOption);
                        if (Array.isArray(votedOptions) && votedOptions.includes(optionId)) {
                            option.classList.add('user-voted');
                        } else {
                            option.classList.remove('user-voted');
                        }
                    } catch (e) {
                        if (optionId === userVotedOption ||
                            userVotedOption.includes(optionId) ||
                            optionId.includes(userVotedOption)) {
                            option.classList.add('user-voted');
                        } else {
                            option.classList.remove('user-voted');
                        }
                    }
                } else {
                    option.classList.remove('user-voted');
                }

                // 🔥【核心】更新票数显示和进度条动画
                const voteCountElement = option.querySelector('.vote-count');
                const resultBarElement = option.querySelector('.result-bar');

                if (voteCountElement) {
                    voteCountElement.textContent = `${votes}票 (${percentage}%)`;
                }

                if (resultBarElement) {
                    // 延迟更新进度条宽度，产生动画效果
                    setTimeout(() => {
                        resultBarElement.style.width = `${percentage}%`;
                    }, 100 + index * 50); // 每个选项延迟50ms，产生波浪效果
                }
            });
        }

        // 【新增】为AI投票帖子生成智能初始数据的函数
        async function generateSmartPollData(postId, post) {
            // 检查是否已经生成过数据
            if (post.pollData && post.pollData.totalVotes > 0) {
                updatePollUI(postId, post.pollData);
                return;
            }

            const pollElement = document.querySelector(`.post-full-body .forum-poll`);
            if (!pollElement) return;

            const options = pollElement.querySelectorAll('.poll-option');
            if (options.length === 0) return;

            // 生成合理的投票数据
            const pollData = { totalVotes: 0, options: {} };

            // 根据帖子类型生成基础票数
            const baseVotes = Math.floor(Math.random() * 40) + 15; // 15-55票基础
            const isPopularTopic = post.title.includes('颜值') || post.title.includes('人气') || post.title.includes('最');
            const totalVotes = isPopularTopic ? baseVotes + Math.floor(Math.random() * 60) : baseVotes;

            // 为每个选项分配票数
            const optionVotes = [];
            let remainingVotes = totalVotes;

            options.forEach((option, index) => {
                const isLastOption = index === options.length - 1;
                if (isLastOption) {
                    // 最后一个选项获得剩余所有票数
                    optionVotes.push(remainingVotes);
                } else {
                    // 随机分配票数，但确保不超过剩余票数
                    const maxVotes = Math.floor(remainingVotes * 0.6); // 最多60%
                    const minVotes = Math.floor(remainingVotes * 0.1); // 最少10%
                    const votes = Math.floor(Math.random() * (maxVotes - minVotes + 1)) + minVotes;
                    optionVotes.push(votes);
                    remainingVotes -= votes;
                }
            });

            // 将票数分配给选项
            options.forEach((option, index) => {
                const onclickAttr = option.getAttribute('onclick');
                let optionId = '';

                if (onclickAttr) {
                    const match = onclickAttr.match(/'([^']+)'/);
                    if (match && match[1]) {
                        optionId = match[1];
                    }
                }

                if (!optionId) {
                    const textContent = option.querySelector('.option-text')?.textContent || '';
                    optionId = textContent.replace(/\s+/g, '_').toLowerCase();
                }

                pollData.options[optionId] = optionVotes[index];
                pollData.totalVotes += optionVotes[index];
            });

            // 保存到数据库
            post.pollData = pollData;
            await db.forumPosts.put(post);

            // 更新UI
            updatePollUI(postId, pollData);
        }

        // 【新增】为投票生成智能假数据的函数
        async function generateSmartPollData(postId, post) {
            // 检查是否已经生成过假数据
            if (post.pollData && post.pollData.totalVotes > 0) {
                updatePollUI(postId, post.pollData);
                return;
            }

            const pollElement = document.querySelector(`.post-full-body .forum-poll`);
            if (!pollElement) return;

            const options = pollElement.querySelectorAll('.poll-option');
            if (options.length === 0) return;

            // 获取当前论坛信息，用于生成符合世界观的数据
            const forum = await db.forums.get(parseInt(currentForumId));
            const forumCharacters = characters.filter(c => forum.characterIds.includes(c.id));

            // 根据论坛类型和世界观生成合理的投票数据
            const pollData = {
                totalVotes: 0,
                options: {}
            };

            // 生成基础投票数：根据论坛活跃度
            const baseVotes = Math.floor(Math.random() * 50) + 20; // 20-70票基础
            const isPopularTopic = post.title.includes('【投票】') || post.title.includes('人气') || post.title.includes('最');
            const totalVotes = isPopularTopic ? baseVotes + Math.floor(Math.random() * 80) : baseVotes;

            // 为每个选项分配票数
            const optionVotes = [];
            let remainingVotes = totalVotes;

            options.forEach((option, index) => {
                const optionText = option.querySelector('.option-text')?.textContent || '';

                // 根据选项内容和世界观调整权重
                let weight = 1;

                // 娱乐圈论坛：明星相关选项更受欢迎
                if (forum.worldview && forum.worldview.includes('娱乐')) {
                    if (forumCharacters.some(c => optionText.includes(c.name))) {
                        weight = 1.5; // 论坛成员相关选项更受欢迎
                    }
                }

                // 校园论坛：实用性选项更受欢迎
                if (forum.worldview && forum.worldview.includes('校园')) {
                    if (optionText.includes('食堂') || optionText.includes('图书馆') || optionText.includes('宿舍')) {
                        weight = 1.3;
                    }
                }

                // 生成该选项的票数（带一些随机性）
                const baseVoteForOption = Math.floor((remainingVotes / (options.length - index)) * weight);
                const randomVariation = Math.floor(Math.random() * 10) - 5; // -5到+5的随机变化
                const finalVotes = Math.max(0, Math.min(remainingVotes, baseVoteForOption + randomVariation));

                optionVotes.push(finalVotes);
                remainingVotes -= finalVotes;
            });

            // 将剩余票数随机分配给各选项
            while (remainingVotes > 0) {
                const randomIndex = Math.floor(Math.random() * options.length);
                optionVotes[randomIndex]++;
                remainingVotes--;
            }

            // 保存投票数据
            options.forEach((option, index) => {
                const onclickAttr = option.getAttribute('onclick');
                let optionId = '';
                if (onclickAttr) {
                    const match = onclickAttr.match(/'([^']+)'/);
                    if (match && match[1]) {
                        optionId = match[1];
                    } else {
                        const textContent = option.querySelector('.option-text')?.textContent || '';
                        optionId = textContent.replace(/\s+/g, '_').toLowerCase();
                    }
                }

                pollData.options[optionId] = optionVotes[index];
                pollData.totalVotes += optionVotes[index];
            });

            // 保存到数据库
            post.pollData = pollData;
            await db.forumPosts.put(post);

            // 更新UI显示
            updatePollUI(postId, pollData);


        }

        // 【新增】清理旧的投票记录，保留最近的投票
        function cleanOldVoteRecords(maxRecords = 100) {
            try {
                // 获取所有投票相关的localStorage键
                const voteKeys = Object.keys(localStorage)
                    .filter(key => key.startsWith('poll_voted_'))
                    .map(key => {
                        const postId = key.replace('poll_voted_', '');
                        return {
                            key: key,
                            postId: parseInt(postId),
                            timestamp: Date.now() // 简化处理，使用当前时间
                        };
                    })
                    .sort((a, b) => b.postId - a.postId); // 按帖子ID降序排列（新帖子ID通常更大）

                // 如果超过限制，删除旧的记录
                if (voteKeys.length > maxRecords) {
                    const toDelete = voteKeys.slice(maxRecords);
                    toDelete.forEach(item => {
                        localStorage.removeItem(item.key);
                    });
                    console.log(`🧹 [投票清理] 已清理 ${toDelete.length} 条旧投票记录，保留最近 ${maxRecords} 条`);
                }
            } catch (error) {
                console.error('清理投票记录失败:', error);
            }
        }

        // 【新增】增强版投票记录保存，包含更多信息
        function saveVoteRecord(postId, optionId, optionText, postTitle) {
            try {
                // 保存基本的投票选择（用于防重复投票）
                localStorage.setItem(`poll_voted_${postId}`, optionId);

                // 保存详细的投票记录（用于历史查看）
                const voteRecord = {
                    postId: postId,
                    postTitle: postTitle || '未知帖子',
                    optionId: optionId,
                    optionText: optionText || '未知选项',
                    timestamp: Date.now(),
                    date: new Date().toLocaleString()
                };

                localStorage.setItem(`vote_detail_${postId}`, JSON.stringify(voteRecord));

                // 执行清理，保留最近100条记录
                cleanOldVoteRecords(100);

            } catch (error) {
                console.error('保存投票记录失败:', error);
                // 如果localStorage满了，尝试清理后重试
                cleanOldVoteRecords(50);
                try {
                    localStorage.setItem(`poll_voted_${postId}`, optionId);
                } catch (retryError) {
                    console.error('重试保存投票记录仍然失败:', retryError);
                }
            }
        }

        // 【新增】获取用户的投票历史
        function getUserVoteHistory(limit = 20) {
            try {
                const voteDetails = Object.keys(localStorage)
                    .filter(key => key.startsWith('vote_detail_'))
                    .map(key => {
                        try {
                            return JSON.parse(localStorage.getItem(key));
                        } catch {
                            return null;
                        }
                    })
                    .filter(record => record !== null)
                    .sort((a, b) => b.timestamp - a.timestamp)
                    .slice(0, limit);

                return voteDetails;
            } catch (error) {
                console.error('获取投票历史失败:', error);
                return [];
            }
        }

        // 【新增】显示投票历史
        function showVoteHistory() {
            const voteHistory = getUserVoteHistory(50);

            if (voteHistory.length === 0) {
                showToast('您还没有投票记录', 'info');
                return;
            }

            const historyHtml = voteHistory.map(record => `
                <div class="vote-history-item">
                    <div class="vote-post-title">${record.postTitle}</div>
                    <div class="vote-choice">选择了：${record.optionText}</div>
                    <div class="vote-date">${record.date}</div>
                </div>
            `).join('');

            const modalHtml = `
                <div class="modal-overlay" onclick="closeModal()">
                    <div class="modal-content vote-history-modal" onclick="event.stopPropagation()">
                        <div class="modal-header">
                            <h3>我的投票历史</h3>
                            <button class="modal-close" onclick="closeModal()">×</button>
                        </div>
                        <div class="modal-body">
                            <div class="vote-history-list">
                                ${historyHtml}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="closeModal()">关闭</button>
                            <button class="btn btn-danger" onclick="clearVoteHistory()">清空历史</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }



        // 🔥【优化后】显示创建论坛界面
        async function showCreateForumScreen() {
            hideApp('forum-screen');
            const characterContainer = document.getElementById('forum-character-selection');
            const personaContainer = document.getElementById('forum-persona-selection');
            const worldbookContainer = document.getElementById('forum-worldbook-selection');

            // 清空表单
            document.getElementById('forum-form-id').value = '';
            document.getElementById('forum-name-input').value = '';
            document.getElementById('forum-worldview-input').value = '';
            document.getElementById('forum-form-title').textContent = '创建新论坛';
            document.getElementById('forum-form-submit-btn').textContent = '进入论坛';

            // 渲染角色和身份面具选项
            characterContainer.innerHTML = characters.map(char => `
                <div class="selection-item" data-id="${char.id}" onclick="toggleSelection(this)">
                    <img src="${char.avatarUrl || createDefaultAvatar(char.name)}" alt="${char.name}">
                    <div class="selection-item-name">${char.name}</div>
                </div>
            `).join('');

            personaContainer.innerHTML = personas.map(p => `
                <div class="selection-item" data-id="${p.id}" onclick="toggleSelection(this, true)">
                    <img src="${p.avatarUrl || createDefaultAvatar(p.name)}" alt="${p.name}">
                    <div class="selection-item-name">${p.name}</div>
                </div>
            `).join('');

            // 渲染局部世界书选项
            const localWorldbooks = worldbooks.filter(w => !w.isGlobal);
            if (localWorldbooks.length > 0) {
                worldbookContainer.innerHTML = localWorldbooks.map(book => `
                    <div class="selection-item" data-id="${book.id}" onclick="toggleSelection(this)">
                        <div class="selection-item-icon"><i class="fas fa-book-open"></i></div>
                        <div class="selection-item-name">${book.title || book.name}</div>
                    </div>
                `).join('');
            } else {
                worldbookContainer.innerHTML = '<p style="color: #999; font-size: 12px; text-align: center;">暂无局部世界书</p>';
            }

            showApp('create-forum-screen');
        }

        // 多选/单选切换
        function toggleSelection(element, isSingle = false) {
            const container = element.parentElement;
            if (isSingle) {
                // 单选逻辑
                const currentlySelected = container.querySelector('.selected');
                if (currentlySelected) {
                    currentlySelected.classList.remove('selected');
                }
            }
            element.classList.toggle('selected');
        }

        // 🔥【新增】删除论坛功能
        async function deleteForum(forumId, event) {
            event.stopPropagation();

            const forum = await db.forums.get(parseInt(forumId));
            if (!forum) {
                alert("找不到要删除的论坛");
                return;
            }

            if (confirm(`确定要删除论坛 "${forum.name}" 吗？\n\n删除后将同时删除该论坛的所有帖子、回复和相关数据，此操作不可撤销！`)) {
                try {
                    // 🔥【修复】删除论坛及其所有相关数据

                    // 首先获取该论坛的所有帖子
                    const forumPosts = await db.forumPosts.where('forumId').equals(parseInt(forumId)).toArray();
                    const postIds = forumPosts.map(post => post.id);

                    // 删除论坛本身
                    await db.forums.delete(parseInt(forumId));

                    // 删除论坛的所有帖子
                    await db.forumPosts.where('forumId').equals(parseInt(forumId)).delete();

                    // 删除论坛挂载的世界书记录
                    await db.forumMountedWorldbooks.where('forumId').equals(parseInt(forumId)).delete();

                    // 如果有帖子，删除与帖子相关的数据
                    if (postIds.length > 0) {
                        // 获取所有回复
                        const allReplies = [];
                        for (const postId of postIds) {
                            const replies = await db.forumReplies.where('postId').equals(postId).toArray();
                            allReplies.push(...replies);
                        }
                        const replyIds = allReplies.map(reply => reply.id);

                        // 删除帖子相关数据
                        await Promise.all([
                            // 删除帖子的回复
                            ...postIds.map(postId => db.forumReplies.where('postId').equals(postId).delete()),
                            // 删除帖子的图片
                            ...postIds.map(postId => db.forumPostImages.where('postId').equals(postId).delete())
                        ]);

                        // 删除帖子的收藏记录（需要特殊处理复合索引）
                        for (const postId of postIds) {
                            await db.forumFavorites.where('postId').equals(postId).delete();
                        }

                        // 删除回复的点赞记录
                        if (replyIds.length > 0) {
                            await Promise.all(replyIds.map(replyId =>
                                db.replyLikes.where('replyId').equals(replyId).delete()
                            ));
                        }
                    }

                    showToast(`论坛 "${forum.name}" 已删除`, 'success');
                    await renderForumArchives(); // 重新渲染论坛列表
                } catch (error) {
                    console.error('删除论坛失败:', error);
                    showToast('删除失败: ' + error.message, 'error');
                }
            }
        }

        // 🔥【新增】显示编辑论坛界面
        async function showEditForumScreen(forumId, event) {
            event.stopPropagation();
            hideApp('forum-screen');

            const forum = await db.forums.get(parseInt(forumId));
            if (!forum) {
                alert("找不到要编辑的论坛");
                return;
            }

            // 复用创建界面，但填充数据
            await showCreateForumScreen();

            document.getElementById('forum-form-id').value = forum.id;
            document.getElementById('forum-name-input').value = forum.name;
            document.getElementById('forum-worldview-input').value = forum.worldview;
            document.getElementById('forum-form-title').textContent = '编辑论坛';
            document.getElementById('forum-form-submit-btn').textContent = '保存修改';

            // 预选角色
            forum.characterIds.forEach(id => {
                const el = document.querySelector(`#forum-character-selection .selection-item[data-id='${id}']`);
                if (el) el.classList.add('selected');
            });

            // 预选身份
            const personaEl = document.querySelector(`#forum-persona-selection .selection-item[data-id='${forum.personaId}']`);
            if (personaEl) personaEl.classList.add('selected');

            // 预选世界书
            (forum.mountedWorldbookIds || []).forEach(id => {
                const el = document.querySelector(`#forum-worldbook-selection .selection-item[data-id='${id}']`);
                if (el) el.classList.add('selected');
            });
        }

        // 🔥【新增】统一处理表单提交（创建/编辑）
        async function handleForumFormSubmit() {
            const forumId = document.getElementById('forum-form-id').value;
            const name = document.getElementById('forum-name-input').value.trim();
            const worldview = document.getElementById('forum-worldview-input').value.trim();

            const selectedCharElements = document.querySelectorAll('#forum-character-selection .selected');
            const selectedPersonaElement = document.querySelector('#forum-persona-selection .selected');
            const selectedWorldbookElements = document.querySelectorAll('#forum-worldbook-selection .selected');

            if (!name) return alert('请输入论坛名称');
            if (selectedCharElements.length === 0) return alert('请至少选择一个角色');
            if (!selectedPersonaElement) return alert('请选择你的身份');

            const characterIds = Array.from(selectedCharElements).map(el => el.dataset.id);
            const personaId = selectedPersonaElement.dataset.id;
            const mountedWorldbookIds = Array.from(selectedWorldbookElements).map(el => el.dataset.id);

            const forumData = {
                name,
                characterIds,
                personaId,
                worldview,
                mountedWorldbookIds,
                createdAt: forumId ? undefined : Date.now() // 仅创建时设置
            };

            try {
                if (forumId) { // 编辑模式
                    await db.forums.update(parseInt(forumId), { name, characterIds, worldview, mountedWorldbookIds });
                    showToast(`论坛 "${name}" 修改成功！`, 'success');
                    hideApp('create-forum-screen');
                    await renderForumArchives();
                    showApp('forum-screen');
                } else { // 创建模式
                    const newForumId = await db.forums.add(forumData);
                    showToast(`论坛 "${name}" 创建成功！正在生成帖子...`, 'success');
                    hideApp('create-forum-screen');
                    await loadAndDisplayForum(newForumId, true);
                }
            } catch (error) {
                console.error("论坛操作失败:", error);
                alert("操作失败，请重试。");
            }
        }

        // 渲染论坛存档列表
        async function renderForumArchives() {
            const forums = await db.forums.toArray();
            const listContainer = document.getElementById('forum-archive-list');

            if (forums.length === 0) {
                listContainer.innerHTML = `
                    <div class="forum-empty-state">
                        <i class="fas fa-comments"></i>
                        <p>还没有创建任何论坛</p>
                        <p>点击右上角 + 创建你的第一个论坛</p>
                    </div>`;
                return;
            }

            listContainer.innerHTML = forums.sort((a, b) => b.createdAt - a.createdAt).map(forum => `
                <div class="forum-archive-item" onclick="loadAndDisplayForum('${forum.id}')">
                    <div class="forum-archive-header">
                        <div class="forum-archive-title">${forum.name}</div>
                        <div class="forum-archive-actions">
                            <button class="forum-delete-btn" onclick="deleteForum('${forum.id}', event)">
                                <i class="fas fa-trash"></i>
                            </button>
                            <button class="forum-edit-btn" onclick="showEditForumScreen('${forum.id}', event)">
                                <i class="fas fa-pencil-alt"></i>
                            </button>
                        </div>
                    </div>
                    <div class="forum-archive-meta">
                        <span><svg class="forum-users-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M16 4c0-1.11.89-2 2-2s2 .89 2 2-.89 2-2 2-2-.89-2-2zM4 18v-1c0-2.66 5.33-4 8-4s8 1.34 8 4v1H4zM12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm6 6c.2-.71.78-1.29 1.49-1.51A6.991 6.991 0 0 0 21 14c0-2.21-1.79-4-4-4-.51 0-1 .1-1.47.26C16.21 10.69 17 11.77 17 13v5h1z"/></svg> ${forum.characterIds.length} 个角色</span>
                        <span>${new Date(forum.createdAt).toLocaleDateString()}</span>
                    </div>
                </div>
            `).join('');
        }

        // 加载并显示一个论坛
        async function loadAndDisplayForum(forumId, shouldGeneratePosts = false) {
            currentForumId = forumId;
            const forum = await db.forums.get(parseInt(forumId));
            if (!forum) {
                alert("找不到该论坛");
                return;
            }

            document.getElementById('forum-view-title').innerText = forum.name;
            hideApp('forum-screen');
            showApp('forum-view-screen');

            if (shouldGeneratePosts) {
                await generateForumPosts(forumId);
            }
            await renderForumPosts(forumId);
        }

        // 返回论坛存档列表
        async function backToForumArchives() {
            // 🔥【修复】先显示论坛主页，再隐藏当前页面，避免闪现主屏幕
            await renderForumArchives();
            showApp('forum-screen');
            hideApp('forum-view-screen');
        }

        // 🔥【优化后】的论坛帖子生成函数 (深度整合记忆与世界书)
        async function generateForumPosts(forumId) {
            const forum = await db.forums.get(parseInt(forumId));
            if (!forum) return;

            const forumCharacters = characters.filter(c => forum.characterIds.includes(c.id));
            const persona = personas.find(p => p.id === forum.personaId);

            const MAX_CONTEXT_LENGTH = 8000;
            let currentLength = 0;
            let finalContext = '';

            const appendContext = (title, content) => {
                if (!content || content.trim() === '' || currentLength >= MAX_CONTEXT_LENGTH) return;
                const section = `\n\n## ${title}:\n${content}\n`;
                if (currentLength + section.length < MAX_CONTEXT_LENGTH) {
                    finalContext += section;
                    currentLength += section.length;
                } else {
                    const remainingLength = MAX_CONTEXT_LENGTH - currentLength - title.length - 20;
                    if (remainingLength > 100) {
                         finalContext += `\n\n## ${title}:\n${content.substring(0, remainingLength)}...\n[内容已截断]\n`;
                    }
                    currentLength = MAX_CONTEXT_LENGTH;
                }
            };

            // 优先级 1: 时间感知上下文
            const now = new Date();
            const hour = now.getHours();
            const dayOfWeek = now.getDay();
            const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
            let timeOfDay, timeCharacteristics;
            if (hour >= 5 && hour < 9) { timeOfDay = "清晨"; timeCharacteristics = "大家刚起床，可能在讨论早餐、今天的计划、昨晚的梦境等"; }
            else if (hour >= 9 && hour < 12) { timeOfDay = "上午"; timeCharacteristics = isWeekend ? "周末上午，大家比较悠闲，可能在讨论娱乐活动、购物计划等" : "工作日上午，可能有人在摸鱼、偷偷刷论坛、讨论课程或工作"; }
            else if (hour >= 12 && hour < 14) { timeOfDay = "午休"; timeCharacteristics = "午饭时间，大家可能在讨论食物、下午的安排、分享午餐照片等"; }
            else if (hour >= 14 && hour < 18) { timeOfDay = "下午"; timeCharacteristics = isWeekend ? "周末下午，适合分享活动、约会、购物等话题" : "工作日下午，可能有人继续摸鱼、讨论下班后的计划"; }
            else if (hour >= 18 && hour < 22) { timeOfDay = "晚上"; timeCharacteristics = "晚饭后的黄金时间，大家比较活跃，适合各种话题讨论、分享今天的经历"; }
            else if (hour >= 22 && hour < 24) { timeOfDay = "深夜"; timeCharacteristics = "夜深人静，适合更私人、深度的话题，情感分享、人生感悟等"; }
            else { timeOfDay = "凌晨"; timeCharacteristics = "夜猫子时间，可能有失眠的人在聊天、分享深夜想法、或者早起的人开始新的一天"; }
            const timeContext = `现在是${timeOfDay}（${now.toLocaleTimeString('zh-CN', {hour: '2-digit', minute:'2-digit'})}），${isWeekend ? '周末' : '工作日'}。${timeCharacteristics}`;
            appendContext("当前时间与氛围", timeContext);

            // 优先级 2: 世界事件 ("大新闻")
            let eventContext = '';
            if (worldEvent && worldEvent.expires > Date.now()) {
                eventContext = `**这是刚刚发生的、最重要的新闻，请务必围绕这个事件生成一些帖子:**\n${worldEvent.content}`;
            }
            appendContext("头条新闻/世界线变动", eventContext);

            // 优先级 3: 角色近期记忆 (核心记忆 + 情景记忆)
            let memoryContext = '';
            const charactersForMemory = forumCharacters.sort(() => 0.5 - Math.random()).slice(0, 3);
            for (const char of charactersForMemory) {
                const coreMemories = await db.coreMemories.where('characterId').equals(char.id).limit(2).toArray();
                const episodicMemories = await db.episodicMemories.where('characterId').equals(char.id).reverse().limit(3).toArray();
                if (coreMemories.length > 0 || episodicMemories.length > 0) {
                    memoryContext += `### 关于 ${char.name} 的近期动态:\n`;
                    coreMemories.forEach(mem => { memoryContext += `- (核心记忆) ${mem.fact}\n`; });
                    episodicMemories.forEach(mem => { memoryContext += `- (最近发生) ${mem.fact}\n`; });
                }
            }
            appendContext("最近发生的大事件 (角色记忆)", memoryContext);

            // 优先级 4: 全局世界书 + 社区挂载的局部世界书
            const allWorldbooks = await db.worldbooks.toArray();
            let worldbookContext = '';
            const globalBooks = allWorldbooks.filter(b => b.isGlobal && (window.activeGlobalWorldbooks || []).includes(b.id));
            const mountedBooks = allWorldbooks.filter(b => (forum.mountedWorldbookIds || []).includes(b.id));
            const relevantBooks = [...new Set([...globalBooks, ...mountedBooks])]; // 合并去重

            if (relevantBooks.length > 0) {
                worldbookContext = relevantBooks.map(book => `### ${book.title}\n${book.content}`).join('\n\n');
                appendContext("论坛参考的世界观设定 (世界书)", worldbookContext);
            }

            let prompt = `
# 角色：论坛内容生成AI
你的任务是为一个名为 "${forum.name}" 的虚拟论坛生成10个新的帖子。

## 论坛背景设定:
**核心世界观**: ${forum.worldview || '一个普通的现代社区，大家在这里分享日常生活与见闻。'}
${finalContext}

## 论坛成员:
${forumCharacters.map(c => `- ${c.name} (人设: ${c.bio})`).join('\n')}
- ${persona.name} (这是用户, 人设: ${persona.description})

## 帖子生成指令:
请严格遵循以下要求，生成**完整的10个帖子**的JSON对象。
**【重要】**: 必须生成完整的10个帖子，不能少于10个。

### 【新增功能】投票帖子 (单选/多选):
- 你可以选择性地将1-2个帖子创建为 **单选** 或 **多选** 投票帖。
- **【极其重要】**: 当帖子的 "content" 字段包含HTML时，该HTML代码 **必须满足以下两个条件**:
    1.  **必须是单行文本**，绝对不能包含任何换行符 (\\n)。
    2.  HTML代码中的所有 **双引号 (")** 都 **必须用反斜杠转义成 (\\")**。

- **单选投票 (正确格式示例)**:
  \`\`\`json
  "content": "<div class=\\"forum-poll\\" data-poll-type=\\"single\\"><h4>【投票】单选标题</h4><div class=\\"poll-option\\" onclick=\\"handlePollVote(this, 'option_1')\\"><span class=\\"option-text\\">选项一</span><span class=\\"vote-count\\">0票</span></div><div class=\\"poll-option\\" onclick=\\"handlePollVote(this, 'option_2')\\"><span class=\\"option-text\\">选项二</span><span class=\\"vote-count\\">0票</span></div></div>"
  \`\`\`
- **多选投票 (正确格式示例)**:
  \`\`\`json
  "content": "<div class=\\"forum-poll\\" data-poll-type=\\"multiple\\"><h4>【投票】多选标题</h4><div class=\\"poll-option\\" onclick=\\"handlePollVote(this, 'option_A')\\"><span class=\\"option-text\\">选项A</span><span class=\\"vote-count\\">0票</span></div><div class=\\"poll-option\\" onclick=\\"handlePollVote(this, 'option_B')\\"><span class=\\"option-text\\">选项B</span><span class=\\"vote-count\\">0票</span></div><button class=\\"vote-submit-btn\\" onclick=\\"submitMultipleChoiceVote(this)\\">投票</button></div>"
  \`\`\`
- 投票的标题和选项内容必须与论坛的世界观和角色相关。
- 每个投票选项的onclick中的option_id必须是唯一的（如option_1, option_2等）。
- 多选投票必须包含投票按钮，单选投票不需要。

### 【重要】发帖人分配规则:
- **8-9个帖子**: 必须由普通NPC路人发布，使用符合世界观的普通网名（如"学霸小王"、"夜猫子"、"篮球少年"等）
- **最多1-2个帖子**: 可以由论坛成员角色发布，格式为"网名(真实姓名)"
- **【严格禁止】**: 绝对不得冒充用户 ${persona.name} 发帖或评论，用户有自己的发帖权限

### 内容要求:
1.  **🔥 时间感知**: 帖子的内容和氛围要符合当前的 **${timeOfDay}** 时段特点。请根据"当前时间与氛围"部分的描述来调整帖子的话题、语气和活跃度。
2.  **真实论坛感**: 大部分帖子应该是普通人的日常分享、求助、吐槽、闲聊等，就像真实论坛一样
3.  **世界观融合**: 在保持真实感的前提下，适度融入背景世界观
4.  **话题多样性**: 包括学习、生活、娱乐、求助、分享、八卦等各种日常话题，但要符合当前时间段的特点
5.  **避免过度关联**: 不要让太多帖子都围绕论坛成员角色展开

### 【极其重要】输出格式:
你的回复**必须**是一个严格的、不包含任何额外解释文字的JSON数组格式。

**标准帖子格式示例**:
\`\`\`json
[
  {
    "authorName": "学霸小王",
    "title": "今天的数学作业好难啊",
    "content": "有没有大神能帮忙解答一下这道题？感觉自己要被绕糊涂了...",
    "timestamp": "12:30"
  },
  {
    "authorName": "夜猫子(张明辉)",
    "title": "深夜食堂推荐",
    "content": "刚发现学校附近有家24小时营业的小店，泡面加蛋才8块钱，性价比超高！",
    "timestamp": "23:45"
  }
]
\`\`\`

**重要**: 每个帖子对象必须包含 authorName、title、content 三个字段，timestamp 字段可选。
`;

            // 🔥【调试】输出完整的prompt
            console.log('🔥 [论坛帖子生成] 完整Prompt:');
            console.log('='.repeat(80));
            console.log(prompt);
            console.log('='.repeat(80));

            showToast('AI正在生成新帖子，请稍候...', 'info');

            try {
                console.log('🔥 [论坛帖子生成] Prompt长度:', prompt.length, '字符');
                const response = await callForumAPI(prompt);
                console.log('🔥 [论坛帖子生成] AI原始响应长度:', response.length, '字符');
                console.log('🔥 [论坛帖子生成] AI原始响应:', response);

                let posts;
                try {
                    posts = JSON.parse(response);
                } catch (e) {
                    console.log('🔥 [论坛帖子生成] 直接JSON解析失败，尝试提取代码块');

                    // 尝试提取 ```json 代码块
                    const jsonMatch = response.match(/```json\s*([\s\S]*?)\s*```/);
                    if (jsonMatch && jsonMatch[1]) {
                        console.log('🔥 [论坛帖子生成] 找到JSON代码块');
                        try {
                            posts = JSON.parse(jsonMatch[1]);
                            console.log('✅ [论坛帖子生成] 成功解析JSON代码块，获得', posts.length, '个帖子');
                        } catch (e2) {
                            console.error('🔥 [论坛帖子生成] JSON代码块解析失败:', e2);
                            throw new Error("AI返回的JSON代码块格式错误。");
                        }
                    } else {
                        // 只有在确实没有找到完整代码块时，才尝试修复截断的JSON
                        console.log('🔥 [论坛帖子生成] 未找到完整代码块，检查是否为截断的JSON');

                        const partialMatch = response.match(/```json\s*([\s\S]*)/);
                        if (partialMatch && partialMatch[1]) {
                            let jsonContent = partialMatch[1].trim();
                            console.log('🔥 [论坛帖子生成] 找到部分JSON内容，长度:', jsonContent.length);

                            // 只有当JSON明显不完整时才修复
                            if (!jsonContent.endsWith(']') && !jsonContent.endsWith('}]')) {
                                console.log('🔥 [论坛帖子生成] JSON确实被截断，尝试修复');

                                // 找到最后一个完整的对象
                                const lastCompleteEnd = jsonContent.lastIndexOf('},');
                                if (lastCompleteEnd > 0) {
                                    jsonContent = jsonContent.substring(0, lastCompleteEnd + 1) + '\n]';
                                    console.log('🔥 [论坛帖子生成] 修复截断的JSON');
                                }
                            }

                            try {
                                posts = JSON.parse(jsonContent);
                                console.log('✅ [论坛帖子生成] 成功解析JSON，获得', posts.length, '个帖子');
                            } catch (e3) {
                                console.error('🔥 [论坛帖子生成] 修复后仍无法解析:', e3);
                                throw new Error("AI返回的JSON格式错误，无法修复。");
                            }
                        } else {
                            console.error('🔥 [论坛帖子生成] 无法解析的响应:', response.substring(0, 500) + '...');
                            throw new Error("AI返回的不是有效的JSON格式。请检查控制台查看详细信息。");
                        }
                    }
                }
                if (!Array.isArray(posts)) throw new Error("AI返回的数据不是一个数组。");

                for (const post of posts) {
                    const authorName = post.authorName || post.author || post.poster;
                    if (post && typeof authorName === 'string' && post.title && post.content) {
                        let author = null;
                        let authorAvatar = null;
                        const realNameMatch = authorName.match(/^(.+)\((.+)\)$/);
                        if (realNameMatch) {
                            const realName = realNameMatch[2];
                            author = characters.find(c => c.name === realName) || personas.find(p => p.name === realName);
                            if (author) authorAvatar = author.avatarUrl;
                        }
                        if (!author) authorAvatar = createDefaultAvatar(authorName);
                        await db.forumPosts.add({
                            forumId: parseInt(forumId),
                            title: post.title,
                            content: post.content,
                            authorId: author ? author.id : null,
                            authorName: authorName,
                            authorAvatar: authorAvatar,
                            timestamp: Date.now() - Math.floor(Math.random() * 10000),
                            replies: 0,
                            likes: 0
                        });
                    } else {
                        console.warn("AI生成了一个格式不规范的帖子，已跳过:", post);
                    }
                }
            } catch (error) {
                console.error("生成帖子失败:", error);
                alert("AI生成帖子失败，请检查API设置或刷新重试。\n错误详情: " + error.message);
            }
        }

        // 渲染帖子列表
        async function renderForumPosts(forumId) {
            const posts = await db.forumPosts.where('forumId').equals(parseInt(forumId)).toArray();
            const listContainer = document.getElementById('forum-posts-list');

            if (posts.length === 0) {
                listContainer.innerHTML = `<div class="forum-empty-state"><p>这个论坛还没有帖子</p></div>`;
                return;
            }

            // 1. 计算每个帖子的热度（改进算法）
            const now = Date.now();
            for (const post of posts) {
                const repliesCount = await db.forumReplies.where('postId').equals(post.id).count();

                // 🔥【改进热度算法】考虑时间衰减和活跃度
                const ageInHours = (now - post.timestamp) / (1000 * 60 * 60); // 帖子年龄（小时）
                const timeFactor = Math.max(0.1, 1 / (1 + ageInHours / 24)); // 时间衰减因子，24小时后开始明显衰减

                // 获取最近24小时的回复数（活跃度指标）
                const recentReplies = await db.forumReplies
                    .where('postId').equals(post.id)
                    .and(reply => reply.timestamp > (now - 24 * 60 * 60 * 1000))
                    .count();

                // 热度计算：基础分数 + 时间衰减 + 近期活跃度加成
                const baseScore = repliesCount * 2 + (post.likes || 0);
                const recentActivityBonus = recentReplies * 5; // 近期回复权重更高

                post.hotness = (baseScore + recentActivityBonus) * timeFactor;

                // 调试信息
                console.log(`帖子"${post.title}": 回复${repliesCount}, 近期回复${recentReplies}, 年龄${ageInHours.toFixed(1)}h, 热度${post.hotness.toFixed(2)}`);
            }

            // 2. 按热度降序排列
            posts.sort((a, b) => b.hotness - a.hotness);

            // 3. 分离出热帖和最新帖子 (最多3个热帖)
            const hotPostsCount = Math.min(3, posts.length);
            const hotPosts = posts.slice(0, hotPostsCount);
            const newestPosts = posts.slice(hotPostsCount).sort((a, b) => b.timestamp - a.timestamp);

            // 4. 渲染HTML
            let html = '';

            // 渲染热帖区
            if (hotPosts.length > 0) {
                html += '<div class="forum-section-header">热门帖子</div>';
                html += await Promise.all(hotPosts.map(async post => {
                    // 检查帖子是否有图片
                    const hasImage = await db.forumPostImages.where('postId').equals(post.id).count() > 0;

                    return `
                        <div class="post-item hot" onclick="showPostView(${post.id})">
                            <div class="post-title-container">
                                <div class="post-title">
                                    ${post.title}
                                    ${hasImage ? '<svg class="image-post-badge" viewBox="0 0 24 24"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>' : ''}
                                </div>
                                ${post.isUserPost ? '<span class="user-post-badge">我</span>' : ''}
                            </div>
                            <div class="post-meta">
                                <span class="post-author">${post.authorName}</span>
                                <span>${formatTime(post.timestamp)}</span>
                            </div>
                        </div>
                    `;
                })).then(results => results.join(''));
            }

            // 渲染最新帖子区
            if (newestPosts.length > 0) {
                html += '<div class="forum-section-header">最新帖子</div>';
                html += await Promise.all(newestPosts.map(async post => {
                    // 检查帖子是否有图片
                    const hasImage = await db.forumPostImages.where('postId').equals(post.id).count() > 0;

                    return `
                        <div class="post-item" onclick="showPostView(${post.id})">
                            <div class="post-title-container">
                                <div class="post-title">
                                    ${post.title}
                                    ${hasImage ? '<svg class="image-post-badge" viewBox="0 0 24 24"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>' : ''}
                                </div>
                                ${post.isUserPost ? '<span class="user-post-badge">我</span>' : ''}
                            </div>
                            <div class="post-meta">
                                <span class="post-author">${post.authorName}</span>
                                <span>${formatTime(post.timestamp)}</span>
                            </div>
                        </div>
                    `;
                })).then(results => results.join(''));
            }

            listContainer.innerHTML = html;
        }

        // 刷新帖子
        async function refreshPosts() {
            if (!currentForumId) return;

            // 显示加载动画
            const forumTitle = document.getElementById('forum-view-title');
            const originalTitle = forumTitle.textContent;
            forumTitle.innerHTML = originalTitle + '<span class="forum-loading-spinner"></span>';

            showToast("正在获取最新动态...", "info");

            try {
                // 1. 生成10条新帖子
                await generateForumPosts(currentForumId);

                // --- 帖子的"新陈代谢"与"永久珍藏"逻辑 ---

                // 2. 获取所有帖子ID、用户收藏的帖子ID、用户自己发布的帖子ID
                const allPostsInForum = await db.forumPosts.where('forumId').equals(parseInt(currentForumId)).toArray();
                const allPostIds = new Set(allPostsInForum.map(post => post.id));

                const favoriteRecords = await db.forumFavorites.where({ userId: 'user' }).toArray();
                const favoritedPostIds = new Set(favoriteRecords.map(fav => fav.postId));

                const userPosts = allPostsInForum.filter(post => post.isUserPost === true);
                const userPostIds = new Set(userPosts.map(post => post.id));

                // 3. 确定需要保留的帖子：最新的30条 + 所有收藏的 + 所有用户发布的
                const postsToKeepIds = new Set();

                // 3.1 添加最新的30条
                allPostsInForum
                    .sort((a, b) => b.timestamp - a.timestamp)
                    .slice(0, 30)
                    .forEach(post => postsToKeepIds.add(post.id));

                // 3.2 添加所有收藏的
                favoritedPostIds.forEach(id => postsToKeepIds.add(id));

                // 3.3 添加所有用户自己发布的
                userPostIds.forEach(id => postsToKeepIds.add(id));

                // 4. 找出需要删除的帖子
                const postsToDeleteIds = [];
                allPostIds.forEach(id => {
                    if (!postsToKeepIds.has(id)) {
                        postsToDeleteIds.push(id);
                    }
                });

                // 5. 执行删除
                if (postsToDeleteIds.length > 0) {
                    console.log(`论坛帖子清理：准备删除 ${postsToDeleteIds.length} 条过期/未收藏/非用户发布的帖子。`);
                    await db.forumPosts.bulkDelete(postsToDeleteIds);
                    await db.forumReplies.where('postId').anyOf(postsToDeleteIds).delete();
                    console.log(`✅ 清理完成！`);
                }

                // 6. 重新渲染界面
                await renderForumPosts(currentForumId);
                showToast("论坛已刷新！", "success");

            } catch (error) {
                console.error('刷新帖子失败:', error);
                showToast('刷新失败: ' + error.message, 'error');
                await renderForumPosts(currentForumId);
            } finally {
                // 移除加载动画
                forumTitle.innerHTML = originalTitle;
            }
        }

        // 从帖子详情返回论坛
        function backToForum() {
            // 🔥【修复】根据来源页面返回到正确位置
            const source = window.postViewSource || 'forum';

            if (source === 'chat') {
                // 从聊天界面进入的，返回聊天界面
                showApp('api-chat-screen');
            } else {
                // 从论坛进入的，返回论坛
                if (currentForumId) {
                    loadAndDisplayForum(currentForumId);
                } else {
                    showApp('forum-screen');
                }
            }
            hideApp('post-view-screen');
        }

        // 🔥【优化后】显示帖子详情 (支持图片)
        async function showPostView(postId, fromSource = 'forum') {
            const post = await db.forumPosts.get(postId);
            if (!post) return;

            window.currentPostId = postId;
            currentForumId = post.forumId;

            // 🔥【新增】记录来源页面，用于返回导航
            window.postViewSource = fromSource;

            const contentContainer = document.getElementById('post-view-content');

            // 获取帖子图片
            const postImage = await db.forumPostImages.where('postId').equals(postId).first();
            const imageUrl = postImage ? postImage.imageUrl : null;

            // 安全地渲染帖子内容
            const postBodyContainerHTML = (post.content || '').replace(/\n/g, '<br>');

            contentContainer.innerHTML = `
                <div class="post-full-content">
                    <div class="post-full-title-container">
                        <div class="post-full-title">${post.title}${imageUrl ? '<svg class="image-post-badge" viewBox="0 0 24 24"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>' : ''}</div>
                        ${post.isUserPost ? '<span class="user-post-badge">我</span>' : ''}
                    </div>
                    <div class="post-full-meta">由 ${post.authorName} 发布于 ${new Date(post.timestamp).toLocaleString()}</div>
                    <div class="post-full-body" id="post-body-container">${postBodyContainerHTML}${imageUrl ? `<img src="${imageUrl}" alt="帖子图片" style="max-width: 100%; border-radius: 8px; margin-top: 15px;">` : ''}</div>
                </div>
                <div class="replies-section">
                    <h3>回复</h3>
                    <div id="replies-list"><div class="loading-container" style="text-align: center; padding: 30px;"><div class="loading-spinner" style="width: 30px; height: 30px; border: 2px solid #f3f3f3; border-top: 2px solid #007AFF; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 15px auto;"></div><div style="color: #666; font-size: 12px;">加载评论中...</div></div></div>
                </div>
            `;

            // 更新收藏按钮状态
            const isFav = await db.forumFavorites.where('[userId+postId]').equals(['user', postId]).first();
            const favIcon = document.querySelector('#favorite-btn i');
            favIcon.className = isFav ? 'fas fa-star' : 'far fa-star';

            showApp('post-view-screen');

            setTimeout(async () => {
                // 🔥【恢复】为投票帖子生成智能票数数据
                const pollElement = document.querySelector('.post-full-body .forum-poll');
                if (pollElement) {
                    await generateSmartPollData(postId, post);
                }

                const existingReplies = await db.forumReplies.where('postId').equals(postId).count();
                if (existingReplies === 0) {
                    await generateRepliesForUserPost(postId, imageUrl);
                }
                await renderReplies(postId);
            }, 100);
        }

        // 生成帖子评论
        async function generateRepliesForPost(postId) {
            const post = await db.forumPosts.get(postId);
            if (!post) return;

            const forum = await db.forums.get(post.forumId);
            const forumCharacters = characters.filter(c => forum.characterIds.includes(c.id));
            const persona = personas.find(p => p.id === forum.personaId);

            // 显示加载动画
            const repliesContainer = document.getElementById('replies-list');
            repliesContainer.innerHTML = `
                <div class="loading-container" style="text-align: center; padding: 30px;">
                    <div class="loading-spinner" style="
                        width: 30px;
                        height: 30px;
                        border: 2px solid #f3f3f3;
                        border-top: 2px solid #007AFF;
                        border-radius: 50%;
                        animation: spin 1s linear infinite;
                        margin: 0 auto 15px auto;
                    "></div>
                    <div style="color: #666; font-size: 12px;">加载评论中...</div>
                </div>
            `;

            const prompt = `
# 角色：论坛评论生成AI
请为以下帖子生成10条真实的评论回复。

## 帖子信息:
标题: ${post.title}
内容: ${post.content}
作者: ${post.authorName}

## 论坛背景:
世界观: ${forum.worldview || '现代都市生活分享社区'}

## 可参与评论的角色:
${forumCharacters.map(c => `- ${c.name}: ${c.bio}`).join('\n')}

**重要：绝对不要生成用户(${persona.name})的评论！用户会自己评论！**

## 评论生成要求:
1. **真实感**: 评论要像真人写的，有不同的观点和语气
2. **多样性**: 包括赞同、反对、提问、分享经验等不同类型
3. **角色分配**:
   - 50%由虚构的路人网友评论（请创造符合世界观的网友昵称）
   - 30%由上述角色评论，要符合人设，使用"网名(真实身份)"格式
   - 20%由上述角色匿名评论，只使用网名，不暴露真实身份
4. **互动性**: 评论之间可以有回应和讨论
5. **长度适中**: 每条评论1-3句话即可

### 输出格式:
严格的JSON数组，不要其他文字：

[
  {
    "authorName": "评论者姓名",
    "content": "评论内容"
  }
]
`;

            // 🔥【调试】输出论坛评论生成的完整prompt
            console.log('🔥 [论坛评论生成] 完整Prompt:');
            console.log('='.repeat(80));
            console.log(prompt);
            console.log('='.repeat(80));

            try {
                const response = await callForumAPI(prompt);
                let replies;
                try {
                    replies = JSON.parse(response);
                } catch (e) {
                    const jsonMatch = response.match(/```json\s*([\s\S]*?)\s*```/);
                    if (jsonMatch && jsonMatch[1]) {
                        replies = JSON.parse(jsonMatch[1]);
                    } else {
                        throw new Error("AI返回的不是有效的JSON格式。");
                    }
                }

                if (!Array.isArray(replies)) {
                    throw new Error("AI返回的数据不是一个数组。");
                }

                // 保存评论到数据库
                for (let i = 0; i < replies.length; i++) {
                    const reply = replies[i];
                    if (reply.authorName && reply.content) {
                        // 🔥【修复】正确识别角色身份，支持"网名(真实身份)"格式
                        let author = null;
                        let realName = '';

                        // 检查是否是"网名(真实身份)"格式
                        const nameMatch = reply.authorName.match(/^(.+)\((.+)\)$/);
                        if (nameMatch) {
                            realName = nameMatch[2]; // 提取真实身份
                            author = characters.find(c => c.name === realName) || personas.find(p => p.name === realName);
                        } else {
                            // 直接匹配角色名
                            author = characters.find(c => c.name === reply.authorName) || personas.find(p => p.name === reply.authorName);
                        }

                        await db.forumReplies.add({
                            postId: postId,
                            content: reply.content,
                            authorName: reply.authorName,
                            authorAvatar: author ? author.avatarUrl : createDefaultAvatar(reply.authorName),
                            timestamp: Date.now() + i * 1000, // 错开时间戳
                            likes: Math.floor(Math.random() * 100) // 关键新增：生成0-99的随机点赞数
                        });
                    }
                }
            } catch (error) {
                console.error("生成评论失败:", error);
                showToast("生成评论失败: " + error.message, 'error');
            }
        }

        // 渲染回复 (已美化版本)
        async function renderReplies(postId) {
            const replies = await db.forumReplies.where('postId').equals(postId).sortBy('timestamp');
            const listContainer = document.getElementById('replies-list');

            const userLikes = await db.replyLikes.where('userId').equals('user').toArray();
            const likedReplyIds = new Set(userLikes.map(like => like.replyId));

            // SVG图标定义
            const svgThumbsUpOutline = `<svg viewBox="0 0 24 24"><path d="M7.493 18.75c-.425 0-.82-.236-.975-.632A7.48 7.48 0 0 1 6 15.375c0-1.75.599-3.358 1.602-4.634.151-.192.373-.309.6-.397.473-.183.89-.514 1.212-.924a9.042 9.042 0 0 1 2.861-2.4c.723-.384 1.35-.956 1.653-1.715a4.498 4.498 0 0 0 .322-1.672V3a.75.75 0 0 1 .75-.75A2.25 2.25 0 0 1 16.5 4.5c0 1.152-.26 2.243-.723 3.218-.266.558-.107 1.282.725 1.282h3.126c1.026 0 1.945.694 2.054 1.715.045.422.068.85.068 1.285a11.95 11.95 0 0 1-2.649 7.521c-.388.482-.987.729-1.605.729H14.23c-.483 0-.964-.078-1.423-.23l-3.114-1.04a4.501 4.501 0 0 0-1.423-.23h-.777ZM2.331 10.727a11.969 11.969 0 0 0-.831 4.398 12 12 0 0 0 .52 3.507C2.28 19.482 3.105 20 3.994 20H4.9c.445 0 .72-.498.523-.898a8.963 8.963 0 0 1-.924-3.977c0-1.708.476-3.305 1.302-4.666.245-.403-.028-.959-.5-.959H4.25c-.832 0-1.612.453-1.918 1.227Z"></path></svg>`;
            const svgThumbsUpFilled = `<svg viewBox="0 0 24 24"><path d="M7.493 18.75c-.425 0-.82-.236-.975-.632A7.48 7.48 0 0 1 6 15.375c0-1.75.599-3.358 1.602-4.634.151-.192.373-.309.6-.397.473-.183.89-.514 1.212-.924a9.042 9.042 0 0 1 2.861-2.4c.723-.384 1.35-.956 1.653-1.715a4.498 4.498 0 0 0 .322-1.672V3a.75.75 0 0 1 .75-.75A2.25 2.25 0 0 1 16.5 4.5c0 1.152-.26 2.243-.723 3.218-.266.558-.107 1.282.725 1.282h3.126c1.026 0 1.945.694 2.054 1.715.045.422.068.85.068 1.285a11.95 11.95 0 0 1-2.649 7.521c-.388.482-.987.729-1.605.729H14.23c-.483 0-.964-.078-1.423-.23l-3.114-1.04a4.501 4.501 0 0 0-1.423-.23h-.777ZM2.331 10.727a11.969 11.969 0 0 0-.831 4.398 12 12 0 0 0 .52 3.507C2.28 19.482 3.105 20 3.994 20H4.9c.445 0 .72-.498.523-.898a8.963 8.963 0 0 1-.924-3.977c0-1.708.476-3.305 1.302-4.666.245-.403-.028-.959-.5-.959H4.25c-.832 0-1.612.453-1.918 1.227Z" fill="currentColor"></path></svg>`;

            const repliesHtml = replies.map((reply, index) => { // 🔥【修复】添加 index 参数
                const isLiked = likedReplyIds.has(reply.id);
                const likedClass = isLiked ? 'liked' : '';
                const thumbsUpIcon = isLiked ? svgThumbsUpFilled : svgThumbsUpOutline;
                // 🔥【修复】格式化时间戳
                const formattedTime = new Date(reply.timestamp).toLocaleString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });

                return `
                    <div class="reply-item" data-reply-id="${reply.id}">
                        <img class="reply-avatar" src="${reply.authorAvatar || createDefaultAvatar(reply.authorName)}" alt="${reply.authorName}">
                        <div class="reply-body">
                            <div class="reply-author">${reply.authorName}</div>

                            <div class="reply-meta">
                                <span>No.${index + 1}</span>
                                <span>${formattedTime}</span>
                            </div>

                            <div class="reply-content">${reply.content.replace(/\n/g, '<br>')}</div>
                            <div class="reply-actions">
                                <button class="reply-action-btn like-btn ${likedClass}" onclick="likeReply(${reply.id})" title="点赞">
                                    ${thumbsUpIcon}
                                    <span class="like-count">${reply.likes || 0}</span>
                                </button>
                                <button class="reply-action-btn" onclick="replyToComment(${reply.id}, '${reply.authorName}')" title="回复">
                                    <i class="far fa-comment"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            // 🔥【新增】在评论列表最后添加"加载更多评论"按钮
            const loadMoreButton = replies.length > 0 ? `
                <div class="load-more-comments-container">
                    <button class="load-more-comments-btn" onclick="loadMoreComments(${postId})">
                        🔘加载更多评论
                    </button>
                </div>
            ` : '';

            listContainer.innerHTML = repliesHtml + loadMoreButton;
        }

        // 🔥【新增】加载更多评论功能
        async function loadMoreComments(postId) {
            try {
                const post = await db.forumPosts.get(postId);
                if (!post) return;

                const forum = await db.forums.get(post.forumId);
                const forumCharacters = characters.filter(c => forum.characterIds.includes(c.id));
                const persona = personas.find(p => p.id === forum.personaId);

                // 获取现有评论作为上下文
                const existingReplies = await db.forumReplies.where('postId').equals(postId).sortBy('timestamp');

                // 显示加载状态
                const loadMoreBtn = document.querySelector('.load-more-comments-btn');
                const originalText = loadMoreBtn.textContent;
                loadMoreBtn.textContent = '加载中...';
                loadMoreBtn.disabled = true;

                // 构建上下文信息
                const recentContext = existingReplies.slice(-5).map(reply =>
                    `${reply.authorName}: ${reply.content}`
                ).join('\n');

                const prompt = `
# 角色：论坛评论生成AI
请为以下帖子生成10条真实的评论回复，这些评论需要与之前的讨论有一定的上下文关联。

## 帖子信息:
标题: ${post.title}
内容: ${post.content}
作者: ${post.authorName}

## 论坛背景:
世界观: ${forum.worldview || '现代都市生活分享社区'}

## 最近的评论上下文:
${recentContext || '暂无评论'}

## 可参与评论的角色:
${forumCharacters.map(c => `- ${c.name}: ${c.bio}`).join('\n')}

**重要：绝对不要生成用户(${persona.name})的评论！用户会自己评论！**

## 评论生成要求:
1. **真实感**: 评论要像真人写的，有不同的观点和语气
2. **上下文关联**: 新评论应该与之前的讨论有关联，可以：
   - 回应之前某个角色的观点
   - 继续之前的话题讨论
   - 提出新的相关问题
   - 对之前的评论表示赞同或不同意见
3. **多样性**: 包括赞同、反对、提问、分享经验等不同类型
4. **角色分配**:
   - 50%由虚构的路人网友评论（请创造符合世界观的网友昵称）
   - 30%由上述角色评论，要符合人设，使用"网名(真实身份)"格式
   - 20%由上述角色匿名评论，只使用网名，不暴露真实身份
5. **互动性**: 评论之间可以有回应和讨论
6. **长度适中**: 每条评论1-3句话即可

### 输出格式:
严格的JSON数组，不要其他文字：

[
  {
    "authorName": "评论者姓名",
    "content": "评论内容"
  }
]
`;

                // 🔥【修复】使用正确的API调用函数
                const response = await callForumAPI(prompt);
                let newReplies = [];

                try {
                    newReplies = JSON.parse(response);
                } catch (e) {
                    console.log('🔥 [loadMoreComments] 直接解析JSON失败，尝试提取代码块');

                    // 尝试提取 ```json 代码块
                    const jsonMatch = response.match(/```json\s*([\s\S]*?)\s*```/);
                    if (jsonMatch && jsonMatch[1]) {
                        console.log('🔥 [loadMoreComments] 找到JSON代码块:', jsonMatch[1]);
                        try {
                            newReplies = JSON.parse(jsonMatch[1]);
                        } catch (e2) {
                            console.error('🔥 [loadMoreComments] JSON代码块解析失败:', e2);
                            throw new Error(`AI返回的JSON代码块格式错误: ${e2.message}`);
                        }
                    } else {
                        // 尝试提取普通的 ``` 代码块
                        const codeMatch = response.match(/```\s*([\s\S]*?)\s*```/);
                        if (codeMatch && codeMatch[1]) {
                            console.log('🔥 [loadMoreComments] 找到普通代码块:', codeMatch[1]);
                            try {
                                newReplies = JSON.parse(codeMatch[1]);
                            } catch (e3) {
                                console.error('🔥 [loadMoreComments] 普通代码块解析失败:', e3);
                                throw new Error(`AI返回的代码块格式错误: ${e3.message}`);
                            }
                        } else {
                            // 尝试查找数组格式 [...]
                            const arrayMatch = response.match(/\[[\s\S]*\]/);
                            if (arrayMatch) {
                                console.log('🔥 [loadMoreComments] 找到数组格式:', arrayMatch[0]);
                                try {
                                    newReplies = JSON.parse(arrayMatch[0]);
                                } catch (e4) {
                                    console.error('🔥 [loadMoreComments] 数组格式解析失败:', e4);
                                    throw new Error(`AI返回的数组格式错误: ${e4.message}`);
                                }
                            } else {
                                console.error('🔥 [loadMoreComments] 无法找到有效的JSON格式');
                                throw new Error(`AI返回的不是有效的JSON格式。原始响应: ${response.substring(0, 200)}...`);
                            }
                        }
                    }
                }

                // 保存新评论到数据库
                const baseTimestamp = Date.now();
                let successCount = 0;

                for (let i = 0; i < newReplies.length; i++) {
                    const replyData = newReplies[i];
                    if (!replyData.content || !replyData.authorName) continue;

                    // 🔥【修复】正确识别角色身份，支持"网名(真实身份)"格式
                    let author = null;
                    let realName = '';

                    // 检查是否是"网名(真实身份)"格式
                    const nameMatch = replyData.authorName.match(/^(.+?)\((.+?)\)$/);
                    if (nameMatch) {
                        const nickname = nameMatch[1].trim();
                        realName = nameMatch[2].trim();
                        author = characters.find(c => c.name === realName);
                        if (author) {
                            // 使用网名作为显示名称
                            replyData.authorName = nickname;
                        }
                    } else {
                        // 直接匹配角色名
                        author = characters.find(c => c.name === replyData.authorName);
                    }

                    const reply = {
                        postId: postId,
                        authorName: replyData.authorName,
                        authorAvatar: author ? author.avatarUrl : createDefaultAvatar(replyData.authorName),
                        content: replyData.content,
                        timestamp: baseTimestamp + (i * 1000), // 间隔1秒
                        likes: Math.floor(Math.random() * 5), // 随机点赞数
                        characterId: author ? author.id : null
                    };
                    await db.forumReplies.add(reply);
                    successCount++;
                }

                // 重新渲染评论列表
                await renderReplies(postId);
                showToast(`成功加载了 ${successCount} 条新评论`, 'success');

            } catch (error) {
                console.error('加载更多评论失败:', error);
                showToast('加载评论失败: ' + error.message, 'error');

                // 恢复按钮状态
                const loadMoreBtn = document.querySelector('.load-more-comments-btn');
                if (loadMoreBtn) {
                    loadMoreBtn.textContent = '🔘加载更多评论';
                    loadMoreBtn.disabled = false;
                }
            }
        }

        // 🔥【优化后】显示发帖模态框
        function showCreatePostModal() {
            const modal = document.getElementById('create-post-modal');
            modal.style.display = 'flex';

            // 清空输入框和预览
            document.getElementById('post-title-input').value = '';
            document.getElementById('post-content-input').value = '';
            document.getElementById('anonymous-post-checkbox').checked = false;
            document.getElementById('post-image-upload').value = '';
            document.getElementById('post-image-preview-container').style.display = 'none';
            document.getElementById('post-image-preview').src = '';
            updateCharCount();

            const titleInput = document.getElementById('post-title-input');
            const contentInput = document.getElementById('post-content-input');
            titleInput.oninput = updateCharCount;
            contentInput.oninput = updateCharCount;

            // 绑定图片上传按钮事件
            const uploadBtn = document.getElementById('post-upload-image-btn');
            const fileInput = document.getElementById('post-image-upload');
            const removeBtn = document.getElementById('post-remove-image-btn');
            const previewContainer = document.getElementById('post-image-preview-container');
            const previewImg = document.getElementById('post-image-preview');

            uploadBtn.onclick = () => fileInput.click();

            fileInput.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        previewImg.src = event.target.result;
                        previewContainer.style.display = 'block';
                    };
                    reader.readAsDataURL(file);
                }
            };

            removeBtn.onclick = () => {
                fileInput.value = '';
                previewImg.src = '';
                previewContainer.style.display = 'none';
            };
        }

        // 隐藏发帖模态框
        function hideCreatePostModal(event) {
            if (event && event.target !== event.currentTarget) return;
            const modal = document.getElementById('create-post-modal');
            modal.style.display = 'none';
        }

        // 更新字符计数
        function updateCharCount() {
            const titleInput = document.getElementById('post-title-input');
            const contentInput = document.getElementById('post-content-input');
            const titleCount = document.getElementById('title-count');
            const contentCount = document.getElementById('content-count');

            titleCount.textContent = `${titleInput.value.length}/100`;
            contentCount.textContent = `${contentInput.value.length}/2000`;

            // 超出限制时变红
            titleCount.style.color = titleInput.value.length > 100 ? '#ff3b30' : '#666';
            contentCount.style.color = contentInput.value.length > 2000 ? '#ff3b30' : '#666';
        }

        // 🔥【优化后】提交用户发帖 (支持图片)
        async function submitUserPost() {
            const title = document.getElementById('post-title-input').value.trim();
            const content = document.getElementById('post-content-input').value.trim();
            const isAnonymous = document.getElementById('anonymous-post-checkbox').checked;
            const imageInput = document.getElementById('post-image-upload');
            const imageFile = imageInput.files[0];

            if (!title && !imageFile) { // 如果标题和图片都为空
                showToast('请输入标题或上传图片', 'error');
                return;
            }
            if (!content && !imageFile) { // 如果内容和图片都为空
                showToast('请输入内容或上传图片', 'error');
                return;
            }

            if (title.length > 100 || content.length > 2000) {
                showToast('标题或内容超出字数限制', 'error');
                return;
            }

            showToast('正在发布帖子...', 'info');

            try {
                const forum = await db.forums.get(parseInt(currentForumId));
                const persona = personas.find(p => p.id === forum.personaId);

                let authorName, authorId, authorAvatar;
                if (isAnonymous) {
                    const anonymousNames = ['神秘路人', '匿名网友', '路过的人'];
                    authorName = anonymousNames[Math.floor(Math.random() * anonymousNames.length)];
                    authorId = 'anonymous_' + Date.now();
                    authorAvatar = null;
                } else {
                    authorName = persona.name;
                    authorId = persona.id;
                    authorAvatar = persona.avatarUrl;
                }

                const postData = {
                    forumId: parseInt(currentForumId),
                    title: title || "分享图片", // 如果没有标题，给个默认标题
                    content,
                    authorId,
                    authorName,
                    authorAvatar,
                    timestamp: Date.now(),
                    isUserPost: true,
                    isAnonymous
                };

                let imageUrl = null;
                if (imageFile) {
                    imageUrl = await new Promise(resolve => {
                        const reader = new FileReader();
                        reader.onload = e => resolve(e.target.result);
                        reader.readAsDataURL(imageFile);
                    });
                }

                const postId = await db.forumPosts.add(postData);

                if (imageUrl) {
                    await db.forumPostImages.add({ postId, imageUrl });
                }

                hideCreatePostModal();
                await renderForumPosts(currentForumId);

                showToast('帖子发布成功！', 'success');

            } catch (error) {
                console.error('发帖失败:', error);
                showToast('发帖失败: ' + error.message, 'error');
            }
        }

        // 【最终修复】为用户帖子生成AI回复 (智能分流)
        async function generateRepliesForUserPost(postId, imageUrl = null) {
            const post = await db.forumPosts.get(postId);
            if (!post) return;

            const forum = await db.forums.get(post.forumId);
            const forumCharacters = characters.filter(c => forum.characterIds.includes(c.id));
            const persona = personas.find(p => p.id === forum.personaId);

            let imageContext = '';
            if (imageUrl) {
                // 这是告诉AI有图片存在的关键
                imageContext = `\n\n**重要**：用户在帖子中附带了一张图片，你必须对图片内容进行回应。你的回复必须体现出你看到了这张图片。`;
            }

            const prompt = `
# 角色：论坛回复生成AI
用户在论坛发了一个帖子，请生成8-12条真实的回复。

## 用户帖子:
标题: ${post.title}
内容: ${post.content}
作者: ${post.authorName}${post.isAnonymous ? ' (匿名用户，身份未知)' : ''}
${imageContext}

## 论坛背景:
世界观: ${forum.worldview || '现代都市生活分享社区'}

## 可参与回复的角色:
${forumCharacters.map(c => `- ${c.name}: ${c.bio}`).join('\n')}

**重要：绝对不要生成用户(${persona.name})的评论！用户会自己评论！**

## 回复生成要求:
1.  **🔥 识图优先**: 如果帖子有图片，你的回复必须优先围绕图片内容展开。
2.  **真实感**: 回复要像真人写的，有不同的观点和语气
3.  **多样性**: 包括赞同、反对、提问、分享经验、调侃等不同类型
4.  **角色分配**:
   - 50%由虚构的路人网友回复（请创造符合世界观的网友昵称）
   - 30%由上述角色回复，要符合人设，使用"网名(真实身份)"格式
   - 20%由上述角色匿名回复，只使用网名，不暴露真实身份
5.  **互动性**: 可以@用户或其他回复者${post.isAnonymous ? '，但不要试图猜测匿名用户的真实身份' : ''}
6.  **长度适中**: 每条回复1-3句话即可
7.  **匿名保护**: ${post.isAnonymous ? '帖子作者是匿名的，AI角色不应该认出或暗示知道作者的真实身份' : '正常互动即可'}

### 输出格式:
**重要：只输出JSON数组，不要任何其他文字、解释或代码块标记！**

[
  {
    "authorName": "回复者网名或网名(真实身份)",
    "content": "回复内容"
  }
]

**再次强调：直接输出JSON数组，不要包装在代码块中！**
`;

            try {
                let response;
                // 【智能分流】
                if (imageUrl) {
                    console.log("正在调用图片API...");
                    response = await callForumAPIWithImage(prompt, imageUrl);
                } else {
                    console.log("正在调用文本API...");
                    response = await callForumAPI(prompt);
                }

                let replies;
                console.log('🔥 [generateRepliesForUserPost] AI原始响应:', response);

                try {
                    replies = JSON.parse(response);
                } catch (e) {
                    console.log('🔥 [generateRepliesForUserPost] 直接解析JSON失败，尝试提取代码块');

                    // 尝试提取 ```json 代码块
                    const jsonMatch = response.match(/```json\s*([\s\S]*?)\s*```/);
                    if (jsonMatch && jsonMatch[1]) {
                        console.log('🔥 [generateRepliesForUserPost] 找到JSON代码块:', jsonMatch[1]);
                        try {
                            replies = JSON.parse(jsonMatch[1]);
                        } catch (e2) {
                            console.error('🔥 [generateRepliesForUserPost] JSON代码块解析失败:', e2);
                            throw new Error(`AI返回的JSON代码块格式错误: ${e2.message}`);
                        }
                    } else {
                        // 尝试提取普通的 ``` 代码块
                        const codeMatch = response.match(/```\s*([\s\S]*?)\s*```/);
                        if (codeMatch && codeMatch[1]) {
                            console.log('🔥 [generateRepliesForUserPost] 找到普通代码块:', codeMatch[1]);
                            try {
                                replies = JSON.parse(codeMatch[1]);
                            } catch (e3) {
                                console.error('🔥 [generateRepliesForUserPost] 普通代码块解析失败:', e3);
                                throw new Error(`AI返回的代码块格式错误: ${e3.message}`);
                            }
                        } else {
                            // 尝试查找数组格式 [...]
                            const arrayMatch = response.match(/\[[\s\S]*\]/);
                            if (arrayMatch) {
                                console.log('🔥 [generateRepliesForUserPost] 找到数组格式:', arrayMatch[0]);
                                try {
                                    replies = JSON.parse(arrayMatch[0]);
                                } catch (e4) {
                                    console.error('🔥 [generateRepliesForUserPost] 数组格式解析失败:', e4);
                                    throw new Error(`AI返回的数组格式错误: ${e4.message}`);
                                }
                            } else {
                                console.error('🔥 [generateRepliesForUserPost] 无法找到有效的JSON格式');
                                throw new Error(`AI返回的不是有效的JSON格式。原始响应: ${response.substring(0, 200)}...`);
                            }
                        }
                    }
                }

                if (Array.isArray(replies)) {
                    for (let i = 0; i < replies.length; i++) {
                        const reply = replies[i];
                        if (reply.authorName && reply.content) {
                            // 🔥【修复】正确识别角色身份，支持"网名(真实身份)"格式
                            let author = null;
                            let realName = '';

                            // 检查是否是"网名(真实身份)"格式
                            const nameMatch = reply.authorName.match(/^(.+)\((.+)\)$/);
                            if (nameMatch) {
                                realName = nameMatch[2]; // 提取真实身份
                                author = characters.find(c => c.name === realName) || personas.find(p => p.name === realName);
                            } else {
                                // 直接匹配角色名
                                author = characters.find(c => c.name === reply.authorName) || personas.find(p => p.name === reply.authorName);
                            }

                            await db.forumReplies.add({
                                postId: postId,
                                content: reply.content,
                                authorName: reply.authorName,
                                authorAvatar: author ? author.avatarUrl : createDefaultAvatar(reply.authorName),
                                timestamp: Date.now() + i * 2000
                            });
                        }
                    }
                    showToast(`收到了${replies.length}条回复！`, 'success');
                }

            } catch (error) {
                console.error("生成用户帖子回复失败:", error);
                // 【重要】向用户显示具体的错误信息
                showToast(`生成回复失败: ${error.message}`, 'error');
            }
        }

        // 点赞评论 (已美化版本)
        async function likeReply(replyId) {
            try {
                const reply = await db.forumReplies.get(replyId);
                if (!reply) return;

                const likeBtn = document.querySelector(`[data-reply-id="${replyId}"] .like-btn`);
                const likeCountSpan = likeBtn.querySelector('.like-count');

                // SVG图标定义 (与renderReplies中保持一致)
                const svgThumbsUpOutline = `<svg viewBox="0 0 24 24"><path d="M7.493 18.75c-.425 0-.82-.236-.975-.632A7.48 7.48 0 0 1 6 15.375c0-1.75.599-3.358 1.602-4.634.151-.192.373-.309.6-.397.473-.183.89-.514 1.212-.924a9.042 9.042 0 0 1 2.861-2.4c.723-.384 1.35-.956 1.653-1.715a4.498 4.498 0 0 0 .322-1.672V3a.75.75 0 0 1 .75-.75A2.25 2.25 0 0 1 16.5 4.5c0 1.152-.26 2.243-.723 3.218-.266.558-.107 1.282.725 1.282h3.126c1.026 0 1.945.694 2.054 1.715.045.422.068.85.068 1.285a11.95 11.95 0 0 1-2.649 7.521c-.388.482-.987.729-1.605.729H14.23c-.483 0-.964-.078-1.423-.23l-3.114-1.04a4.501 4.501 0 0 0-1.423-.23h-.777ZM2.331 10.727a11.969 11.969 0 0 0-.831 4.398 12 12 0 0 0 .52 3.507C2.28 19.482 3.105 20 3.994 20H4.9c.445 0 .72-.498.523-.898a8.963 8.963 0 0 1-.924-3.977c0-1.708.476-3.305 1.302-4.666.245-.403-.028-.959-.5-.959H4.25c-.832 0-1.612.453-1.918 1.227Z"></path></svg>`;
                const svgThumbsUpFilled = `<svg viewBox="0 0 24 24"><path d="M7.493 18.75c-.425 0-.82-.236-.975-.632A7.48 7.48 0 0 1 6 15.375c0-1.75.599-3.358 1.602-4.634.151-.192.373-.309.6-.397.473-.183.89-.514 1.212-.924a9.042 9.042 0 0 1 2.861-2.4c.723-.384 1.35-.956 1.653-1.715a4.498 4.498 0 0 0 .322-1.672V3a.75.75 0 0 1 .75-.75A2.25 2.25 0 0 1 16.5 4.5c0 1.152-.26 2.243-.723 3.218-.266.558-.107 1.282.725 1.282h3.126c1.026 0 1.945.694 2.054 1.715.045.422.068.85.068 1.285a11.95 11.95 0 0 1-2.649 7.521c-.388.482-.987.729-1.605.729H14.23c-.483 0-.964-.078-1.423-.23l-3.114-1.04a4.501 4.501 0 0 0-1.423-.23h-.777ZM2.331 10.727a11.969 11.969 0 0 0-.831 4.398 12 12 0 0 0 .52 3.507C2.28 19.482 3.105 20 3.994 20H4.9c.445 0 .72-.498.523-.898a8.963 8.963 0 0 1-.924-3.977c0-1.708.476-3.305 1.302-4.666.245-.403-.028-.959-.5-.959H4.25c-.832 0-1.612.453-1.918 1.227Z" fill="currentColor"></path></svg>`;

                const existingLike = await db.replyLikes.where('[userId+replyId]').equals(['user', replyId]).first();

                if (existingLike) {
                    // 取消点赞
                    await db.replyLikes.delete(existingLike.id);
                    reply.likes = Math.max(0, (reply.likes || 0) - 1);
                    likeBtn.classList.remove('liked');
                    likeBtn.innerHTML = svgThumbsUpOutline + `<span class="like-count">${reply.likes || 0}</span>`;
                } else {
                    // 点赞
                    await db.replyLikes.add({ userId: 'user', replyId: replyId, timestamp: Date.now() });
                    reply.likes = (reply.likes || 0) + 1;
                    likeBtn.classList.add('liked');
                    likeBtn.innerHTML = svgThumbsUpFilled + `<span class="like-count">${reply.likes || 0}</span>`;
                }

                await db.forumReplies.update(replyId, { likes: reply.likes });

            } catch (error) {
                console.error('点赞失败:', error);
                showToast('点赞失败', 'error');
            }
        }

        // 回复评论
        async function replyToComment(replyId, authorName) {
            const input = document.getElementById('reply-input');
            if (input) {
                input.value = `@${authorName} `;
                input.focus();
                // 将光标移到末尾
                input.setSelectionRange(input.value.length, input.value.length);
            }
        }

        // 【新增】为论坛回复设计的简化版API调用函数
        async function callSimpleTextAPI(prompt) {
            if (!apiSettings.key) {
                throw new Error('API密钥未设置');
            }

            const requestBody = {
                model: apiSettings.model,
                messages: [{ role: "user", content: prompt }],
                temperature: 0.85 // 稍微提高一点创造性
            };

            const isGemini = apiSettings.base.includes('generativelanguage.googleapis.com');
            let url, headers, body;

            if (isGemini) {
                url = `${apiSettings.base}/models/${apiSettings.model}:generateContent?key=${apiSettings.key}`;
                headers = { 'Content-Type': 'application/json' };
                body = JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] });
            } else {
                url = apiSettings.base.endsWith('/v1') ? `${apiSettings.base}/chat/completions` : `${apiSettings.base}/v1/chat/completions`;
                headers = { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiSettings.key}` };
                body = JSON.stringify(requestBody);
            }

            const response = await fetch(url, { method: 'POST', headers: headers, body: body });
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`API请求失败: ${response.status} - ${errorText}`);
            }

            const data = await response.json();
            if (isGemini) {
                return data.candidates?.[0]?.content?.parts?.[0]?.text;
            } else {
                return data.choices?.[0]?.message?.content;
            }
        }

        // 【新增】匿名模式状态
        let isAnonymousMode = false;

        // 【新增】切换匿名模式
        function toggleAnonymousMode() {
            isAnonymousMode = !isAnonymousMode;
            const toggleBtn = document.getElementById('anonymous-toggle');
            const replyInput = document.getElementById('reply-input');

            if (isAnonymousMode) {
                toggleBtn.classList.add('active');
                toggleBtn.title = '匿名模式已开启，点击关闭';
                replyInput.placeholder = '匿名回复...';
            } else {
                toggleBtn.classList.remove('active');
                toggleBtn.title = '匿名回复';
                replyInput.placeholder = '输入你的回复...';
            }
        }

        // 【新增】生成匿名用户名
        function generateAnonymousName() {
            const prefixes = [
                '热心网友', '路过网友', '匿名用户', '神秘的', '低调的',
                '潜水网友', '吃瓜网友', '围观网友', '装深沉', '安静的',
                '佛系的', '淡定的', '装忧郁', '理性的', '客观的'
            ];

            const suffixes = [
                '小白', '小黑', '小红', '小蓝', '小绿', '小紫', '好心人', '小黄',
                '阿强', '阿明', '小狗', '小猫', '被人亲', '被人打', '同学', '一只猹',
                '小A', '小B', '小C', '小D', '小E', '小F', '小G', '小H'
            ];

            const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
            const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];

            return `${prefix}${suffix}（我）`;
        }

        // 发送回复
        async function sendReply() {
            const input = document.getElementById('reply-input');
            const content = input.value.trim();
            if (!content || !window.currentPostId) return;

            // 【修复】如果没有currentForumId，从当前帖子获取论坛ID
            if (!currentForumId) {
                const post = await db.forumPosts.get(window.currentPostId);
                if (post) {
                    currentForumId = post.forumId;
                } else {
                    showToast('找不到帖子信息', 'error');
                    return;
                }
            }

            const forum = await db.forums.get(parseInt(currentForumId));
            if (!forum) {
                showToast('找不到当前论坛信息', 'error');
                return;
            }

            let persona = null;
            if (!isAnonymousMode) {
                persona = personas.find(p => p.id === forum.personaId);
                if (!persona) {
                    showToast('找不到用户身份信息', 'error');
                    return;
                }
            }

            let reply;

            if (isAnonymousMode) {
                // 匿名回复
                reply = {
                    postId: window.currentPostId,
                    authorId: 'anonymous',
                    authorName: generateAnonymousName(),
                    authorAvatar: createDefaultAvatar('匿名'),
                    content: content,
                    timestamp: Date.now(),
                    isAnonymous: true
                };
            } else {
                // 正常回复（使用身份面具）
                reply = {
                    postId: window.currentPostId,
                    authorId: 'user',
                    authorName: persona.name,
                    authorAvatar: persona.avatarUrl,
                    content: content,
                    timestamp: Date.now(),
                    isAnonymous: false
                };
            }

            await db.forumReplies.add(reply);
            input.value = '';
            await renderReplies(window.currentPostId);

            // 【核心修改】调用新的、专属的论坛AI回复控制器
            handleForumAIReply(content, window.currentPostId);
        }

        // 【新增】论坛AI回复的总控制器
        async function handleForumAIReply(userContent, postId) {
            try {
                const post = await db.forumPosts.get(postId);
                const forum = await db.forums.get(post.forumId);
                const forumCharacters = characters.filter(c => forum.characterIds.includes(c.id));

                const mentionMatch = userContent.match(/@(\S+)/);
                let replyingCharacter = null;
                let shouldReply = false;

                if (mentionMatch) { // 用户@了某人
                    const mentionedName = mentionMatch[1];
                    const targetCharacter = forumCharacters.find(c => c.name === mentionedName);

                    if (targetCharacter) { // @的是主要角色
                        shouldReply = Math.random() < 0.6; // 60%概率角色回复
                        replyingCharacter = targetCharacter;
                    } else { // @的是NPC
                        shouldReply = Math.random() < 0.7; // 70%概率NPC回复
                        replyingCharacter = { name: mentionedName, bio: '一个论坛路人' }; // 模拟一个NPC对象
                    }
                } else { // 用户没有@任何人，是普通回复
                    shouldReply = Math.random() < 0.7; // 70%概率有人回复
                    if (shouldReply && forumCharacters.length > 0) {
                        // 随机选一个角色来回复
                        replyingCharacter = forumCharacters[Math.floor(Math.random() * forumCharacters.length)];
                    }
                }

                if (shouldReply && replyingCharacter) {
                    console.log(`[论坛回复决策] 决定由 "${replyingCharacter.name}" 进行回复。`);
                    const prompt = await buildForumReplyPrompt(replyingCharacter, post, userContent);

                    // 🔥【调试】输出论坛回复的完整prompt
                    console.log(`🔥 [论坛回复生成] ${replyingCharacter.name} 的完整Prompt:`);
                    console.log('='.repeat(80));
                    console.log(prompt);
                    console.log('='.repeat(80));

                    // 【重要】调用一个简化的API函数，避免上下文污染
                    const aiReplyText = await callSimpleTextAPI(prompt);

                    if (aiReplyText && aiReplyText.trim()) {
                        const reply = {
                            postId: postId,
                            authorId: replyingCharacter.id || 'npc',
                            authorName: replyingCharacter.name,
                            authorAvatar: replyingCharacter.avatarUrl || createDefaultAvatar(replyingCharacter.name),
                            content: aiReplyText.trim(),
                            timestamp: Date.now() + 1000 // 确保在用户回复之后
                        };
                        await db.forumReplies.add(reply);
                        // 延迟刷新，模拟真实回复
                        setTimeout(() => renderReplies(postId), 1500);
                    }
                } else {
                    console.log('[论坛回复决策] 本次决定不触发AI回复。');
                }
            } catch (error) {
                console.error("处理论坛AI回复失败:", error);
            }
        }

        // 【新增】为论坛回复构建专属的AI指令
        async function buildForumReplyPrompt(replyingCharacter, post, userContent) {
            const replies = await db.forumReplies.where('postId').equals(post.id).sortBy('timestamp');
            const recentReplies = replies.slice(-5); // 最近5条评论作为上下文

            return `
角色：论坛评论员
你的身份是 ${replyingCharacter.name}，你的人设是: ${replyingCharacter.bio || '一个普通的论坛网友'}

当前场景:
在一个名为 "${post.title}" 的帖子里，你看到了用户的一条新评论。

帖子内容:
${post.content}

最近的几条评论:
${recentReplies.map(r => `${r.authorName}: ${r.content}`).join('\n')}

用户刚刚说:
"${userContent}"

你的任务:
作为 ${replyingCharacter.name}，对用户的评论做出自然的回应。

回复要求:
1. 保持人设: 严格按照你的性格和身份进行回复。
2. 自然简短: 回复要像真实的论坛评论，1-3句话即可。
3. 使用表情: 为了让论坛更有趣，请在你的回复中少量使用文字表情、颜文字或emoji，但整条帖子的评论区这类表情的总数不应超过两个。
4. 直接输出: 只返回纯文本的回复内容，不要添加任何JSON格式或多余的解释。

请现在开始你的回复:
`;
        }

        // 收藏/取消收藏帖子 (已修复并增加调试日志的版本)
        async function toggleFavoritePost() {
            console.log('--- [论坛收藏] 功能触发 ---');

            if (!window.currentPostId) {
                console.error('【错误】收藏失败，因为 window.currentPostId 未设置。');
                showToast('错误：没有帖子ID', 'error');
                return;
            }

            // 确保postId是数字类型，这对于数据库查询至关重要
            const postId = parseInt(window.currentPostId);
            const favIcon = document.querySelector('#favorite-btn i');

            console.log(`[论坛收藏] 准备为帖子 ID: ${postId} (类型: ${typeof postId}) 切换收藏状态`);

            if (!favIcon) {
                console.error('【错误】找不到收藏按钮的图标元素。');
                return;
            }

            try {
                console.log('[论坛收藏] 正在查询数据库，检查是否已收藏...');
                const existingFav = await db.forumFavorites.where('[userId+postId]').equals(['user', postId]).first();

                if (existingFav) {
                    console.log('[论坛收藏] 帖子已收藏，准备取消。记录:', existingFav);
                    await db.forumFavorites.delete(existingFav.id);
                    console.log('[论坛收藏] 数据库删除操作成功。');

                    favIcon.className = 'far fa-star';
                    showToast('已取消收藏', 'info');
                    console.log('[论坛收藏] UI已更新为"未收藏"状态。');
                } else {
                    const newFav = { userId: 'user', postId: postId, timestamp: Date.now() };
                    console.log('[论坛收藏] 帖子未收藏，准备添加。新记录:', newFav);
                    await db.forumFavorites.add(newFav);
                    console.log('[论坛收藏] 数据库添加操作成功。');

                    favIcon.className = 'fas fa-star';
                    showToast('收藏成功！', 'success');
                    console.log('[论坛收藏] UI已更新为"已收藏"状态。');
                }
            } catch (error) {
                console.error("--- [论坛收藏] 数据库操作失败！---", error);
                showToast("收藏操作数据库失败，请查看控制台获取详情", "error");
            }
            console.log('--- [论坛收藏] 功能执行完毕 ---');
        }

        // 显示个人主页
        async function showForumProfile() {
            // 切换到个人主页视图
            showApp('forum-profile-screen');
            hideApp('forum-view-screen');

            // 默认显示"我的帖子"
            switchProfileTab('my-posts');

            // --- 异步加载两个分区的数据 ---

            // 1. 加载并渲染"我的帖子"
            const myPostsList = document.getElementById('my-posts-list');
            // 使用filter方法来安全地查询用户帖子
            const allPosts = await db.forumPosts.toArray();
            const userPosts = allPosts.filter(post => post.isUserPost === true).sort((a, b) => b.timestamp - a.timestamp);
            if (userPosts.length === 0) {
                myPostsList.innerHTML = `<div class="forum-empty-state"><p>你还没有发过帖子</p></div>`;
            } else {
                const userPostsHtml = await Promise.all(userPosts.map(async post => {
                    // 检查帖子是否有图片
                    const hasImage = await db.forumPostImages.where('postId').equals(post.id).count() > 0;

                    return `
                        <div class="post-item" onclick="showPostView(${post.id})">
                            <div class="post-title-container">
                                <div class="post-title">
                                    ${post.title}
                                    ${hasImage ? '<svg class="image-post-badge" viewBox="0 0 24 24"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>' : ''}
                                </div>
                                <span class="user-post-badge">我</span>
                            </div>
                            <div class="post-meta">
                                <span class="post-author">${post.authorName}</span>
                                <span>${formatTime(post.timestamp)}</span>
                            </div>
                        </div>
                    `;
                }));
                myPostsList.innerHTML = userPostsHtml.join('');
            }

            // 2. 加载并渲染"我的收藏"
            const favListContainer = document.getElementById('favorite-posts-list');
            const favoriteRecords = await db.forumFavorites.where('userId').equals('user').toArray();
            const postIds = favoriteRecords.map(fav => fav.postId);

            if (postIds.length === 0) {
                favListContainer.innerHTML = `<div class="forum-empty-state"><p>你还没有收藏任何帖子</p></div>`;
            } else {
                const favoritePosts = await db.forumPosts.where('id').anyOf(postIds).toArray();
                const favoritePostsHtml = await Promise.all(favoritePosts.sort((a,b) => b.timestamp - a.timestamp).map(async post => {
                    // 检查帖子是否有图片
                    const hasImage = await db.forumPostImages.where('postId').equals(post.id).count() > 0;

                    return `
                        <div class="post-item" onclick="showPostView(${post.id})">
                            <div class="post-title-container">
                                <div class="post-title">
                                    ${post.title}
                                    ${hasImage ? '<svg class="image-post-badge" viewBox="0 0 24 24"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>' : ''}
                                </div>
                                ${post.isUserPost ? '<span class="user-post-badge">我</span>' : ''}
                            </div>
                            <div class="post-meta">
                                <span class="post-author">${post.authorName}</span>
                                <span>${formatTime(post.timestamp)}</span>
                            </div>
                        </div>
                    `;
                }));
                favListContainer.innerHTML = favoritePostsHtml.join('');
            }
        }

        // 🔥【新增】从个人主页返回当前论坛社区
        async function backToCurrentForum() {
            if (!currentForumId) {
                // 如果没有当前论坛ID，返回论坛主页
                hideApp('forum-profile-screen');
                await renderForumArchives();
                showApp('forum-screen');
                return;
            }

            // 返回当前论坛社区页面
            const forum = await db.forums.get(parseInt(currentForumId));
            if (forum) {
                document.getElementById('forum-view-title').innerText = forum.name;
                await renderForumPosts(currentForumId);
                showApp('forum-view-screen');
                hideApp('forum-profile-screen');
            } else {
                // 论坛不存在，返回论坛主页
                hideApp('forum-profile-screen');
                await renderForumArchives();
                showApp('forum-screen');
            }
        }

        // 初始化论坛应用
        function initializeForumApp() {
            // 绑定论坛应用图标点击事件
            const forumAppIcon = document.querySelector('.mini-app[onclick*="forum-screen"]');
            if (forumAppIcon) {
                // 🔥【修复】不移除onclick属性，保持图标选择器的兼容性
                // 而是添加额外的事件监听器来增强功能
                forumAppIcon.addEventListener('click', async (e) => {
                    // 阻止原有的onclick事件
                    e.preventDefault();
                    e.stopPropagation();
                    await renderForumArchives();
                    showApp('forum-screen');
                });
            }
            console.log('✅ 论坛应用初始化完成');
        }

    </script>

    <!-- 🔥【新增】群成员头像更换模态框 -->
    <div class="modal" id="member-avatar-modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">更换成员头像</h3>
                <button class="modal-close" onclick="hideMemberAvatarModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="member-avatar-form">
                    <div class="current-member-info">
                        <h4 id="member-avatar-name" class="member-name-title">角色名称</h4>
                        <p class="member-info-desc">为该角色设置新的头像，将在群聊中立即生效</p>
                    </div>

                    <div class="avatar-upload-section">
                        <div class="avatar-preview-large">
                            <img id="member-avatar-preview" src="" alt="头像预览" class="preview-image">
                        </div>

                        <div class="upload-buttons">
                            <button class="upload-btn primary" onclick="handleMemberAvatarUpload()">
                                <i class="fas fa-upload"></i>
                                选择新头像
                            </button>
                            <button class="upload-btn secondary" onclick="resetMemberAvatar()">
                                <i class="fas fa-undo"></i>
                                重置默认
                            </button>
                        </div>

                        <input type="file" id="member-avatar-upload" accept="image/*" style="display: none;">
                    </div>

                    <div class="avatar-tips">
                        <div class="tips-header">
                            <i class="fas fa-info-circle"></i>
                            <span>头像更换说明</span>
                        </div>
                        <div class="tips-content">
                            • 支持JPG、PNG等常见图片格式<br>
                            • 建议使用正方形图片，效果更佳<br>
                            • 头像更换后将在群聊中立即显示<br>
                            • 角色也可以在聊天时自主更换头像
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-button modal-secondary" onclick="hideMemberAvatarModal()">取消</button>
                <button class="modal-button modal-primary" onclick="saveMemberAvatar()">保存更改</button>
            </div>
        </div>
    </div>

    <!-- 群公告编辑模态框 -->
    <div class="modal" id="group-notice-modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">编辑群公告</h3>
                <button class="modal-close" onclick="hideGroupNoticeModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="group-notice-form">
                    <div class="form-group">
                        <label class="form-label">群公告内容</label>
                        <textarea
                            id="group-notice-content"
                            class="form-textarea group-notice-textarea"
                            placeholder="输入群公告内容...&#10;&#10;可以包括：&#10;• 群规则说明&#10;• 重要通知&#10;• 活动安排&#10;• 其他事项"
                            maxlength="500"></textarea>
                        <div class="notice-char-count">
                            <span id="notice-char-current">0</span>/500字
                        </div>
                    </div>
                    <div class="notice-tips">
                        <div class="tips-header">
                            <i class="fas fa-lightbulb"></i>
                            <span>公告小贴士</span>
                        </div>
                        <div class="tips-content">
                            • 简洁明了，突出重点<br>
                            • 使用友好的语调<br>
                            • 定期更新重要信息<br>
                            • 可以使用emoji增加趣味性
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary" onclick="hideGroupNoticeModal()">取消</button>
                <button class="modal-primary" onclick="saveGroupNotice()">保存公告</button>
            </div>
        </div>
    </div>

    <!-- 定时发布时间设置模态框 -->
    <div class="modal" id="schedule-times-modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">定时发布时间设置</h3>
                <button class="modal-close" onclick="hideModal('schedule-times-modal')">&times;</button>
            </div>
            <div class="modal-body">
                <p style="color: #666; font-size: 14px; margin-bottom: 15px;">
                    设置角色每天自动发布动态的时间点（最多10个）
                </p>
                <div id="schedule-times-modal-container">
                    <!-- 时间输入项将动态生成 -->
                </div>
                <button onclick="addScheduleTime()" style="margin-top: 10px; padding: 8px 16px; background: #007AFF; color: white; border: none; border-radius: 6px; cursor: pointer;">
                    + 添加时间点
                </button>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary" onclick="hideModal('schedule-times-modal')">取消</button>
                <button class="modal-primary" onclick="saveScheduleTimes()">保存</button>
            </div>
        </div>
    </div>



    <!-- 游戏选择模态框 -->
    <div id="game-menu-modal" class="modal" style="display: none;">
        <div class="modal-content game-modal-content">
            <div class="modal-header game-modal-header">
                <div class="game-modal-title">
                    <i class="fas fa-gamepad"></i>
                    <span>选择游戏</span>
                </div>
                <button class="modal-close game-modal-close" onclick="hideGameMenu()">×</button>
            </div>
            <div class="modal-body game-modal-body">
                <div class="game-buttons-container" id="game-buttons-container">
                    <!-- 游戏按钮将通过JavaScript动态生成 -->
                </div>
            </div>
        </div>
    </div>

    <!-- 位置分享模态框 -->
    <div id="chat-location-modal" class="modal" style="display: none;">
        <div class="modal-content location-modal-content">
            <div class="modal-header">
                <h3 class="modal-title">分享位置</h3>
                <button class="modal-close" onclick="hideChatLocationModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="location-input-section">
                    <label for="location-address">位置名称</label>
                    <input type="text" id="location-address" placeholder="请输入位置名称，如：咖啡厅、学校、家..." maxlength="50">

                    <!-- 最近使用历史记录 -->
                    <div class="location-history" id="location-history">
                        <div class="location-history-title">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
                                <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                            </svg>
                            最近使用
                        </div>
                        <div class="location-history-items" id="location-history-items">
                            <div class="location-history-empty">暂无历史记录</div>
                        </div>
                    </div>
                </div>
                <div class="virtual-map-container">
                    <div class="map-header" style="background: linear-gradient(135deg, #f6ffed 0%, #d9f7be 100%);">
                        <div class="map-location-name" id="map-location-display" style="color: #52c41a;">请输入位置名称</div>
                        <div class="map-coordinates" style="color: #73d13d;">116.4074°E, 39.9042°N</div>
                    </div>
                    <div class="virtual-map">
                        <div class="map-background"></div>
                        <!-- 弯曲河流 -->
                        <div class="river" style="top: 8%; left: 55%; width: 25px; height: 4px; transform: rotate(30deg);"></div>
                        <div class="river-curve" style="top: 18%; left: 68%; width: 22px; height: 4px; transform: rotate(10deg);"></div>
                        <div class="river" style="top: 26%; left: 78%; width: 20px; height: 4px; transform: rotate(-10deg);"></div>
                        <div class="river-curve" style="top: 32%; left: 85%; width: 18px; height: 4px; transform: rotate(-30deg);"></div>
                        <div class="river" style="top: 60%; left: 5%; width: 28px; height: 4px; transform: rotate(-15deg);"></div>
                        <div class="river-curve" style="top: 68%; left: 25%; width: 25px; height: 4px; transform: rotate(5deg);"></div>
                        <div class="river" style="top: 75%; left: 42%; width: 22px; height: 4px; transform: rotate(20deg);"></div>
                        <!-- 公园绿地 -->
                        <div style="position: absolute; top: 25%; left: 65%; width: 25px; height: 20px; background: linear-gradient(135deg, #f6ffed 0%, #d9f7be 50%, #b7eb8f 100%); border-radius: 3px; opacity: 0.6; z-index: 1;"></div>
                        <div style="position: absolute; top: 50%; left: 15%; width: 30px; height: 25px; background: linear-gradient(135deg, #f6ffed 0%, #d9f7be 50%, #b7eb8f 100%); border-radius: 3px; opacity: 0.6; z-index: 1;"></div>
                        <!-- 道路 -->
                        <div class="map-roads">
                            <div class="road road-horizontal" style="top: 30%; left: 0; width: 100%;"></div>
                            <div class="road road-vertical" style="left: 25%; top: 0; height: 100%;"></div>
                            <div class="road road-horizontal" style="top: 70%; left: 0; width: 100%;"></div>
                            <div class="road road-vertical" style="left: 75%; top: 0; height: 100%;"></div>
                        </div>
                        <!-- 建筑物 -->
                        <div class="map-buildings">
                            <div class="building" style="top: 10%; left: 35%; width: 20px; height: 15px; background: linear-gradient(135deg, #f0f0f0 0%, #d9d9d9 100%); border: 1px solid #bfbfbf; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                            <div class="building" style="top: 15%; left: 55%; width: 25px; height: 20px; background: linear-gradient(135deg, #e6f7ff 0%, #bae7ff 100%); border: 1px solid #91d5ff; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                            <div class="building" style="top: 40%; left: 10%; width: 18px; height: 12px; background: linear-gradient(135deg, #fff1f0 0%, #ffd8d6 100%); border: 1px solid #ffaaa5; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                            <div class="building" style="top: 45%; left: 85%; width: 22px; height: 18px; background: linear-gradient(135deg, #f0f0f0 0%, #d9d9d9 100%); border: 1px solid #bfbfbf; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                            <div class="building" style="top: 75%; left: 40%; width: 30px; height: 20px; background: linear-gradient(135deg, #e6f7ff 0%, #bae7ff 100%); border: 1px solid #91d5ff; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                            <div class="building" style="top: 80%; left: 15%; width: 20px; height: 15px; background: linear-gradient(135deg, #fff1f0 0%, #ffd8d6 100%); border: 1px solid #ffaaa5; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                        </div>
                        <!-- 树木 -->
                        <div style="position: absolute; top: 35%; left: 20%; width: 8px; height: 8px; background: radial-gradient(circle, #52c41a 0%, #389e0d 70%, #237804 100%); border-radius: 50%; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15); z-index: 3;"></div>
                        <div style="position: absolute; top: 60%; left: 30%; width: 6px; height: 6px; background: radial-gradient(circle, #73d13d 0%, #52c41a 70%, #389e0d 100%); border-radius: 50%; box-shadow: 0 0.5px 1px rgba(0, 0, 0, 0.1); z-index: 3;"></div>
                        <div style="position: absolute; top: 12%; left: 70%; width: 7px; height: 7px; background: radial-gradient(circle, #52c41a 0%, #389e0d 70%, #237804 100%); border-radius: 50%; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15); z-index: 3;"></div>
                        <div style="position: absolute; top: 85%; left: 90%; width: 5px; height: 5px; background: radial-gradient(circle, #73d13d 0%, #52c41a 70%, #389e0d 100%); border-radius: 50%; box-shadow: 0 0.5px 1px rgba(0, 0, 0, 0.1); z-index: 3;"></div>
                        <div style="position: absolute; top: 50%; left: 90%; width: 6px; height: 6px; background: radial-gradient(circle, #73d13d 0%, #52c41a 70%, #389e0d 100%); border-radius: 50%; box-shadow: 0 0.5px 1px rgba(0, 0, 0, 0.1); z-index: 3;"></div>
                        <!-- 位置标记 -->
                        <div class="map-marker" id="location-marker">
                            <div class="marker-pin">
                                <svg width="28" height="28" viewBox="0 0 24 24" fill="none">
                                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                </svg>
                            </div>
                        </div>
                        <div class="map-current-location">
                            <div class="current-location-dot"></div>
                        </div>
                    </div>
                    <div class="map-footer">
                        <div class="map-scale">500m</div>
                        <div class="map-controls">
                            <button class="map-control-btn" onclick="randomizeMapPosition()">🎯 重新定位</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary" onclick="hideChatLocationModal()">取消</button>
                <button class="modal-primary" onclick="sendLocationMessage()">发送位置</button>
            </div>
        </div>
    </div>
    </div>

    <script>
        // 🔥【新增】群成员头像上传事件监听
        document.addEventListener('DOMContentLoaded', function() {
            const memberAvatarUpload = document.getElementById('member-avatar-upload');
            if (memberAvatarUpload) {
                memberAvatarUpload.addEventListener('change', function(e) {
                    if (e.target.files && e.target.files[0]) {
                        const file = e.target.files[0];
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            const preview = document.getElementById('member-avatar-preview');
                            if (preview) {
                                preview.src = event.target.result;
                            }
                        };
                        reader.readAsDataURL(file);
                    }
                });
            }
        });
    </script>

    <!-- 🔥【永久修复】身份选择功能自动修复脚本 -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🔧 开始应用身份选择功能永久修复...');

            // 修复1: 重写showPersonaSelectionForSingleChat函数
            if (typeof showPersonaSelectionForSingleChat === 'function') {
                const originalShowPersonaSelectionForSingleChat = showPersonaSelectionForSingleChat;
                showPersonaSelectionForSingleChat = function() {
                    originalShowPersonaSelectionForSingleChat();

                    // 延迟修复事件绑定，确保DOM已生成
                    setTimeout(() => {
                        const items = document.querySelectorAll('#persona-selection-modal .persona-selection-item');
                        console.log('🔧 修复身份选择事件绑定，找到元素:', items.length);

                        items.forEach(item => {
                            // 移除旧的事件监听器
                            item.onclick = null;

                            // 添加新的点击事件
                            item.addEventListener('click', function() {
                                console.log('身份选择点击:', this.dataset.personaId);

                                // 移除所有选中状态
                                document.querySelectorAll('#persona-selection-modal .persona-selection-item').forEach(i => {
                                    i.classList.remove('selected');
                                });

                                // 设置当前元素为选中
                                this.classList.add('selected');

                                // 保存身份ID
                                window.selectedPersonaForChat = this.dataset.personaId;
                                console.log('设置selectedPersonaForChat:', window.selectedPersonaForChat);

                                // 启用确认按钮
                                const confirmBtn = document.getElementById('confirm-persona-btn');
                                if (confirmBtn) {
                                    confirmBtn.disabled = false;
                                }
                            });
                        });
                    }, 100);
                };
            }

            // 修复2: 重写confirmPersonaAndShowCharacters函数
            if (typeof confirmPersonaAndShowCharacters === 'function') {
                confirmPersonaAndShowCharacters = function() {
                    console.log('confirmPersonaAndShowCharacters调用，身份ID:', window.selectedPersonaForChat);

                    if (!window.selectedPersonaForChat) {
                        console.error('身份ID为空！');
                        return;
                    }

                    // 保存身份ID
                    const savedPersonaId = window.selectedPersonaForChat;

                    // 隐藏模态框
                    const modal = document.getElementById('persona-selection-modal');
                    if (modal) {
                        modal.remove();
                    }

                    // 恢复身份ID
                    window.selectedPersonaForChat = savedPersonaId;
                    console.log('保护后的身份ID:', window.selectedPersonaForChat);

                    showCharacterSelectionForSingleChat();
                };
            }

            // 修复3: 重写buildCharacterPrompt函数
            if (typeof buildCharacterPrompt === 'function') {
                const originalBuildCharacterPrompt = buildCharacterPrompt;
                buildCharacterPrompt = async function(character, hasImage = false) {
                    // 调用原函数获取基础prompt
                    let characterPrompt = await originalBuildCharacterPrompt(character, hasImage);

                    // 移除原有的currentPersona逻辑，替换为从聊天设置读取
                    const chatSettings = getCurrentChatSettings();
                    if (chatSettings.selectedIdentityId) {
                        const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                        if (selectedPersona) {
                            console.log('🔧 为角色', character.name, '使用身份:', selectedPersona.name);

                            // 移除旧的身份信息（如果有）
                            const personaRegex = /\n\n# 对话者的角色设定：[\s\S]*?请根据用户的这个面具身份来进行对话。/;
                            characterPrompt = characterPrompt.replace(personaRegex, '');

                            // 添加新的身份信息
                            const personaInfo = `\n\n# 对话者的角色设定：\n用户当前使用的面具是"${selectedPersona.name}"${selectedPersona.description ? `：${selectedPersona.description}` : ''}\n请根据用户的这个面具身份来进行对话。`;

                            // 在角色设定后插入身份信息
                            const insertPoint = characterPrompt.indexOf('\n# 🔥【修复】表情包库信息');
                            if (insertPoint !== -1) {
                                characterPrompt = characterPrompt.slice(0, insertPoint) + personaInfo + characterPrompt.slice(insertPoint);
                            } else {
                                characterPrompt += personaInfo;
                            }
                        }
                    }

                    return characterPrompt;
                };
            }

            console.log('✅ 身份选择功能永久修复已应用');
        });
    </script>

    <!-- 🔧【简单修复】群聊身份设置直接修复 -->
    <script>
        // 简单直接的群聊身份修复
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🔧 [简单修复] 群聊身份设置修复启动...');

            // 重写createGroupChat函数，确保身份设置立即生效
            if (typeof window.createGroupChat === 'function') {
                const originalCreateGroupChat = window.createGroupChat;
                window.createGroupChat = async function(personaId) {
                    console.log('🔧 [修复] createGroupChat被调用，身份ID:', personaId);

                    // 调用原函数，传递personaId参数
                    await originalCreateGroupChat.call(this, personaId);

                    // 如果有选择身份，立即加载到内存
                    if (personaId && groupChats && groupChats.length > 0) {
                        const latestGroup = groupChats[groupChats.length - 1];
                        const savedSettings = localStorage.getItem(`chatSettings_${latestGroup.id}`);

                        if (savedSettings) {
                            try {
                                const settings = JSON.parse(savedSettings);
                                window.chatSettings[latestGroup.id] = settings;
                                console.log('🔧 [修复] 群聊身份设置已加载到内存:', settings);
                            } catch (error) {
                                console.error('🔧 [修复] 解析群聊设置失败:', error);
                            }
                        }
                    }
                };
            }

            console.log('🔧 [简单修复] 群聊身份设置修复完成');
        });
    </script>

    <!-- 📱【移动端优化】输入框viewport行为修复 -->
    <script>
        // 移动端输入框优化
        (function() {
            'use strict';

            console.log('📱 [移动端优化] 输入框viewport行为修复启动...');

            let isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            let isAndroid = /Android/.test(navigator.userAgent);
            let isMobile = isIOS || isAndroid;

            if (!isMobile) {
                console.log('📱 非移动端设备，跳过移动端优化');
                return;
            }

            // 获取所有可能的输入框
            function getAllInputs() {
                return document.querySelectorAll('textarea, input[type="text"], input[type="password"], input[type="email"], input[type="number"]');
            }

            // 防止iOS Safari自动缩放
            function preventZoom() {
                const viewportMeta = document.querySelector('meta[name="viewport"]');
                if (viewportMeta) {
                    viewportMeta.setAttribute('content',
                        'width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no'
                    );
                }
            }

            // 恢复缩放功能
            function restoreZoom() {
                const viewportMeta = document.querySelector('meta[name="viewport"]');
                if (viewportMeta) {
                    viewportMeta.setAttribute('content',
                        'width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=3.0, user-scalable=yes'
                    );
                }
            }

            // 输入框焦点处理
            function handleInputFocus(e) {
                console.log('📱 输入框获得焦点，防止自动缩放');

                // 防止iOS自动缩放
                if (isIOS) {
                    preventZoom();
                }

                // 确保输入框可见
                setTimeout(() => {
                    e.target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center'
                    });
                }, 300);
            }

            // 输入框失焦处理
            function handleInputBlur(e) {
                console.log('📱 输入框失去焦点，恢复缩放功能');

                // 恢复缩放功能
                if (isIOS) {
                    setTimeout(() => {
                        restoreZoom();
                    }, 100);
                }

                // 🔥【关键修复】强制重新计算布局，防止页面偏移
                setTimeout(() => {
                    // 重置滚动位置
                    window.scrollTo(0, 0);
                    document.body.scrollTop = 0;
                    document.documentElement.scrollTop = 0;

                    // 强制重新计算虚拟手机的位置
                    const phoneScreen = document.getElementById('phone-screen');
                    if (phoneScreen) {
                        // 临时改变一个样式属性来触发重新渲染
                        phoneScreen.style.transform = 'translateZ(0)';
                        setTimeout(() => {
                            phoneScreen.style.transform = '';
                        }, 10);
                    }

                    // 确保body居中对齐
                    document.body.style.display = 'flex';
                    document.body.style.justifyContent = 'center';
                    document.body.style.alignItems = 'center';
                }, 300);
            }

            // 绑定事件到所有输入框
            function bindInputEvents() {
                const inputs = getAllInputs();
                console.log(`📱 找到 ${inputs.length} 个输入框，正在绑定事件...`);

                inputs.forEach(input => {
                    // 移除旧的事件监听器（如果存在）
                    input.removeEventListener('focus', handleInputFocus);
                    input.removeEventListener('blur', handleInputBlur);

                    // 添加新的事件监听器
                    input.addEventListener('focus', handleInputFocus, { passive: true });
                    input.addEventListener('blur', handleInputBlur, { passive: true });

                    // 确保输入框字体大小至少16px（防止iOS缩放）
                    const computedStyle = window.getComputedStyle(input);
                    const fontSize = parseInt(computedStyle.fontSize);
                    if (fontSize < 16) {
                        input.style.fontSize = '16px';
                        console.log('📱 调整输入框字体大小为16px，防止iOS缩放');
                    }
                });
            }

            // 监听DOM变化，处理动态添加的输入框
            const observer = new MutationObserver(function(mutations) {
                let shouldRebind = false;
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList') {
                        mutation.addedNodes.forEach(function(node) {
                            if (node.nodeType === 1) { // Element node
                                if (node.matches && (node.matches('textarea') || node.matches('input'))) {
                                    shouldRebind = true;
                                } else if (node.querySelector) {
                                    const inputs = node.querySelectorAll('textarea, input');
                                    if (inputs.length > 0) {
                                        shouldRebind = true;
                                    }
                                }
                            }
                        });
                    }
                });

                if (shouldRebind) {
                    console.log('📱 检测到新的输入框，重新绑定事件...');
                    setTimeout(bindInputEvents, 100);
                }
            });

            // 开始监听DOM变化
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });

            // 页面加载完成后绑定事件
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', bindInputEvents);
            } else {
                bindInputEvents();
            }

            // 页面显示时重新绑定（处理从后台返回的情况）
            document.addEventListener('visibilitychange', function() {
                if (!document.hidden) {
                    setTimeout(bindInputEvents, 100);
                }
            });

            // 🔥【新增】监听viewport变化，修复虚拟键盘收起后的布局问题
            let initialViewportHeight = window.innerHeight;
            let isKeyboardOpen = false;

            function handleViewportChange() {
                const currentHeight = window.innerHeight;
                const heightDiff = initialViewportHeight - currentHeight;

                // 判断虚拟键盘是否打开（高度减少超过150px认为是键盘打开）
                const keyboardWasOpen = isKeyboardOpen;
                isKeyboardOpen = heightDiff > 150;

                console.log(`📱 Viewport变化: ${currentHeight}px (初始: ${initialViewportHeight}px, 差值: ${heightDiff}px, 键盘状态: ${isKeyboardOpen})`);

                // 如果键盘从打开变为关闭，强制修复布局
                if (keyboardWasOpen && !isKeyboardOpen) {
                    console.log('📱 检测到虚拟键盘关闭，修复布局...');
                    setTimeout(() => {
                        // 重置所有滚动位置
                        window.scrollTo(0, 0);
                        document.body.scrollTop = 0;
                        document.documentElement.scrollTop = 0;

                        // 强制重新渲染虚拟手机
                        const phoneScreen = document.getElementById('phone-screen');
                        if (phoneScreen) {
                            phoneScreen.style.transform = 'translateZ(0)';
                            requestAnimationFrame(() => {
                                phoneScreen.style.transform = '';
                            });
                        }

                        // 确保body布局正确
                        document.body.style.height = '100%';
                        document.body.style.display = 'flex';
                        document.body.style.justifyContent = 'center';
                        document.body.style.alignItems = 'center';
                    }, 100);
                }
            }

            // 监听viewport变化
            window.addEventListener('resize', handleViewportChange, { passive: true });
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    initialViewportHeight = window.innerHeight;
                    handleViewportChange();
                }, 500);
            }, { passive: true });

            console.log('📱 [移动端优化] 输入框viewport行为修复已启动');
        })();
    </script>

    <!-- 💰【转账功能优化】让AI根据人设自然回应 -->
    <script>
        // 转账功能优化 - 移除自动收款，让AI根据人设自然回应
        (function() {
            'use strict';

            console.log('💰 [转账优化] 移除自动收款逻辑，让AI根据人设自然回应...');

            // 🔥【重要修改】移除自动收款逻辑，让AI根据角色人设自然决定
            // 转账状态变化应该由AI的自然回复触发，而不是自动处理
            // AI会根据自己的人设（比如高冷、温柔、傲娇等）来决定是否收款

            console.log('💰 [转账优化] AI将根据角色人设自然回应转账，不再自动收款');
        })();
    </script>

    <!-- 🚫【拉黑系统】模态框 -->
    <div id="blacklist-settings-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">拉黑管理</h3>
                <button class="modal-close" onclick="hideBlacklistSettings()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="settings-section">
                    <div class="section-header">
                        <i class="fas fa-user-slash section-icon"></i>
                        <span class="section-title">当前状态</span>
                    </div>
                    <div class="setting-card">
                        <div class="setting-item" id="current-blacklist-status">
                            <div class="setting-left">
                                <div class="setting-label">拉黑状态</div>
                                <div class="setting-desc" id="blacklist-status-desc">正常聊天中</div>
                            </div>
                        </div>
                    </div>
                </div>



                <div class="settings-section">
                    <div class="section-header">
                        <i class="fas fa-exclamation-triangle section-icon danger-section-icon"></i>
                        <span class="section-title danger-section-title">操作</span>
                    </div>
                    <div class="setting-card">
                        <div class="setting-item" id="block-action-item" onclick="performBlockAction()">
                            <div class="setting-left">
                                <div class="setting-label" id="block-action-label">拉黑此角色</div>
                                <div class="setting-desc" id="block-action-desc">阻止该角色向你发送消息</div>
                            </div>
                            <div class="setting-right">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary" onclick="hideBlacklistSettings()">关闭</button>
            </div>
        </div>
    </div>

    <!-- 🚫【好友申请】模态框 -->
    <div id="friend-request-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">好友申请</h3>
                <button class="modal-close" onclick="hideFriendRequestModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">申请理由（可选）</label>
                    <textarea id="friend-request-message" class="form-textarea" placeholder="请输入申请理由..." maxlength="200"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary" onclick="hideFriendRequestModal()">取消</button>
                <button class="modal-primary" onclick="sendFriendRequestConfirm()">发送申请</button>
            </div>
        </div>
    </div>

    <!-- 🔥【新增】心声模态框 -->
    <div id="inner-thoughts-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">
                    💭心声
                </h3>
                <button class="modal-close" onclick="hideInnerThoughtsModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div id="inner-thoughts-content" class="inner-thoughts-content">
                    <div class="inner-thoughts-loading">
                        <div class="loading-spinner"></div>
                        <p>正在读取角色的内心想法...</p>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary inner-thoughts-refresh-btn" onclick="refreshInnerThoughts(selectedMessageId)">
                    <i class="fas fa-sync-alt"></i> 重新生成
                </button>
                <button class="modal-secondary" onclick="hideInnerThoughtsModal()">关闭</button>
            </div>
        </div>
    </div>

    <!-- 🚫【拉黑系统】JavaScript核心功能 -->
    <script>
        // 拉黑系统全局变量 - 检查是否已存在，避免重复声明
        if (typeof blacklistData === 'undefined') {
            var blacklistData = [];
            var friendRequestsData = [];
            var characterStatusData = [];
        }

        // 加载拉黑系统数据
        async function loadBlacklistData() {
            try {
                blacklistData = await db.blacklist.orderBy('timestamp').reverse().toArray();
                console.log('拉黑数据加载完成:', blacklistData);
            } catch (error) {
                console.error('加载拉黑数据失败:', error);
                blacklistData = [];
            }
        }

        // 检查是否被拉黑
        function isBlocked(blockerId, blockedId) {
            return blacklistData.some(record =>
                record.blockerId === blockerId &&
                record.blockedId === blockedId &&
                !record.unblocked
            );
        }



        // 拉黑角色
        async function blockCharacter(characterId, reason = '') {
            try {
                const now = new Date();

                if (isBlocked('user', characterId)) {
                    showToast('该角色已被拉黑', 'warning');
                    return;
                }

                const blockRecord = {
                    id: `block_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    blockerId: 'user',
                    blockedId: characterId,
                    timestamp: now.toISOString(),
                    reason: reason,
                    unblocked: false
                };

                blacklistData.unshift(blockRecord);
                await db.blacklist.add(blockRecord);

                const character = characters.find(c => c.id === characterId);
                showToast(`已拉黑 ${character?.name || '角色'}`, 'success');

                // 🔥【新增】通知角色被拉黑了
                await notifyCharacterBlocked(characterId, reason);

                // 立即更新聊天界面显示
                if (currentChatCharacter && currentChatCharacter.id === characterId) {
                    updateChatBlockedStatus();
                }

                renderContactList();
                renderMessageList();

            } catch (error) {
                console.error('拉黑角色失败:', error);
                showToast('拉黑失败', 'error');
            }
        }

        // 解除拉黑
        async function unblockCharacter(characterId) {
            try {
                const blockRecord = blacklistData.find(r =>
                    r.blockerId === 'user' &&
                    r.blockedId === characterId &&
                    !r.unblocked
                );

                if (!blockRecord) {
                    showToast('该角色未被拉黑', 'warning');
                    return;
                }

                blockRecord.unblocked = true;
                blockRecord.unblockTimestamp = new Date().toISOString();

                await db.blacklist.put(blockRecord);

                const character = characters.find(c => c.id === characterId);
                showToast(`已解除对 ${character?.name || '角色'} 的拉黑`, 'success');

                // 🔥【新增】通知角色被解除拉黑了
                await notifyCharacterUnblocked(characterId);

                // 刷新聊天界面显示
                if (currentChatCharacter && currentChatCharacter.id === characterId) {
                    renderChatMessages(currentChatCharacter.id);
                    updateChatBlockedStatus();
                }

                renderContactList();
                renderMessageList();

            } catch (error) {
                console.error('解除拉黑失败:', error);
                showToast('解除拉黑失败', 'error');
            }
        }

        // 更新角色状态
        async function updateCharacterStatus(characterId, status, activity = '', location = '') {
            try {
                let statusRecord = characterStatusData.find(s => s.characterId === characterId);

                if (!statusRecord) {
                    statusRecord = {
                        id: `status_${characterId}`,
                        characterId: characterId,
                        status: status,
                        activity: activity,
                        location: location,
                        lastUpdate: new Date().toISOString(),
                        lastChatTime: null // 🔥【新增】保留最后聊天时间字段
                    };
                    characterStatusData.push(statusRecord);
                } else {
                    // 🔥【修复】保留现有的lastChatTime字段
                    const existingLastChatTime = statusRecord.lastChatTime;
                    statusRecord.status = status;
                    statusRecord.activity = activity;
                    statusRecord.location = location;
                    statusRecord.lastUpdate = new Date().toISOString();
                    statusRecord.lastChatTime = existingLastChatTime; // 保留原有的聊天时间
                }

                await db.characterStatus.put(statusRecord);

            } catch (error) {
                console.error('更新角色状态失败:', error);
            }
        }

        // 获取角色状态
        function getCharacterStatus(characterId) {
            return characterStatusData.find(s => s.characterId === characterId) || {
                status: 'online',
                activity: '在线',
                location: '',
                lastUpdate: new Date().toISOString(),
                lastChatTime: null // 🔥【新增】最后聊天时间
            };
        }

        // 角色拉黑用户
        async function aiBlockUser(characterId, reason = '') {
            try {
                const now = new Date();

                // 检查是否已经拉黑
                if (isBlocked(characterId, 'user')) {
                    return;
                }

                const blockRecord = {
                    id: `block_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    blockerId: characterId,
                    blockedId: 'user',
                    timestamp: now.toISOString(),
                    reason: reason,
                    unblocked: false
                };

                blacklistData.unshift(blockRecord);
                await db.blacklist.add(blockRecord);

                // 更新聊天界面显示
                if (currentChatCharacter && currentChatCharacter.id === characterId) {
                    updateChatBlockedStatus();
                }

                const character = characters.find(c => c.id === characterId);
                showToast(`${character?.name || '角色'} 已将你拉黑`, 'warning');

            } catch (error) {
                console.error('角色拉黑用户失败:', error);
            }
        }

        // 发送好友申请
        async function sendFriendRequest(characterId, message = '') {
            try {
                const request = {
                    id: `request_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    fromId: 'user',
                    toId: characterId,
                    timestamp: new Date().toISOString(),
                    status: 'pending',
                    type: 'friend',
                    message: message
                };

                friendRequestsData.unshift(request);
                await db.friendRequests.add(request);

                showToast('好友申请已发送', 'success');

            } catch (error) {
                console.error('发送好友申请失败:', error);
                showToast('发送申请失败', 'error');
            }
        }

        // 🔥【修改】更新聊天界面的拉黑状态显示 - 群聊不显示拉黑提示
        function updateChatBlockedStatus() {
            if (!currentChatCharacter) return;

            const characterId = currentChatCharacter.id;
            const isGroupChat = currentChatCharacter.isGroup;

            // 移除现有的拉黑提示
            const existingBlockedUI = document.querySelector('.blocked-input-notice');
            if (existingBlockedUI) {
                existingBlockedUI.remove();
            }

            // 移除现有的角色被拉黑提示
            const existingCharacterHint = document.querySelector('.character-blocked-hint');
            if (existingCharacterHint) {
                existingCharacterHint.remove();
            }

            // 🔥【修改】群聊不显示拉黑相关提示，只有单聊才处理拉黑状态
            if (!isGroupChat) {
                const isUserBlocked = isBlocked('user', characterId);
                const isCharacterBlocked = isBlocked(characterId, 'user');

                // 当用户被角色拉黑时，在输入框上方显示提示
                if (isCharacterBlocked) {
                    const inputArea = document.querySelector('.chat-input-area');
                    if (inputArea) {
                        const blockedNotice = document.createElement('div');
                        blockedNotice.className = 'blocked-input-notice show';

                        blockedNotice.innerHTML = `
                            <div class="notice-text">你被 ${currentChatCharacter.name} 拉黑了</div>
                            <button class="notice-button" onclick="showFriendRequestModal()">申请添加为好友</button>
                        `;

                        inputArea.appendChild(blockedNotice);
                    }

                    // 🔥【新增】在聊天区域显示角色申请好友的提示
                    addCharacterBlockedHint(characterId);
                }

                // 重新渲染消息列表以显示拉黑状态指示器
                renderChatMessages(characterId);
            }
        }

        // 🔥【新增】在聊天界面显示角色被拉黑的提示
        function addCharacterBlockedHint(characterId) {
            const messagesContainer = document.getElementById('chat-messages');
            if (!messagesContainer) return;

            // 移除现有的提示
            const existingHint = messagesContainer.querySelector('.character-blocked-hint');
            if (existingHint) {
                existingHint.remove();
            }

            // 创建提示消息
            const hintContainer = document.createElement('div');
            hintContainer.className = 'character-blocked-hint';
            hintContainer.style.cssText = `
                text-align: center;
                margin: 20px auto;
                padding: 15px 20px;
                background: rgba(255, 193, 7, 0.1);
                border: 1px solid rgba(255, 193, 7, 0.3);
                border-radius: 12px;
                max-width: 320px;
                color: #856404;
                font-size: 13px;
                line-height: 1.4;
            `;

            hintContainer.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 8px;">💡 提示</div>
                <div>${currentChatCharacter.name} 被拉黑了，但仍可以发送消息。如果想修复关系，可以发送好友申请。</div>
                <div style="margin-top: 8px; font-size: 12px; color: #6c757d;">
                    好友申请格式：{"type": "friend_request", "message": "道歉或请求信息"}
                </div>
            `;

            // 将提示添加到消息容器的顶部
            messagesContainer.insertBefore(hintContainer, messagesContainer.firstChild);
        }

        // 🔥【修复】检查拉黑状态并创建系统消息（只在发送消息时调用一次）
        function checkAndCreateBlockedSystemMessage(userMessage, characterId) {
            if (!currentChatCharacter || currentChatCharacter.isGroup) return; // 群聊不处理拉黑

            // 检查角色是否拉黑了用户
            const isCharacterBlocked = isBlocked(characterId, 'user');

            if (isCharacterBlocked) {
                // 🔥【修复】不保存到聊天记录，只在界面上临时显示系统提示
                // 创建临时的系统提示元素
                const messagesContainer = document.getElementById('api-chat-messages');
                const systemHint = document.createElement('div');
                systemHint.className = 'blocked-message-hint';
                systemHint.style.cssText = `
                    text-align: center;
                    color: #999;
                    font-size: 12px;
                    padding: 4px 8px;
                    margin: 2px 0;
                    background: transparent;
                    border: none;
                    display: block;
                    max-width: 80%;
                    width: fit-content;
                    margin-left: auto;
                    margin-right: auto;
                `;
                systemHint.textContent = '消息已发出，但被对方拒收了';

                // 添加到界面
                messagesContainer.appendChild(systemHint);

                // 滚动到底部
                setTimeout(() => {
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                }, 100);
            }
        }

        // 🔥【新增】清理已保存的拉黑系统消息
        function cleanupBlockedSystemMessages() {
            let hasChanges = false;

            // 遍历所有聊天记录
            Object.keys(chatMessages).forEach(characterId => {
                const messages = chatMessages[characterId];
                const originalLength = messages.length;

                // 过滤掉拉黑系统消息
                chatMessages[characterId] = messages.filter(msg =>
                    !(msg.sender === 'system' && msg.isBlockedMessage)
                );

                if (chatMessages[characterId].length !== originalLength) {
                    hasChanges = true;
                    console.log(`🧹 [清理] 从角色 ${characterId} 的聊天记录中移除了 ${originalLength - chatMessages[characterId].length} 条拉黑系统消息`);
                }
            });

            // 如果有变化，保存到数据库
            if (hasChanges) {
                saveChatMessages();
                console.log('🧹 [清理] 拉黑系统消息清理完成，已保存到数据库');
            }
        }

        // 🔥【修复】为消息添加拉黑状态指示器 - 显示红色感叹号和系统提示
        function addBlockedIndicatorToMessage(messageContainer, message, characterId) {
            if (!currentChatCharacter) return;

            // 🔥【新增】跳过好友申请消息，不显示拉黑指示器
            if (message.type === 'friend_request') {
                return; // 好友申请是修复关系的行为，不应该显示拉黑标志
            }

            // 检查消息是否在拉黑状态下发送
            const messageTimestamp = message.timestamp;
            let shouldShowIndicator = false;
            let blockTimestamp = null;

            // 🔥【修复】查找相关的拉黑记录 - 即使解除拉黑后也要显示历史消息的指示器
            if (message.sender === 'sent') {
                // 用户发送的消息，检查角色是否曾经拉黑了用户
                const blockRecord = blacklistData.find(r =>
                    r.blockerId === characterId &&
                    r.blockedId === 'user'
                    // 🔥【移除】不再检查 !r.unblocked，让历史消息保留指示器
                );
                if (blockRecord) {
                    blockTimestamp = new Date(blockRecord.timestamp).getTime();
                    // 🔥【修复】如果消息是在拉黑期间发送的，就显示指示器
                    const unblockTimestamp = blockRecord.unblocked && blockRecord.unblockTimestamp
                        ? new Date(blockRecord.unblockTimestamp).getTime()
                        : Date.now();
                    shouldShowIndicator = messageTimestamp >= blockTimestamp &&
                                        (messageTimestamp <= unblockTimestamp || !blockRecord.unblocked);
                }
            } else if (message.sender === 'received') {
                // 角色发送的消息，检查用户是否曾经拉黑了角色
                const blockRecord = blacklistData.find(r =>
                    r.blockerId === 'user' &&
                    r.blockedId === characterId
                    // 🔥【移除】不再检查 !r.unblocked，让历史消息保留指示器
                );
                if (blockRecord) {
                    blockTimestamp = new Date(blockRecord.timestamp).getTime();
                    // 🔥【修复】如果消息是在拉黑期间发送的，就显示指示器
                    const unblockTimestamp = blockRecord.unblocked && blockRecord.unblockTimestamp
                        ? new Date(blockRecord.unblockTimestamp).getTime()
                        : Date.now();
                    shouldShowIndicator = messageTimestamp >= blockTimestamp &&
                                        (messageTimestamp <= unblockTimestamp || !blockRecord.unblocked);
                }
            }

            if (shouldShowIndicator) {
                // 🔥【修复】检查是否已经有指示器，避免重复添加
                const existingIndicator = messageContainer.querySelector('.message-blocked-indicator');
                const existingHint = messageContainer.nextElementSibling?.classList.contains('blocked-message-hint-inline');

                if (existingIndicator && existingHint) {
                    return; // 已经有指示器和提示了，不重复添加
                }

                // 创建拉黑指示器（红色感叹号）
                if (!existingIndicator) {
                    const indicator = document.createElement('div');
                    indicator.className = 'message-blocked-indicator';
                    indicator.innerHTML = '!';
                    indicator.title = '消息已发出，但被对方拒收了';

                    // 添加指示器到消息容器
                    messageContainer.style.position = 'relative';
                    messageContainer.appendChild(indicator);

                    // 🔥【新增】动态定位感叹号到气泡外侧
                    setTimeout(() => {
                        const bubble = messageContainer.querySelector('.message-bubble');
                        if (bubble) {
                            // 获取气泡相对于消息容器的位置
                            const containerRect = messageContainer.getBoundingClientRect();
                            const bubbleRect = bubble.getBoundingClientRect();

                            if (message.sender === 'sent') {
                                // 用户消息：感叹号在气泡左边
                                const bubbleLeftOffset = bubbleRect.left - containerRect.left;
                                indicator.style.left = (bubbleLeftOffset - 20) + 'px'; // 16px感叹号宽度 + 4px间距
                                indicator.style.right = 'auto';
                            } else if (message.sender === 'received') {
                                // 🔥【修复】角色消息：感叹号在气泡右下角外侧3px处
                                const bubbleRightOffset = bubbleRect.right - containerRect.left;
                                indicator.style.left = (bubbleRightOffset + 3) + 'px'; // 气泡右边 + 3px间距
                                indicator.style.right = 'auto';
                            }
                        }
                    }, 10);
                }

                // 🔥【新增】在消息下方添加系统提示
                if (!existingHint) {
                    const systemHint = document.createElement('div');
                    systemHint.className = 'blocked-message-hint-inline';
                    systemHint.style.cssText = `
                        text-align: center;
                        color: #999;
                        font-size: 12px;
                        padding: 2px 8px;
                        margin: 2px 0 8px 0;
                        background: transparent;
                        border: none;
                        display: block;
                        max-width: 80%;
                        width: fit-content;
                        margin-left: auto;
                        margin-right: auto;
                    `;
                    systemHint.textContent = '消息已发出，但被对方拒收了';

                    // 在消息容器后面插入系统提示
                    messageContainer.parentNode.insertBefore(systemHint, messageContainer.nextSibling);
                }
            }
        }

        // 🔥【修改】显示拉黑/屏蔽设置 - 区分单聊和群聊
        function showBlacklistSettings() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'warning');
                return;
            }

            const characterId = currentChatCharacter.id;
            const isGroupChat = currentChatCharacter.isGroup;

            if (isGroupChat) {
                // 🔥【新增】群聊只能屏蔽，且只有用户可以屏蔽群聊
                showGroupMuteSettings(characterId);
            } else {
                // 单聊使用原有的拉黑逻辑
                const isUserBlocked = isBlocked('user', characterId);

                const statusDesc = document.getElementById('blacklist-status-desc');
                const actionLabel = document.getElementById('block-action-label');
                const actionDesc = document.getElementById('block-action-desc');

                if (isUserBlocked) {
                    statusDesc.textContent = '你已拉黑此角色';
                    actionLabel.textContent = '解除拉黑';
                    actionDesc.textContent = '恢复与该角色的正常聊天';
                } else {
                    statusDesc.textContent = '正常聊天中';
                    actionLabel.textContent = '拉黑此角色';
                    actionDesc.textContent = '阻止该角色向你发送消息';
                }

                document.getElementById('blacklist-settings-modal').style.display = 'flex';
            }
        }

        // 🔥【新增】更新设置界面的拉黑/屏蔽管理文案
        function updateBlockManageLabel(isGroupChat) {
            const labelElement = document.getElementById('block-manage-label');
            const descElement = document.getElementById('block-manage-desc');

            if (labelElement && descElement) {
                if (isGroupChat) {
                    labelElement.textContent = '屏蔽管理';
                    descElement.textContent = '屏蔽/取消屏蔽群聊消息通知';
                } else {
                    labelElement.textContent = '拉黑管理';
                    descElement.textContent = '拉黑/解除拉黑管理';
                }
            }
        }

        // 🔥【新增】显示群聊屏蔽设置
        function showGroupMuteSettings(groupId) {
            // 检查是否已屏蔽该群聊
            const isMuted = isGroupMuted(groupId);

            const statusDesc = document.getElementById('blacklist-status-desc');
            const actionLabel = document.getElementById('block-action-label');
            const actionDesc = document.getElementById('block-action-desc');

            // 修改界面文案为屏蔽相关
            if (isMuted) {
                statusDesc.textContent = '你已屏蔽此群聊';
                actionLabel.textContent = '取消屏蔽';
                actionDesc.textContent = '重新接收该群聊的消息通知';
            } else {
                statusDesc.textContent = '正常接收群聊消息';
                actionLabel.textContent = '屏蔽此群聊';
                actionDesc.textContent = '不再接收该群聊的消息通知';
            }

            document.getElementById('blacklist-settings-modal').style.display = 'flex';
        }

        // 🔥【新增】检查群聊是否被屏蔽
        function isGroupMuted(groupId) {
            const mutedGroups = JSON.parse(localStorage.getItem('mutedGroups') || '[]');
            return mutedGroups.includes(groupId);
        }

        // 🔥【新增】屏蔽/取消屏蔽群聊
        function toggleGroupMute(groupId) {
            const mutedGroups = JSON.parse(localStorage.getItem('mutedGroups') || '[]');
            const isMuted = mutedGroups.includes(groupId);

            if (isMuted) {
                // 取消屏蔽
                const index = mutedGroups.indexOf(groupId);
                if (index > -1) {
                    mutedGroups.splice(index, 1);
                }
                showToast(`已取消屏蔽 ${currentChatCharacter?.name}`, 'success');
            } else {
                // 屏蔽群聊
                mutedGroups.push(groupId);
                showToast(`已屏蔽 ${currentChatCharacter?.name}`, 'info');
            }

            localStorage.setItem('mutedGroups', JSON.stringify(mutedGroups));

            // 更新界面
            renderContactList();
            hideBlacklistSettings();
        }

        // 隐藏拉黑设置
        function hideBlacklistSettings() {
            document.getElementById('blacklist-settings-modal').style.display = 'none';
        }

        // 显示好友申请模态框
        function showFriendRequestModal() {
            if (!currentChatCharacter) return;

            document.getElementById('friend-request-message').value = '';
            document.getElementById('friend-request-modal').style.display = 'flex';
        }

        // 隐藏好友申请模态框
        function hideFriendRequestModal() {
            document.getElementById('friend-request-modal').style.display = 'none';
        }

        // 发送好友申请确认
        async function sendFriendRequestConfirm() {
    if (!currentChatCharacter) return;

    const message = document.getElementById('friend-request-message').value.trim();
    const characterId = currentChatCharacter.id;

    // 1. 先在数据库中记录这个申请事件
    await sendFriendRequest(characterId, message);
    hideFriendRequestModal();

    // 2. 🔥【核心新增】立刻调用API，让AI处理这个好友申请
    showToast('申请已发送，等待对方回应...', 'info');
    await processAIFriendRequestResponse(characterId, message);
}

        // 🔥【新增】轻量级防崩坏检查 - 只防止短时间内的重复申请
        function isRecentFriendRequestSpam(characterId) {
            if (!characterId || !chatMessages[characterId]) {
                return false;
            }

            const messages = chatMessages[characterId];
            const now = Date.now();
            const recentThreshold = 5 * 60 * 1000; // 5分钟内

            // 检查最近5分钟内是否有未处理的好友申请
            for (let i = messages.length - 1; i >= 0; i--) {
                const message = messages[i];
                if (message.type === 'friend_request' && message.sender === 'received') {
                    const timeDiff = now - message.timestamp;

                    // 如果5分钟内有未处理的申请，认为是spam
                    if (timeDiff < recentThreshold && !message.friendRequestProcessed) {
                        console.log('🚫 [防崩坏] 检测到5分钟内的重复好友申请，跳过');
                        return true;
                    }

                    // 只检查最近的申请，不需要遍历所有历史
                    break;
                }
            }

            return false;
        }

        // 🔥【新增】处理AI主动发送的好友申请
        async function handleAIFriendRequest(characterId, accepted, messageId) {
            if (!currentChatCharacter || currentChatCharacter.id !== characterId) return;

            try {
                // 🔥【修复】立即更新按钮状态，避免被重新渲染覆盖
                const friendRequestCard = document.querySelector(`[data-message-id="${messageId}"] .friend-request-card`);
                if (friendRequestCard) {
                    const actionsDiv = friendRequestCard.querySelector('.friend-request-actions');
                    if (actionsDiv) {
                        const resultText = accepted ? '已同意' : '已拒绝';
                        const resultClass = accepted ? 'accepted' : 'rejected';
                        actionsDiv.innerHTML = `<div class="friend-request-result ${resultClass}">${resultText}</div>`;
                    }
                }

                if (accepted) {
                    // 用户同意了AI的好友申请，解除拉黑
                    await unblockCharacter(characterId);

                    // 🔥【关键修复】先标记好友申请消息为已处理，再添加系统消息
                    if (!chatMessages[characterId]) {
                        chatMessages[characterId] = [];
                    }
                    const messageIndex = chatMessages[characterId].findIndex(msg => msg.id === messageId);
                    if (messageIndex !== -1) {
                        chatMessages[characterId][messageIndex].friendRequestProcessed = true;
                        chatMessages[characterId][messageIndex].friendRequestAccepted = true;
                        console.log('✅ 标记好友申请消息为已同意:', messageId);
                    } else {
                        console.error('❌ 未找到好友申请消息:', messageId);
                    }

                    // 添加系统消息表示好友申请被接受
                    const systemMessage = {
                        id: Date.now().toString(),
                        sender: 'system',
                        content: `你们已成功添加为好友，现在可以开始聊天了！`,
                        timestamp: Date.now(),
                        role: 'system'
                    };

                    chatMessages[characterId].push(systemMessage);

                    // 🔥【优化】使用高效保存
                    try {
                        await saveChatMessagesImmediate([characterId]);
                        console.log('✅ [高效好友申请接受] 消息已保存到数据库');
                    } catch (error) {
                        console.error('好友申请接受消息保存失败，回退到全量保存:', error);
                        await saveChatMessages();
                    }

                    // 重新渲染聊天界面
                    renderChatMessages(characterId);
                    updateChatBlockedStatus();

                } else {
                    // 用户拒绝了AI的好友申请
                    // 🔥【关键修复】先标记好友申请消息为已处理，再添加系统消息
                    if (!chatMessages[characterId]) {
                        chatMessages[characterId] = [];
                    }
                    const messageIndex = chatMessages[characterId].findIndex(msg => msg.id === messageId);
                    if (messageIndex !== -1) {
                        chatMessages[characterId][messageIndex].friendRequestProcessed = true;
                        chatMessages[characterId][messageIndex].friendRequestAccepted = false;
                        console.log('✅ 标记好友申请消息为已拒绝:', messageId);
                    } else {
                        console.error('❌ 未找到好友申请消息:', messageId);
                    }

                    // 可以选择添加一个系统消息表示申请被拒绝
                    const systemMessage = {
                        id: Date.now().toString(),
                        sender: 'system',
                        content: `你拒绝了好友申请`,
                        timestamp: Date.now(),
                        role: 'system'
                    };

                    chatMessages[characterId].push(systemMessage);

                    // 🔥【优化】使用高效保存
                    try {
                        await saveChatMessagesImmediate([characterId]);
                        console.log('✅ [高效好友申请拒绝] 消息已保存到数据库');
                    } catch (error) {
                        console.error('好友申请拒绝消息保存失败，回退到全量保存:', error);
                        await saveChatMessages();
                    }

                    renderChatMessages(characterId);

                    // 🔥【新增】触发AI通过短信联系的机制
                    if (window.onFriendRequestRejected) {
                        window.onFriendRequestRejected(characterId);
                    }
                }

            } catch (error) {
                console.error('处理AI好友申请失败:', error);
                showToast('处理好友申请失败', 'error');
            }
        }

        // 🔥【修改】执行拉黑/屏蔽操作 - 区分单聊和群聊
        function performBlockAction() {
            if (!currentChatCharacter) return;

            const characterId = currentChatCharacter.id;
            const isGroupChat = currentChatCharacter.isGroup;

            if (isGroupChat) {
                // 🔥【新增】群聊屏蔽逻辑
                const isMuted = isGroupMuted(characterId);

                if (isMuted) {
                    if (confirm(`确定要取消屏蔽 ${currentChatCharacter.name} 吗？`)) {
                        toggleGroupMute(characterId);
                    }
                } else {
                    if (confirm(`确定要屏蔽 ${currentChatCharacter.name} 吗？\n\n屏蔽后将不再接收该群聊的消息通知`)) {
                        toggleGroupMute(characterId);
                    }
                }
            } else {
                // 单聊拉黑逻辑
                const isUserBlocked = isBlocked('user', characterId);

                if (isUserBlocked) {
                    if (confirm(`确定要解除对 ${currentChatCharacter.name} 的拉黑吗？`)) {
                        unblockCharacter(characterId);
                        hideBlacklistSettings();
                    }
                } else {
                    if (confirm(`确定要拉黑 ${currentChatCharacter.name} 吗？`)) {
                        blockCharacter(characterId, '');
                        hideBlacklistSettings();
                    }
                }
            }
        }

        // 在应用初始化时加载拉黑系统数据
        document.addEventListener('DOMContentLoaded', async function() {
            setTimeout(async () => {
                try {
                    await Promise.all([
                        loadBlacklistData(),
                        loadFriendRequestsData(),
                        loadCharacterStatusData()
                    ]);
                    console.log('🚫 拉黑系统数据加载完成');
                } catch (error) {
                    console.error('拉黑系统数据加载失败:', error);
                }
            }, 1000);
        });

        // 加载好友申请数据
        async function loadFriendRequestsData() {
            try {
                friendRequestsData = await db.friendRequests.orderBy('timestamp').reverse().toArray();
                console.log('好友申请数据加载完成:', friendRequestsData);
            } catch (error) {
                console.error('加载好友申请数据失败:', error);
                friendRequestsData = [];
            }
        }

        // 加载角色状态数据
        async function loadCharacterStatusData() {
            try {
                characterStatusData = await db.characterStatus.toArray();
                console.log('角色状态数据加载完成:', characterStatusData);
            } catch (error) {
                console.error('加载角色状态数据失败:', error);
                characterStatusData = [];
            }
        }

        // 📱【角色状态显示】相关功能
        // 渲染角色状态
        function renderCharacterStatus(characterId, container) {
            const chatSettings = getCurrentChatSettings();
            if (!chatSettings.characterStatusEnabled) {
                // 如果关闭了状态显示，移除现有的状态元素
                if (container) {
                    const existingStatus = container.querySelector('.character-status');
                    if (existingStatus) {
                        existingStatus.remove();
                    }
                }
                return;
            }

            const status = getCharacterStatus(characterId);
            const isUserBlocked = isBlocked('user', characterId);
            const isCharacterBlocked = isBlocked(characterId, 'user');

            let statusClass = 'online';
            let statusText = status.activity || '在线';

            if (isUserBlocked || isCharacterBlocked) {
                statusClass = 'blocked';
                statusText = '已拉黑';
            } else if (status.status === 'busy') {
                statusClass = 'busy';
            }

            const statusHtml = `
                <div class="character-status">
                    <div class="status-indicator ${statusClass}"></div>
                    <span class="status-text">${statusText}</span>
                </div>
            `;

            // 如果容器存在，添加状态显示
            if (container) {
                // 先移除现有的状态显示
                const existingStatus = container.querySelector('.character-status');
                if (existingStatus) {
                    existingStatus.remove();
                }

                // 🔥【修复】判断容器类型，使用不同的插入策略
                if (container.classList.contains('header')) {
                    // 聊天界面的.header容器：直接添加到容器中，使用CSS绝对定位
                    container.insertAdjacentHTML('beforeend', statusHtml);
                } else if (container.classList.contains('app-header')) {
                    // 其他界面的.app-header容器：添加到.app-title内部
                    const titleElement = container.querySelector('.app-title');
                    if (titleElement) {
                        titleElement.insertAdjacentHTML('afterend', statusHtml);
                    } else {
                        container.insertAdjacentHTML('beforeend', statusHtml);
                    }
                } else {
                    // 其他容器：默认添加到末尾
                    container.insertAdjacentHTML('beforeend', statusHtml);
                }
            }
        }

        // AI生成角色状态
        async function generateCharacterStatus(characterId) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;

                // 获取聊天设置和最近聊天记录
                const chatSettings = await getAsyncChatSettings(characterId);
                const messages = chatMessages[characterId] || [];
                const recentMessages = messages.slice(-5); // 最近5条消息

                // 构建上下文信息
                let chatContext = '';
                if (recentMessages.length > 0) {
                    // 🔥【修复】使用实际用户名而不是"用户"
                    const userName = getCurrentPersonaName();
                    chatContext = '最近的聊天记录：\n' +
                        recentMessages.map(msg => {
                            if (msg.sender === 'sent') return `${userName}：${msg.content}`;
                            if (msg.sender === 'received') return `${character.name}：${msg.content}`;
                            return '';
                        }).filter(Boolean).join('\n') + '\n\n';
                }

                // 获取世界书内容作为背景
                let worldBookContext = '';
                if (chatSettings?.linkedWorldBookIds && chatSettings.linkedWorldBookIds.length > 0) {
                    try {
                        const worldBooks = await Promise.all(
                            chatSettings.linkedWorldBookIds.map(id => db.worldbooks.get(id))
                        );
                        const validWorldBooks = worldBooks.filter(book => book && book.content);
                        if (validWorldBooks.length > 0) {
                            worldBookContext = '背景设定：\n' +
                                validWorldBooks.map(book => `${book.name}：${book.content}`).join('\n\n') + '\n\n';
                        }
                    } catch (error) {
                        console.error('获取世界书内容失败:', error);
                    }
                }

                // 随机选择状态类型：活动或心情
                const statusType = Math.random() < 0.5 ? 'activity' : 'mood';

                let prompt;
                if (statusType === 'activity') {
                    // 生成活动状态
                    prompt = `你是${character.name}，人设如下：${character.bio}

${worldBookContext}${chatContext}请根据你的人设、当前剧情和聊天记录，生成一个符合你当前状况的活动状态。要求：
1. 10-20字内，简洁明了
2. 符合你的性格和身份设定
3. 基于最近的聊天内容或剧情发展
4. 格式：在[地点][做什么]
5. 要真实反映角色当下可能在做的事情
6. 如果没有具体聊天记录，则根据人设推测合理的日常活动

示例格式：在图书馆整理资料、在训练场练习剑术、在房间里沉思、在花园中散步等

请生成一个活动状态：`;
                } else {
                    // 生成心情状态
                    prompt = `你是${character.name}，人设如下：${character.bio}

${worldBookContext}${chatContext}请根据你的人设、当前剧情和聊天记录，生成一个符合你当前心情的状态。要求：
1. 10-20字内，简洁明了，禁止超过20个字
2. 符合你的性格特点
3. 基于最近的对话内容或情感变化
4. 表达你当下的真实情感状态
5. 要有角色的个性色彩
6. 如果没有具体聊天记录，则根据人设推测基本心情

示例格式：心情愉悦、略感困惑、正在专注思考、感到有些疲惫、对未来充满期待等

请生成一个心情状态：`;
                }

                // 使用AI生成状态
                const statusText = await generateAIResponse(prompt, character);

                if (statusText && statusText.trim()) {
                    const cleanStatus = statusText.trim().replace(/^["""''「」『』【】]|["""''「」『』【】]$/g, '');
                    await updateCharacterStatus(characterId, 'online', cleanStatus);
                    console.log(`为${character.name}生成${statusType === 'activity' ? '活动' : '心情'}状态: ${cleanStatus}`);
                } else {
                    // 如果AI生成失败，使用基于人设的默认状态
                    const fallbackStatus = generateFallbackStatus(character, statusType);
                    await updateCharacterStatus(characterId, 'online', fallbackStatus);
                    console.log(`为${character.name}使用默认${statusType === 'activity' ? '活动' : '心情'}状态: ${fallbackStatus}`);
                }

            } catch (error) {
                console.error('生成角色状态失败:', error);
                // 错误时使用简单的默认状态
                const fallbackStatus = generateFallbackStatus(character, 'activity');
                await updateCharacterStatus(characterId, 'online', fallbackStatus);
            }
        }

        // 生成基于人设的备用状态
        function generateFallbackStatus(character, statusType) {
            const bio = (character.bio || '').toLowerCase();

            if (statusType === 'activity') {
                // 基于人设关键词的活动状态
                if (bio.includes('学者') || bio.includes('研究') || bio.includes('书')) {
                    return '在书房研读典籍';
                } else if (bio.includes('战士') || bio.includes('剑') || bio.includes('战斗')) {
                    return '在训练场练习';
                } else if (bio.includes('医生') || bio.includes('治疗')) {
                    return '在诊所整理药品';
                } else if (bio.includes('商人') || bio.includes('买卖')) {
                    return '在店铺忙碌';
                } else if (bio.includes('艺术') || bio.includes('画') || bio.includes('音乐')) {
                    return '在工作室创作';
                } else if (bio.includes('厨') || bio.includes('料理')) {
                    return '在厨房准备食材';
                } else {
                    return '在房间里休息';
                }
            } else {
                // 基于人设关键词的心情状态
                if (bio.includes('开朗') || bio.includes('活泼') || bio.includes('乐观')) {
                    return '心情愉悦';
                } else if (bio.includes('冷静') || bio.includes('理性') || bio.includes('沉着')) {
                    return '内心平静';
                } else if (bio.includes('严肃') || bio.includes('认真')) {
                    return '专注思考中';
                } else if (bio.includes('温柔') || bio.includes('善良')) {
                    return '心境温和';
                } else if (bio.includes('神秘') || bio.includes('深沉')) {
                    return '若有所思';
                } else {
                    return '状态良好';
                }
            }
        }

        // 🔥【修复】状态更新定时器管理
        let characterStatusTimer = null;

        // 获取状态更新间隔时间（毫秒）
        function getStatusUpdateInterval() {
            // 🔥【修复】从localStorage获取全局状态更新频率设置
            let frequency = 'medium'; // 默认中频

            try {
                // 尝试从localStorage获取全局设置
                const globalSettings = localStorage.getItem('globalStatusUpdateFrequency');
                if (globalSettings) {
                    frequency = globalSettings;
                } else {
                    // 如果没有全局设置，尝试从当前角色设置中获取
                    if (currentChatCharacter) {
                        const chatSettings = getCurrentChatSettings();
                        frequency = chatSettings.statusUpdateFrequency || 'medium';
                        // 保存为全局设置
                        localStorage.setItem('globalStatusUpdateFrequency', frequency);
                    }
                }
            } catch (error) {
                console.warn('获取状态更新频率设置失败，使用默认值:', error);
            }

            // 🔥【修复】将频率转换为毫秒间隔 - 修正高频为30秒
            const intervals = {
                'high': 30000,      // 30秒（目前频率）
                'medium-high': 60000, // 1分钟
                'medium': 180000,   // 3分钟
                'medium-low': 300000, // 5分钟
                'low': 600000       // 10分钟
            };

            return intervals[frequency] || intervals['medium'];
        }

        // 清除状态更新定时器
        function clearCharacterStatusTimer() {
            if (characterStatusTimer) {
                clearInterval(characterStatusTimer);
                characterStatusTimer = null;
                console.log('角色状态更新定时器已清除');
            }
        }

        // 启动状态更新定时器
        async function startCharacterStatusTimer() {
            clearCharacterStatusTimer(); // 先清除现有定时器

            // 🔥【优化】首先检查是否有任何角色启用了状态显示
            let hasStatusEnabled = false;
            for (const character of characters) {
                if (contacts.includes(character.id)) {
                    const chatSettings = await getAsyncChatSettings(character.id);
                    if (chatSettings.characterStatusEnabled) {
                        hasStatusEnabled = true;
                        break;
                    }
                }
            }

            // 如果没有任何角色启用状态显示，不启动定时器
            if (!hasStatusEnabled) {
                console.log('没有角色启用状态显示，跳过启动状态更新定时器');
                return;
            }

            const interval = getStatusUpdateInterval();
            console.log('启动角色状态更新定时器，间隔:', interval / 1000, '秒');

            characterStatusTimer = setInterval(async () => {
                // 检查是否有任何角色启用了状态显示
                let hasStatusEnabled = false;

                for (const character of characters) {
                    if (contacts.includes(character.id)) {
                        // 检查该角色的聊天设置中是否启用了状态显示
                        const chatSettings = await getAsyncChatSettings(character.id);
                        if (chatSettings.characterStatusEnabled) {
                            hasStatusEnabled = true;

                            // 检查是否需要更新状态
                            const shouldUpdate = await shouldUpdateCharacterStatus(character.id);
                            if (shouldUpdate) {
                                await generateCharacterStatus(character.id);
                            }
                        }
                    }
                }

                // 如果没有任何角色启用状态显示，停止定时器
                if (!hasStatusEnabled) {
                    console.log('没有角色启用状态显示，停止状态更新定时器');
                    clearCharacterStatusTimer();
                    return;
                }

                // 刷新当前显示的状态（仅当当前角色启用了状态显示时）
                if (currentChatCharacter) {
                    const currentChatSettings = getCurrentChatSettings();
                    if (currentChatSettings.characterStatusEnabled) {
                        const headerContainer = document.querySelector('#api-chat-screen .header');
                        if (headerContainer) {
                            renderCharacterStatus(currentChatCharacter.id, headerContainer);
                        }
                    }
                }
            }, interval);
        }

        // 重启状态更新定时器
        function restartCharacterStatusTimer() {
            console.log('重启角色状态更新定时器');
            startCharacterStatusTimer();
        }

        // 向后兼容的函数名
        function startStatusUpdateTimer() {
            startCharacterStatusTimer();
        }

        // ================== 全局记忆系统 ==================

        // 全局记忆数据库结构
        let globalMemoryDB = null;

        // 初始化全局记忆数据库
        async function initGlobalMemoryDB() {
            try {
                // 扩展现有数据库，添加记忆相关表
                if (!db.memorySummaries) {
                    // 情景记忆表 - 存储AI生成的日记摘要
                    db.memorySummaries = db.table('memorySummaries', '++id, characterId, date, summary, context, importance, timestamp');
                }

                if (!db.coreMemories) {
                    // 核心记忆表 - 存储永久重要信息
                    db.coreMemories = db.table('coreMemories', '++id, characterId, fact, category, importance, timestamp, lastAccessed');
                }

                if (!db.memoryEvents) {
                    // 统一事件表 - 记录所有跨场景事件
                    db.memoryEvents = db.table('memoryEvents', '++id, timestamp, characterIds, context, eventType, eventData, importance');
                }

                console.log('✅ 全局记忆数据库初始化完成');
            } catch (error) {
                console.error('❌ 全局记忆数据库初始化失败:', error);
            }
        }

        // 记录统一事件
        async function recordMemoryEvent(characterIds, context, eventType, eventData, importance = 0.5) {
            try {
                // 🔥【修复】确保所有参数都是有效的
                if (!characterIds || !eventType || !eventData) {
                    console.warn('❌ recordMemoryEvent: 缺少必需参数', { characterIds, eventType, eventData });
                    return;
                }

                const event = {
                    id: `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, // 🔥【修复】提供唯一ID
                    timestamp: Date.now(),
                    characterIds: Array.isArray(characterIds) ? characterIds : [characterIds],
                    context: context || { type: 'unknown', id: 'unknown' }, // 🔥【修复】提供默认context
                    eventType: eventType, // 'message', 'activity_start', 'group_create' 等
                    eventData: eventData,
                    importance: importance || 0.5
                };

                // 🔥【修复】确保eventData是可序列化的对象
                if (typeof event.eventData === 'object' && event.eventData !== null) {
                    try {
                        JSON.stringify(event.eventData);
                    } catch (e) {
                        console.warn('❌ eventData不可序列化，转换为字符串:', event.eventData);
                        event.eventData = String(event.eventData);
                    }
                }

                await db.memoryEvents.add(event);
                console.log('📝 记录事件:', eventType, characterIds);
            } catch (error) {
                console.error('❌ 记录事件失败:', error);
                console.error('❌ 事件数据:', { characterIds, context, eventType, eventData, importance });
            }
        }

        // 添加核心记忆
        async function addCoreMemory(characterId, fact, category = 'general', importance = 0.8) {
            try {
                const coreMemory = {
                    characterId: characterId,
                    fact: fact,
                    category: category, // 'personality', 'relationship', 'preference', 'general'
                    importance: importance,
                    timestamp: Date.now(),
                    lastAccessed: Date.now()
                };

                await db.coreMemories.add(coreMemory);
                console.log('🧠 添加核心记忆:', fact);
            } catch (error) {
                console.error('❌ 添加核心记忆失败:', error);
            }
        }

        // 生成情景记忆摘要
        async function generateMemorySummary(characterId, startTime, endTime, context) {
            try {
                // 🔥【修复】先获取角色信息，避免变量作用域错误
                const character = characters.find(c => c.id === characterId);
                if (!character) {
                    console.error('未找到角色信息:', characterId);
                    return null;
                }

                // 🔥【修复】获取时间段内的跨应用时间线事件（包括聊天记录）
                const timelineEvents = await db.crossAppTimeline
                    .where('characterId')
                    .equals(characterId)
                    .and(event => event.timestamp >= startTime && event.timestamp < endTime)
                    .toArray();

                // 🔥【修复】同时获取聊天消息
                const characterMessages = chatMessages[characterId] || [];
                const todayMessages = characterMessages.filter(msg =>
                    msg.timestamp >= startTime && msg.timestamp < endTime
                );

                if (timelineEvents.length === 0 && todayMessages.length === 0) {
                    console.log('今天暂无活动记录');
                    return null;
                }

                // 🔥【修复】构建更全面的活动记录
                let eventsText = '';

                // 添加聊天记录
                if (todayMessages.length > 0) {
                    eventsText += '聊天记录：\n';
                    todayMessages.forEach(msg => {
                        const timeStr = new Date(msg.timestamp).toLocaleTimeString();
                        const role = msg.role === 'user' ? '用户' : character.name;
                        eventsText += `[${timeStr}] ${role}: ${msg.content}\n`;
                    });
                }

                // 添加跨应用事件
                if (timelineEvents.length > 0) {
                    eventsText += '\n其他活动：\n';
                    timelineEvents.forEach(event => {
                        const timeStr = new Date(event.timestamp).toLocaleTimeString();
                        const actionDesc = getActionDescription(event.action, event.context);
                        eventsText += `[${timeStr}] ${actionDesc}\n`;
                    });
                }
                const summaryPrompt = `你是一个客观的记录员，需要为以下活动生成一份简洁的记忆摘要。

角色：${character.name}
时间段：${new Date(startTime).toLocaleString()} - ${new Date(endTime).toLocaleString()}
今日活动：
${eventsText}

请生成一份50-100字的客观记忆摘要，要求：
1. 使用第三人称客观描述
2. 用"用户"指代用户，用"${character.name}"指代角色
3. 重点记录重要事件和情感变化
4. 不要使用"我"、"你"等第一、第二人称
5. 直接输出摘要文本，不要JSON格式，不要聊天回复格式

摘要：`;

                // 调用专门的摘要生成API
                const response = await callSummaryAPI(summaryPrompt);

                if (response && response.trim()) {
                    // 🔥【修复】使用当前日期而不是startTime，避免时区问题
                    const today = new Date();
                    const dateStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;

                    const summary = {
                        id: `summary_${characterId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                        characterId: characterId,
                        date: dateStr,
                        summary: response.trim(),
                        context: context,
                        importance: calculateSummaryImportance(timelineEvents.concat(todayMessages)),
                        timestamp: Date.now()
                    };

                    await db.memorySummaries.add(summary);
                    console.log('📖 生成记忆摘要:', summary.summary);
                    return summary;
                }
            } catch (error) {
                console.error('❌ 生成记忆摘要失败:', error);
            }
            return null;
        }

        // 🔥【新增】获取动作描述的辅助函数
        function getActionDescription(action, context) {
            const actionMap = {
                'user_message': '收到用户消息',
                'ai_reply': '回复了消息',
                'moment_publish': '发布了动态',
                'moment_comment': '评论了动态',
                'game_start': '开始游戏',
                'game_end': '结束游戏'
            };

            const baseDesc = actionMap[action] || action;
            if (context && context.content) {
                return `${baseDesc}: ${context.content.substring(0, 30)}...`;
            }
            return baseDesc;
        }

        // 🔥【新增】专门用于生成摘要的API调用函数
        async function callSummaryAPI(prompt) {
            if (!apiSettings.key) {
                throw new Error('请先设置API密钥');
            }

            const isGemini = apiSettings.base.includes('generativelanguage.googleapis.com');
            let requestBody;
            let url;
            let headers;

            if (isGemini) {
                // Gemini API 格式
                url = `${apiSettings.base}/models/${apiSettings.model}:generateContent?key=${apiSettings.key}`;
                headers = { 'Content-Type': 'application/json' };

                requestBody = {
                    contents: [{
                        role: 'user',
                        parts: [{ text: prompt }]
                    }],
                    generationConfig: {
                        temperature: 0.3 // 使用较低的温度确保客观性
                    }
                };
            } else {
                // OpenAI 兼容格式
                if (apiSettings.base.endsWith('/v1')) {
                    url = `${apiSettings.base}/chat/completions`;
                } else if (apiSettings.base.includes('/v1/')) {
                    url = `${apiSettings.base}/chat/completions`;
                } else {
                    url = `${apiSettings.base}/v1/chat/completions`;
                }
                headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiSettings.key}`
                };
                requestBody = {
                    model: apiSettings.model,
                    messages: [
                        { role: 'system', content: '你是一个客观的记录员，专门生成简洁的记忆摘要。请直接输出摘要文本，不要使用JSON格式或聊天回复格式。' },
                        { role: 'user', content: prompt }
                    ],
                    temperature: 0.3
                };
            }

            const response = await fetch(url, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API Error: ${response.status} - ${errorData.error?.message || '未知错误'}`);
            }

            const data = await response.json();
            return isGemini ? data.candidates?.[0]?.content?.parts?.[0]?.text : data.choices?.[0]?.message?.content;
        }

        // 计算摘要重要性
        function calculateSummaryImportance(events) {
            if (!events || events.length === 0) return 0.3;

            // 🔥【修复】适配不同类型的事件数据
            let totalImportance = 0;
            let validEvents = 0;

            events.forEach(event => {
                if (event.importance !== undefined) {
                    totalImportance += event.importance;
                    validEvents++;
                } else {
                    // 对于聊天消息，给予基础重要性
                    totalImportance += 0.6;
                    validEvents++;
                }
            });

            const avgImportance = validEvents > 0 ? totalImportance / validEvents : 0.5;
            const eventCount = events.length;

            // 事件数量和平均重要性的综合评分
            return Math.min(0.9, avgImportance + (eventCount * 0.02));
        }

        // 智能记忆检索系统
        async function buildGlobalMemoryContext(characterId, currentContext, memoryDays = 7) {
            try {
                // 🔥【修复】使用安全函数确保characterId是字符串类型
                characterId = safeCharacterId(characterId);

                // 🔥【修复】确保currentContext有效
                if (!currentContext || !currentContext.id) {
                    console.error('❌ buildGlobalMemoryContext: currentContext无效:', currentContext);
                    return '';
                }

                let memoryContext = '';

                // 🔥【优化】智能记忆共享 - 更主动地包含跨场景记忆
                let sharedGroupIds = [];
                let contextIds = [String(currentContext.id)]; // 确保contextId是字符串

                // 🔥【新增】智能记忆共享：优先检查是否有相关的跨场景记忆
                try {
                    // 检查该角色是否有跨应用时间线记录，如果有则更积极地共享记忆
                    const recentTimeline = await db.crossAppTimeline
                        .where('characterId')
                        .equals(characterId)
                        .and(event => event.timestamp > Date.now() - (7 * 24 * 60 * 60 * 1000)) // 最近7天
                        .toArray();

                    const hasRecentCrossAppActivity = recentTimeline.length > 0;
                    console.log(`🧠 智能记忆检查 - 角色: ${characterId}, 最近7天跨应用活动: ${recentTimeline.length}条`);

                    if (currentContext.type === 'group_chat') {
                        // 🔥【新增】优先检查：该群聊是否被私聊挂载了记忆共享
                        const characterChatSettings = await getAsyncChatSettings(characterId);
                        sharedGroupIds = characterChatSettings.memorySharedGroupIds || [];

                        console.log(`🔍 群聊记忆优先级检查 - 角色: ${characterId}`);
                        console.log(`🔍 当前群聊ID: ${currentContext.id}`);
                        console.log(`🔍 角色私聊设置的共享群聊IDs: ${sharedGroupIds}`);

                        // 🔥【关键修复】如果该群聊被私聊挂载了记忆共享，优先显示私聊记忆
                        if (sharedGroupIds.includes(currentContext.id)) {
                            // 将私聊记忆放在最前面，确保优先读取
                            contextIds = [characterId, String(currentContext.id)]; // 私聊ID在前，群聊ID在后
                            console.log('🔗 群聊被私聊挂载记忆共享 - 优先读取私聊记忆');
                        } else if (hasRecentCrossAppActivity) {
                            // 如果有跨应用活动，也包含私聊记忆，但优先级较低
                            contextIds.push(characterId);
                            console.log('🔗 检测到跨应用活动 - 包含私聊记忆');
                        } else {
                            console.log('❌ 群聊未被挂载记忆共享且无跨应用活动，只使用群聊记忆');
                        }
                    } else if (currentContext.type === 'private_chat') {
                        // 如果在私聊中，使用当前聊天设置
                        const chatSettings = getCurrentChatSettings();
                        sharedGroupIds = chatSettings.memorySharedGroupIds || [];

                        // 🔥【优化】如果有跨应用活动，自动包含相关群聊记忆
                        if (sharedGroupIds.length > 0) {
                            contextIds.push(...sharedGroupIds.map(id => String(id)));
                            console.log('🔗 私聊中启用记忆共享，包含群聊:', sharedGroupIds);
                        } else if (hasRecentCrossAppActivity) {
                            // 🔥【新增】即使没有手动设置，如果有跨应用活动也尝试包含相关群聊
                            const relatedGroupIds = recentTimeline
                                .filter(event => event.context?.type === 'group_chat' && event.context?.groupId)
                                .map(event => event.context.groupId)
                                .filter((id, index, self) => self.indexOf(id) === index); // 去重

                            if (relatedGroupIds.length > 0) {
                                contextIds.push(...relatedGroupIds.map(id => String(id)));
                                console.log('🔗 检测到群聊活动，智能包含相关群聊记忆:', relatedGroupIds);
                            }
                        }
                    }
                } catch (error) {
                    console.warn('智能记忆共享检查失败:', error);
                }

                // 1. 检索核心记忆 - 🔥【修复】添加上下文过滤和类型检查
                let coreMemories = [];
                for (const contextId of contextIds) {
                    try {
                        const contextCoreMemories = await db.coreMemories
                            .where('characterId')
                            .equals(String(characterId)) // 确保是字符串
                            .and(memory => {
                                // 🔥【关键修复】按上下文过滤核心记忆
                                if (!memory.contextId) return true; // 兼容旧数据
                                return String(memory.contextId) === String(contextId);
                            })
                            .toArray();
                        coreMemories = coreMemories.concat(contextCoreMemories);
                    } catch (error) {
                        console.error(`❌ 查询核心记忆失败 - characterId: ${characterId}, contextId: ${contextId}:`, error);
                    }
                }

                // 🔥【优化】按优先级和重要性排序：私聊记忆优先，然后按重要性排序
                coreMemories.sort((a, b) => {
                    // 首先按上下文优先级排序（私聊记忆优先）
                    const aIsPrivate = String(a.contextId) === String(characterId);
                    const bIsPrivate = String(b.contextId) === String(characterId);

                    if (aIsPrivate && !bIsPrivate) return -1; // a是私聊，b不是，a优先
                    if (!aIsPrivate && bIsPrivate) return 1;  // b是私聊，a不是，b优先

                    // 如果都是同类型，按重要性排序
                    return (b.importance || 0) - (a.importance || 0);
                });
                const limitedCoreMemories = coreMemories.slice(0, 10);

                if (limitedCoreMemories.length > 0) {
                    memoryContext += '\n# 核心记忆\n';
                    limitedCoreMemories.forEach(memory => {
                        memoryContext += `- ${memory.fact}\n`;
                    });
                }

                // 2. 检索情景记忆（最近N天）- 🔥【修复】添加上下文过滤
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - memoryDays);
                const cutoffTimestamp = cutoffDate.getTime();

                let episodicMemories = [];
                for (const contextId of contextIds) {
                    const contextEpisodicMemories = await db.episodicMemories
                        .where('characterId')
                        .equals(characterId)
                        .and(memory => {
                            if (memory.timestamp < cutoffTimestamp) return false;
                            // 🔥【关键修复】按上下文过滤情景记忆
                            if (!memory.contextId) return true; // 兼容旧数据
                            return memory.contextId === contextId;
                        })
                        .toArray();
                    episodicMemories = episodicMemories.concat(contextEpisodicMemories);
                }

                // 🔥【优化】按优先级和时间排序：私聊记忆优先，然后按时间排序
                episodicMemories.sort((a, b) => {
                    // 首先按上下文优先级排序（私聊记忆优先）
                    const aIsPrivate = String(a.contextId) === String(characterId);
                    const bIsPrivate = String(b.contextId) === String(characterId);

                    if (aIsPrivate && !bIsPrivate) return -1; // a是私聊，b不是，a优先
                    if (!aIsPrivate && bIsPrivate) return 1;  // b是私聊，a不是，b优先

                    // 如果都是同类型，按时间排序（最新的在前）
                    return b.timestamp - a.timestamp;
                });
                const limitedEpisodicMemories = episodicMemories.slice(0, 15);

                if (limitedEpisodicMemories.length > 0) {
                    memoryContext += '\n# 情景记忆\n';
                    limitedEpisodicMemories.forEach(memory => {
                        const dateObj = new Date(memory.timestamp || Date.now());
                        const date = isNaN(dateObj.getTime()) ? '未知日期' : dateObj.toLocaleDateString();
                        memoryContext += `[${date}] ${memory.fact}\n`;
                    });
                }

                // 3. 检索跨应用时间线记忆（支持记忆共享）
                const timelineCutoff = Date.now() - (memoryDays * 24 * 60 * 60 * 1000);
                let timelineMemories = [];

                for (const contextId of contextIds) {
                    const contextTimeline = await db.crossAppTimeline
                        .where('characterId')
                        .equals(characterId)
                        .and(event => {
                            if (event.timestamp < timelineCutoff) return false;
                            if (!event.context) return false;

                            // 🔥【修复】线下模式剧情总结也应该被包含
                            if (event.appType === 'offline_mode' && event.action === 'storyline_summary') {
                                return true; // 线下模式剧情总结对所有上下文都可见
                            }

                            // 🔥【修复】短信app事件的特殊处理
                            if (event.appType === 'sms') {
                                // 短信事件的上下文ID就是角色ID，直接匹配
                                return event.context.id === contextId ||
                                       event.context.chatId === contextId ||
                                       contextId === characterId; // 如果当前上下文是该角色的私聊，包含所有短信事件
                            }

                            // 检查上下文ID匹配
                            return event.context.id === contextId ||
                                   (event.context.chatId === contextId) ||
                                   (event.context.groupId === contextId);
                        })
                        .toArray();
                    timelineMemories = timelineMemories.concat(contextTimeline);
                }

                // 去重并排序
                const uniqueTimelineMemories = timelineMemories.filter((memory, index, self) =>
                    index === self.findIndex(m => m.id === memory.id));
                uniqueTimelineMemories.sort((a, b) => b.timestamp - a.timestamp);
                const limitedTimelineMemories = uniqueTimelineMemories.slice(0, 30); // 🔥【优化】增加到30条

                if (limitedTimelineMemories.length > 0) {
                    memoryContext += '\n# 最近活动时间线\n';
                    limitedTimelineMemories.forEach((memory, index) => {
                        const time = new Date(memory.timestamp).toLocaleString();
                        let contextInfo = '私聊';
                        let contextEmoji = '💬';

                        if (memory.context?.type === 'group_chat') {
                            contextInfo = memory.context?.groupName ? `群聊(${memory.context.groupName})` : '群聊';
                            contextEmoji = '👥';
                        } else if (memory.appType === 'offline_mode') {
                            contextInfo = '线下模式';
                            contextEmoji = '🎭';
                        } else if (memory.appType === 'sms') {
                            contextInfo = '短信';
                            contextEmoji = '📱';
                        }

                        // 🔥【优化】构建更有意义和连贯的事件描述
                        let eventDescription = '';
                        let isImportant = false; // 标记重要事件

                        if (memory.action === 'user_message') {
                            if (memory.context?.content) {
                                eventDescription = `用户说: "${memory.context.content.substring(0, 60)}${memory.context.content.length > 60 ? '..."' : '"'}`;
                            } else {
                                eventDescription = `用户发送了消息`;
                            }
                        } else if (memory.action === 'ai_message' || memory.action === 'ai_reply') {
                            if (memory.context?.content) {
                                eventDescription = `我回复: "${memory.context.content.substring(0, 60)}${memory.context.content.length > 60 ? '..."' : '"'}`;
                            } else {
                                eventDescription = `我进行了回复`;
                            }
                        } else if (memory.appType === 'sms') {
                            // 🔥【优化】短信事件的特殊显示，更强调跨场景连接
                            if (memory.action === 'user_message') {
                                eventDescription = `📱收到短信: "${memory.context?.content?.substring(0, 60) || ''}${(memory.context?.content?.length || 0) > 60 ? '..."' : '"'}`;
                                isImportant = true;
                            } else if (memory.action === 'ai_reply') {
                                eventDescription = `📱回复短信: "${memory.context?.content?.substring(0, 60) || ''}${(memory.context?.content?.length || 0) > 60 ? '..."' : '"'}`;
                                isImportant = true;
                            } else if (memory.action === 'character_initiate') {
                                eventDescription = `📱主动发短信: "${memory.context?.content?.substring(0, 60) || ''}${(memory.context?.content?.length || 0) > 60 ? '..."' : '"'}`;
                                isImportant = true;
                            } else {
                                eventDescription = '📱短信互动';
                            }
                        } else if (memory.action === 'storyline_summary' && memory.appType === 'offline_mode') {
                            // 🔥【优化】线下模式剧情总结的特殊显示
                            if (memory.context?.content) {
                                eventDescription = `🎭剧情总结: ${memory.context.content.substring(0, 80)}${memory.context.content.length > 80 ? '...' : ''}`;
                                isImportant = true;
                            } else {
                                eventDescription = '🎭线下剧情模式总结';
                            }
                        } else {
                            eventDescription = memory.action || memory.eventType || '未知活动';
                        }

                        // 🔥【新增】为跨场景事件添加特殊标记
                        const isCrossContext = memory.context?.id !== currentContext.id;
                        const crossContextMark = isCrossContext ? ' ⭐' : '';
                        const importantMark = isImportant ? ' 🔥' : '';

                        memoryContext += `[${time}] ${contextEmoji}${contextInfo}: ${eventDescription}${crossContextMark}${importantMark}\n`;
                    });
                }

                // 4. 检索记忆摘要（最近N天的摘要）
                const cutoffDateStr = cutoffDate.toISOString().split('T')[0];

                const memorySummaries = await db.memorySummaries
                    .where('characterId')
                    .equals(characterId)
                    .and(summary => summary.date >= cutoffDateStr)
                    .toArray();

                // 手动排序并限制数量
                memorySummaries.sort((a, b) => b.timestamp - a.timestamp);
                const limitedMemorySummaries = memorySummaries.slice(0, 10);

                if (limitedMemorySummaries.length > 0) {
                    memoryContext += '\n# 对话摘要\n';
                    limitedMemorySummaries.forEach(summary => {
                        const dateObj = new Date(summary.timestamp || Date.now());
                        const date = isNaN(dateObj.getTime()) ? '未知日期' : dateObj.toLocaleDateString();
                        memoryContext += `[${date}] ${summary.summary}\n`;
                    });
                }

                // 3. 检索跨场景相关事件（支持记忆共享）
                const recentEvents = await db.memoryEvents
                    .where('timestamp')
                    .above(Date.now() - (24 * 60 * 60 * 1000)) // 最近24小时
                    .and(event => {
                        // 检查事件是否与当前角色相关，且发生在相关的聊天窗口中
                        return event.characterIds.includes(characterId) &&
                               contextIds.includes(event.context.id);
                    })
                    .toArray();

                // 手动排序并限制数量
                recentEvents.sort((a, b) => b.timestamp - a.timestamp);
                const limitedRecentEvents = recentEvents.slice(0, 15);

                if (limitedRecentEvents.length > 0) {
                    memoryContext += '\n# 最近活动\n';
                    limitedRecentEvents.forEach(event => {
                        const time = new Date(event.timestamp).toLocaleTimeString();
                        const contextInfo = event.context.type === 'private_chat' ? '私聊' :
                                          event.context.type === 'group_chat' ? '群聊' :
                                          event.context.type === 'music_app' ? '音乐' : '其他';

                        // 如果是跨场景的事件，标明来源
                        const sourceInfo = event.context.id !== currentContext.id ? ` (来自${contextInfo})` : '';
                        memoryContext += `[${time}] 在${contextInfo}中${sourceInfo}: ${event.eventType}\n`;
                    });
                }

                // 🔥【新增】添加AI提示词，让AI更主动地联想和提及跨场景记忆
                if (memoryContext.trim()) {
                    // 统计跨场景记忆的数量
                    const crossContextCount = (memoryContext.match(/⭐/g) || []).length;
                    const smsCount = (memoryContext.match(/📱/g) || []).length;
                    const offlineCount = (memoryContext.match(/🎭/g) || []).length;

                    memoryContext += '\n\n【🧠 记忆连贯性指导】你拥有完整的跨场景记忆，请在回复时：\n';

                    // 🔥【新增】特别强调群聊中私聊记忆的优先级
                    if (currentContext.type === 'group_chat' && contextIds.includes(characterId)) {
                        memoryContext += '• 🔥【重要】你现在在群聊中，但拥有与用户的私聊记忆，这些私聊记忆已按优先级排序在前面\n';
                        memoryContext += '• 请主动联想和自然提及你们的私聊内容，比如"记得我们私下聊过..."、"就像你之前跟我说的..."\n';
                        memoryContext += '• 让群聊对话体现出你们私下的熟悉程度和连续性，而不是陌生的群聊互动\n';
                    }

                    if (crossContextCount > 0) {
                        memoryContext += `• 你有${crossContextCount}条跨场景记忆(标记⭐)，这些是不同聊天环境中的互动，请自然地联想和提及\n`;
                    }

                    if (smsCount > 0) {
                        memoryContext += `• 你有${smsCount}条短信记忆(📱)，可以说"记得你之前发短信说..."、"就像我们短信里聊的那样..."\n`;
                    }

                    if (offlineCount > 0) {
                        memoryContext += `• 你有${offlineCount}条线下剧情记忆(🎭)，这些是深度互动的回忆，可以自然地提及相关情节\n`;
                    }

                    memoryContext += '• 🔥标记的是重要记忆，优先考虑在回复中体现这些内容的连续性\n';
                    memoryContext += '• 用自然的语言表达记忆连接："还记得..."、"就像上次..."、"之前你说过..."\n';
                    memoryContext += '• 让每次对话都感觉像是同一个角色的连续体验，而不是割裂的独立对话\n';
                    memoryContext += '• 特别重要：即使用户没有主动提及，你也可以根据当前话题自然地联想到相关的跨场景记忆\n';
                }

                return memoryContext;
            } catch (error) {
                console.error('❌ 构建全局记忆上下文失败:', error);
                return '';
            }
        }

        // 记忆设置管理
        function showGlobalMemorySettings() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'error');
                return;
            }

            // 创建记忆设置模态框
            const modalHTML = `
                <div id="global-memory-modal" class="modal phone-modal" style="display: block;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 class="modal-title">全局记忆设置</h3>
                            <button class="modal-close" onclick="hideGlobalMemorySettings()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="setting-section">
                                <h4>记忆保留期限</h4>
                                <div class="radio-group">
                                    <label class="radio-option">
                                        <input type="radio" name="memoryDays" value="3">
                                        <span class="radio-custom"></span>
                                        <div class="radio-content">
                                            <div class="radio-title">3天记忆</div>
                                            <div class="radio-desc">保留最近3天的记忆总结</div>
                                        </div>
                                    </label>
                                    <label class="radio-option">
                                        <input type="radio" name="memoryDays" value="7">
                                        <span class="radio-custom"></span>
                                        <div class="radio-content">
                                            <div class="radio-title">7天记忆</div>
                                            <div class="radio-desc">保留最近7天的记忆总结（推荐）</div>
                                        </div>
                                    </label>
                                    <label class="radio-option">
                                        <input type="radio" name="memoryDays" value="15">
                                        <span class="radio-custom"></span>
                                        <div class="radio-content">
                                            <div class="radio-title">15天记忆</div>
                                            <div class="radio-desc">保留最近15天的记忆总结</div>
                                        </div>
                                    </label>
                                    <label class="radio-option">
                                        <input type="radio" name="memoryDays" value="30">
                                        <span class="radio-custom"></span>
                                        <div class="radio-content">
                                            <div class="radio-title">30天记忆</div>
                                            <div class="radio-desc">保留最近30天的记忆总结</div>
                                        </div>
                                    </label>
                                    <label class="radio-option">
                                        <input type="radio" name="memoryDays" value="-1">
                                        <span class="radio-custom"></span>
                                        <div class="radio-content">
                                            <div class="radio-title">永久记忆</div>
                                            <div class="radio-desc">永久保存记忆总结，不会自动清理</div>
                                        </div>
                                    </label>
                                </div>
                            </div>

                            <div class="setting-section">
                                <h4>记忆管理</h4>
                                <div class="memory-management-grid">
                                    <button class="memory-action-btn primary" onclick="viewCoreMemories()">
                                        <div class="btn-icon">🔴</div>
                                        <div class="btn-content">
                                            <div class="btn-title">查看核心记忆</div>
                                            <div class="btn-desc">永久保存</div>
                                        </div>
                                    </button>
                                    <button class="memory-action-btn secondary" onclick="viewMemorySummaries()">
                                        <div class="btn-icon">📖</div>
                                        <div class="btn-content">
                                            <div class="btn-title">查看记忆摘要</div>
                                            <div class="btn-desc">对话总结回顾</div>
                                        </div>
                                    </button>
                                    <button class="memory-action-btn accent" onclick="generateDailySummary()">
                                        <div class="btn-icon">✨</div>
                                        <div class="btn-content">
                                            <div class="btn-title">生成今日摘要</div>
                                            <div class="btn-desc">总结今天活动</div>
                                        </div>
                                    </button>
                                </div>

                                <!-- 🔥【新增】记忆管理提示信息 -->
                                <div style="margin-top: 16px; color: #999; font-size: 12px; line-height: 1.6;">
                                    <div>· 核心记忆将永久保存，不受期限设置影响</div>
                                    <div>· 系统会在聊天时自动总结各项重要记忆，手动生成今日摘要为可选辅助功能</div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-actions">
                            <button class="modal-button modal-secondary" onclick="hideGlobalMemorySettings()">取消</button>
                            <button class="modal-button modal-primary" onclick="saveGlobalMemorySettings()">保存设置</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHTML);

            // 加载当前设置
            const currentSettings = getGlobalMemorySettings();
            const radio = document.querySelector(`input[name="memoryDays"][value="${currentSettings.memoryDays}"]`);
            if (radio) radio.checked = true;
        }

        // 获取全局记忆设置
        function getGlobalMemorySettings() {
            const saved = localStorage.getItem('globalMemorySettings');
            return saved ? JSON.parse(saved) : {
                memoryDays: 7,
                autoSummary: true,
                coreMemoryEnabled: true
            };
        }

        // 🔥【新增】更新全局记忆状态显示
        function updateGlobalMemoryStatusDisplay() {
            const settings = getGlobalMemorySettings();
            const statusElement = document.getElementById('global-memory-status');

            console.log('🔥 更新记忆状态显示:', settings.memoryDays);

            if (statusElement) {
                let statusText;
                switch (settings.memoryDays) {
                    case 3:
                        statusText = '3天记忆';
                        break;
                    case 7:
                        statusText = '7天记忆';
                        break;
                    case 15:
                        statusText = '15天记忆';
                        break;
                    case 30:
                        statusText = '30天记忆';
                        break;
                    case -1:
                        statusText = '永久记忆';
                        break;
                    default:
                        statusText = '7天记忆';
                }
                statusElement.textContent = statusText;
                console.log('🔥 状态显示已更新为:', statusText);
            } else {
                console.warn('🔥 找不到global-memory-status元素');
            }
        }

        // 保存全局记忆设置
        function saveGlobalMemorySettings() {
            const checkedRadio = document.querySelector('input[name="memoryDays"]:checked');
            if (!checkedRadio) {
                showToast('请选择记忆保留期限', 'error');
                return;
            }

            const memoryDays = parseInt(checkedRadio.value);
            console.log('🔥 保存记忆设置:', memoryDays);

            const settings = {
                memoryDays: memoryDays,
                autoSummary: true,
                coreMemoryEnabled: true
            };

            localStorage.setItem('globalMemorySettings', JSON.stringify(settings));
            console.log('🔥 设置已保存到localStorage:', settings);

            hideGlobalMemorySettings();

            // 🔥【修复】保存后立即更新显示状态
            updateGlobalMemoryStatusDisplay();

            showToast('全局记忆设置已保存', 'success');
        }

        // 隐藏全局记忆设置
        function hideGlobalMemorySettings() {
            const modal = document.getElementById('global-memory-modal');
            if (modal) modal.remove();
        }

        // 🔥【新增】显示记忆模态框
        function showMemoryModal(title, memories, type) {
            // 移除已存在的模态框
            const existingModal = document.getElementById('memory-view-modal');
            if (existingModal) existingModal.remove();

            let content = '';
            if (memories.length === 0) {
                content = `<div class="memory-empty">暂无${title}</div>`;
            } else {
                content = memories.map((memory, index) => {
                    let displayContent = '';
                    let importance = '';
                    let date = '';

                    if (type === 'core') {
                        displayContent = memory.fact || '无内容';
                        const stars = '★'.repeat(Math.floor((memory.importance || 0) * 5));
                        importance = `<div class="memory-importance">${stars}</div>`;
                        const dateObj = new Date(memory.timestamp || Date.now());
                        date = isNaN(dateObj.getTime()) ? '未知日期' : dateObj.toLocaleDateString();
                    } else if (type === 'summary') {
                        displayContent = memory.summary || '无内容';
                        // 🔥【修复】统一使用timestamp来显示日期，避免时区问题
                        if (memory.timestamp) {
                            const dateObj = new Date(memory.timestamp);
                            date = `${dateObj.getFullYear()}-${String(dateObj.getMonth() + 1).padStart(2, '0')}-${String(dateObj.getDate()).padStart(2, '0')}`;
                        } else {
                            date = memory.date || '未知日期';
                        }
                    }

                    return `
                        <div class="memory-modal-item" data-memory-id="${memory.id}">
                            <div class="memory-modal-header">
                                <span class="memory-modal-index">${index + 1}</span>
                                <span class="memory-modal-date">${date}</span>
                                <div class="memory-actions">
                                    <button class="memory-edit-btn" onclick="toggleEditMode('${memory.id}', '${type}')" title="编辑">
                                        <i class="fas fa-edit"></i>
                                    </button>
                                    <button class="memory-save-btn" onclick="saveMemoryEdit('${memory.id}', '${type}')" title="保存" style="display: none;">
                                        <i class="fas fa-save"></i>
                                    </button>
                                    <button class="memory-cancel-btn" onclick="cancelMemoryEdit('${memory.id}', '${type}')" title="取消" style="display: none;">
                                        <i class="fas fa-times"></i>
                                    </button>
                                    <button class="memory-delete-btn" onclick="deleteMemoryItem('${memory.id}', '${type}')" title="删除">
                                        <i class="fas fa-trash"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="memory-modal-content" data-original-content="${displayContent.replace(/"/g, '&quot;')}">${displayContent}</div>
                            ${importance}
                        </div>
                    `;
                }).join('');
            }

            const modalHTML = `
                <div id="memory-view-modal" class="modal" style="display: flex;">
                    <div class="modal-content" style="max-width: 600px; max-height: 80vh;">
                        <div class="modal-header">
                            <h3>${currentChatCharacter.name} 的${title}</h3>
                            <button class="modal-close" onclick="hideMemoryModal()">×</button>
                        </div>
                        <div class="modal-body" style="max-height: 60vh; overflow-y: auto;">
                            ${content}
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        // 隐藏记忆模态框
        function hideMemoryModal() {
            const modal = document.getElementById('memory-view-modal');
            if (modal) modal.remove();
        }

        // 🔥【新增】切换编辑模式
        function toggleEditMode(memoryId, type) {
            const memoryItem = document.querySelector(`[data-memory-id="${memoryId}"]`);
            if (!memoryItem) return;

            const contentDiv = memoryItem.querySelector('.memory-modal-content');
            const editBtn = memoryItem.querySelector('.memory-edit-btn');
            const saveBtn = memoryItem.querySelector('.memory-save-btn');
            const cancelBtn = memoryItem.querySelector('.memory-cancel-btn');
            const deleteBtn = memoryItem.querySelector('.memory-delete-btn');

            // 切换到编辑模式
            const originalContent = contentDiv.getAttribute('data-original-content');

            // 创建文本域
            contentDiv.innerHTML = `
                <textarea class="memory-edit-textarea" style="
                    width: calc(100% - 16px);
                    max-width: 500px;
                    min-height: 80px;
                    padding: 12px;
                    border: 2px solid #007AFF;
                    border-radius: 8px;
                    font-size: 13px;
                    line-height: 1.5;
                    resize: vertical;
                    font-family: inherit;
                    background: #f8f9fa;
                    box-sizing: border-box;
                    margin: 0;
                ">${originalContent}</textarea>
            `;

            // 切换按钮显示
            editBtn.style.display = 'none';
            saveBtn.style.display = 'inline-block';
            cancelBtn.style.display = 'inline-block';
            deleteBtn.style.display = 'none';

            // 聚焦到文本域
            const textarea = contentDiv.querySelector('.memory-edit-textarea');
            textarea.focus();
            textarea.setSelectionRange(textarea.value.length, textarea.value.length);
        }

        // 🔥【新增】保存记忆编辑
        async function saveMemoryEdit(memoryId, type) {
            const memoryItem = document.querySelector(`[data-memory-id="${memoryId}"]`);
            if (!memoryItem) return;

            const contentDiv = memoryItem.querySelector('.memory-modal-content');
            const textarea = contentDiv.querySelector('.memory-edit-textarea');
            const newContent = textarea.value.trim();

            if (!newContent) {
                showToast('内容不能为空', 'error');
                return;
            }

            try {
                let memory;
                let fieldName;

                if (type === 'core') {
                    memory = await db.coreMemories.get(memoryId);
                    fieldName = 'fact';
                } else if (type === 'summary') {
                    memory = await db.memorySummaries.get(memoryId);
                    fieldName = 'summary';
                }

                if (!memory) {
                    showToast('记忆不存在', 'error');
                    return;
                }

                // 更新记忆内容
                memory[fieldName] = newContent;

                if (type === 'core') {
                    await db.coreMemories.put(memory);
                    showToast('核心记忆已更新', 'success');
                } else if (type === 'summary') {
                    await db.memorySummaries.put(memory);
                    showToast('记忆摘要已更新', 'success');
                }

                // 退出编辑模式
                exitEditMode(memoryId, newContent);

            } catch (error) {
                console.error('保存记忆失败:', error);
                showToast('保存记忆失败', 'error');
            }
        }

        // 🔥【新增】取消记忆编辑
        function cancelMemoryEdit(memoryId, type) {
            const memoryItem = document.querySelector(`[data-memory-id="${memoryId}"]`);
            if (!memoryItem) return;

            const contentDiv = memoryItem.querySelector('.memory-modal-content');
            const originalContent = contentDiv.getAttribute('data-original-content');

            // 退出编辑模式
            exitEditMode(memoryId, originalContent);
        }

        // 🔥【新增】退出编辑模式
        function exitEditMode(memoryId, content) {
            const memoryItem = document.querySelector(`[data-memory-id="${memoryId}"]`);
            if (!memoryItem) return;

            const contentDiv = memoryItem.querySelector('.memory-modal-content');
            const editBtn = memoryItem.querySelector('.memory-edit-btn');
            const saveBtn = memoryItem.querySelector('.memory-save-btn');
            const cancelBtn = memoryItem.querySelector('.memory-cancel-btn');
            const deleteBtn = memoryItem.querySelector('.memory-delete-btn');

            // 恢复内容显示
            contentDiv.innerHTML = content;
            contentDiv.setAttribute('data-original-content', content);

            // 切换按钮显示
            editBtn.style.display = 'inline-block';
            saveBtn.style.display = 'none';
            cancelBtn.style.display = 'none';
            deleteBtn.style.display = 'inline-block';
        }

        // 🔥【新增】删除记忆项
        async function deleteMemoryItem(memoryId, type) {
            if (!confirm('确定要删除这条记忆吗？')) {
                return;
            }

            try {
                if (type === 'core') {
                    await db.coreMemories.delete(memoryId);
                    showToast('核心记忆已删除', 'success');
                } else if (type === 'summary') {
                    await db.memorySummaries.delete(memoryId);
                    showToast('记忆摘要已删除', 'success');
                }

                // 刷新模态框内容
                if (type === 'core') {
                    viewCoreMemories();
                } else if (type === 'summary') {
                    viewMemorySummaries();
                }
            } catch (error) {
                console.error('删除记忆失败:', error);
                showToast('删除记忆失败', 'error');
            }
        }

        // 查看核心记忆
        async function viewCoreMemories() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'error');
                return;
            }

            // 🔥【修复】自动关闭全局记忆设置模态框
            hideGlobalMemorySettings();

            // 🔥【新增】显示加载动画
            const loadingModal = showLoadingModal('正在加载核心记忆...', '读取重要信息中');

            try {
                const coreMemories = await db.coreMemories
                    .where('characterId')
                    .equals(currentChatCharacter.id)
                    .toArray();

                // 手动排序并限制数量
                coreMemories.sort((a, b) => (b.importance || 0) - (a.importance || 0));
                const limitedMemories = coreMemories.slice(0, 10);

                // 🔥【新增】隐藏加载动画
                hideLoadingModal(loadingModal);

                showMemoryModal('核心记忆', limitedMemories, 'core');
            } catch (error) {
                // 🔥【新增】出错时也要隐藏加载动画
                hideLoadingModal(loadingModal);
                console.error('查看核心记忆失败:', error);
                showToast('查看核心记忆失败', 'error');
            }
        }

        // 查看记忆摘要
        async function viewMemorySummaries() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'error');
                return;
            }

            // 🔥【修复】自动关闭全局记忆设置模态框
            hideGlobalMemorySettings();

            // 🔥【新增】显示加载动画
            const loadingModal = showLoadingModal('正在加载记忆摘要...', '读取对话总结中');

            try {
                const memorySummaries = await db.memorySummaries
                    .where('characterId')
                    .equals(currentChatCharacter.id)
                    .toArray();

                // 手动排序并限制数量
                memorySummaries.sort((a, b) => b.timestamp - a.timestamp);
                const limitedSummaries = memorySummaries.slice(0, 10);

                // 🔥【新增】隐藏加载动画
                hideLoadingModal(loadingModal);

                showMemoryModal('记忆摘要', limitedSummaries, 'summary');
            } catch (error) {
                // 🔥【新增】出错时也要隐藏加载动画
                hideLoadingModal(loadingModal);
                console.error('查看记忆摘要失败:', error);
                showToast('查看记忆摘要失败', 'error');
            }
        }

        // 生成今日摘要
        async function generateDailySummary() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'error');
                return;
            }

            // 🔥【新增】显示加载动画
            const loadingModal = showLoadingModal('正在生成今日摘要...', '这可能需要几秒钟时间');

            try {
                const today = new Date();
                const startTime = new Date(today.getFullYear(), today.getMonth(), today.getDate()).getTime();
                const endTime = startTime + 24 * 60 * 60 * 1000;

                const summary = await generateMemorySummary(
                    currentChatCharacter.id,
                    startTime,
                    endTime,
                    {
                        type: currentChatCharacter.isGroup ? 'group_chat' : 'private_chat',
                        id: currentChatCharacter.id
                    }
                );

                // 🔥【新增】隐藏加载动画
                hideLoadingModal(loadingModal);

                if (summary) {
                    showToast('今日摘要生成成功', 'success');
                    alert(`今日摘要已生成：\n\n${summary.summary}`);
                } else {
                    showToast('今天暂无活动可生成摘要', 'warning');
                }
            } catch (error) {
                // 🔥【新增】出错时也要隐藏加载动画
                hideLoadingModal(loadingModal);
                console.error('生成今日摘要失败:', error);
                showToast('生成今日摘要失败', 'error');
            }
        }

        // 记忆共享设置
        function showMemoryShareSettings() {
            if (!currentChatCharacter || currentChatCharacter.isGroup) {
                showToast('此功能仅适用于单聊', 'error');
                return;
            }

            // 获取当前角色参与的所有群聊
            const characterGroups = groupChats.filter(group =>
                group.members && group.members.some(member => member.id === currentChatCharacter.id)
            );

            if (characterGroups.length === 0) {
                showToast('该角色还没有参与任何群聊', 'warning');
                return;
            }

            const chatSettings = getCurrentChatSettings();
            const currentSharedGroups = chatSettings.memorySharedGroupIds || [];

            const modalHTML = `
                <div id="memory-share-modal" class="modal phone-modal" style="display: block;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 class="modal-title">记忆共享设置</h3>
                            <button class="modal-close" onclick="hideMemoryShareSettings()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="setting-section">
                                <h4>选择要共享记忆的群聊</h4>
                                <div class="checkbox-group">
                                    ${characterGroups.map(group => `
                                        <label class="checkbox-option">
                                            <input type="checkbox" name="sharedGroups" value="${group.id}" ${currentSharedGroups.includes(group.id) ? 'checked' : ''}>
                                            <span class="checkbox-custom"></span>
                                            <div class="checkbox-content">
                                                <div class="checkbox-title">${group.name}</div>
                                                <div class="checkbox-desc">与此群聊共享记忆</div>
                                            </div>
                                        </label>
                                    `).join('')}
                                </div>
                            </div>

                            <div class="setting-section">
                                <h4>功能说明</h4>
                                <div class="info-text">
                                    • 开启后，角色在单聊中能记住群聊的内容<br>
                                    • 角色在群聊中也能记住单聊的内容<br>
                                    • 实现真正的跨场景记忆连贯性<br>
                                    • 可以同时选择多个群聊进行记忆共享
                                </div>
                            </div>
                        </div>
                        <div class="modal-actions">
                            <button class="modal-button modal-secondary" onclick="hideMemoryShareSettings()">取消</button>
                            <button class="modal-button modal-primary" onclick="saveMemoryShareSettings()">保存设置</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        // 保存记忆共享设置
        async function saveMemoryShareSettings() {
            const selectedGroups = Array.from(document.querySelectorAll('input[name="sharedGroups"]:checked'))
                .map(checkbox => checkbox.value);

            const chatSettings = getCurrentChatSettings();
            chatSettings.memorySharedGroupIds = selectedGroups;

            // 🔥【兼容性】保留旧的单选字段，使用第一个选中的群聊
            chatSettings.memorySharedGroupId = selectedGroups.length > 0 ? selectedGroups[0] : '';

            await saveChatSettings();

            // 更新显示状态
            updateMemoryShareStatus();

            hideMemoryShareSettings();

            if (selectedGroups.length > 0) {
                const groupNames = selectedGroups.map(id => {
                    const group = groupChats.find(g => g.id === id);
                    return group ? group.name : '未知群聊';
                }).join('、');
                showToast(`已开启与"${groupNames}"的记忆共享`, 'success');
            } else {
                showToast('已关闭记忆共享', 'success');
            }
        }

        // 隐藏记忆共享设置
        function hideMemoryShareSettings() {
            const modal = document.getElementById('memory-share-modal');
            if (modal) modal.remove();
        }

        // 更新记忆共享状态显示
        function updateMemoryShareStatus() {
            const statusElement = document.getElementById('memory-share-status');
            if (!statusElement) return;

            const chatSettings = getCurrentChatSettings();
            const sharedGroupIds = chatSettings.memorySharedGroupIds || [];

            if (sharedGroupIds.length > 0) {
                if (sharedGroupIds.length === 1) {
                    const group = groupChats.find(g => g.id === sharedGroupIds[0]);
                    statusElement.textContent = group ? `与"${group.name}"共享` : '已开启';
                } else {
                    statusElement.textContent = `与${sharedGroupIds.length}个群聊共享`;
                }
            } else {
                statusElement.textContent = '已关闭';
            }
        }

        // ================== 日记功能系统 ==================

        // 从日记界面返回到来源界面
        function backFromDiary() {
            // 检查是否在单个日记视图中
            const singleDiaryView = document.getElementById('single-diary-view');
            if (singleDiaryView && singleDiaryView.classList.contains('active')) {
                // 从单个日记视图返回到过往日记列表
                backFromSingleDiary();
                return;
            }

            // 获取来源界面，默认返回聊天界面
            const sourceScreen = window.diarySourceScreen || 'api-chat-screen';

            // 隐藏日记界面
            hideApp('diary-screen');

            // 显示来源界面
            showApp(sourceScreen);

            // 清除来源记录
            window.diarySourceScreen = null;
        }

        // 显示日记界面
        function showDiaryMenu() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'error');
                return;
            }

            // 🔥【修改】群聊中不支持日记功能
            if (currentChatCharacter.isGroup) {
                showToast('群聊中不支持日记功能，请在单聊中使用', 'error');
                return;
            }

            // 🔥【新增】记录来源界面，用于返回导航
            window.diarySourceScreen = 'api-chat-screen';

            // 显示全屏日记界面
            showApp('diary-screen');
            // 初始化纸张设置
            initDiaryPaper();
            // 默认显示今日日记
            switchDiaryTab('today');
            // 加载今日日记内容
            loadTodayDiary();
        }

        // 切换日记选项卡
        function switchDiaryTab(tabName) {
            // 更新视图显示
            document.querySelectorAll('.diary-view').forEach(view => {
                view.classList.remove('active');
            });

            const titleElement = document.getElementById('diary-mode-title');
            const editBtn = document.getElementById('edit-diary-btn');

            if (tabName === 'today') {
                document.getElementById('today-diary-view').classList.add('active');
                if (titleElement) titleElement.textContent = '今日日记';
                loadTodayDiary();
            } else if (tabName === 'past') {
                document.getElementById('past-diaries-view').classList.add('active');
                if (titleElement) titleElement.textContent = '过往日记';
                if (editBtn) editBtn.style.display = 'none';
                loadPastDiaries();
            }
        }

        // ================== 游戏功能系统 ==================

        // 🎮【新增】五子棋游戏状态管理
        let gomokuGameState = {
            board: null,
            currentPlayer: 'user', // 'user' 或 'ai'
            gameActive: false,
            gameStartTime: null,
            gameSession: null, // 临时游戏活动日志
            chatHistory: [], // 游戏内聊天记录
            moveHistory: [], // 棋步历史
            gameTimer: null,
            // 🎮【移除】难度系统已删除，AI根据角色性格下棋
        };

        // 🎮【移除】难度配置系统已删除，AI根据角色性格和智能程度下棋

        // 显示游戏菜单
        function showGameMenu() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'error');
                return;
            }

            // 根据单聊/群聊生成不同的游戏选项
            generateGameButtons();
            showModal('game-menu-modal');
        }

        // 生成游戏按钮
        function generateGameButtons() {
            const container = document.getElementById('game-buttons-container');
            const isGroup = currentChatCharacter && currentChatCharacter.isGroup;

            // 定义游戏数据
            const allGames = {
                'gomoku': {
                    name: '五子棋',
                    desc: '经典棋类游戏，适合单聊',
                    icon: 'fas fa-chess-board',
                    class: 'gomoku',
                    badge: null,
                    badgeText: '',
                    singleChat: true,
                    groupChat: false,
                    available: true
                },
                'turtle-soup': {
                    name: '海龟汤（不完善慎点）',
                    desc: '推理解谜游戏，适合单聊和群聊',
                    icon: 'fas fa-question-circle',
                    class: 'turtle-soup',
                    badge: null,
                    badgeText: '',
                    singleChat: true,
                    groupChat: true,
                    available: true
                },
                'werewolf': {
                    name: '狼人杀',
                    desc: '多人推理游戏，适合群聊',
                    icon: 'fas fa-moon',
                    class: 'werewolf',
                    badge: 'coming-soon',
                    badgeText: '开发中',
                    singleChat: false,
                    groupChat: true,
                    available: false
                },
                'monopoly': {
                    name: '大富翁',
                    desc: '经营策略游戏，适合群聊',
                    icon: 'fas fa-building',
                    class: 'monopoly',
                    badge: 'coming-soon',
                    badgeText: '开发中',
                    singleChat: false,
                    groupChat: true,
                    available: false
                }
            };

            // 根据聊天类型筛选游戏
            const availableGames = Object.entries(allGames).filter(([key, game]) => {
                return isGroup ? game.groupChat : game.singleChat;
            });

            // 生成按钮HTML
            container.innerHTML = availableGames.map(([key, game]) => {
                const disabledClass = game.available ? '' : ' disabled';
                const badgeHtml = game.badge ? `<div class="game-button-badge ${game.badge}">${game.badgeText}</div>` : '';

                return `
                    <button class="game-button ${game.class}${disabledClass}" onclick="selectGame('${key}')" ${!game.available ? 'disabled' : ''}>
                        <div class="game-button-icon">
                            <i class="${game.icon}"></i>
                        </div>
                        <div class="game-button-content">
                            <div class="game-button-title">${game.name}</div>
                            <div class="game-button-desc">${game.desc}</div>
                        </div>
                        ${badgeHtml}
                    </button>
                `;
            }).join('');
        }

        // 隐藏游戏菜单
        function hideGameMenu() {
            hideModal('game-menu-modal');
        }

        // 选择游戏
        function selectGame(gameType) {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'error');
                return;
            }

            // 检查游戏是否可用
            if (gameType === 'werewolf' || gameType === 'monopoly') {
                showToast('该游戏正在开发中，敬请期待！', 'info');
                return;
            }

            hideGameMenu();

            // 显示等待模态框
            showWaitingModal();

            // 调用API告诉AI用户要玩什么游戏
            requestGameWithAI(gameType);
        }

        function showWaitingModal() {
            const waitingModal = document.createElement('div');
            waitingModal.className = 'waiting-modal';
            waitingModal.id = 'waitingModal';
            waitingModal.innerHTML = `
                <div class="waiting-modal-content">
                    <div class="waiting-spinner"></div>
                    <p class="waiting-text">正在等待对方接受...</p>
                </div>
            `;
            document.body.appendChild(waitingModal);
        }

        function hideWaitingModal() {
            const waitingModal = document.getElementById('waitingModal');
            if (waitingModal) {
                waitingModal.remove();
            }
        }

        function requestGameWithAI(gameType) {
            const gameNames = {
                'gomoku': '五子棋',
                'turtle-soup': '海龟汤',
                'werewolf': '狼人杀',
                'monopoly': '大富翁'
            };

            const gameName = gameNames[gameType] || gameType;

            // 模拟API调用
            setTimeout(() => {
                // AI根据人设决定是否接受
                const shouldAccept = Math.random() > 0.2; // 80%概率接受

                hideWaitingModal();

                if (shouldAccept) {
                    // AI接受邀请，启动游戏
                    startGameSession(gameType, gameName);
                } else {
                    // AI拒绝邀请
                    showToast(`${currentChatCharacter.name}拒绝了你的${gameName}邀请，可能现在不太方便呢~`, 'info');
                }
            }, 2000 + Math.random() * 2000); // 2-4秒随机等待时间
        }

        // 开始游戏会话
        function startGameSession(gameType, gameName) {
            showToast(`正在启动${gameName}...`, 'info');

            setTimeout(async () => {
                if (gameType === 'gomoku') {
                    // 启动五子棋游戏
                    await startGomokuGame();
                } else if (gameType === 'turtle-soup') {
                    // 启动海龟汤游戏
                    await startTurtleSoupGame();
                } else {
                    // 其他游戏暂时显示开发中提示
                    alert(`🎮 ${gameName}游戏界面开发中...\n\n即将支持：\n• 全屏游戏界面（上方70%游戏区，下方30%聊天区）\n• 实时游戏状态同步\n• 游戏中聊天记录\n• 游戏结果记录到记忆系统`);
                }
            }, 500);
        }

        // 🎮【新增】启动五子棋游戏
        function startGomokuGame() {
            // 检查是否有保存的游戏
            const savedGame = localStorage.getItem('gomoku_saved_game');

            if (savedGame) {
                // 显示继续游戏选项
                showContinueGameModal();
            } else {
                // 直接开始新游戏
                startNewGomokuGame();
            }
        }

        // 🎮【新增】显示继续游戏选项
        function showContinueGameModal() {
            const modal = document.createElement('div');
            modal.className = 'game-exit-modal';
            modal.innerHTML = `
                <div class="game-exit-overlay"></div>
                <div class="game-exit-content">
                    <div class="game-exit-header">
                        <h3>发现保存的游戏</h3>
                    </div>
                    <div class="game-exit-body">
                        <p class="game-exit-desc">检测到有未完成的五子棋游戏，请选择：</p>
                        <div class="game-exit-options">
                            <button class="game-exit-btn pause-btn" onclick="continueGomokuGame()">
                                <i class="fas fa-play-circle"></i>
                                <div class="btn-content">
                                    <div class="btn-title">继续上一局游戏</div>
                                </div>
                            </button>
                            <button class="game-exit-btn save-btn" onclick="startNewGomokuGameFromModal()">
                                <i class="fas fa-plus-circle"></i>
                                <div class="btn-content">
                                    <div class="btn-title">开始新游戏</div>
                                    <div class="btn-desc">将清除保存的游戏</div>
                                </div>
                            </button>
                        </div>
                    </div>
                </div>
            `;
            // 将模态框添加到手机屏幕内，这样定位就相对于手机屏幕
            const phoneScreen = document.getElementById('phone-screen');
            if (phoneScreen) {
                phoneScreen.appendChild(modal);
            } else {
                document.body.appendChild(modal);
            }
        }

        // 🎮【新增】继续保存的游戏
        function continueGomokuGame() {
            const savedGame = JSON.parse(localStorage.getItem('gomoku_saved_game'));

            // 关闭模态框
            document.querySelector('.game-exit-modal').remove();

            // 隐藏聊天界面，显示游戏界面
            hideApp('chat-screen');
            showApp('gomoku-game-screen');

            // 恢复游戏状态
            gomokuGameState = {
                board: savedGame.board,
                currentPlayer: savedGame.currentPlayer,
                gameActive: true,
                gameStartTime: savedGame.startTime,
                userIsBlack: savedGame.userIsBlack || true, // 兼容旧版本保存的游戏
                // 🎮【移除】难度系统已删除
                gameSession: savedGame.gameSession,
                chatHistory: savedGame.chatHistory || [],
                moveHistory: savedGame.moveHistory,
                gameTimer: null
            };

            // 添加时间桥梁消息
            gomokuGameState.gameSession.gameEvents.push({
                type: 'game_resume',
                timestamp: Date.now(),
                player: 'system',
                data: { reason: '继续之前暂停的游戏' }
            });

            // 创建棋盘并恢复状态
            createGomokuBoard();
            updateBoardUI();
            updateGomokuUI();
            updatePlayerPieceDisplay();
            startGameTimer();
            setupAIPlayerInfo();

            // 重新设置棋子显示（因为setupAIPlayerInfo可能会覆盖）
            updatePlayerPieceDisplay();

            // 恢复聊天记录
            const chatContainer = document.getElementById('gomoku-chat-messages');
            chatContainer.innerHTML = '';
            if (savedGame.chatHistory) {
                savedGame.chatHistory.forEach(msg => {
                    addGameChatMessage(msg.sender, msg.content, false);
                });
            }

            // 添加继续游戏的系统消息
            addGameChatMessage('system', '🎮 继续之前的游戏...');
            addGameChatMessage('ai', '欢迎回来！我们继续刚才的对局吧~', true);
        }

        // 🎮【新增】从模态框开始新游戏
        function startNewGomokuGameFromModal() {
            // 清除保存的游戏
            localStorage.removeItem('gomoku_saved_game');

            // 关闭模态框
            document.querySelector('.game-exit-modal').remove();

            // 开始新游戏
            startNewGomokuGame();
        }

        // 🎮【新增】开始新的五子棋游戏
        function startNewGomokuGame() {
            // 隐藏聊天界面，显示游戏界面
            hideApp('chat-screen');
            showApp('gomoku-game-screen');

            // 初始化游戏状态
            initGomokuGame();

            // 记录游戏开始事件
            recordGameStart();
        }

        // 🎮【新增】初始化五子棋游戏
        async function initGomokuGame() {
            // 🎲 随机分配黑白子
            const userIsBlack = Math.random() < 0.5; // 50%概率用户拿黑子
            const firstPlayer = userIsBlack ? 'user' : 'ai';

            // 重置游戏状态
            gomokuGameState = {
                board: Array(15).fill().map(() => Array(15).fill(null)),
                currentPlayer: firstPlayer,
                gameActive: true,
                gameStartTime: Date.now(),
                userIsBlack: userIsBlack, // 记录用户是否拿黑子
                // 🎮【移除】难度系统已删除
                gameSession: {
                    gameId: `gomoku_${Date.now()}`,
                    players: ['user', currentChatCharacter.id],
                    boardState: [],
                    chatHistory: [],
                    gameEvents: [
                        {
                            type: 'game_start',
                            timestamp: Date.now(),
                            player: 'system',
                            data: {
                                gameName: '五子棋',
                                userIsBlack: userIsBlack,
                                firstPlayer: firstPlayer
                            }
                        }
                    ]
                },
                chatHistory: [],
                moveHistory: [],
                gameTimer: null
            };

            // 创建棋盘
            createGomokuBoard();

            // 更新UI
            updateGomokuUI();
            updatePlayerPieceDisplay();

            // 启动计时器
            startGameTimer();

            // 设置AI角色信息
            setupAIPlayerInfo();

            // 重新设置棋子显示（因为setupAIPlayerInfo可能会覆盖）
            updatePlayerPieceDisplay();

            // 添加欢迎消息
            const userPieceText = userIsBlack ? '黑子' : '白子';
            const aiPieceText = userIsBlack ? '白子' : '黑子';
            const firstPlayerText = firstPlayer === 'user' ? '你先行' : '对方先行';

            addGameChatMessage('system', `🎮 五子棋游戏开始！你执${userPieceText}，${firstPlayerText}。`);

            // 🎮【删除】游戏开始时的自动回复
            if (currentChatCharacter) {
                // 记录游戏开始事件
                await recordGameEvent(currentChatCharacter.id, 'game_start', {
                    gameName: '五子棋',
                    result: null,
                    score: null,
                    chatContent: `游戏开始，你执${aiPieceText}，用户执${userPieceText}，${firstPlayer === 'user' ? '用户先行' : '你先行'}`
                });

                // 不再发送自动回复消息
            }

            // 如果AI先走，延迟一下再下第一步
            if (firstPlayer === 'ai') {
                setTimeout(() => {
                    makeAIMove();
                }, 2000); // 给AI回应留出时间
            }
        }



        // 🎮【新增】创建棋盘
        function createGomokuBoard() {
            const board = document.getElementById('gomoku-board');
            board.innerHTML = '';

            // 创建14x14的格子作为背景
            for (let row = 0; row < 14; row++) {
                for (let col = 0; col < 14; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'gomoku-cell';
                    board.appendChild(cell);
                }
            }

            // 在格子上创建15x15的交叉点点击区域
            for (let row = 0; row < 15; row++) {
                for (let col = 0; col < 15; col++) {
                    const intersection = document.createElement('div');
                    intersection.className = 'gomoku-intersection';
                    intersection.dataset.row = row;
                    intersection.dataset.col = col;
                    intersection.onclick = () => handleCellClick(row, col);

                    // 计算交叉点位置
                    const cellSize = 300 / 14; // 每个格子的大小约21.43px
                    const intersectionSize = 16; // 交叉点点击区域大小
                    intersection.style.position = 'absolute';
                    intersection.style.left = `${col * cellSize - intersectionSize/2}px`;
                    intersection.style.top = `${row * cellSize - intersectionSize/2}px`;
                    intersection.style.width = `${intersectionSize}px`;
                    intersection.style.height = `${intersectionSize}px`;
                    intersection.style.cursor = 'pointer';
                    intersection.style.borderRadius = '50%';
                    intersection.style.transition = 'background-color 0.2s ease';
                    intersection.style.display = 'flex';
                    intersection.style.alignItems = 'center';
                    intersection.style.justifyContent = 'center';
                    intersection.style.zIndex = '10';

                    board.appendChild(intersection);
                }
            }
        }

        // 🎮【新增】处理棋盘点击
        async function handleCellClick(row, col) {
            if (!gomokuGameState.gameActive ||
                gomokuGameState.currentPlayer !== 'user' ||
                gomokuGameState.board[row][col] !== null) {
                return;
            }

            // 用户下棋
            await makeMove(row, col, 'user');
        }

        // 🎮【新增】下棋
        async function makeMove(row, col, player) {
            // 更新棋盘状态
            gomokuGameState.board[row][col] = player;

            // 记录棋步
            const move = {
                row,
                col,
                player,
                timestamp: Date.now(),
                moveNumber: gomokuGameState.moveHistory.length + 1
            };
            gomokuGameState.moveHistory.push(move);

            // 记录到游戏事件
            gomokuGameState.gameSession.gameEvents.push({
                type: 'move',
                timestamp: Date.now(),
                player: player,
                data: { row, col, moveNumber: move.moveNumber }
            });

            // 更新UI
            updateBoardUI();

            // 🎮【修复】立即切换玩家状态并更新UI
            gomokuGameState.currentPlayer = player === 'user' ? 'ai' : 'user';
            updateGomokuUI();

            // 🎮【删除API调用】移除用户威胁检测的API回应
            // 用户威胁检测的API调用已删除

            // 检查胜负
            const winner = checkWinner(row, col);
            if (winner) {
                endGame(winner);
                return;
            }

            // 检查平局
            if (gomokuGameState.moveHistory.length >= 225) {
                endGame('draw');
                return;
            }

            // 如果轮到AI，延迟一下再下棋
            if (gomokuGameState.currentPlayer === 'ai') {
                // 🎮【新增】显示AI思考状态
                setTimeout(() => {
                    const statusElement = document.getElementById('current-turn');
                    statusElement.textContent = '对方思考中…';
                    statusElement.style.color = '#718096';
                }, 500); // 0.5秒后显示思考状态

                setTimeout(() => {
                    makeAIMove();
                }, 1000 + Math.random() * 2000); // 1-3秒随机延迟
            }
        }

        // 🎮【重构】AI根据人设智能下棋
        async function makeAIMove() {
            if (!gomokuGameState.gameActive || gomokuGameState.currentPlayer !== 'ai') {
                return;
            }

            if (!currentChatCharacter) {
                // 如果没有角色，使用备用算法
                makeBackupMove();
                return;
            }

            try {
                // 显示AI思考状态
                const statusElement = document.getElementById('current-turn');
                statusElement.textContent = `${currentChatCharacter.name}正在思考...`;
                statusElement.style.color = '#718096';

                // 调用AI API决定下棋位置
                const aiMove = await getAIMoveFromAPI();

                if (aiMove && aiMove.row !== undefined && aiMove.col !== undefined) {
                    // 验证AI选择的位置是否有效
                    if (isValidMove(aiMove.row, aiMove.col)) {
                        setTimeout(async () => {
                            await makeMove(aiMove.row, aiMove.col, 'ai');

                            // 如果AI提供了思考过程，显示出来
                            if (aiMove.reasoning) {
                                setTimeout(() => {
                                    addGameChatMessage('ai', aiMove.reasoning, true);
                                }, 500);
                            }
                        }, 800 + Math.random() * 1200); // 0.8-2秒思考时间
                    } else {
                        console.warn('AI选择了无效位置，使用备用算法');
                        makeBackupMove();
                    }
                } else {
                    console.warn('AI未返回有效走法，使用备用算法');
                    makeBackupMove();
                }
            } catch (error) {
                console.error('AI下棋API调用失败:', error);
                makeBackupMove();
            }
        }

        // 🎮【新增】随机下棋（犯错时使用）
        function makeRandomMove() {
            const emptyCells = [];
            for (let row = 0; row < 15; row++) {
                for (let col = 0; col < 15; col++) {
                    if (gomokuGameState.board[row][col] === null) {
                        emptyCells.push({ row, col });
                    }
                }
            }

            if (emptyCells.length > 0) {
                const randomIndex = Math.floor(Math.random() * emptyCells.length);
                const { row, col } = emptyCells[randomIndex];

                setTimeout(async () => {
                    await makeMove(row, col, 'ai');
                }, 500);
            }
        }

        // 🎮【新增】寻找最佳下棋位置
        function findBestMove(depth) {
            const board = gomokuGameState.board;

            // 优先级1：检查AI是否能获胜
            const winMove = findWinningMove('ai');
            if (winMove) return winMove;

            // 优先级2：阻止用户获胜
            const blockMove = findWinningMove('user');
            if (blockMove) return blockMove;

            // 优先级3：根据深度进行更深层分析
            if (depth >= 2) {
                const strategicMove = findStrategicMove(depth);
                if (strategicMove) return strategicMove;
            }

            // 优先级4：选择中心区域
            const centerMove = findCenterMove();
            if (centerMove) return centerMove;

            return null;
        }

        // 🎮【新增】寻找获胜位置
        function findWinningMove(player) {
            for (let row = 0; row < 15; row++) {
                for (let col = 0; col < 15; col++) {
                    if (gomokuGameState.board[row][col] === null) {
                        // 模拟下棋
                        gomokuGameState.board[row][col] = player;
                        if (checkWinner(row, col)) {
                            gomokuGameState.board[row][col] = null; // 恢复
                            return { row, col };
                        }
                        gomokuGameState.board[row][col] = null; // 恢复
                    }
                }
            }
            return null;
        }

        // 🎮【新增】寻找战略位置
        function findStrategicMove(depth) {
            // 简化的战略分析：寻找能形成多个威胁的位置
            let bestScore = -1;
            let bestMove = null;

            for (let row = 0; row < 15; row++) {
                for (let col = 0; col < 15; col++) {
                    if (gomokuGameState.board[row][col] === null) {
                        const score = evaluatePosition(row, col, 'ai');
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = { row, col };
                        }
                    }
                }
            }

            return bestMove;
        }

        // 🎮【新增】寻找中心位置
        function findCenterMove() {
            const center = 7;
            const candidates = [];

            // 优先选择中心附近的位置
            for (let radius = 0; radius <= 3; radius++) {
                for (let row = center - radius; row <= center + radius; row++) {
                    for (let col = center - radius; col <= center + radius; col++) {
                        if (row >= 0 && row < 15 && col >= 0 && col < 15 &&
                            gomokuGameState.board[row][col] === null) {
                            candidates.push({ row, col });
                        }
                    }
                }
                if (candidates.length > 0) break;
            }

            return candidates.length > 0 ? candidates[Math.floor(Math.random() * candidates.length)] : null;
        }

        // 🎮【新增】评估位置价值
        function evaluatePosition(row, col, player) {
            let score = 0;
            const directions = [[0,1], [1,0], [1,1], [1,-1]];

            for (const [dx, dy] of directions) {
                score += evaluateDirection(row, col, dx, dy, player);
            }

            return score;
        }

        // 🎮【新增】评估方向价值
        function evaluateDirection(row, col, dx, dy, player) {
            let count = 1; // 包括当前位置
            let openEnds = 0;

            // 向正方向检查
            let r = row + dx, c = col + dy;
            while (r >= 0 && r < 15 && c >= 0 && c < 15 && gomokuGameState.board[r][c] === player) {
                count++;
                r += dx;
                c += dy;
            }
            if (r >= 0 && r < 15 && c >= 0 && c < 15 && gomokuGameState.board[r][c] === null) {
                openEnds++;
            }

            // 向负方向检查
            r = row - dx;
            c = col - dy;
            while (r >= 0 && r < 15 && c >= 0 && c < 15 && gomokuGameState.board[r][c] === player) {
                count++;
                r -= dx;
                c -= dy;
            }
            if (r >= 0 && r < 15 && c >= 0 && c < 15 && gomokuGameState.board[r][c] === null) {
                openEnds++;
            }

            // 根据连子数和开放端数评分
            if (count >= 5) return 10000; // 获胜
            if (count === 4 && openEnds > 0) return 1000; // 冲四
            if (count === 3 && openEnds === 2) return 100; // 活三
            if (count === 3 && openEnds === 1) return 10; // 眠三
            if (count === 2 && openEnds === 2) return 5; // 活二

            return count * openEnds;
        }

        // 🎮【新增】AI智能下棋API调用
        async function getAIMoveFromAPI() {
            if (!currentChatCharacter) return null;

            // 构建棋盘状态描述
            const boardDescription = getBoardDescription();
            const moveHistory = getMoveHistoryDescription();
            const gameAnalysis = getGameAnalysis();

            const prompt = `你是${currentChatCharacter.name}，${currentChatCharacter.prompt}

现在你在和用户下五子棋。游戏规则：
- 棋盘是15x15，坐标从(0,0)到(14,14)
- 目标是连成5个子（横、竖、斜）
- 你执${gomokuGameState.userIsBlack ? '白子(O)' : '黑子(●)'}，用户执${gomokuGameState.userIsBlack ? '黑子(●)' : '白子(O)'}

当前游戏状态：
${boardDescription}

${moveHistory}

${gameAnalysis}

重要提醒：
1. 只能选择空位（·）下棋
2. 坐标格式：row(行)和col(列)都是0-14的整数
3. 优先考虑：获胜机会 > 阻止对手获胜 > 形成威胁 > 防守
4. 体现你的性格特点

请分析棋局并选择你的下一步，必须严格按照JSON格式回复：

{
    "row": 整数(0-14),
    "col": 整数(0-14),
    "reasoning": "简短解释选择这个位置的原因"
}

注意：只返回JSON，不要有其他文字！`;

            try {
                const response = await callChatAPI(prompt, currentChatCharacter);
                return parseAIMoveResponse(response);
            } catch (error) {
                console.error('AI下棋API调用失败:', error);
                return null;
            }
        }

        // 🎮【新增】分析威胁
        function analyzeThreats(row, col, player) {
            const threats = [];
            const directions = [[0,1], [1,0], [1,1], [1,-1]];

            for (const [dx, dy] of directions) {
                const count = countDirection(row, col, dx, dy, player);
                if (count >= 3) {
                    threats.push({ type: count === 3 ? 'three' : 'four', direction: [dx, dy] });
                }
            }

            return threats;
        }

        // 🎮【新增】计算方向上的连子数
        function countDirection(row, col, dx, dy, player) {
            let count = 1;

            // 正方向
            let r = row + dx, c = col + dy;
            while (r >= 0 && r < 15 && c >= 0 && c < 15 && gomokuGameState.board[r][c] === player) {
                count++;
                r += dx;
                c += dy;
            }

            // 负方向
            r = row - dx;
            c = col - dy;
            while (r >= 0 && r < 15 && c >= 0 && c < 15 && gomokuGameState.board[r][c] === player) {
                count++;
                r -= dx;
                c -= dy;
            }

            return count;
        }

        // 🎮【新增】检查是否阻止用户威胁
        function isBlockingUserThreat(row, col) {
            // 模拟用户在此位置下棋，看是否会形成威胁
            gomokuGameState.board[row][col] = 'user';
            const userThreats = analyzeThreats(row, col, 'user');
            gomokuGameState.board[row][col] = 'ai'; // 恢复AI棋子

            return userThreats.length > 0;
        }

        // 🎮【改进】棋盘状态描述函数 - 更清晰的格式
        function getBoardDescription() {
            let description = "当前棋盘状态（15x15，坐标从0开始，●=黑子，O=白子，·=空位）：\n";
            description += "   ";
            for (let col = 0; col < 15; col++) {
                description += col.toString().padStart(2, ' ');
            }
            description += "\n";

            for (let row = 0; row < 15; row++) {
                let rowStr = row.toString().padStart(2, ' ') + ' ';
                for (let col = 0; col < 15; col++) {
                    const piece = gomokuGameState.board[row][col];
                    if (piece === 'user') {
                        rowStr += gomokuGameState.userIsBlack ? '●' : 'O';
                    } else if (piece === 'ai') {
                        rowStr += gomokuGameState.userIsBlack ? 'O' : '●';
                    } else {
                        rowStr += '·';
                    }
                    if (col < 14) rowStr += ' ';
                }
                description += rowStr + '\n';
            }

            // 添加空位列表（只显示前20个空位）
            const emptyPositions = [];
            for (let row = 0; row < 15; row++) {
                for (let col = 0; col < 15; col++) {
                    if (gomokuGameState.board[row][col] === null) {
                        emptyPositions.push(`(${row},${col})`);
                    }
                }
            }

            if (emptyPositions.length > 0) {
                description += `\n可下棋位置示例: ${emptyPositions.slice(0, 20).join(', ')}`;
                if (emptyPositions.length > 20) {
                    description += ` 等${emptyPositions.length}个位置`;
                }
            }

            return description;
        }

        // 🎮【新增】历史走法描述
        function getMoveHistoryDescription() {
            if (gomokuGameState.moveHistory.length === 0) {
                return "这是游戏开始，还没有任何走法。";
            }

            let description = `历史走法（共${gomokuGameState.moveHistory.length}步）：\n`;
            const recentMoves = gomokuGameState.moveHistory.slice(-6); // 只显示最近6步

            recentMoves.forEach((move, index) => {
                const stepNum = gomokuGameState.moveHistory.length - recentMoves.length + index + 1;
                const player = move.player === 'user' ? '用户' : '你';
                description += `第${stepNum}步: ${player}在(${move.row},${move.col})下了${move.player === 'user' ? (gomokuGameState.userIsBlack ? '黑子●' : '白子O') : (gomokuGameState.userIsBlack ? '白子O' : '黑子●')}\n`;
            });

            return description;
        }

        // 🎮【新增】游戏分析
        function getGameAnalysis() {
            const totalMoves = gomokuGameState.moveHistory.length;
            let analysis = `游戏进行到第${totalMoves}步。`;

            if (totalMoves < 6) {
                analysis += " 现在还是开局阶段，需要抢占有利位置。";
            } else if (totalMoves < 15) {
                analysis += " 现在是中局，需要平衡攻防。";
            } else {
                analysis += " 现在是残局，每一步都很关键。";
            }

            return analysis;
        }

        // 🎮【改进】解析AI回复 - 增强错误处理和调试信息
        function parseAIMoveResponse(response) {
            try {
                let responseText = '';
                if (Array.isArray(response)) {
                    responseText = response[0];
                } else {
                    responseText = response;
                }

                console.log('🤖 AI原始回复:', responseText);

                // 尝试提取JSON
                const jsonMatch = responseText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const moveData = JSON.parse(jsonMatch[0]);
                    console.log('🎯 解析出的走法数据:', moveData);

                    // 验证数据格式和范围
                    if (typeof moveData.row === 'number' &&
                        typeof moveData.col === 'number' &&
                        moveData.row >= 0 && moveData.row <= 14 &&
                        moveData.col >= 0 && moveData.col <= 14) {

                        // 检查位置是否已被占用
                        if (gomokuGameState.board[moveData.row][moveData.col] !== null) {
                            console.warn(`🚫 AI选择的位置(${moveData.row},${moveData.col})已被占用:`, gomokuGameState.board[moveData.row][moveData.col]);
                            return null;
                        }

                        console.log(`✅ AI选择有效位置: (${moveData.row},${moveData.col})`);
                        return moveData;
                    } else {
                        console.warn('❌ AI回复的坐标格式或范围不正确:', moveData);
                    }
                } else {
                    console.warn('❌ 无法从AI回复中提取JSON:', responseText);
                }

                return null;
            } catch (error) {
                console.error('❌ 解析AI回复失败:', error, response);
                return null;
            }
        }

        // 🎮【新增】验证走法是否有效
        function isValidMove(row, col) {
            return row >= 0 && row < 15 &&
                   col >= 0 && col < 15 &&
                   gomokuGameState.board[row][col] === null;
        }

        // 🎮【新增】备用下棋算法（API失败时使用）
        function makeBackupMove() {
            // 使用简化的本地算法作为备用
            const bestMove = findBestMove(2); // 使用中等深度

            if (bestMove) {
                setTimeout(async () => {
                    await makeMove(bestMove.row, bestMove.col, 'ai');
                }, 500 + Math.random() * 1000);
            } else {
                makeRandomMove();
            }
        }

        // 🎮【新增】检查胜负
        function checkWinner(row, col) {
            const player = gomokuGameState.board[row][col];
            const directions = [
                [0, 1],   // 水平
                [1, 0],   // 垂直
                [1, 1],   // 对角线
                [1, -1]   // 反对角线
            ];

            for (const [dx, dy] of directions) {
                let count = 1;
                const winningCells = [{row, col}];

                // 向一个方向检查
                for (let i = 1; i < 5; i++) {
                    const newRow = row + dx * i;
                    const newCol = col + dy * i;
                    if (newRow >= 0 && newRow < 15 && newCol >= 0 && newCol < 15 &&
                        gomokuGameState.board[newRow][newCol] === player) {
                        count++;
                        winningCells.push({row: newRow, col: newCol});
                    } else {
                        break;
                    }
                }

                // 向相反方向检查
                for (let i = 1; i < 5; i++) {
                    const newRow = row - dx * i;
                    const newCol = col - dy * i;
                    if (newRow >= 0 && newRow < 15 && newCol >= 0 && newCol < 15 &&
                        gomokuGameState.board[newRow][newCol] === player) {
                        count++;
                        winningCells.unshift({row: newRow, col: newCol});
                    } else {
                        break;
                    }
                }

                if (count >= 5) {
                    // 标记获胜的棋子
                    winningCells.forEach(({row, col}) => {
                        const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"] .gomoku-piece`);
                        if (cell) {
                            cell.classList.add('winning');
                        }
                    });
                    return player;
                }
            }

            return null;
        }

        // 🎮【新增】游戏结束
        async function endGame(winner) {
            gomokuGameState.gameActive = false;
            clearInterval(gomokuGameState.gameTimer);

            // 记录游戏结束事件
            const gameEndEvent = {
                type: 'game_end',
                timestamp: Date.now(),
                player: 'system',
                data: {
                    winner: winner,
                    totalMoves: gomokuGameState.moveHistory.length,
                    gameDuration: Date.now() - gomokuGameState.gameStartTime
                }
            };
            gomokuGameState.gameSession.gameEvents.push(gameEndEvent);

            // 显示结果消息
            let resultMessage;
            if (winner === 'user') {
                resultMessage = '🎉 恭喜你获胜了！';
            } else if (winner === 'ai') {
                resultMessage = '😅 对方获胜了！';
            } else {
                resultMessage = '🤝 平局！';
            }
            addGameChatMessage('system', resultMessage);

            // 🎮【删除】游戏结束时的自动回复
            if (currentChatCharacter) {
                // 记录游戏结束事件
                const gameDuration = Math.round((Date.now() - gomokuGameState.gameStartTime) / 1000 / 60);
                const totalMoves = gomokuGameState.moveHistory.length;
                await recordGameEvent(currentChatCharacter.id, 'game_end', {
                    gameName: '五子棋',
                    result: winner,
                    score: totalMoves,
                    chatContent: `游戏结束，结果：${winner}，总共${totalMoves}步，用时${gameDuration}分钟`
                });

                // 不再发送自动回复消息
            }

            updateGomokuUI();

            // 延迟调用游戏总结
            setTimeout(() => {
                summarizeGameSession();
            }, 3000);
        }



        // 🎮【新增】更新棋盘UI
        function updateBoardUI() {
            for (let row = 0; row < 15; row++) {
                for (let col = 0; col < 15; col++) {
                    const intersection = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                    const piece = gomokuGameState.board[row][col];

                    // 清除现有棋子
                    intersection.innerHTML = '';

                    if (piece) {
                        const pieceElement = document.createElement('div');
                        // 根据用户是否拿黑子来决定棋子颜色
                        let pieceColor;
                        if (piece === 'user') {
                            pieceColor = gomokuGameState.userIsBlack ? 'black' : 'white';
                        } else {
                            pieceColor = gomokuGameState.userIsBlack ? 'white' : 'black';
                        }
                        pieceElement.className = `gomoku-piece ${pieceColor}`;
                        intersection.appendChild(pieceElement);
                    }
                }
            }
        }

        // 🎮【新增】更新游戏UI
        function updateGomokuUI() {
            const statusElement = document.getElementById('current-turn');
            if (gomokuGameState.gameActive) {
                if (gomokuGameState.currentPlayer === 'user') {
                    statusElement.textContent = '你的回合';
                    statusElement.style.color = '#2d3748';
                } else {
                    statusElement.textContent = '对方回合';
                    statusElement.style.color = '#718096';
                }
            } else {
                statusElement.textContent = '游戏结束';
                statusElement.style.color = '#e53e3e';
            }
        }

        // 🎮【新增】更新玩家棋子显示
        function updatePlayerPieceDisplay() {
            // 查找所有的用户和AI棋子指示器
            const userPieceElements = document.querySelectorAll('.user-piece');
            const aiPieceElements = document.querySelectorAll('.ai-piece');

            console.log('棋子元素查找:', {
                userCount: userPieceElements.length,
                aiCount: aiPieceElements.length
            });

            // 更新所有用户棋子指示器
            userPieceElements.forEach(element => {
                element.classList.remove('black', 'white');
                if (gomokuGameState.userIsBlack) {
                    element.classList.add('black');
                } else {
                    element.classList.add('white');
                }
                element.textContent = '';
                element.style.display = 'block';
                element.style.visibility = 'visible';
            });

            // 更新所有AI棋子指示器
            aiPieceElements.forEach(element => {
                element.classList.remove('black', 'white');
                if (gomokuGameState.userIsBlack) {
                    element.classList.add('white');
                } else {
                    element.classList.add('black');
                }
                element.textContent = '';
                element.style.display = 'block';
                element.style.visibility = 'visible';
            });

            console.log('棋子显示已更新 - 用户执子:', gomokuGameState.userIsBlack ? '黑子' : '白子');
        }

        // 🎮【新增】启动游戏计时器
        function startGameTimer() {
            const timerElement = document.getElementById('game-timer');
            gomokuGameState.gameTimer = setInterval(() => {
                const elapsed = Date.now() - gomokuGameState.gameStartTime;
                const minutes = Math.floor(elapsed / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                timerElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }

        // 🎮【新增】设置玩家信息（用户和AI）
        function setupAIPlayerInfo() {
            const aiNameElement = document.getElementById('ai-player-name');
            const aiAvatarElement = document.getElementById('ai-player-avatar');
            const aiAvatarHeaderElement = document.getElementById('ai-player-avatar-header'); // 标题栏中的AI头像
            const userAvatarElement = document.getElementById('user-player-avatar');
            const userAvatarHeaderElement = document.getElementById('user-player-avatar-header'); // 标题栏中的用户头像

            // 设置AI角色信息
            if (currentChatCharacter) {
                if (aiNameElement) {
                    aiNameElement.textContent = currentChatCharacter.name;
                }
                // 使用正确的AI头像获取逻辑
                const chatSettings = getCurrentChatSettings();
                const aiAvatar = chatSettings.aiChatAvatar || currentChatCharacter.avatarUrl || currentChatCharacter.avatar;

                // 设置原来的AI头像
                if (aiAvatar && aiAvatarElement) {
                    // 保留棋子指示器，只替换头像内容
                    const existingPieceIndicator = aiAvatarElement.querySelector('.piece-indicator');
                    aiAvatarElement.innerHTML = `<img src="${aiAvatar}" alt="${currentChatCharacter.name}" style="width: 100%; height: 100%; border-radius: 50%; object-fit: cover;">`;
                    // 重新添加棋子指示器
                    if (existingPieceIndicator) {
                        aiAvatarElement.appendChild(existingPieceIndicator);
                    }
                }

                // 设置标题栏中的AI头像
                if (aiAvatar && aiAvatarHeaderElement) {
                    // 保留棋子指示器，只替换头像内容
                    const existingPieceIndicator = aiAvatarHeaderElement.querySelector('.piece-indicator');
                    aiAvatarHeaderElement.innerHTML = `<img src="${aiAvatar}" alt="${currentChatCharacter.name}" style="width: 100%; height: 100%; border-radius: 50%; object-fit: cover;">`;
                    // 重新添加棋子指示器
                    if (existingPieceIndicator) {
                        aiAvatarHeaderElement.appendChild(existingPieceIndicator);
                    }
                }
            }

            // 设置用户头像 - 使用和聊天界面相同的逻辑
            const chatSettings = getCurrentChatSettings();
            let userAvatar = null;

            // 优先级1：聊天专属头像设置
            if (chatSettings.myChatAvatar) {
                userAvatar = chatSettings.myChatAvatar;
            }

            // 优先级2：身份面具卡头像
            if (!userAvatar && chatSettings.selectedIdentityId) {
                const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                if (selectedPersona && selectedPersona.avatarUrl) {
                    userAvatar = selectedPersona.avatarUrl;
                }
            }

            // 优先级3：全局用户头像
            if (!userAvatar && window.userAvatar) {
                userAvatar = window.userAvatar;
            }

            // 设置原来的用户头像
            if (userAvatar && userAvatarElement) {
                // 保留棋子指示器，只替换头像内容
                const existingPieceIndicator = userAvatarElement.querySelector('.piece-indicator');
                userAvatarElement.innerHTML = `<img src="${userAvatar}" alt="你" style="width: 100%; height: 100%; border-radius: 50%; object-fit: cover;">`;
                // 重新添加棋子指示器
                if (existingPieceIndicator) {
                    userAvatarElement.appendChild(existingPieceIndicator);
                }
            }

            // 设置标题栏中的用户头像
            if (userAvatar && userAvatarHeaderElement) {
                // 保留棋子指示器，只替换头像内容
                const existingPieceIndicator = userAvatarHeaderElement.querySelector('.piece-indicator');
                userAvatarHeaderElement.innerHTML = `<img src="${userAvatar}" alt="你" style="width: 100%; height: 100%; border-radius: 50%; object-fit: cover;">`;
                // 重新添加棋子指示器
                if (existingPieceIndicator) {
                    userAvatarHeaderElement.appendChild(existingPieceIndicator);
                }
            }
        }

        // 🎮【新增】显示AI正在回复的加载气泡
        function showGameChatLoading() {
            const messagesContainer = document.getElementById('gomoku-chat-messages');
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'game-chat-message ai';
            loadingDiv.id = 'game-chat-loading';

            const bubbleDiv = document.createElement('div');
            bubbleDiv.className = 'game-chat-bubble loading';
            bubbleDiv.innerHTML = '<span class="typing-dots"><span>.</span><span>.</span><span>.</span></span>';

            loadingDiv.appendChild(bubbleDiv);
            messagesContainer.appendChild(loadingDiv);

            // 滚动到底部
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // 🎮【新增】隐藏AI正在回复的加载气泡
        function hideGameChatLoading() {
            const loadingElement = document.getElementById('game-chat-loading');
            if (loadingElement) {
                loadingElement.remove();
            }
        }

        // 🎮【新增】添加游戏聊天消息
        function addGameChatMessage(sender, content, shouldRecord = false) {
            const messagesContainer = document.getElementById('gomoku-chat-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `game-chat-message ${sender}`;

            const bubbleDiv = document.createElement('div');
            bubbleDiv.className = 'game-chat-bubble';
            bubbleDiv.textContent = content;

            messageDiv.appendChild(bubbleDiv);
            messagesContainer.appendChild(messageDiv);

            // 滚动到底部
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            // 记录到游戏会话
            const chatMessage = {
                sender,
                content,
                timestamp: Date.now()
            };
            gomokuGameState.gameSession.chatHistory.push(chatMessage);

            // 如果需要记录到全局记忆系统
            if (shouldRecord && currentChatCharacter) {
                recordGameChat(currentChatCharacter.id, sender, content, {
                    gameName: '五子棋',
                    gameState: 'playing'
                });
            }
        }

        // 🎮【重构】游戏聊天 - 与平时聊天一样有记忆和上下文
        async function sendGameChatMessage() {
            const input = document.getElementById('gomoku-chat-input');
            const content = input.value.trim();

            if (!content) return;
            if (!currentChatCharacter) return;

            // 添加用户消息到游戏聊天界面
            addGameChatMessage('user', content, true);
            input.value = '';

            try {
                // 显示加载状态
                showGameChatLoading();

                // 🎮【新功能】将游戏聊天消息添加到主聊天记录中，保持上下文连续性
                const gameContextMessage = `[五子棋游戏中] ${content}`;

                // 添加到主聊天数据库，保持记忆连续性
                const userMessage = {
                    id: Date.now(),
                    characterId: currentChatCharacter.id,
                    content: gameContextMessage,
                    sender: 'user',
                    timestamp: Date.now(),
                    isGameContext: true // 标记为游戏上下文消息
                };

                await db.chatMessages.add(userMessage);

                // 构建游戏聊天的特殊提示词
                const gameStatus = gomokuGameState.gameActive ? '进行中' : '已结束';
                const moveCount = gomokuGameState.moveHistory.length;
                const userPiece = gomokuGameState.userIsBlack ? '黑子' : '白子';
                const aiPiece = gomokuGameState.userIsBlack ? '白子' : '黑子';

                const gameContextPrompt = `[游戏状态] 你们正在下五子棋，游戏${gameStatus}，已下${moveCount}步。你执${aiPiece}，用户执${userPiece}。用户在游戏中对你说："${content}"

请自然地回应用户，就像平时聊天一样。你可以：
1. 回应用户的话题
2. 评论当前的棋局
3. 聊其他任何话题
4. 保持你的性格特点

回复要自然，不要刻意提醒这是在游戏中。`;

                // 使用完整的聊天API，包含记忆和上下文
                const response = await callChatAPI(gameContextPrompt, currentChatCharacter);
                const aiMessages = await parseAiResponse(response);

                // 隐藏加载状态
                hideGameChatLoading();

                // 处理AI回复
                if (Array.isArray(aiMessages) && aiMessages.length > 0) {
                    for (let i = 0; i < aiMessages.length; i++) {
                        const message = aiMessages[i];
                        let messageText = '';

                        if (typeof message === 'string') {
                            messageText = message.trim();
                        } else if (typeof message === 'object' && message.content) {
                            messageText = message.content.trim();
                        }

                        if (messageText) {
                            setTimeout(async () => {
                                // 添加到游戏聊天界面
                                addGameChatMessage('ai', messageText, true);

                                // 🎮【新功能】同时添加到主聊天记录，保持记忆连续性
                                const aiChatMessage = {
                                    id: Date.now() + i,
                                    characterId: currentChatCharacter.id,
                                    content: `[五子棋游戏中] ${messageText}`,
                                    sender: 'ai',
                                    timestamp: Date.now() + i,
                                    isGameContext: true
                                };

                                await db.chatMessages.add(aiChatMessage);
                            }, 300 + i * 800);
                        }
                    }
                }

                // 记录游戏聊天事件
                await recordGameEvent(currentChatCharacter.id, 'game_chat', {
                    gameName: '五子棋',
                    result: null,
                    score: moveCount,
                    chatContent: `用户说：${content}`
                });

            } catch (error) {
                console.error('游戏聊天API调用失败:', error);
                hideGameChatLoading();

                // 降级到简单回复
                setTimeout(() => {
                    const aiReplies = [
                        "哈哈，有趣！",
                        "说得对呢~",
                        "我也这么想！",
                        "继续加油！",
                        "你说话真有意思",
                        "专心下棋啦~",
                        "嗯嗯，我在听着呢",
                        "好的好的！"
                    ];
                    const reply = aiReplies[Math.floor(Math.random() * aiReplies.length)];
                    addGameChatMessage('ai', reply, true);
                }, 1000 + Math.random() * 2000);
            }
        }

        // 🎮【新增】清空游戏聊天
        function clearGameChat() {
            if (confirm('确定要清空游戏聊天记录吗？')) {
                document.getElementById('gomoku-chat-messages').innerHTML = '';
                gomokuGameState.gameSession.chatHistory = [];
                showToast('聊天记录已清空', 'success');
            }
        }

        // 🎮【新增】记录游戏开始事件
        function recordGameStart() {
            if (currentChatCharacter) {
                recordGameEvent(currentChatCharacter.id, 'game_start', {
                    gameName: '五子棋',
                    result: null,
                    score: null,
                    chatContent: null
                });
            }
        }

        // 🎮【新增】清除游戏相关的时间线记忆
        async function clearGameTimelineMemories(characterId, gameId) {
            try {
                // 获取该角色的所有时间线记忆
                const allMemories = await db.crossAppTimeline
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                // 筛选出当前游戏会话相关的记忆
                const gameMemories = allMemories.filter(memory => {
                    // 检查是否是游戏相关的记忆
                    if (memory.appType !== 'game') return false;

                    // 检查是否包含当前游戏会话ID
                    const data = memory.data || {};
                    return data.gameId === gameId ||
                           (data.id && data.id.includes(gameId)) ||
                           (memory.timestamp >= gomokuGameState.gameStartTime);
                });

                // 删除这些记忆
                if (gameMemories.length > 0) {
                    const memoryIds = gameMemories.map(m => m.id);
                    await db.crossAppTimeline.bulkDelete(memoryIds);
                    console.log(`🎮 已删除 ${gameMemories.length} 条游戏时间线记忆`);
                }
            } catch (error) {
                console.error('清除游戏时间线记忆失败:', error);
                throw error;
            }
        }

        // 🎮【新增】退出五子棋游戏
        function exitGomokuGame() {
            if (gomokuGameState.gameActive) {
                // 显示退出选项
                showExitGameModal();
            } else {
                // 游戏已结束，直接返回
                hideApp('gomoku-game-screen');
                showApp('api-chat-screen');
            }
        }

        // 🎮【新增】显示退出游戏选项模态框
        function showExitGameModal() {
            const modal = document.createElement('div');
            modal.className = 'game-exit-modal';
            modal.innerHTML = `
                <div class="game-exit-overlay"></div>
                <div class="game-exit-content">
                    <div class="game-exit-header">
                        <h3>退出游戏</h3>
                    </div>
                    <div class="game-exit-body">
                        <p class="game-exit-desc">游戏还在进行中，请选择退出方式：</p>
                        <div class="game-exit-options">
                            <button class="game-exit-btn save-btn" onclick="exitGameWithSave()">
                                <i class="fas fa-bookmark"></i>
                                <div class="btn-content">
                                    <div class="btn-title">保存并退出</div>
                                    <div class="btn-desc">游戏过程会被角色记住</div>
                                </div>
                            </button>
                            <button class="game-exit-btn clear-btn" onclick="exitGameWithClear()">
                                <i class="fas fa-eraser"></i>
                                <div class="btn-content">
                                    <div class="btn-title">清空并退出</div>
                                    <div class="btn-desc">清除所有记录，就像从未发生过</div>
                                </div>
                            </button>
                            <button class="game-exit-btn pause-btn" onclick="exitGameTemporary()">
                                <i class="fas fa-pause-circle"></i>
                                <div class="btn-content">
                                    <div class="btn-title">暂时离开</div>
                                    <div class="btn-desc">保存状态，下次可以继续</div>
                                </div>
                            </button>
                            <button class="game-exit-btn game-cancel-btn" onclick="closeExitGameModal()">
                                <i class="fas fa-times-circle"></i>
                                <div class="btn-content">
                                    <div class="btn-title">取消</div>
                                </div>
                            </button>
                        </div>
                    </div>
                </div>
            `;
            // 将模态框添加到手机屏幕内，这样定位就相对于手机屏幕
            const phoneScreen = document.getElementById('phone-screen');
            if (phoneScreen) {
                phoneScreen.appendChild(modal);
            } else {
                document.body.appendChild(modal);
            }
        }

        // 🎮【新增】关闭退出游戏模态框
        function closeExitGameModal() {
            const modal = document.querySelector('.game-exit-modal');
            if (modal) {
                modal.remove();
            }
        }

        // 🎮【新增】保存并退出游戏
        function exitGameWithSave() {
            // 记录游戏中途退出
            gomokuGameState.gameSession.gameEvents.push({
                type: 'game_exit_save',
                timestamp: Date.now(),
                player: 'user',
                data: { reason: '用户选择保存并退出' }
            });

            gomokuGameState.gameActive = false;
            clearInterval(gomokuGameState.gameTimer);

            // 总结游戏会话
            summarizeGameSession();

            closeExitGameModal();
            hideApp('gomoku-game-screen');
            showApp('api-chat-screen');
            showToast('游戏已保存并退出', 'success');
        }

        // 🎮【新增】清空并退出游戏
        async function exitGameWithClear() {
            // 获取当前游戏会话ID
            const gameId = gomokuGameState.gameSession?.gameId;

            // 清空游戏会话数据
            gomokuGameState.gameSession = {
                gameId: null,
                players: [],
                boardState: [],
                chatHistory: [],
                gameEvents: []
            };

            // 清空聊天记录
            document.getElementById('gomoku-chat-messages').innerHTML = '';

            gomokuGameState.gameActive = false;
            clearInterval(gomokuGameState.gameTimer);

            // 🔥【新增】删除当前游戏会话相关的时间线记忆
            if (gameId && currentChatCharacter) {
                try {
                    await clearGameTimelineMemories(currentChatCharacter.id, gameId);
                    console.log('🎮 已清除游戏相关的时间线记忆');
                } catch (error) {
                    console.error('清除游戏时间线记忆失败:', error);
                }
            }

            // 不调用总结函数，直接退出
            closeExitGameModal();
            hideApp('gomoku-game-screen');
            showApp('api-chat-screen');
            showToast('游戏记录已清空', 'success');
        }

        // 🎮【新增】暂时离开游戏
        function exitGameTemporary() {
            // 保存游戏状态到本地存储
            const gameState = {
                board: gomokuGameState.board,
                currentPlayer: gomokuGameState.currentPlayer,
                userIsBlack: gomokuGameState.userIsBlack,
                // 🎮【移除】难度系统已删除
                moveHistory: gomokuGameState.moveHistory,
                gameSession: gomokuGameState.gameSession,
                startTime: gomokuGameState.startTime,
                chatHistory: Array.from(document.getElementById('gomoku-chat-messages').children).map(msg => ({
                    sender: msg.classList.contains('user') ? 'user' : (msg.classList.contains('ai') ? 'ai' : 'system'),
                    content: msg.textContent,
                    timestamp: Date.now()
                }))
            };

            localStorage.setItem('gomoku_saved_game', JSON.stringify(gameState));

            // 记录暂时离开事件
            gomokuGameState.gameSession.gameEvents.push({
                type: 'game_pause',
                timestamp: Date.now(),
                player: 'user',
                data: { reason: '用户选择暂时离开' }
            });

            gomokuGameState.gameActive = false;
            clearInterval(gomokuGameState.gameTimer);

            closeExitGameModal();
            hideApp('gomoku-game-screen');
            showApp('api-chat-screen');
            showToast('游戏已暂停保存', 'success');
        }

        // 🎮【新增】重新开始游戏
        async function restartGomokuGame() {
            if (confirm('确定要重新开始吗？当前进度将丢失。')) {
                // 清除保存的游戏
                localStorage.removeItem('gomoku_saved_game');

                // 重新初始化游戏
                await initGomokuGame();

                showToast('游戏已重新开始', 'success');
            }
        }

        // 🎮【新增】悔棋功能 - 使用真实API调用
        async function undoGomokuMove() {
            if (!gomokuGameState.gameActive) {
                showToast('游戏已结束，无法悔棋', 'warning');
                return;
            }

            if (gomokuGameState.moveHistory.length >= 2) {
                // 撤销最后两步（用户和AI各一步）
                for (let i = 0; i < 2; i++) {
                    const lastMove = gomokuGameState.moveHistory.pop();
                    if (lastMove) {
                        gomokuGameState.board[lastMove.row][lastMove.col] = null;
                    }
                }
                gomokuGameState.currentPlayer = 'user';
                updateBoardUI();
                updateGomokuUI();
                addGameChatMessage('system', '已悔棋两步');

                // 🎮【改进】悔棋事件记录
                if (currentChatCharacter) {
                    // 记录悔棋事件到时间线
                    await recordCrossAppEvent(
                        currentChatCharacter.id,
                        'game',
                        'undo_move',
                        {
                            id: `undo_${Date.now()}`,
                            type: 'game_undo',
                            gameName: '五子棋',
                            content: `用户在五子棋游戏中申请悔棋，${currentChatCharacter.name}同意了`,
                            moveCount: gomokuGameState.moveHistory.length,
                            timestamp: Date.now()
                        }
                    );

                    // 使用简单的预设回复
                    addGameChatMessage('ai', '好吧，给你一次机会~', true);
                }
            } else {
                showToast('无法悔棋，棋盘上棋子不足', 'warning');
            }
        }

        // 🎮【新增】认输功能 - 使用真实API调用
        async function surrenderGomokuGame() {
            if (!gomokuGameState.gameActive) {
                showToast('游戏已结束', 'warning');
                return;
            }

            if (confirm('确定要认输吗？')) {
                addGameChatMessage('system', '你选择了认输');

                // 🎮【改进】认输事件记录
                if (currentChatCharacter) {
                    // 记录认输事件到时间线
                    await recordCrossAppEvent(
                        currentChatCharacter.id,
                        'game',
                        'surrender',
                        {
                            id: `surrender_${Date.now()}`,
                            type: 'game_surrender',
                            gameName: '五子棋',
                            content: `用户在五子棋游戏中主动认输，${currentChatCharacter.name}获胜`,
                            result: 'ai_win',
                            moveCount: gomokuGameState.moveHistory.length,
                            timestamp: Date.now()
                        }
                    );

                    // 使用简单的预设回复
                    addGameChatMessage('ai', '好的，这局我赢了！下次再来挑战我吧~', true);
                }

                // 延迟结束游戏，让AI回应先显示
                setTimeout(() => {
                    endGame('ai');
                }, 1500);
            }
        }

        // 🎮【新增】开始下一局游戏
        async function startNextGomokuGame() {
            if (gomokuGameState.gameActive) {
                if (!confirm('当前游戏还在进行中，确定要开始新的一局吗？')) {
                    return;
                }
            }

            // 清除当前游戏状态
            localStorage.removeItem('gomoku_saved_game');

            // 重新初始化游戏
            await initGomokuGame();

            showToast('新的一局开始了！', 'success');
        }

        // 🎮【新增】游戏会话总结（按照你和Gemini讨论的方案）
        async function summarizeGameSession() {
            if (!currentChatCharacter || !gomokuGameState.gameSession) {
                return;
            }

            try {
                // 构建游戏事件日志
                const gameEvents = gomokuGameState.gameSession.gameEvents;
                const chatHistory = gomokuGameState.gameSession.chatHistory;

                // 分析游戏结果
                const lastEvent = gameEvents[gameEvents.length - 1];
                let winner = 'unknown';
                let gameResult = '游戏异常结束';

                if (lastEvent && lastEvent.type === 'game_end') {
                    winner = lastEvent.data.winner;
                    if (winner === 'user') {
                        gameResult = '用户获胜';
                    } else if (winner === 'ai') {
                        gameResult = `${currentChatCharacter.name}获胜`;
                    } else {
                        gameResult = '平局';
                    }
                }

                // 🎮【改进】使用AI生成人性化的游戏记忆总结
                try {
                    const gameDuration = Math.round((Date.now() - gomokuGameState.gameStartTime) / 1000 / 60);
                    const chatSummary = chatHistory.length > 0 ?
                        `游戏期间我们聊了${chatHistory.length}条消息，` +
                        (chatHistory.length > 5 ? '聊得很开心' : '简单交流了一下') :
                        '专心下棋，没怎么聊天';

                    // 构建AI记忆生成的提示词
                    const memoryPrompt = `你是${currentChatCharacter.name}，刚刚和用户下完了一局五子棋。

游戏详情：
- 游戏结果：${gameResult}
- 游戏时长：${gameDuration}分钟
- 总步数：${gomokuGameState.moveHistory.length}步
- 聊天情况：${chatSummary}

请生成一个人性化的情景记忆总结，要求：
1. 用第三人称描述（用"用户"和"${currentChatCharacter.name}"）
2. 体现你的性格特点
3. 包含游戏过程中的互动和感受
4. 如果有聊天，可以概括聊天内容的感受
5. 控制在50字以内，要生动有趣

只返回记忆内容，不要其他文字。`;

                    // 调用AI生成记忆
                    const memoryResponse = await callChatAPI(memoryPrompt, currentChatCharacter);
                    let aiGeneratedMemory = '';

                    if (Array.isArray(memoryResponse) && memoryResponse.length > 0) {
                        aiGeneratedMemory = memoryResponse[0].trim();
                    } else if (typeof memoryResponse === 'string') {
                        aiGeneratedMemory = memoryResponse.trim();
                    }

                    // 如果AI生成失败，使用备用记忆
                    if (!aiGeneratedMemory) {
                        aiGeneratedMemory = winner === 'user' ?
                            `用户在五子棋中击败了${currentChatCharacter.name}，${chatHistory.length > 0 ? '期间还愉快地聊了天' : '专心对弈'}` :
                            winner === 'ai' ?
                            `${currentChatCharacter.name}在五子棋中获胜了，${chatHistory.length > 0 ? '游戏过程中和用户聊得很开心' : '下得很专注'}` :
                            `${currentChatCharacter.name}和用户五子棋下成了平局，${chatHistory.length > 0 ? '边下边聊很有趣' : '势均力敌'}`;
                    }

                    console.log('🎮 AI生成的游戏记忆:', aiGeneratedMemory);

                    // 记录到时间线记忆
                    await recordCrossAppEvent(
                        currentChatCharacter.id,
                        'game',
                        'game_summary',
                        {
                            id: `game_summary_${Date.now()}`,
                            type: 'game_session_summary',
                            gameName: '五子棋',
                            summary: aiGeneratedMemory,
                            result: gameResult,
                            totalMoves: gomokuGameState.moveHistory.length,
                            chatMessages: chatHistory.length,
                            gameDuration: gameDuration,
                            timestamp: Date.now()
                        }
                    );

                    // 添加到情景记忆
                    await db.episodicMemories.add({
                        id: `game_memory_${Date.now()}`,
                        characterId: currentChatCharacter.id,
                        fact: aiGeneratedMemory,
                        importance: 0.7, // 游戏记忆的重要性
                        timestamp: Date.now(),
                        category: 'game_interaction',
                        contextId: currentChatCharacter.id
                    });

                } catch (error) {
                    console.error('生成游戏记忆失败:', error);

                    // 降级到简单记忆
                    const fallbackMemory = winner === 'user' ?
                        '用户在五子棋中获胜了' :
                        winner === 'ai' ?
                        `${currentChatCharacter.name}在五子棋中获胜了` :
                        '五子棋下成了平局';

                    await db.episodicMemories.add({
                        id: `game_memory_${Date.now()}`,
                        characterId: currentChatCharacter.id,
                        fact: fallbackMemory,
                        importance: 0.7,
                        timestamp: Date.now(),
                        category: 'game_interaction',
                        contextId: currentChatCharacter.id
                    });
                }

                console.log('🎮 游戏记忆已保存到全局记忆系统');
                showToast('游戏记录已保存', 'success');

            } catch (error) {
                console.error('保存游戏记忆失败:', error);
            }
        }

        // 🎮【移除】难度设置相关函数已删除
        // AI现在根据角色性格和智能程度进行下棋决策

        // 🎮【新增】监听游戏聊天输入框回车事件
        document.addEventListener('DOMContentLoaded', function() {
            const gameInput = document.getElementById('gomoku-chat-input');
            if (gameInput) {
                gameInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        sendGameChatMessage();
                    }
                });
            }

            // 🎮【移除】难度设置加载已删除
        });

        // ================== 海龟汤游戏系统 ==================

        // 🎮【新增】海龟汤游戏状态管理
        let turtleSoupGameState = {
            gameActive: false,
            gameStartTime: null,
            currentStory: null,
            currentAnswer: null,
            questionCount: 0,
            gameTimer: null,
            gameSession: null,
            dmPersonality: 'friendly', // DM性格：friendly, mysterious, humorous
            gameMode: 'single' // single 或 group
        };

        // 🎮【新增】海龟汤故事库（模拟数据）
        const turtleSoupStories = [
            {
                id: 1,
                title: "深夜的电话",
                story: "一个男人在深夜接到一个电话，听了几句话后就自杀了。",
                answer: "这个男人是盲人，电话里告诉他医院弄错了，他的眼睛其实没有治好，他以为自己重见光明了，但其实一直都是黑暗的。",
                difficulty: "medium",
                tags: ["classic", "心理", "医疗", "误解"]
            },
            {
                id: 2,
                title: "推门而入",
                story: "一个人推门进入房间，看到房间里的情况后立即报警。",
                answer: "这个人是邮递员，推门进入时发现屋主已经死了很久，尸体腐烂发臭。",
                difficulty: "easy",
                tags: ["classic", "日常", "发现", "死亡"]
            },
            {
                id: 3,
                title: "半夜惊醒",
                story: "一个女人半夜惊醒，发现丈夫不在身边，于是立刻报警。",
                answer: "这个女人是盲人，平时丈夫都会在她身边，但这次她摸到的是一具冰冷的尸体，丈夫已经死了。",
                difficulty: "hard",
                tags: ["horror", "夫妻", "盲人", "死亡"]
            },
            {
                id: 4,
                title: "消失的影子",
                story: "一个男人发现自己的影子消失了，他四处寻找，最后在一面镜子前找到了它。",
                answer: "男人得了严重的抑郁症，觉得自己像行尸走肉一样没有灵魂。'找到影子'其实是他重新找回了生活的希望和自我认同。",
                difficulty: "easy",
                tags: ["funny", "幽默", "心理", "比喻"]
            },
            {
                id: 5,
                title: "爱情的证明",
                story: "一个男人每天都给女朋友买同样的花，直到有一天他买了不同的花，女朋友就和他分手了。",
                answer: "女朋友对那种花过敏，男人每天买同样的花是因为记住了她的过敏症。买不同花说明他忘记了她的身体状况，她觉得他不够关心自己。",
                difficulty: "medium",
                tags: ["romantic", "爱情", "关心", "细节"]
            },
            {
                id: 6,
                title: "神秘的礼物",
                story: "一个女人收到匿名礼物，是一把钥匙，她用这把钥匙打开了自己家的门。",
                answer: "女人失忆了，忘记了自己的家在哪里。送钥匙的是她的丈夫，用这种方式帮助她找回回家的路。",
                difficulty: "medium",
                tags: ["romantic", "爱情", "失忆", "温暖"]
            }
        ];

        // 🎮【修复】启动海龟汤游戏 - 学习五子棋的启动逻辑
        async function startTurtleSoupGame() {
            // 🔥【修复】学习五子棋，从当前界面进入游戏
            // 如果在API聊天界面，隐藏API聊天界面
            if (document.getElementById('api-chat-screen').style.display !== 'none') {
                hideApp('api-chat-screen');
            }
            // 如果在消息列表界面，隐藏消息列表界面
            if (document.getElementById('chat-screen').style.display !== 'none') {
                hideApp('chat-screen');
            }

            showApp('turtle-soup-game-screen');

            // 初始化游戏状态
            await initTurtleSoupGame();
        }

        // 🎮【修改】初始化海龟汤游戏 - 支持用户偏好设置
        async function initTurtleSoupGame() {
            // 确定游戏模式
            const gameMode = currentChatCharacter && currentChatCharacter.isGroup ? 'group' : 'single';

            // 🔥【新增】加载用户设置
            let userSettings = { preferredType: 'random', dmPersonality: 'friendly' };
            try {
                const settings = await db.globalSettings.get('turtleSoupSettings');
                if (settings && settings.value) {
                    userSettings = settings.value;
                }
            } catch (error) {
                console.error('加载海龟汤设置失败:', error);
            }

            // 🔥【新增】让DM AI自动生成海龟汤故事
            let storyData;
            try {
                console.log('🎭 DM正在创作新的海龟汤故事...');
                storyData = await generateTurtleSoupStoryByDM(userSettings.preferredType);
            } catch (error) {
                console.error('DM生成故事失败，使用预设故事:', error);
                // 回退到预设故事
                let availableStories = turtleSoupStories;
                if (userSettings.preferredType !== 'random') {
                    availableStories = turtleSoupStories.filter(story =>
                        story.tags && story.tags.includes(userSettings.preferredType)
                    );
                    if (availableStories.length === 0) {
                        availableStories = turtleSoupStories;
                    }
                }
                storyData = availableStories[Math.floor(Math.random() * availableStories.length)];
            }

            // 重置游戏状态
            turtleSoupGameState = {
                gameActive: true,
                gameStartTime: Date.now(),
                currentStory: storyData,
                currentAnswer: storyData.answer,
                questionCount: 0,
                gameTimer: null,
                gameMode: gameMode,
                dmPersonality: userSettings.dmPersonality,
                gameSession: {
                    gameId: `turtle_soup_${Date.now()}`,
                    players: gameMode === 'group' ? ['user', ...Object.keys(currentChatCharacter.members || {})] : ['user', currentChatCharacter.id],
                    storyId: storyData.id,
                    chatHistory: [],
                    gameEvents: [
                        {
                            type: 'game_start',
                            timestamp: Date.now(),
                            player: 'system',
                            data: {
                                gameName: '海龟汤',
                                storyTitle: storyData.title,
                                gameMode: gameMode
                            }
                        }
                    ]
                }
            };

            // 更新UI
            updateTurtleSoupUI();
            startTurtleSoupTimer();

            // 清空聊天记录
            const chatContainer = document.getElementById('turtle-soup-chat-messages');
            chatContainer.innerHTML = '';

            // DM开场白
            setTimeout(() => {
                showDMMessage("欢迎来到海龟汤推理游戏！我是你们的游戏主持人。");
            }, 500);

            setTimeout(() => {
                showDMMessage("规则很简单：我会给出一个看似不合理的情景，你们通过提问来推理出真相。");
            }, 1500);

            setTimeout(() => {
                showDMMessage("记住，你们只能问是/否问题，我只会回答'是'、'否'或'无关'。");
            }, 2500);

            setTimeout(() => {
                showDMMessage("准备好了吗？让我们开始吧！");
            }, 3500);

            setTimeout(() => {
                presentStory(storyData);
            }, 4500);
        }

        // 🎮【新增】展示故事（汤面）
        function presentStory(story) {
            // 更新汤面显示
            const storyElement = document.getElementById('turtle-soup-story-content');
            storyElement.textContent = story.story;

            // DM介绍故事
            setTimeout(() => {
                showDMMessage(`这就是今天的汤面："${story.title}"`);
            }, 500);

            setTimeout(() => {
                showDMMessage("现在开始你们的推理吧！记住只能问是/否问题哦~");
            }, 1500);

            // 🔥【修改】不在聊天区域显示汤面，汤面只在上方游戏区域显示
        }

        // 🎮【修改】显示DM消息 - 支持历史记录和角色可读
        function showDMMessage(message, shouldRecord = true) {
            const dmMessageElement = document.getElementById('turtle-soup-dm-message');
            dmMessageElement.textContent = message;

            // 🔥【新增】记录DM消息到游戏历史，让角色能够读取
            if (shouldRecord && turtleSoupGameState.gameActive) {
                const dmMessage = {
                    id: `dm_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    sender: 'dm',
                    content: message,
                    timestamp: Date.now(),
                    isGameMessage: true,
                    gameName: '海龟汤'
                };

                // 添加到游戏会话历史
                turtleSoupGameState.gameSession.chatHistory.push(dmMessage);

                // 🔥【修改】不再将DM消息添加到主聊天记录中，避免污染正常聊天
                // DM消息只保存在游戏会话中，退出游戏后不会显示在主聊天界面
            }
        }

        // 🎮【修改】添加海龟汤聊天消息 - 移除头像，只显示气泡
        function addTurtleSoupChatMessage(sender, content, shouldRecord = false) {
            const messagesContainer = document.getElementById('turtle-soup-chat-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `game-chat-message ${sender}`;

            // 🔥【修改】不显示头像，直接创建气泡

            const bubbleDiv = document.createElement('div');
            bubbleDiv.className = 'game-chat-bubble';
            bubbleDiv.textContent = content;

            messageDiv.appendChild(bubbleDiv);
            messagesContainer.appendChild(messageDiv);

            // 滚动到底部
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            // 记录到游戏会话
            const chatMessage = {
                id: `chat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                sender,
                content,
                timestamp: Date.now(),
                isGameMessage: true,
                gameName: '海龟汤'
            };
            turtleSoupGameState.gameSession.chatHistory.push(chatMessage);

            // 🔥【修改】不再将游戏消息添加到主聊天记录中，避免污染正常聊天
            // 游戏消息只保存在游戏会话中，退出游戏后不会显示在主聊天界面
            if (shouldRecord && currentChatCharacter) {
                // 记录到全局记忆系统（用于AI记忆，但不显示在聊天界面）
                recordGameChat(currentChatCharacter.id, sender, content, {
                    gameName: '海龟汤',
                    gameState: 'playing'
                });
            }
        }

        // 🎮【重构】发送海龟汤问题 - 学习五子棋的回合制机制
        async function sendTurtleSoupQuestion() {
            const input = document.getElementById('turtle-soup-chat-input');
            const content = input.value.trim();

            if (!content) return;
            if (!turtleSoupGameState.gameActive) {
                showToast('游戏已结束', 'warning');
                return;
            }

            // 添加用户问题
            addTurtleSoupChatMessage('user', content, true);
            input.value = '';

            // 🔥【学习五子棋】立即让角色回应，就像五子棋中AI立即下棋一样
            setTimeout(async () => {
                try {
                    await generateCharacterTurtleSoupResponse(content);
                } catch (error) {
                    console.error('角色回应生成失败:', error);
                    // 添加默认回应，确保游戏继续
                    const defaultResponses = [
                        "嗯，让我想想...",
                        "这个线索很有意思",
                        "还有其他可能吗？",
                        "我觉得这个方向值得探索"
                    ];
                    const randomResponse = defaultResponses[Math.floor(Math.random() * defaultResponses.length)];
                    addTurtleSoupChatMessage(currentChatCharacter.id, randomResponse, true);
                }
            }, 800 + Math.random() * 1200); // 缩短延迟，更像五子棋的即时回应
        }

        // 🔥【重构】发言结束，触发DM工作 - 学习五子棋的即时回应机制
        async function finishSpeakingAndTriggerDM() {
            if (!turtleSoupGameState.gameActive) {
                showToast('游戏已结束', 'warning');
                return;
            }

            // 🔥【改进】收集这一轮的完整讨论内容（用户+角色）
            const recentMessages = turtleSoupGameState.gameSession.chatHistory
                .slice(-10) // 增加分析范围
                .filter(msg => msg.sender === 'user' || (msg.sender !== 'dm' && msg.sender !== 'system'))
                .map(msg => `${msg.sender}: ${msg.content}`)
                .join('\n');

            if (!recentMessages.trim()) {
                showToast('请先提出问题或进行讨论', 'warning');
                return;
            }

            // 🔥【学习五子棋】立即显示DM状态，就像五子棋显示"AI思考中"
            showDMMessage('🎭 DM正在分析讨论...');

            // 🔥【学习五子棋】更快的响应时间
            setTimeout(async () => {
                try {
                    const dmResponse = await generateDMResponseToDiscussion(recentMessages);

                    // 更新DM消息显示区域
                    showDMMessage(dmResponse);

                    // 🔥【修改】DM消息不添加到下方聊天区域，只在上方游戏区域显示

                    // 🔥【改进】更智能的问题计数
                    const hasQuestion = recentMessages.includes('?') || recentMessages.includes('？') ||
                                      recentMessages.includes('是否') || recentMessages.includes('是不是') ||
                                      recentMessages.includes('会不会') || recentMessages.includes('有没有');

                    if (hasQuestion) {
                        turtleSoupGameState.questionCount++;
                        updateTurtleSoupUI();
                    }

                } catch (error) {
                    console.error('DM回应生成失败:', error);
                    // 🔥【学习五子棋】提供备用回应，确保游戏继续
                    const backupResponses = [
                        "这个问题很有趣，让我想想...",
                        "你们的推理很有道理",
                        "继续这个思路试试",
                        "还需要更多线索",
                        "这个方向值得深入"
                    ];
                    const backupResponse = backupResponses[Math.floor(Math.random() * backupResponses.length)];
                    showDMMessage(backupResponse);
                    // 🔥【修改】DM备用回应也不添加到下方聊天区域
                }
            }, 500 + Math.random() * 1000); // 更快的响应，像五子棋一样
        }

        // 🔥【新增】DM分析讨论内容并回应
        async function generateDMResponseToDiscussion(discussionContent) {
            const story = turtleSoupGameState.currentStory;
            const answer = turtleSoupGameState.currentAnswer;
            const questionCount = turtleSoupGameState.questionCount;

            // 获取游戏历史
            const gameHistory = turtleSoupGameState.gameSession.chatHistory
                .slice(-15)
                .map(msg => `${msg.sender}: ${msg.content}`)
                .join('\n');

            const dmPersonality = turtleSoupGameState.dmPersonality || 'friendly';
            let personalityGuide = '';

            switch (dmPersonality) {
                case 'friendly':
                    personalityGuide = '你是一个友善耐心的DM，会给予玩家鼓励和适当的提示，语气温和亲切。';
                    break;
                case 'mysterious':
                    personalityGuide = '你是一个神秘莫测的DM，回答简洁冷静，保持神秘感，很少给出额外信息。';
                    break;
                case 'humorous':
                    personalityGuide = '你是一个幽默风趣的DM，会用轻松幽默的语气回答，偶尔开个小玩笑活跃气氛。';
                    break;
                default:
                    personalityGuide = '你是一个专业的DM，保持中性的态度。';
            }

            const dmPrompt = `你是海龟汤游戏的专业主持人(DM)。${personalityGuide}

【当前汤面】：${story.story}
【汤底真相】：${answer}

【游戏进展】：
- 已提问次数：${questionCount}
- 游戏历史：
${gameHistory}

【这轮用户和角色的讨论内容】：
${discussionContent}

请分析用户和角色这轮的讨论，并给出合适的回应：

1. 如果包含明确的是/否问题，请回答"是"、"否"或"无关"
2. 如果是讨论和推理，给予适当的引导和鼓励
3. 如果推理方向正确，给予肯定和提示
4. 如果推理偏离，给予温和的纠正
5. 如果讨论停滞，提供新的思考角度
6. 保持神秘感，不要直接透露答案
7. 回答要简洁明确（不超过30字）

重要：请直接输出纯文本回答，不要使用JSON格式或数组格式。

请给出你的回应：`;

            try {
                const response = await callTurtleSoupDMAPI(dmPrompt);
                let dmResponse = '';

                if (Array.isArray(response) && response.length > 0) {
                    dmResponse = response[0].trim();
                } else if (typeof response === 'string') {
                    dmResponse = response.trim();
                }

                // 🔥【修复】清理DM回应中的JSON格式
                if (dmResponse.startsWith('```json') || dmResponse.startsWith('```')) {
                    // 移除代码块标记
                    dmResponse = dmResponse.replace(/```json\s*|\s*```/g, '').trim();
                }

                if (dmResponse.startsWith('[') && dmResponse.endsWith(']')) {
                    try {
                        // 如果是JSON数组，提取第一个元素
                        const parsed = JSON.parse(dmResponse);
                        if (Array.isArray(parsed) && parsed.length > 0) {
                            dmResponse = parsed[0].toString().trim();
                        }
                    } catch (e) {
                        // 如果解析失败，移除方括号
                        dmResponse = dmResponse.replace(/^\[|\]$/g, '').trim();
                        // 移除引号
                        if (dmResponse.startsWith('"') && dmResponse.endsWith('"')) {
                            dmResponse = dmResponse.slice(1, -1);
                        }
                    }
                }

                if (!dmResponse || dmResponse.length > 100) {
                    throw new Error('DM回应格式不正确');
                }

                return dmResponse;
            } catch (error) {
                console.error('DM回应生成失败:', error);
                throw error;
            }
        }

        // 🔥【重构】独立的海龟汤DM AI系统
        async function generateAIDMAnswer(question) {
            const story = turtleSoupGameState.currentStory;
            const answer = turtleSoupGameState.currentAnswer;
            const questionCount = turtleSoupGameState.questionCount;

            // 获取最近的游戏对话历史
            const recentHistory = turtleSoupGameState.gameSession.chatHistory
                .slice(-10)
                .map(msg => `${msg.sender}: ${msg.content}`)
                .join('\n');

            // 🔥【新增】根据DM性格调整prompt风格
            const dmPersonality = turtleSoupGameState.dmPersonality || 'friendly';
            let personalityGuide = '';

            switch (dmPersonality) {
                case 'friendly':
                    personalityGuide = '你是一个友善耐心的DM，会给予玩家鼓励和适当的提示，语气温和亲切。';
                    break;
                case 'mysterious':
                    personalityGuide = '你是一个神秘莫测的DM，回答简洁冷静，保持神秘感，很少给出额外信息。';
                    break;
                case 'humorous':
                    personalityGuide = '你是一个幽默风趣的DM，会用轻松幽默的语气回答，偶尔开个小玩笑活跃气氛。';
                    break;
                default:
                    personalityGuide = '你是一个专业的DM，保持中性的态度。';
            }

            const dmPrompt = `你是海龟汤游戏的专业主持人(DM)。${personalityGuide}

【当前汤面】：${story.story}
【汤底真相】：${answer}

【游戏规则】：
1. 玩家只能问是/否问题
2. 你只能回答"是"、"否"或"无关"
3. 如果问题与真相无关，回答"无关"
4. 如果问题接近真相，可以给予鼓励
5. 保持神秘感，不要直接透露答案

【当前游戏状态】：
- 已提问次数：${questionCount}
- 最近对话：
${recentHistory}

【玩家问题】：${question}

请根据你的性格特点，作为专业的海龟汤DM给出简洁明确的回答（不超过20字）。如果问题很接近真相，可以给予适当的提示和鼓励。

重要：请直接输出纯文本回答，不要使用JSON格式或数组格式。`;

            try {
                // 🔥【重要】使用独立的API调用，不依赖现有角色
                const response = await callTurtleSoupDMAPI(dmPrompt);
                let dmAnswer = '';

                if (Array.isArray(response) && response.length > 0) {
                    dmAnswer = response[0].trim();
                } else if (typeof response === 'string') {
                    dmAnswer = response.trim();
                }

                // 🔥【修复】清理DM回答中的JSON格式
                if (dmAnswer.startsWith('```json') || dmAnswer.startsWith('```')) {
                    dmAnswer = dmAnswer.replace(/```json\s*|\s*```/g, '').trim();
                }

                if (dmAnswer.startsWith('[') && dmAnswer.endsWith(']')) {
                    try {
                        const parsed = JSON.parse(dmAnswer);
                        if (Array.isArray(parsed) && parsed.length > 0) {
                            dmAnswer = parsed[0].toString().trim();
                        }
                    } catch (e) {
                        dmAnswer = dmAnswer.replace(/^\[|\]$/g, '').trim();
                        if (dmAnswer.startsWith('"') && dmAnswer.endsWith('"')) {
                            dmAnswer = dmAnswer.slice(1, -1);
                        }
                    }
                }

                // 确保回答符合游戏规则
                if (!dmAnswer || dmAnswer.length > 50) {
                    throw new Error('AI回答格式不正确');
                }

                return dmAnswer;
            } catch (error) {
                console.error('AI DM回答生成失败:', error);
                throw error;
            }
        }

        // 🔥【新增】独立的海龟汤DM API调用函数
        async function callTurtleSoupDMAPI(prompt) {
            // 🔥【修复】直接使用全局变量 apiSettings
            console.log('🎭 DM API调用开始，检查API设置:', apiSettings);

            if (!apiSettings.key || !apiSettings.base) {
                throw new Error('API设置不完整，请先配置API');
            }

            // 创建独立的DM角色设定
            const dmCharacter = {
                id: 'turtle_soup_dm',
                name: '海龟汤主持人',
                description: '专业的海龟汤游戏主持人，擅长引导推理游戏',
                personality: '专业、神秘、善于引导',
                scenario: '你是一个专业的海龟汤游戏主持人，负责主持推理游戏。',
                firstMessage: '欢迎来到海龟汤推理游戏！',
                avatar: '🎭'
            };

            console.log('🎭 调用callChatAPI，prompt长度:', prompt.length);
            const result = await callChatAPI(prompt, dmCharacter);
            console.log('🎭 callChatAPI返回结果:', result);
            return result;
        }

        // 🔥【新增】DM自动生成海龟汤故事
        async function generateTurtleSoupStoryByDM(preferredType = 'random') {
            let typeGuide = '';

            switch (preferredType) {
                case 'classic':
                    typeGuide = '经典推理类型，注重逻辑推理和细节观察';
                    break;
                case 'horror':
                    typeGuide = '恐怖悬疑类型，带有恐怖元素但不过分血腥';
                    break;
                case 'funny':
                    typeGuide = '轻松搞笑类型，幽默有趣的推理故事';
                    break;
                case 'romantic':
                    typeGuide = '浪漫情感类型，以爱情为主题的推理故事';
                    break;
                default:
                    typeGuide = '任意类型，可以是经典、恐怖、搞笑或浪漫中的任何一种';
            }

            const storyPrompt = `你是一个专业的海龟汤游戏主持人。请创作一个${typeGuide}的海龟汤推理故事。

要求：
1. 故事要有一个看似不合理或令人困惑的情景描述（汤面）
2. 要有一个合理的解释或真相（汤底）
3. 真相要能够通过是/否问题逐步推理出来
4. 故事要有趣且逻辑合理
5. 适合多人推理讨论

请按以下JSON格式返回：
{
    "title": "故事标题",
    "story": "汤面描述（看似不合理的情景）",
    "answer": "汤底真相（合理的解释）",
    "difficulty": "easy/medium/hard",
    "tags": ["类型标签"]
}

只返回JSON，不要其他文字。`;

            try {
                const response = await callTurtleSoupDMAPI(storyPrompt);
                let storyText = '';

                if (Array.isArray(response) && response.length > 0) {
                    storyText = response[0].trim();
                } else if (typeof response === 'string') {
                    storyText = response.trim();
                }

                // 🔥【增强调试】记录原始响应
                console.log('🎭 DM原始响应:', storyText);

                // 尝试解析JSON
                let storyData;
                try {
                    // 清理可能的markdown代码块标记
                    storyText = storyText.replace(/```json\n?/g, '').replace(/```\n?/g, '');
                    console.log('🎭 清理后的文本:', storyText);

                    const parsedData = JSON.parse(storyText);
                    console.log('🎭 解析后的数据:', parsedData);

                    // 🔥【修复】处理AI返回数组格式的情况
                    if (Array.isArray(parsedData) && parsedData.length > 0) {
                        storyData = parsedData[0]; // 取数组的第一个元素
                        console.log('🎭 从数组中提取的故事数据:', storyData);
                    } else if (typeof parsedData === 'object' && parsedData !== null) {
                        storyData = parsedData; // 直接使用对象
                    } else {
                        throw new Error('解析结果格式不正确');
                    }

                } catch (parseError) {
                    console.error('解析DM生成的故事JSON失败:', parseError);
                    console.error('原始文本:', storyText);
                    throw new Error('故事格式解析失败');
                }

                // 🔥【增强验证】详细检查必要字段
                console.log('🎭 验证字段:', {
                    title: storyData.title,
                    story: storyData.story,
                    answer: storyData.answer
                });

                if (!storyData.title || !storyData.story || !storyData.answer) {
                    console.error('🎭 故事数据不完整:', storyData);
                    throw new Error('故事数据不完整');
                }

                // 添加ID和默认值
                storyData.id = `dm_generated_${Date.now()}`;
                storyData.difficulty = storyData.difficulty || 'medium';
                storyData.tags = storyData.tags || [preferredType];

                console.log('🎭 DM成功生成新故事:', storyData.title);
                return storyData;

            } catch (error) {
                console.error('DM生成故事失败:', error);

                // 🔥【新增】如果API调用失败，生成一个简单的默认故事
                console.log('🎭 使用备用故事生成方案');
                const backupStory = generateBackupTurtleSoupStory(preferredType);
                return backupStory;
            }
        }

        // 🔥【新增】备用故事生成函数
        function generateBackupTurtleSoupStory(preferredType = 'random') {
            const backupStories = {
                classic: {
                    title: "深夜的电话",
                    story: "一个男人深夜接到电话后，立刻开车出门，第二天早上被发现死在车里。",
                    answer: "他是医生，接到急救电话后出诊，但在路上心脏病发作去世了。",
                    difficulty: "medium",
                    tags: ["classic"]
                },
                horror: {
                    title: "镜子里的女人",
                    story: "一个女人每天照镜子时都看到另一个女人，但她并不害怕。",
                    answer: "她是双胞胎姐妹，镜子对面就是她的双胞胎妹妹的房间。",
                    difficulty: "easy",
                    tags: ["horror"]
                },
                funny: {
                    title: "不吃饭的顾客",
                    story: "餐厅里有个顾客点了很多菜但一口都不吃，老板却很高兴。",
                    answer: "这是美食评论家在拍照写评论，虽然不吃但会带来很多客人。",
                    difficulty: "easy",
                    tags: ["funny"]
                },
                romantic: {
                    title: "每天的花束",
                    story: "一个男人每天都给同一个女人送花，但她从来不收。",
                    answer: "女人已经去世了，男人每天给她的墓碑送花。",
                    difficulty: "medium",
                    tags: ["romantic"]
                }
            };

            let selectedStory;
            if (preferredType !== 'random' && backupStories[preferredType]) {
                selectedStory = backupStories[preferredType];
            } else {
                const storyTypes = Object.keys(backupStories);
                const randomType = storyTypes[Math.floor(Math.random() * storyTypes.length)];
                selectedStory = backupStories[randomType];
            }

            // 添加ID和时间戳
            selectedStory.id = `backup_story_${Date.now()}`;
            console.log('🎭 生成备用故事:', selectedStory.title);

            return selectedStory;
        }

        // 🔥【重构】生成角色在海龟汤游戏中的回应 - 学习五子棋的AI智能化
        async function generateCharacterTurtleSoupResponse(userMessage) {
            if (!turtleSoupGameState.gameActive) return;

            const character = currentChatCharacter;
            if (!character) return;

            const story = turtleSoupGameState.currentStory;
            const questionCount = turtleSoupGameState.questionCount;

            // 🔥【学习五子棋】更详细的游戏状态分析
            const recentHistory = turtleSoupGameState.gameSession.chatHistory
                .slice(-10) // 增加历史分析范围
                .map(msg => `${msg.sender}: ${msg.content}`)
                .join('\n');

            // 🔥【学习五子棋】根据角色性格调整回应风格
            const characterPrompt = `你是${character.name}，${character.prompt}

现在你在和用户一起玩海龟汤推理游戏。

【汤面】：${story.story}

【游戏进展】：
- 已提问${questionCount}次
- 最近完整对话（包括DM的回应）：
${recentHistory}

【用户刚说】：${userMessage}

作为${character.name}，请根据你的性格特点回应用户。你可以：
1. 分析用户的推理逻辑
2. 提出新的推理角度和猜测
3. 表达赞同或质疑
4. 分享你的直觉想法
5. 对DM刚才的回应进行分析讨论
6. 提出新的问题方向

要求：
- 保持你的性格特点和说话风格
- 回复简洁有趣（20-40字）
- 像真人一样参与推理讨论
- 像真正的推理伙伴一样参与讨论
- 不要重复之前说过的话

请回应：`;

            try {
                const response = await callChatAPI(characterPrompt, character);
                let characterReply = '';

                if (Array.isArray(response) && response.length > 0) {
                    characterReply = response[0].trim();
                } else if (typeof response === 'string') {
                    characterReply = response.trim();
                }

                // 🔥【修复】移除严格限制，让回应更自然
                if (characterReply && characterReply.length > 0) {
                    // 如果回应太长，截取前100字
                    if (characterReply.length > 100) {
                        characterReply = characterReply.substring(0, 97) + '...';
                    }
                    addTurtleSoupChatMessage(character.id, characterReply, true);
                } else {
                    throw new Error('AI回应为空');
                }

            } catch (error) {
                console.error('角色回应生成失败:', error);
                // 🔥【学习五子棋】根据角色性格提供个性化的备用回应
                const personalizedResponses = getPersonalizedBackupResponses(character, userMessage);
                const randomResponse = personalizedResponses[Math.floor(Math.random() * personalizedResponses.length)];
                addTurtleSoupChatMessage(character.id, randomResponse, true);
            }
        }

        // 🔥【新增】根据角色性格生成个性化备用回应
        function getPersonalizedBackupResponses(character, userMessage) {
            // 基础回应
            const baseResponses = [
                "这个想法很有趣...",
                "让我想想这个可能性",
                "还有别的线索吗？",
                "这个方向值得探索"
            ];

            // 根据角色描述调整回应风格
            const characterDesc = (character.prompt || character.description || '').toLowerCase();

            if (characterDesc.includes('可爱') || characterDesc.includes('萌') || characterDesc.includes('天真')) {
                return [
                    "哇，好聪明的想法！",
                    "我也这么觉得呢~",
                    "还会有什么呢？",
                    "好神秘哦..."
                ];
            } else if (characterDesc.includes('冷静') || characterDesc.includes('理性') || characterDesc.includes('聪明')) {
                return [
                    "这个推理有逻辑",
                    "需要更多证据",
                    "还有其他可能性",
                    "让我分析一下"
                ];
            } else if (characterDesc.includes('活泼') || characterDesc.includes('开朗') || characterDesc.includes('热情')) {
                return [
                    "哇！这个想法不错！",
                    "我觉得你说得对！",
                    "还有什么线索呢？",
                    "好有趣的推理！"
                ];
            }

            return baseResponses;
        }

        // 🎮【保留】生成DM回答（备用模拟逻辑）
        function generateDMAnswer(question) {
            const lowerQuestion = question.toLowerCase();
            const story = turtleSoupGameState.currentStory;
            const answer = turtleSoupGameState.currentAnswer;

            // 简单的关键词匹配逻辑（后续会替换为真实API）
            if (lowerQuestion.includes('死') || lowerQuestion.includes('自杀')) {
                if (story.id === 1) return "是的。";
                return "不是。";
            }

            if (lowerQuestion.includes('盲') || lowerQuestion.includes('看不见')) {
                if (story.id === 1 || story.id === 3) return "是的。";
                return "不是。";
            }

            if (lowerQuestion.includes('电话') || lowerQuestion.includes('通话')) {
                if (story.id === 1) return "是的，这很重要。";
                return "无关。";
            }

            if (lowerQuestion.includes('医院') || lowerQuestion.includes('医生')) {
                if (story.id === 1) return "是的！";
                return "不是。";
            }

            if (lowerQuestion.includes('邮递员') || lowerQuestion.includes('送信')) {
                if (story.id === 2) return "是的！";
                return "不是。";
            }

            if (lowerQuestion.includes('尸体') || lowerQuestion.includes('死人')) {
                if (story.id === 2 || story.id === 3) return "是的。";
                return "不是。";
            }

            // 默认回答
            const randomAnswers = ["是的。", "不是。", "无关。", "这个问题很有趣，但答案是否定的。", "是的，你想对了！"];
            return randomAnswers[Math.floor(Math.random() * randomAnswers.length)];
        }

        // 🎮【新增】获取DM评论
        function getDMComment(question, answer) {
            if (answer.includes('是的！') || answer.includes('你想对了')) {
                return "很好的问题！你们离真相越来越近了！";
            } else if (answer === "是的。") {
                return "回答正确，继续这个方向思考。";
            } else if (answer === "不是。") {
                return "不对哦，换个角度试试。";
            } else {
                return "这个问题与案件无关，问点别的吧。";
            }
        }

        // 🎮【新增】更新海龟汤游戏UI
        function updateTurtleSoupUI() {
            // 更新问题计数
            const questionCountElement = document.getElementById('turtle-soup-question-count');
            questionCountElement.textContent = `提问次数: ${turtleSoupGameState.questionCount}`;
        }

        // 🎮【新增】启动海龟汤计时器
        function startTurtleSoupTimer() {
            const timerElement = document.getElementById('turtle-soup-game-timer');
            turtleSoupGameState.gameTimer = setInterval(() => {
                const elapsed = Date.now() - turtleSoupGameState.gameStartTime;
                const minutes = Math.floor(elapsed / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                timerElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }

        // 🎮【新增】请求提示
        function requestTurtleSoupHint() {
            if (!turtleSoupGameState.gameActive) {
                showToast('游戏已结束', 'warning');
                return;
            }

            const story = turtleSoupGameState.currentStory;
            const hints = [
                "想想故事中的关键人物...",
                "注意时间和地点的细节...",
                "考虑一下是否有误解或错觉...",
                "思考一下感官方面的问题..."
            ];

            const randomHint = hints[Math.floor(Math.random() * hints.length)];

            showDMMessage(`💡 提示：${randomHint}`);
            // 🔥【修改】提示只在上方DM区域显示，不在聊天区域显示
        }

        // 🎮【新增】公布答案
        function giveTurtleSoupAnswer() {
            if (!turtleSoupGameState.gameActive) {
                showToast('游戏已结束', 'warning');
                return;
            }

            if (confirm('确定要公布答案吗？游戏将会结束。')) {
                endTurtleSoupGame('give_up');
            }
        }

        // 🎮【新增】结束海龟汤游戏
        function endTurtleSoupGame(reason) {
            turtleSoupGameState.gameActive = false;
            clearInterval(turtleSoupGameState.gameTimer);

            const answer = turtleSoupGameState.currentAnswer;

            // 显示答案
            showDMMessage("游戏结束！让我来公布答案吧...");

            // 🔥【修改】答案揭晓只在上方DM区域显示
            setTimeout(() => {
                showDMMessage(`🎯 汤底揭晓：${answer}`);
            }, 1000);

            setTimeout(() => {
                if (reason === 'give_up') {
                    showDMMessage("虽然没有完全推理出来，但这个过程很有趣！要不要再来一局？");
                } else {
                    showDMMessage("恭喜你们推理出了真相！真是太厉害了！");
                }
            }, 2000);

            // 记录游戏结束事件
            turtleSoupGameState.gameSession.gameEvents.push({
                type: 'game_end',
                timestamp: Date.now(),
                player: 'system',
                data: {
                    reason: reason,
                    questionCount: turtleSoupGameState.questionCount,
                    gameDuration: Date.now() - turtleSoupGameState.gameStartTime
                }
            });
        }

        // 🎮【新增】开始新的海龟汤游戏
        async function startNewTurtleSoupGame() {
            if (turtleSoupGameState.gameActive) {
                if (!confirm('当前游戏还在进行中，确定要开始新游戏吗？')) {
                    return;
                }
            }

            await initTurtleSoupGame();
            showToast('新的海龟汤游戏开始了！', 'success');
        }

        // 🎮【修复】退出海龟汤游戏 - 学习五子棋，返回API聊天界面
        function exitTurtleSoupGame() {
            if (turtleSoupGameState.gameActive) {
                if (confirm('游戏还在进行中，确定要退出吗？')) {
                    turtleSoupGameState.gameActive = false;
                    clearInterval(turtleSoupGameState.gameTimer);
                    hideApp('turtle-soup-game-screen');

                    // 🔥【修复】学习五子棋，返回API聊天界面
                    showApp('api-chat-screen');
                }
            } else {
                hideApp('turtle-soup-game-screen');

                // 🔥【修复】学习五子棋，返回API聊天界面
                showApp('api-chat-screen');
            }
        }

        // 🎮【修改】海龟汤游戏设置 - 添加游戏类型选择
        function showTurtleSoupSettings() {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-content turtle-soup-settings-modal">
                    <div class="modal-header">
                        <h3><i class="fas fa-cog"></i> 海龟汤游戏设置</h3>
                        <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">×</button>
                    </div>
                    <div class="modal-body">
                        <div class="setting-section">
                            <h4><i class="fas fa-list"></i> 游戏类型偏好</h4>
                            <div class="turtle-soup-types">
                                <label class="turtle-soup-type-option">
                                    <input type="radio" name="turtleSoupType" value="classic" checked>
                                    <span class="type-label">
                                        <i class="fas fa-brain"></i>
                                        <strong>经典推理</strong>
                                        <small>传统海龟汤，注重逻辑推理</small>
                                    </span>
                                </label>
                                <label class="turtle-soup-type-option">
                                    <input type="radio" name="turtleSoupType" value="horror">
                                    <span class="type-label">
                                        <i class="fas fa-ghost"></i>
                                        <strong>恐怖悬疑</strong>
                                        <small>带有恐怖元素的推理故事</small>
                                    </span>
                                </label>
                                <label class="turtle-soup-type-option">
                                    <input type="radio" name="turtleSoupType" value="funny">
                                    <span class="type-label">
                                        <i class="fas fa-laugh"></i>
                                        <strong>轻松搞笑</strong>
                                        <small>幽默有趣的推理题目</small>
                                    </span>
                                </label>
                                <label class="turtle-soup-type-option">
                                    <input type="radio" name="turtleSoupType" value="romantic">
                                    <span class="type-label">
                                        <i class="fas fa-heart"></i>
                                        <strong>浪漫情感</strong>
                                        <small>以爱情为主题的推理故事</small>
                                    </span>
                                </label>
                                <label class="turtle-soup-type-option">
                                    <input type="radio" name="turtleSoupType" value="random">
                                    <span class="type-label">
                                        <i class="fas fa-random"></i>
                                        <strong>随机选择</strong>
                                        <small>随机从所有类型中选择</small>
                                    </span>
                                </label>
                            </div>
                        </div>

                        <div class="setting-section">
                            <h4><i class="fas fa-user-tie"></i> DM性格设置</h4>
                            <div class="dm-personality-options">
                                <label class="dm-personality-option">
                                    <input type="radio" name="dmPersonality" value="friendly" checked>
                                    <span>友善型 - 温和耐心，给予鼓励</span>
                                </label>
                                <label class="dm-personality-option">
                                    <input type="radio" name="dmPersonality" value="mysterious">
                                    <span>神秘型 - 保持神秘感，简洁回答</span>
                                </label>
                                <label class="dm-personality-option">
                                    <input type="radio" name="dmPersonality" value="humorous">
                                    <span>幽默型 - 风趣幽默，活跃气氛</span>
                                </label>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="this.closest('.modal-overlay').remove()">取消</button>
                        <button class="btn btn-primary" onclick="saveTurtleSoupSettings()">保存设置</button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // 加载当前设置
            loadTurtleSoupSettings();
        }

        // 🔥【新增】保存海龟汤设置
        async function saveTurtleSoupSettings() {
            const typeRadio = document.querySelector('input[name="turtleSoupType"]:checked');
            const personalityRadio = document.querySelector('input[name="dmPersonality"]:checked');

            if (!typeRadio || !personalityRadio) {
                showToast('请选择设置选项', 'warning');
                return;
            }

            const settings = {
                preferredType: typeRadio.value,
                dmPersonality: personalityRadio.value
            };

            try {
                await db.globalSettings.put({
                    key: 'turtleSoupSettings',
                    value: settings
                });

                // 更新当前游戏状态
                if (turtleSoupGameState.gameActive) {
                    turtleSoupGameState.dmPersonality = settings.dmPersonality;
                }

                showToast('设置已保存', 'success');
                document.querySelector('.modal-overlay').remove();
            } catch (error) {
                console.error('保存海龟汤设置失败:', error);
                showToast('保存设置失败', 'error');
            }
        }

        // 🔥【新增】加载海龟汤设置
        async function loadTurtleSoupSettings() {
            try {
                const settings = await db.globalSettings.get('turtleSoupSettings');
                if (settings && settings.value) {
                    const { preferredType, dmPersonality } = settings.value;

                    // 设置类型选择
                    const typeRadio = document.querySelector(`input[name="turtleSoupType"][value="${preferredType}"]`);
                    if (typeRadio) typeRadio.checked = true;

                    // 设置DM性格
                    const personalityRadio = document.querySelector(`input[name="dmPersonality"][value="${dmPersonality}"]`);
                    if (personalityRadio) personalityRadio.checked = true;
                }
            } catch (error) {
                console.error('加载海龟汤设置失败:', error);
            }
        }

        // 🎮【修改】监听海龟汤聊天输入框回车事件 - 只发送消息，不触发DM
        document.addEventListener('DOMContentLoaded', function() {
            const turtleSoupInput = document.getElementById('turtle-soup-chat-input');
            if (turtleSoupInput) {
                turtleSoupInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        sendTurtleSoupQuestion(); // 只发送消息到聊天区域
                    }
                });
            }
        });

        // 加载今日日记内容
        async function loadTodayDiary() {
            if (!currentChatCharacter) {
                return;
            }

            const today = new Date().toISOString().split('T')[0];
            const diaryId = `${currentChatCharacter.id}_${today}`;

            let todayDiary = null;
            try {
                // 🔥【修复】从Dexie数据库获取今日日记
                todayDiary = await db.characterDiaries.get(diaryId);

                // 🔥【数据迁移】如果Dexie中没有数据，尝试从localStorage迁移
                if (!todayDiary) {
                    const oldDiaryKey = `diary_${currentChatCharacter.id}_${today}`;
                    const localStorageDiary = localStorage.getItem(oldDiaryKey);

                    if (localStorageDiary) {
                        // 迁移到Dexie
                        const cleanedContent = cleanDiaryContent(localStorageDiary);
                        await db.characterDiaries.add({
                            id: diaryId,
                            characterId: currentChatCharacter.id,
                            date: today,
                            content: cleanedContent,
                            timestamp: new Date().getTime(),
                            weather: '☀️'
                        });
                        todayDiary = { content: cleanedContent };

                        // 清理localStorage数据
                        localStorage.removeItem(oldDiaryKey);
                        console.log('✅ 日记数据已从localStorage迁移到Dexie');
                    }
                }
            } catch (error) {
                console.error('获取今日日记失败:', error);
                showToast('获取日记失败', 'error');
                return;
            }

            const contentDiv = document.getElementById('today-diary-content');
            const generateBtn = document.getElementById('generate-diary-btn');

            // 重置按钮状态
            const editBtn = document.getElementById('edit-diary-btn');
            if (generateBtn) {
                generateBtn.disabled = false;
                generateBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
                generateBtn.title = '生成日记';
            }

            if (todayDiary && todayDiary.content) {
                // 显示已有的日记，包含头部信息
                const diaryWithHeader = createDiaryWithHeader(todayDiary.content, today);
                contentDiv.innerHTML = diaryWithHeader;
                contentDiv.classList.remove('empty');
                if (generateBtn) {
                    generateBtn.style.display = 'block';
                    generateBtn.title = '重新生成日记';
                }
                if (editBtn) editBtn.style.display = 'block';
            } else {
                contentDiv.innerHTML = `
                    <div class="empty-diary-message">
                        <div class="empty-diary-text">今天还没有写日记呢...</div>
                        <button class="generate-diary-link" onclick="generateTodayDiary()">🔘 喊他来写日记吧</button>
                    </div>
                `;
                contentDiv.classList.add('empty');
                if (generateBtn) {
                    generateBtn.style.display = 'block';
                    generateBtn.title = '生成日记';
                }
                if (editBtn) editBtn.style.display = 'none';
            }
        }

        // 显示今日日记（兼容旧接口）
        async function showTodayDiary() {
            showDiaryMenu();
        }

        // 生成今日日记
        async function generateTodayDiary() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'error');
                return;
            }

            // 🔥【修改】群聊中不支持日记功能
            if (currentChatCharacter.isGroup) {
                showToast('群聊中不支持日记功能，请在单聊中使用', 'error');
                return;
            }

            const generateBtn = document.getElementById('generate-diary-btn');
            const contentDiv = document.getElementById('today-diary-content');

            // 获取今日日记
            const today = new Date().toISOString().split('T')[0];
            const diaryId = `${currentChatCharacter.id}_${today}`;

            let existingDiary = null;
            try {
                // 🔥【修复】从Dexie数据库获取今日日记
                existingDiary = await db.characterDiaries.get(diaryId);
            } catch (error) {
                console.error('获取今日日记失败:', error);
            }

            // 如果已有日记，提示用户将重新生成
            if (existingDiary && existingDiary.content) {
                const confirmRegenerate = confirm('今天已经有日记了，是否要重新生成？这将覆盖原有的日记。');
                if (!confirmRegenerate) {
                    return;
                }
            }

            // 🔥【修复】添加空值检查
            if (generateBtn) {
                generateBtn.disabled = true;
                generateBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                generateBtn.title = 'TA在写呢...';
            }
            contentDiv.innerHTML = '正在写日记...';
            contentDiv.classList.remove('empty');

            try {
                const character = currentChatCharacter;
                const characterId = character.id;

                // 🔥【修复】获取该角色的聊天设置
                const chatSettings = await getAsyncChatSettings(characterId);

                // 获取聊天历史（使用历史消息回合数设置）
                const messages = chatMessages[characterId] || [];
                const historyCount = chatSettings.historyCount || 5;
                const recentMessages = messages.slice(-historyCount);

                // 🔥【修复】获取角色可见的动态内容，包含分组过滤
                const crossWindowMemory = chatSettings.crossWindowMemory || 3;
                const recentMoments = await getVisibleMomentsForCharacter(character.id, crossWindowMemory);

                // 构建聊天历史上下文
                let chatContext = '';
                if (recentMessages.length > 0) {
                    chatContext = '\n\n最近的聊天记录：\n' +
                        recentMessages.map(msg => {
                            if (msg.sender === 'sent') return `用户：${msg.content}`;
                            if (msg.sender === 'received') return `${character.name}：${msg.content}`;
                            return '';
                        }).filter(Boolean).join('\n');
                }

                // 🔥【修复】构建动态上下文，包含时间戳信息和评论
                let momentsContext = '';
                if (recentMoments.length > 0) {
                    momentsContext = '\n\n最近的动态内容：\n';
                    recentMoments.forEach((moment, index) => {
                        const authorName = moment.authorId === 'user' ? '用户' : moment.nickname;

                        // 🔥【新增】添加时间戳信息
                        let timeInfo = '';
                        if (moment.timestamp) {
                            const now = Date.now();
                            const timeDiff = now - moment.timestamp;
                            const minutes = Math.floor(timeDiff / (1000 * 60));
                            const hours = Math.floor(timeDiff / (1000 * 60 * 60));
                            const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));

                            if (days > 0) {
                                timeInfo = `（${days}天前发布）`;
                            } else if (hours > 0) {
                                timeInfo = `（${hours}小时前发布）`;
                            } else if (minutes > 0) {
                                timeInfo = `（${minutes}分钟前发布）`;
                            } else {
                                timeInfo = '（刚刚发布）';
                            }
                        }

                        let momentText = `${authorName}: ${moment.text}${timeInfo}`;

                        // 保留评论功能
                        if (moment.comments && moment.comments.length > 0) {
                            const commentTexts = moment.comments.map(comment =>
                                `  ${comment.nickname}: ${comment.text}`
                            ).join('\n');
                            momentText += '\n评论：\n' + commentTexts;
                        }

                        momentsContext += momentText + '\n\n';
                    });
                }

                // 获取世界书信息
                let worldbookContext = '';
                if (character.worldbook && character.worldbook.length > 0) {
                    worldbookContext = '\n\n世界书信息：\n' +
                        character.worldbook.map(entry => `${entry.key}: ${entry.value}`).join('\n');
                }

                // 构建日记生成prompt
                const currentDate = new Date().toLocaleDateString('zh-CN', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    weekday: 'long'
                });

                const prompt = `你是${character.name}，你的人设如下：${character.bio}${worldbookContext}

现在是${currentDate}，你需要写一篇私人日记。

重要要求：
- 请直接输出日记内容，不要使用JSON格式或任何代码块
- 请在日记开头自己写上日期和天气，格式如："2025年8月3日 星期日，天气：晴朗"
- 用你的口吻和性格来写
- 记录你今天的想法、感受和经历
- 可以提及对用户的真实感情
- 基于最近的聊天记录，可适当考虑工作记忆和同分组好友的动态内容、角色自己和用户的动态内容
- 保持角色的一致性和真实性
- 内容要自然、真实，像真正的私人日记
- 字数在50-500字之间，根据你的性格和当天的心情自由发挥${chatContext}${momentsContext}

特殊样式说明（可选使用，每种样式在同一篇日记中最多使用2次，该特殊样式并不是一定要使用，可以不用）：
- 如果写到不该说的话或后悔写下的内容，可以用 <strike>内容</strike> 标记划掉
- 如果表达重点或语气激动的内容，可以用 <mark>内容</mark> 标记高亮

请直接写出${character.name}的私人日记内容：`;

                const diaryContent = await generateAIResponse(prompt, character);

                if (diaryContent && diaryContent.trim()) {
                    let finalDiary = diaryContent.trim();

                    // 清理可能的JSON格式包装
                    finalDiary = cleanDiaryContent(finalDiary);

                    // 🔥【修复】保存今日日记到Dexie数据库
                    try {
                        await db.characterDiaries.put({
                            id: diaryId,
                            characterId: characterId,
                            date: today,
                            content: finalDiary,
                            timestamp: Date.now(),
                            weather: '☀️' // 默认天气，后续可以扩展
                        });
                        console.log('✅ 日记已保存到数据库');
                    } catch (saveError) {
                        console.error('保存日记到数据库失败:', saveError);
                        throw new Error('保存日记失败');
                    }

                    // 显示日记内容，包含头部信息
                    const diaryWithHeader = createDiaryWithHeader(finalDiary);
                    contentDiv.innerHTML = diaryWithHeader;
                    contentDiv.classList.remove('empty');

                    // 🔥【修复】添加空值检查
                    if (generateBtn) {
                        generateBtn.disabled = false;
                        generateBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
                        generateBtn.title = '重新生成日记';
                    }

                    // 显示编辑按钮
                    const editBtn = document.getElementById('edit-diary-btn');
                    if (editBtn) editBtn.style.display = 'block';

                    showToast(existingDiary ? '日记重新生成完成' : '日记生成完成', 'success');
                } else {
                    throw new Error('生成日记失败');
                }
            } catch (error) {
                console.error('生成日记失败:', error);
                contentDiv.innerHTML = '生成日记失败，请稍后重试';
                contentDiv.classList.add('empty');

                // 🔥【修复】添加空值检查
                if (generateBtn) {
                    generateBtn.disabled = false;
                    generateBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
                    generateBtn.title = existingDiary ? '重新生成日记' : '生成日记';
                }
                showToast('生成日记失败', 'error');
            }
        }

        // 加载过往日记内容
        async function loadPastDiaries() {
            if (!currentChatCharacter) {
                return;
            }

            const characterId = currentChatCharacter.id;

            let pastDiaries = [];
            try {
                // 🔥【修复】从Dexie数据库获取过往日记
                pastDiaries = await db.characterDiaries
                    .where('characterId')
                    .equals(characterId)
                    .reverse() // 按时间倒序排列
                    .sortBy('timestamp');

                console.log(`获取到 ${pastDiaries.length} 条日记记录`);
            } catch (error) {
                console.error('获取过往日记失败:', error);
                showToast('获取日记失败', 'error');
                return;
            }

            const listDiv = document.getElementById('past-diaries-list');

            if (pastDiaries.length === 0) {
                listDiv.innerHTML = `
                    <div class="no-diaries">
                        <i class="fas fa-book-open"></i>
                        <div>还没有任何日记记录</div>
                    </div>
                `;
            } else {
                listDiv.innerHTML = pastDiaries.map((diary, index) => {
                    const date = new Date(diary.date).toLocaleDateString('zh-CN', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric',
                        weekday: 'long'
                    });

                    // 移除HTML标记用于预览显示
                    const cleanContent = diary.content.replace(/<[^>]*>/g, '');
                    const preview = cleanContent.length > 100 ?
                        cleanContent.substring(0, 100) + '...' :
                        cleanContent;

                    return `
                        <div class="diary-entry" onclick="toggleDiaryEntry(${index})">
                            <div class="diary-entry-date">${date}</div>
                            <div class="diary-entry-preview">${preview}</div>
                            <div class="diary-entry-arrow">›</div>
                        </div>
                    `;
                }).join('');
            }
        }

        // 显示过往日记（兼容旧接口）
        async function showPastDiaries() {
            showDiaryMenu();
            switchDiaryTab('past');
        }

        // 打开单个过往日记的全屏查看
        async function toggleDiaryEntry(index) {
            if (!currentChatCharacter) {
                return;
            }

            try {
                // 获取该角色的所有日记
                const characterId = currentChatCharacter.id;
                const allDiaries = await db.characterDiaries
                    .where('characterId')
                    .equals(characterId)
                    .reverse()
                    .sortBy('date');

                if (index >= 0 && index < allDiaries.length) {
                    const diary = allDiaries[index];

                    // 显示单个日记全屏视图
                    await showSingleDiaryView(diary);
                }
            } catch (error) {
                console.error('打开日记失败:', error);
                showToast('打开日记失败', 'error');
            }
        }

        // 🔥【重构】显示单个日记的全屏视图 - 使用Dexie数据库
        async function showSingleDiaryView(diary) {
            // 隐藏过往日记列表
            document.getElementById('past-diaries-view').classList.remove('active');

            // 显示单个日记视图
            const singleDiaryView = document.getElementById('single-diary-view');
            singleDiaryView.classList.add('active');

            // 更新标题
            const title = document.getElementById('diary-mode-title');
            const date = new Date(diary.date).toLocaleDateString('zh-CN', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                weekday: 'long'
            });
            title.textContent = date;

            // 显示日记内容
            const contentDiv = document.getElementById('single-diary-content');
            const diaryContent = createDiaryWithHeader(diary.content, diary.date);
            contentDiv.innerHTML = diaryContent;

            // 应用当前的日记设置
            await applyDiarySettingsToSingleView();
        }

        // 从单个日记视图返回到过往日记列表
        function backFromSingleDiary() {
            // 隐藏单个日记视图
            document.getElementById('single-diary-view').classList.remove('active');

            // 显示过往日记列表
            document.getElementById('past-diaries-view').classList.add('active');

            // 恢复标题
            document.getElementById('diary-mode-title').textContent = '过往日记';
        }

        // 创建日记内容（不再添加独立的头部，让角色自己填写日期和天气）
        function createDiaryWithHeader(diaryContent, diaryDate = null) {
            // 确保日记内容经过样式处理
            const processedContent = processDiaryStyles(diaryContent);

            // 直接返回处理后的内容，不添加额外的日期和天气头部
            return processedContent;
        }

        // 清理日记内容，移除可能的JSON格式包装
        function cleanDiaryContent(content) {
            // 移除可能的JSON包装
            if (content.startsWith('```json') && content.endsWith('```')) {
                content = content.slice(7, -3).trim();
            }
            if (content.startsWith('```') && content.endsWith('```')) {
                content = content.slice(3, -3).trim();
            }

            // 尝试解析JSON格式的内容
            try {
                const parsed = JSON.parse(content);
                if (typeof parsed === 'string') {
                    content = parsed;
                } else if (parsed.content) {
                    content = parsed.content;
                } else if (parsed.diary) {
                    content = parsed.diary;
                } else if (parsed.text) {
                    content = parsed.text;
                }
            } catch (e) {
                // 不是JSON格式，继续处理
            }

            // 移除可能的引号包装
            if ((content.startsWith('"') && content.endsWith('"')) ||
                (content.startsWith("'") && content.endsWith("'"))) {
                content = content.slice(1, -1);
            }

            // 处理特殊样式标记
            content = processDiaryStyles(content);

            return content;
        }

        // 处理日记特殊样式
        function processDiaryStyles(content) {
            // 限制每种样式最多使用2次
            let strikeCount = 0;
            let highlightCount = 0;

            // 处理划线样式 <strike>内容</strike>
            content = content.replace(/<strike>(.*?)<\/strike>/gi, (match, text) => {
                if (strikeCount < 2) {
                    strikeCount++;
                    return `<span class="diary-strikethrough">${text}</span>`;
                }
                return text; // 超过限制时移除标记但保留文本
            });

            // 处理高亮样式 <mark>内容</mark>
            content = content.replace(/<mark>(.*?)<\/mark>/gi, (match, text) => {
                if (highlightCount < 2) {
                    highlightCount++;
                    return `<span class="diary-highlight">${text}</span>`;
                }
                return text; // 超过限制时移除标记但保留文本
            });

            return content;
        }

        // 🔥【数据迁移】迁移过往日记格式 - 一次性执行
        function migratePastDiariesFormat(characterId, oldDateStr, newDateStr, diaryContent) {
            // 检查是否已经迁移过
            const migrationKey = `diary_migration_${characterId}`;
            if (localStorage.getItem(migrationKey)) {
                return; // 已经迁移过，跳过
            }

            const pastDiariesKey = `past_diaries_${characterId}`;
            let pastDiaries = JSON.parse(localStorage.getItem(pastDiariesKey) || '[]');

            // 检查是否已经有今天的记录（新格式）
            const existingNewIndex = pastDiaries.findIndex(diary => diary.date === newDateStr);

            if (existingNewIndex === -1) {
                // 检查是否有旧格式的记录
                const existingOldIndex = pastDiaries.findIndex(diary => diary.date === oldDateStr);

                if (existingOldIndex !== -1) {
                    // 更新旧记录的日期格式
                    pastDiaries[existingOldIndex].date = newDateStr;
                    pastDiaries[existingOldIndex].content = diaryContent;
                    pastDiaries[existingOldIndex].timestamp = Date.now();
                } else {
                    // 添加新记录
                    pastDiaries.unshift({
                        date: newDateStr,
                        content: diaryContent,
                        timestamp: Date.now()
                    });
                }

                localStorage.setItem(pastDiariesKey, JSON.stringify(pastDiaries));
            }

            // 标记已完成迁移
            localStorage.setItem(migrationKey, 'completed');
        }

        // 编辑今日日记
        async function editTodayDiary() {
            if (!currentChatCharacter) {
                showToast('请先选择角色', 'error');
                return;
            }

            // 🔥【修改】群聊中不支持日记功能
            if (currentChatCharacter.isGroup) {
                showToast('群聊中不支持日记功能，请在单聊中使用', 'error');
                return;
            }

            const characterId = currentChatCharacter.id;

            const today = new Date().toISOString().split('T')[0];
            const diaryId = `${characterId}_${today}`;

            let todayDiary = null;
            try {
                // 🔥【修复】从Dexie数据库获取今日日记
                todayDiary = await db.characterDiaries.get(diaryId);
            } catch (error) {
                console.error('获取今日日记失败:', error);
                showToast('获取日记失败', 'error');
                return;
            }

            if (!todayDiary || !todayDiary.content) {
                showToast('今天还没有日记可以编辑', 'error');
                return;
            }

            // 将HTML格式转换回标记格式用于编辑
            const editableContent = convertHtmlToMarkup(todayDiary.content);

            // 创建编辑模态框
            const editModal = document.createElement('div');
            editModal.className = 'modal';
            editModal.style.display = 'flex';
            editModal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h3 class="modal-title">编辑日记</h3>
                        <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <textarea id="edit-diary-textarea" class="diary-edit-textarea" placeholder="编辑日记内容...">${editableContent}</textarea>
                        <div class="modal-actions">
                            <button class="modal-button modal-secondary" onclick="this.closest('.modal').remove()">取消</button>
                            <button class="modal-button modal-primary" onclick="saveDiaryEdit()">保存</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(editModal);

            // 聚焦到文本框
            const textarea = editModal.querySelector('#edit-diary-textarea');
            textarea.focus();
            textarea.setSelectionRange(textarea.value.length, textarea.value.length);
        }

        // 将HTML格式转换回标记格式用于编辑
        function convertHtmlToMarkup(content) {
            return content
                .replace(/<span class="diary-strikethrough">(.*?)<\/span>/gi, '<strike>$1</strike>')
                .replace(/<span class="diary-highlight">(.*?)<\/span>/gi, '<mark>$1</mark>');
        }

        // 保存日记编辑
        async function saveDiaryEdit() {
            if (!currentChatCharacter) {
                showToast('请先选择角色', 'error');
                return;
            }

            // 🔥【修改】群聊中不支持日记功能
            if (currentChatCharacter.isGroup) {
                showToast('群聊中不支持日记功能，请在单聊中使用', 'error');
                return;
            }

            const characterId = currentChatCharacter.id;
            const today = new Date().toISOString().split('T')[0];
            const diaryId = `${characterId}_${today}`;

            const textarea = document.getElementById('edit-diary-textarea');
            const newContent = textarea.value.trim();

            if (!newContent) {
                showToast('日记内容不能为空', 'error');
                return;
            }

            // 处理特殊样式标记
            const processedContent = processDiaryStyles(newContent);

            try {
                // 🔥【修复】保存到Dexie数据库
                await db.characterDiaries.put({
                    id: diaryId,
                    characterId: characterId,
                    date: today,
                    content: processedContent,
                    timestamp: Date.now(),
                    weather: '☀️' // 保持原有天气或默认值
                });

                // 更新显示
                const contentDiv = document.getElementById('today-diary-content');
                const diaryWithHeader = createDiaryWithHeader(processedContent, today);
                contentDiv.innerHTML = diaryWithHeader;
                contentDiv.classList.remove('empty');

                // 关闭编辑模态框
                document.querySelector('.modal:last-child').remove();

                showToast('日记保存成功', 'success');

            } catch (error) {
                console.error('保存日记失败:', error);
                showToast('保存日记失败', 'error');
            }
        }

        // 🔥【重构】打开日记设置 - 使用Dexie数据库
        async function openDiarySettings() {
            // 记录来源界面
            window.diarySettingsSourceScreen = 'diary-screen';

            // 显示全屏设置界面
            showApp('diary-settings-screen');

            // 初始化设置界面
            await initDiarySettingsScreen();
        }

        // 🔥【重构】从日记设置界面返回 - 使用Dexie数据库
        async function backFromDiarySettings() {
            // 获取来源界面，默认返回日记界面
            const sourceScreen = window.diarySettingsSourceScreen || 'diary-screen';

            // 隐藏设置界面
            hideApp('diary-settings-screen');

            // 显示来源界面
            showApp(sourceScreen);

            // 清除来源记录
            window.diarySettingsSourceScreen = null;

            // 应用设置到日记界面
            await applyDiarySettingsToContent();
        }

        // 🔥【重构】初始化日记设置界面 - 使用Dexie数据库
        async function initDiarySettingsScreen() {
            try {
                // 加载保存的设置
                await loadDiarySettings();

                // 更新预览
                await updateDiaryPreview();
            } catch (error) {
                console.error('初始化日记设置界面失败:', error);
            }
        }

        // 🔥【重构】获取角色特定的日记设置ID
        function getDiarySettingId(settingName) {
            if (!currentChatCharacter) {
                return `global_${settingName}`; // 如果没有当前角色，使用全局设置
            }
            return `${currentChatCharacter.id}_${settingName}`;
        }

        // 🔥【重构】获取角色特定的日记设置 - 使用Dexie数据库
        async function getDiarySetting(settingName, defaultValue) {
            try {
                const settingId = getDiarySettingId(settingName);
                const setting = await db.diarySettings.get(settingId);
                return setting ? setting.settingValue : defaultValue;
            } catch (error) {
                console.error('获取日记设置失败:', error);
                return defaultValue;
            }
        }

        // 🔥【重构】保存角色特定的日记设置 - 使用Dexie数据库
        async function setDiarySetting(settingName, value) {
            try {
                const settingId = getDiarySettingId(settingName);
                const characterId = currentChatCharacter ? currentChatCharacter.id : null;

                await db.diarySettings.put({
                    id: settingId,
                    characterId: characterId,
                    settingName: settingName,
                    settingValue: value,
                    timestamp: Date.now()
                });
            } catch (error) {
                console.error('保存日记设置失败:', error);
            }
        }

        // 🔥【重构】加载日记设置 - 使用Dexie数据库
        async function loadDiarySettings() {
            try {
                // 🔥【修改】移除字体族设置，使用全局字体
                const fontSize = await getDiarySetting('font-size', '16');
                const fontWeight = await getDiarySetting('font-weight', '500');

                // 排版设置
                const lineHeight = await getDiarySetting('line-height', '1.6');
                const paragraphSpacing = await getDiarySetting('paragraph-spacing', '15');
                const textAlign = await getDiarySetting('text-align', 'left');

                // 内容宽度设置
                const contentWidth = await getDiarySetting('content-width', '100');
                const contentPadding = await getDiarySetting('content-padding', '40');
                const contentTopMargin = await getDiarySetting('content-top-margin', '20');

                // 纸张设置
                const paperType = await getDiarySetting('paper-type', 'plain');

                // 🔥【修改】更新界面控件，移除字体族选择器
                // document.getElementById('font-family-select').value = fontFamily; // 已移除
                document.getElementById('font-size-slider').value = fontSize;
                document.getElementById('font-size-value').textContent = fontSize + 'px';

                document.getElementById('line-height-slider').value = lineHeight;
                document.getElementById('line-height-value').textContent = lineHeight;
                document.getElementById('paragraph-spacing-slider').value = paragraphSpacing;
                document.getElementById('paragraph-spacing-value').textContent = paragraphSpacing + 'px';

                document.getElementById('content-width-slider').value = contentWidth;
                document.getElementById('content-width-value').textContent = contentWidth + '%';
                document.getElementById('content-padding-slider').value = contentPadding;
                document.getElementById('content-padding-value').textContent = contentPadding + 'px';
                document.getElementById('content-top-margin-slider').value = contentTopMargin;
                document.getElementById('content-top-margin-value').textContent = contentTopMargin + 'px';

                // 更新下拉选择器状态
                const fontWeightSelect = document.getElementById('fontWeightSelect');
                if (fontWeightSelect) {
                    fontWeightSelect.value = fontWeight;
                }

                const textAlignSelect = document.getElementById('textAlignSelect');
                if (textAlignSelect) {
                    textAlignSelect.value = textAlign;
                }

                // 文本装饰设置
                const textDecoration = await getDiarySetting('text-decoration', 'none');
                const textDecorationSelect = document.getElementById('textDecorationSelect');
                if (textDecorationSelect) {
                    textDecorationSelect.value = textDecoration;
                }

                document.querySelectorAll('.paper-option').forEach(option => {
                    option.classList.remove('active');
                    if (option.dataset.paper === paperType) {
                        option.classList.add('active');
                    }
                });
            } catch (error) {
                console.error('加载日记设置失败:', error);
            }
        }

        // 🔥【重构】更新日记设置 - 使用Dexie数据库
        async function updateDiarySettings() {
            try {
                // 🔥【修改】获取当前设置值，移除字体族
                // const fontFamily = document.getElementById('font-family-select').value; // 已移除
                const fontSize = document.getElementById('font-size-slider').value;
                const lineHeight = document.getElementById('line-height-slider').value;
                const paragraphSpacing = document.getElementById('paragraph-spacing-slider').value;
                const contentWidth = document.getElementById('content-width-slider').value;
                const contentPadding = document.getElementById('content-padding-slider').value;
                const contentTopMargin = document.getElementById('content-top-margin-slider').value;

                // 更新显示值
                document.getElementById('font-size-value').textContent = fontSize + 'px';
                document.getElementById('line-height-value').textContent = lineHeight;
                document.getElementById('paragraph-spacing-value').textContent = paragraphSpacing + 'px';
                document.getElementById('content-width-value').textContent = contentWidth + '%';
                document.getElementById('content-padding-value').textContent = contentPadding + 'px';
                document.getElementById('content-top-margin-value').textContent = contentTopMargin + 'px';

                // 🔥【修改】保存设置，移除字体族
                // await setDiarySetting('font-family', fontFamily); // 已移除
                await setDiarySetting('font-size', fontSize);
                await setDiarySetting('line-height', lineHeight);
                await setDiarySetting('paragraph-spacing', paragraphSpacing);
                await setDiarySetting('content-width', contentWidth);
                await setDiarySetting('content-padding', contentPadding);
                await setDiarySetting('content-top-margin', contentTopMargin);

                // 更新预览
                await updateDiaryPreview();
            } catch (error) {
                console.error('更新日记设置失败:', error);
            }
        }

        // 🔥【重构】设置字体粗细 - 使用Dexie数据库
        async function setFontWeight(weight) {
            const select = document.getElementById('fontWeightSelect');
            if (select) {
                select.value = weight;
            }

            await setDiarySetting('font-weight', weight);
            await updateDiaryPreview();
        }

        // 🔥【重构】设置文本对齐 - 使用Dexie数据库
        async function setTextAlign(align) {
            const select = document.getElementById('textAlignSelect');
            if (select) {
                select.value = align;
            }

            await setDiarySetting('text-align', align);
            await updateDiaryPreview();
        }

        // 🔥【重构】设置文本装饰 - 使用Dexie数据库
        async function setTextDecoration(decoration) {
            const select = document.getElementById('textDecorationSelect');
            if (select) {
                select.value = decoration;
            }

            // 保存设置
            await setDiarySetting('text-decoration', decoration);

            // 应用到当前日记显示
            applyTextDecoration(decoration);

            // 更新预览
            await updateDiaryPreview();
        }

        // 应用文本装饰到日记显示
        function applyTextDecoration(decoration) {
            const diaryContent = document.getElementById('today-diary-content');
            if (diaryContent) {
                // 移除所有装饰类
                diaryContent.classList.remove('decoration-none', 'decoration-underline');

                // 添加新的装饰类
                if (decoration && decoration !== 'none') {
                    diaryContent.classList.add('decoration-' + decoration);
                }
            }
        }

        // 🔥【重构】更新预览效果 - 使用Dexie数据库
        async function updateDiaryPreview() {
            const preview = document.getElementById('diary-preview-content');
            if (!preview) return;

            try {
                // 🔥【修改】获取当前设置，移除字体族
                const fontSize = await getDiarySetting('font-size', '16');
                const fontWeight = await getDiarySetting('font-weight', '500');
                const lineHeight = await getDiarySetting('line-height', '1.6');
                const paragraphSpacing = await getDiarySetting('paragraph-spacing', '15');
                const textAlign = await getDiarySetting('text-align', 'left');
                const contentWidth = await getDiarySetting('content-width', '100');
                const contentPadding = await getDiarySetting('content-padding', '40');
                const contentTopMargin = await getDiarySetting('content-top-margin', '20');
                const paperType = await getDiarySetting('paper-type', 'plain');
                const textDecoration = await getDiarySetting('text-decoration', 'none');

            // 🔥【修改】不再设置字体族，使用全局字体
            // 应用样式（不包括fontFamily）
            preview.style.fontSize = fontSize + 'px';
            preview.style.fontWeight = fontWeight;
            preview.style.lineHeight = lineHeight;
            preview.style.textAlign = textAlign;
            preview.style.width = contentWidth + '%';
            preview.style.paddingLeft = contentPadding + 'px';
            preview.style.paddingRight = contentPadding + 'px';
            preview.style.paddingTop = contentTopMargin + 'px';

            // 应用段落间距
            const previewText = preview.querySelector('.preview-text');
            if (previewText) {
                previewText.style.marginBottom = paragraphSpacing + 'px';
            }

            // 应用纸张背景 - 先清除所有纸张类，再添加新的
            preview.className = 'diary-preview-paper';
            if (paperType && paperType !== 'plain') {
                preview.classList.add(paperType + '-paper');
            }

            // 应用文本装饰
            if (textDecoration && textDecoration !== 'none') {
                preview.classList.add('decoration-' + textDecoration);
            }

                // 处理背景图片
                if (paperType === 'custom') {
                    const customBg = await getDiarySetting('custom-background', '');
                    if (customBg) {
                        preview.style.backgroundImage = `url(${customBg})`;
                    } else {
                        preview.style.backgroundImage = '';
                    }
                } else {
                    // 清除自定义背景图片
                    preview.style.backgroundImage = '';
                }
            } catch (error) {
                console.error('更新日记预览失败:', error);
            }
        }

        // 🔥【重构】重置日记设置 - 使用Dexie数据库
        async function resetDiarySettings() {
            if (!confirm('确定要重置所有日记设置吗？这将恢复默认设置。')) {
                return;
            }

            try {
                // 清除所有设置
                const settingsNames = [
                    'font-family', 'font-size', 'font-weight',
                    'line-height', 'paragraph-spacing', 'text-align',
                    'content-width', 'content-padding', 'content-top-margin', 'paper-type',
                    'custom-background', 'text-decoration'
                ];

                for (const settingName of settingsNames) {
                    const settingId = getDiarySettingId(settingName);
                    await db.diarySettings.delete(settingId);
                }

                // 重新加载设置界面
                await loadDiarySettings();
                await updateDiaryPreview();

                showToast('设置已重置为默认值', 'success');
            } catch (error) {
                console.error('重置日记设置失败:', error);
                showToast('重置设置失败', 'error');
            }
        }

        // 🔥【重构】应用设置到日记内容 - 使用Dexie数据库
        async function applyDiarySettingsToContent() {
            const diaryContent = document.getElementById('today-diary-content');
            if (!diaryContent) return;

            try {
                // 🔥【修改】获取设置，移除字体族
                const fontSize = await getDiarySetting('font-size', '16');
                const fontWeight = await getDiarySetting('font-weight', '500');
                const lineHeight = await getDiarySetting('line-height', '1.6');
                const textAlign = await getDiarySetting('text-align', 'left');
                const contentWidth = await getDiarySetting('content-width', '100');
                const contentPadding = await getDiarySetting('content-padding', '40');
                const contentTopMargin = await getDiarySetting('content-top-margin', '20');
                const textDecoration = await getDiarySetting('text-decoration', 'none');

            // 🔥【修改】不再设置字体族，使用全局字体
            // 应用样式（不包括fontFamily）
            diaryContent.style.fontSize = fontSize + 'px';
            diaryContent.style.fontWeight = fontWeight;
            diaryContent.style.lineHeight = lineHeight;
            diaryContent.style.textAlign = textAlign;
            diaryContent.style.width = contentWidth + '%';
            diaryContent.style.paddingLeft = contentPadding + 'px';
            diaryContent.style.paddingRight = contentPadding + 'px';
            diaryContent.style.paddingTop = contentTopMargin + 'px';

                // 应用文本装饰
                applyTextDecoration(textDecoration);
            } catch (error) {
                console.error('应用日记设置失败:', error);
            }
        }

        // 🔥【重构】应用设置到单个日记视图 - 使用Dexie数据库
        async function applyDiarySettingsToSingleView() {
            const diaryContent = document.getElementById('single-diary-content');
            if (!diaryContent) return;

            try {
                // 🔥【修改】获取设置，移除字体族
                const fontSize = await getDiarySetting('font-size', '16');
                const fontWeight = await getDiarySetting('font-weight', '500');
                const lineHeight = await getDiarySetting('line-height', '1.6');
                const textAlign = await getDiarySetting('text-align', 'left');
                const contentWidth = await getDiarySetting('content-width', '100');
                const contentPadding = await getDiarySetting('content-padding', '40');
                const contentTopMargin = await getDiarySetting('content-top-margin', '20');
                const textDecoration = await getDiarySetting('text-decoration', 'none');
                const paperType = await getDiarySetting('paper-type', 'lined');

            // 🔥【修改】不再设置字体族，使用全局字体
            // 应用样式（不包括fontFamily）
            diaryContent.style.fontSize = fontSize + 'px';
            diaryContent.style.fontWeight = fontWeight;
            diaryContent.style.lineHeight = lineHeight;
            diaryContent.style.textAlign = textAlign;
            diaryContent.style.width = contentWidth + '%';
            diaryContent.style.paddingLeft = contentPadding + 'px';
            diaryContent.style.paddingRight = contentPadding + 'px';
            diaryContent.style.paddingTop = contentTopMargin + 'px';

            // 应用纸张样式
            diaryContent.classList.remove('lined-paper', 'grid-paper', 'plain-paper', 'vintage-paper', 'custom-paper');
            if (paperType && paperType !== 'plain') {
                diaryContent.classList.add(paperType + '-paper');
            }

                // 应用自定义背景（如果有）
                if (paperType === 'custom') {
                    const customBackground = await getDiarySetting('custom-background', '');
                    if (customBackground) {
                        diaryContent.style.backgroundImage = `url(${customBackground})`;
                    }
                }

                // 应用文本装饰
                diaryContent.classList.remove('decoration-none', 'decoration-underline');
                if (textDecoration && textDecoration !== 'none') {
                    diaryContent.classList.add('decoration-' + textDecoration);
                }
            } catch (error) {
                console.error('应用日记设置到单个视图失败:', error);
            }
        }

        // 🔥【重构】设置日记纸张类型 - 使用Dexie数据库
        async function setDiaryPaper(paperType) {
            // 更新选中状态
            document.querySelectorAll('.paper-option').forEach(option => {
                option.classList.remove('active');
                if (option.dataset.paper === paperType) {
                    option.classList.add('active');
                }
            });

            // 保存设置
            await setDiarySetting('paper-type', paperType);

            // 应用到当前日记显示
            await applyDiaryPaper(paperType);

            // 更新预览（如果在设置界面）
            if (document.getElementById('diary-preview-content')) {
                await updateDiaryPreview();
            }
        }

        // 🔥【重构】应用纸张样式到日记显示 - 使用Dexie数据库
        async function applyDiaryPaper(paperType) {
            const diaryContent = document.getElementById('today-diary-content');
            if (diaryContent) {
                try {
                    // 移除所有纸张类
                    diaryContent.classList.remove('lined-paper', 'grid-paper', 'plain-paper', 'vintage-paper', 'custom-paper');

                    // 添加新的纸张类
                    if (paperType && paperType !== 'plain') { // plain是默认样式，不需要额外的类
                        diaryContent.classList.add(paperType + '-paper');
                    }

                    // 如果是自定义背景，应用背景图片
                    if (paperType === 'custom') {
                        const customBg = await getDiarySetting('custom-background', '');
                        if (customBg) {
                            diaryContent.style.backgroundImage = `url(${customBg})`;
                        }
                    } else {
                        // 清除自定义背景图片
                        diaryContent.style.backgroundImage = '';
                    }
                } catch (error) {
                    console.error('应用日记纸张样式失败:', error);
                }
            }
        }

        // 上传自定义纸张
        function uploadCustomPaper() {
            const input = document.getElementById('paperImageInput');
            if (input) {
                input.click();
            } else {
                console.error('找不到文件输入元素');
            }
        }

        // 🔥【重构】处理纸张图片上传 - 使用Dexie数据库
        function handlePaperUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.type.startsWith('image/')) {
                showToast('请选择图片文件', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const imageUrl = e.target.result;

                    // 保存自定义背景
                    await setDiarySetting('custom-background', imageUrl);

                    // 设置为自定义纸张
                    await setDiaryPaper('custom');

                    // 应用自定义背景
                    const diaryContent = document.getElementById('today-diary-content');
                    if (diaryContent) {
                        diaryContent.style.backgroundImage = `url(${imageUrl})`;
                    }

                    // 更新预览（如果在设置界面）
                    if (document.getElementById('diary-preview-content')) {
                        await updateDiaryPreview();
                    }

                    showToast('自定义背景设置成功', 'success');
                } catch (error) {
                    console.error('上传自定义背景失败:', error);
                    showToast('上传背景失败', 'error');
                }
            };

            reader.readAsDataURL(file);
        }

        // 🔥【重构】初始化日记纸张设置 - 使用Dexie数据库
        async function initDiaryPaper() {
            try {
                const savedPaper = await getDiarySetting('paper-type', 'plain');
                await applyDiaryPaper(savedPaper);

                // 应用其他自定义设置
                await applyDiarySettingsToContent();
            } catch (error) {
                console.error('初始化日记纸张设置失败:', error);
            }
        }

        // 判断是否应该更新角色状态
        async function shouldUpdateCharacterStatus(characterId) {
            try {
                const currentStatus = getCharacterStatus(characterId);
                const lastUpdate = new Date(currentStatus.lastUpdate);
                const now = new Date();
                const timeDiff = now - lastUpdate;

                // 🔥【修复】获取用户设置的更新频率间隔
                const updateInterval = getStatusUpdateInterval();

                // 如果距离上次更新的时间还没到设定的间隔，不更新
                if (timeDiff < updateInterval) {
                    return false;
                }

                // 如果状态超过设定间隔很久没更新，强制更新
                if (timeDiff > updateInterval * 2) {
                    return true;
                }

                // 🔥【新增】如果最近有聊天活动，在定时器触发时有更高概率更新
                if (currentStatus.lastChatTime) {
                    const lastChatTime = new Date(currentStatus.lastChatTime);
                    const chatTimeDiff = now - lastChatTime;

                    // 如果最近聊天过，且距离上次更新已经超过设定间隔，有较高概率更新
                    if (chatTimeDiff < updateInterval && timeDiff >= updateInterval) {
                        return Math.random() < 0.7; // 70%概率
                    }
                }

                // 默认情况下，如果到了更新时间，有一定概率更新
                return Math.random() < 0.3; // 30%概率

            } catch (error) {
                console.error('判断角色状态更新失败:', error);
                return Math.random() < 0.1; // 10%概率
            }
        }

        // 更新角色最后聊天时间
        async function updateCharacterLastChatTime(characterId) {
            try {
                let statusRecord = characterStatusData.find(s => s.characterId === characterId);

                if (!statusRecord) {
                    // 如果没有状态记录，创建一个新的
                    statusRecord = {
                        id: `status_${characterId}`,
                        characterId: characterId,
                        status: 'online',
                        activity: '在线',
                        location: '',
                        lastUpdate: new Date().toISOString(),
                        lastChatTime: Date.now()
                    };
                    characterStatusData.push(statusRecord);
                } else {
                    // 只更新聊天时间，不改变其他状态
                    statusRecord.lastChatTime = Date.now();
                }

                await db.characterStatus.put(statusRecord);

            } catch (error) {
                console.error('更新角色聊天时间失败:', error);
            }
        }

        // 在发送/接收消息后触发状态更新
        async function triggerStatusUpdateAfterMessage(characterId) {
            // 🔥【修复】首先检查是否开启了角色状态显示
            const chatSettings = await getAsyncChatSettings(characterId);
            if (!chatSettings.characterStatusEnabled) {
                console.log(`角色 ${characterId} 未启用状态显示，跳过状态更新`);
                return;
            }

            // 🔥【关键修复】不再在每次聊天后立即触发状态更新
            // 状态更新应该完全由定时器控制，遵循用户设置的频率
            // 这里只是记录最后一次聊天时间，供定时器判断是否需要更新
            await updateCharacterLastChatTime(characterId);

            console.log(`角色 ${characterId} 聊天时间已记录，状态更新将由定时器根据用户设置的频率进行`);
        }

        // 在应用初始化时启动状态更新定时器
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                startStatusUpdateTimer();
            }, 5000); // 延迟5秒启动
        });

        console.log('🚫 拉黑系统核心功能已加载');

        // 🔧【新增】记忆设置界面事件监听器
        document.addEventListener('DOMContentLoaded', function() {
            // 添加阈值滑块事件监听器
            const coreThresholdSlider = document.getElementById('coreMemoryThreshold');
            const episodicThresholdSlider = document.getElementById('episodicMemoryThreshold');

            if (coreThresholdSlider) {
                coreThresholdSlider.addEventListener('input', updateThresholdDisplay);
            }
            if (episodicThresholdSlider) {
                episodicThresholdSlider.addEventListener('input', updateThresholdDisplay);
            }
        });

        // 🔥【新增】记忆管理系统

        // 文本相似度计算函数（简单的Jaccard相似度）
        function calculateTextSimilarity(text1, text2) {
            if (!text1 || !text2) return 0;

            // 转换为小写并分词
            const words1 = new Set(text1.toLowerCase().match(/[\u4e00-\u9fa5\w]+/g) || []);
            const words2 = new Set(text2.toLowerCase().match(/[\u4e00-\u9fa5\w]+/g) || []);

            // 计算交集和并集
            const intersection = new Set([...words1].filter(x => words2.has(x)));
            const union = new Set([...words1, ...words2]);

            // Jaccard相似度
            return union.size === 0 ? 0 : intersection.size / union.size;
        }

        // 记忆系统配置（可由用户设置）
        let MEMORY_CONFIG = {
            // AI记忆提取配置
            AI_EXTRACT_INTERVAL: 60, // 默认每30回合对话（60条消息）进行AI提取

            // 核心记忆配置
            CORE_MEMORY_IMPORTANCE_THRESHOLD: 0.9, // 核心记忆重要性阈值90%
            MAX_CORE_MEMORIES_PER_CHARACTER: 50, // 每个角色最多保留50条核心记忆

            // 情景记忆配置
            EPISODIC_MEMORY_IMPORTANCE_THRESHOLD: 0.6, // 情景记忆重要性阈值60%
            MAX_EPISODIC_MEMORIES_PER_CHARACTER: 100, // 每个角色最多保留100条情景记忆

            // 跨应用记忆配置
            CROSS_APP_TIMELINE_LIMIT: 20, // 跨应用时间线在工作记忆中的最大条数
        };

        // 从用户设置中加载记忆配置
        async function loadMemoryConfig() {
            try {
                const settings = await db.globalSettings.get('memoryConfig');
                if (settings && settings.value) {
                    MEMORY_CONFIG = { ...MEMORY_CONFIG, ...settings.value };
                }
            } catch (error) {
                console.error('加载记忆配置失败:', error);
            }
        }

        // 保存记忆配置到用户设置
        async function saveMemoryConfig() {
            try {
                await db.globalSettings.put({
                    id: 'memoryConfig',
                    value: MEMORY_CONFIG
                });
            } catch (error) {
                console.error('保存记忆配置失败:', error);
            }
        }

        // 自动摘要生成功能
        async function generateConversationSummary(characterId, messages) {
            if (!messages || messages.length === 0) return null;

            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return null;

                // 构建摘要生成的prompt，统一使用第三人称
                const summaryPrompt = `
# 对话摘要任务

你需要为以下对话生成一个简洁的摘要。

## 角色信息
- 角色名称: ${character.name}
- 角色设定: ${character.bio || '无特殊设定'}

## 对话内容
${messages.map(msg => {
    const sender = msg.sender === 'sent' ? '用户' : character.name;
    const content = typeof msg.content === 'string' ? msg.content : '[图片/文件]';
    return `${sender}: ${content}`;
}).join('\n')}

## 摘要要求
请生成一个100-200字的对话摘要，包含：
1. 主要话题和讨论内容
2. 重要的情感变化或关键事件
3. 双方的态度和关系变化
4. 任何重要的决定或约定

## 重要要求：统一使用第三人称
- 用"用户"指代用户，用"${character.name}"指代角色
- 不要使用"我"、"你"等第一、第二人称
- 例如："用户向${character.name}询问..."而不是"你问我..."

请用第三人称客观描述，保持简洁明了。`;

                // 调用AI提取记忆
                const response = await callChatAPI(extractPrompt, character);
                const responseText = Array.isArray(response) ? response[0] : response;

                if (responseText && typeof responseText === 'string') {
                    try {
                        // 提取JSON部分
                        const jsonMatch = responseText.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            const memories = JSON.parse(jsonMatch[0]);

                            // 获取现有记忆，检查重复
                            const existingMemories = await db.coreMemories
                                .where('characterId')
                                .equals(characterId)
                                .toArray();

                            // 保存核心记忆（确保角色隔离）
                            for (const memory of memories.core_memories || []) {
                                if (memory.importance >= MEMORY_CONFIG.CORE_MEMORY_IMPORTANCE_THRESHOLD) {
                                    // 只检查该角色的现有记忆，避免跨角色混淆
                                    const isDuplicate = existingMemories.some(existing => {
                                        const similarity = calculateTextSimilarity(existing.fact, memory.fact);
                                        return similarity > 0.8;
                                    });

                                    if (!isDuplicate) {
                                        const coreMemory = {
                                            id: `core_${characterId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                            characterId: characterId, // 严格绑定角色ID
                                            fact: memory.fact,
                                            importance: memory.importance,
                                            category: memory.category || 'other',
                                            timestamp: Date.now(),
                                            type: 'core',
                                            source: 'single_chat', // 标记来源，区分单聊和群聊
                                            contextId: characterId // 🔥【修复】添加上下文ID用于记忆隔离
                                        };

                                        await db.coreMemories.add(coreMemory);
                                        console.log(`✅ [${character.name}] 核心记忆: ${memory.fact}`);
                                    }
                                }
                            }

                            // 保存情景记忆（确保角色隔离）
                            for (const memory of memories.episodic_memories || []) {
                                if (memory.importance >= MEMORY_CONFIG.EPISODIC_MEMORY_IMPORTANCE_THRESHOLD) {
                                    const episodicMemory = {
                                        id: `episodic_${characterId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                        characterId: characterId, // 严格绑定角色ID
                                        fact: memory.fact,
                                        importance: memory.importance,
                                        category: memory.category || 'other',
                                        timestamp: Date.now(),
                                        source: 'single_chat', // 标记来源
                                        contextId: characterId // 🔥【修复】添加上下文ID用于记忆隔离
                                    };

                                    await db.episodicMemories.add(episodicMemory);
                                    console.log(`✅ [${character.name}] 情景记忆: ${memory.fact}`);
                                }
                            }
                        }
                    } catch (parseError) {
                        console.warn('解析记忆JSON失败:', parseError);
                    }
                }
            } catch (error) {
                console.error('AI记忆提取失败:', error);
            }
        }

        // 检查是否需要生成摘要
        async function checkAndGenerateSummary(characterId) {
            try {
                const messages = chatMessages[characterId] || [];
                if (messages.length === 0) return;

                // 获取最后一次摘要的时间
                const summaries = await db.memorySummaries
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                const lastSummary = summaries.length > 0
                    ? summaries.sort((a, b) => b.timestamp - a.timestamp)[0]
                    : null;

                let shouldGenerate = false;
                let messagesToSummarize = [];

                if (!lastSummary) {
                    // 如果从未生成过摘要，且消息数量达到阈值
                    if (messages.length >= MEMORY_CONFIG.SUMMARY_TRIGGER_MESSAGE_COUNT) {
                        messagesToSummarize = messages.slice(-MEMORY_CONFIG.SUMMARY_TRIGGER_MESSAGE_COUNT);
                        shouldGenerate = true;
                    }
                } else {
                    // 计算自上次摘要后的新消息
                    const lastSummaryTime = lastSummary.context?.endTime || lastSummary.timestamp;
                    const newMessages = messages.filter(msg => msg.timestamp > lastSummaryTime);

                    // 检查消息数量或时间间隔
                    const timeDiff = Date.now() - lastSummary.timestamp;
                    const hoursDiff = timeDiff / (1000 * 60 * 60);

                    if (newMessages.length >= MEMORY_CONFIG.SUMMARY_TRIGGER_MESSAGE_COUNT ||
                        hoursDiff >= MEMORY_CONFIG.SUMMARY_TRIGGER_TIME_HOURS) {
                        messagesToSummarize = newMessages.slice(-MEMORY_CONFIG.SUMMARY_TRIGGER_MESSAGE_COUNT);
                        shouldGenerate = true;
                    }
                }

                if (shouldGenerate && messagesToSummarize.length > 0) {
                    await generateConversationSummary(characterId, messagesToSummarize);
                }
            } catch (error) {
                console.error('检查摘要生成失败:', error);
            }
        }

        // 移除关键词提取功能，简化为纯AI提取

        // AI记忆提取功能（严格的核心记忆）
        async function extractMemoriesWithAI(characterId, messages, contextId = null) {
            if (!messages || messages.length === 0) return;

            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;

                // 🔥【修复】如果没有提供contextId，使用characterId作为默认值（单聊）
                if (!contextId) {
                    contextId = characterId;
                }

                // 构建更严格的记忆提取prompt，统一使用第三人称
                const extractPrompt = `
# 记忆提取任务

你需要从以下对话中提取两类记忆：核心记忆和情景记忆。

## 角色信息
- 角色名称: ${character.name}
- 角色设定: ${character.bio || '无特殊设定'}

## 对话内容
${messages.map(msg => {
    const sender = msg.sender === 'sent' ? '用户' : character.name;
    const content = typeof msg.content === 'string' ? msg.content : '[图片/文件]';
    return `${sender}: ${content}`;
}).join('\n')}

## 提取标准

### 核心记忆（importance >= 0.9）
只有以下类型的信息才能成为核心记忆：
- 用户的基本信息：真实姓名、生日、职业、家庭成员
- 重大情感转变：表白、分手、和好、深度情感交流
- 重要承诺和约定：长期计划、重要约定
- 关键人生事件：毕业、工作变动、搬家、重要纪念日
- 角色与用户关系的重大变化

### 情景记忆（importance 0.6-0.8）
日常但有意义的事件：
- 一起做的活动和体验
- 用户的习惯和偏好
- 有趣的对话和互动
- 日常生活的分享

## 重要要求：记忆描述必须使用第三人称
- 用"用户"指代用户，用"${character.name}"指代角色
- 不要使用"我"、"你"等第一、第二人称
- 例如："用户告诉${character.name}自己的生日是..."而不是"我的生日是..."

请严格按照以下JSON格式返回，不要添加任何其他文字：

{
  "core_memories": [
    {"fact": "简洁的核心事实（使用第三人称）", "importance": 0.9, "category": "类别"}
  ],
  "episodic_memories": [
    {"fact": "情景描述（使用第三人称）", "importance": 0.7, "category": "类别"}
  ]
}

注意：
1. 只返回JSON，不要有任何解释文字
2. 如果没有符合标准的记忆，对应数组为空
3. importance必须是数字，不要用字符串
4. 确保JSON格式完全正确
5. 所有fact字段必须使用第三人称描述`;

                // 调用AI提取核心记忆
                const response = await callChatAPI(extractPrompt, character);
                let memories = [];
                let responseText = null; // 在外层定义，确保catch块可以访问

                try {
                    // 尝试解析JSON响应
                    responseText = Array.isArray(response) ? response[0] : response;
                    if (responseText && typeof responseText === 'string') {
                        console.log('🔍 AI记忆提取原始响应:', responseText);

                        // 多种方式尝试提取JSON
                        let jsonText = null;

                        // 方式1: 提取完整的JSON对象
                        const jsonObjectMatch = responseText.match(/\{[\s\S]*\}/);
                        if (jsonObjectMatch) {
                            jsonText = jsonObjectMatch[0];
                        } else {
                            // 方式2: 提取JSON数组
                            const jsonArrayMatch = responseText.match(/\[[\s\S]*\]/);
                            if (jsonArrayMatch) {
                                jsonText = jsonArrayMatch[0];
                            }
                        }

                        if (jsonText) {
                            console.log('🔍 提取的JSON文本:', jsonText);
                            memories = JSON.parse(jsonText);
                        } else {
                            console.warn('⚠️ 未找到有效的JSON格式');
                            return; // 如果没有找到JSON，直接返回
                        }
                    }
                } catch (parseError) {
                    console.warn('解析核心记忆JSON失败:', parseError);
                    console.warn('原始响应:', responseText);
                    return; // 解析失败时直接返回，避免后续错误
                }

                // 获取现有的记忆，检查重复
                const [existingCoreMemories, existingEpisodicMemories] = await Promise.all([
                    db.coreMemories.where('characterId').equals(characterId).toArray(),
                    db.episodicMemories.where('characterId').equals(characterId).toArray()
                ]);

                // 🔥【修复】处理核心记忆
                if (memories.core_memories && Array.isArray(memories.core_memories)) {
                    for (const memory of memories.core_memories) {
                        if (memory.importance >= MEMORY_CONFIG.CORE_MEMORY_IMPORTANCE_THRESHOLD) {
                            // 检查是否已存在相似的记忆
                            const isDuplicate = existingCoreMemories.some(existing => {
                                const similarity = calculateTextSimilarity(existing.fact, memory.fact);
                                return similarity > 0.8; // 相似度超过80%认为是重复
                            });

                            if (!isDuplicate) {
                                const coreMemory = {
                                    id: `core_${characterId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                    characterId: characterId,
                                    fact: memory.fact,
                                    importance: memory.importance,
                                    category: memory.category || 'other',
                                    timestamp: Date.now(),
                                    type: 'core',
                                    contextId: contextId // 🔥【修复】添加上下文ID用于记忆隔离
                                };

                                await db.coreMemories.add(coreMemory);
                                console.log(`✅ 为角色 ${character.name} 添加核心记忆: ${memory.fact}`);
                            } else {
                                console.log(`⚠️ 跳过重复核心记忆: ${memory.fact}`);
                            }
                        }
                    }
                }

                // 🔥【新增】处理情景记忆
                if (memories.episodic_memories && Array.isArray(memories.episodic_memories)) {
                    for (const memory of memories.episodic_memories) {
                        if (memory.importance >= MEMORY_CONFIG.EPISODIC_MEMORY_IMPORTANCE_THRESHOLD) {
                            // 检查是否已存在相似的记忆
                            const isDuplicate = existingEpisodicMemories.some(existing => {
                                const similarity = calculateTextSimilarity(existing.fact, memory.fact);
                                return similarity > 0.8; // 相似度超过80%认为是重复
                            });

                            if (!isDuplicate) {
                                const episodicMemory = {
                                    id: `episodic_${characterId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                    characterId: characterId,
                                    fact: memory.fact,
                                    importance: memory.importance,
                                    category: memory.category || 'other',
                                    timestamp: Date.now(),
                                    contextId: contextId // 🔥【修复】添加上下文ID用于记忆隔离
                                };

                                await db.episodicMemories.add(episodicMemory);
                                console.log(`✅ 为角色 ${character.name} 添加情景记忆: ${memory.fact}`);
                            } else {
                                console.log(`⚠️ 跳过重复情景记忆: ${memory.fact}`);
                            }
                        }
                    }
                }

                // 清理过多的记忆
                await cleanupCoreMemories(characterId);
                await cleanupEpisodicMemories(characterId);

            } catch (error) {
                console.error('提取核心记忆失败:', error);
            }
        }

        // 清理过多的核心记忆，保留最重要的
        async function cleanupCoreMemories(characterId) {
            try {
                const allMemories = await db.coreMemories
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                const memories = allMemories.sort((a, b) => b.importance - a.importance);
                const maxCoreMemories = MEMORY_CONFIG.MAX_CORE_MEMORIES_PER_CHARACTER || 50;

                if (memories.length > maxCoreMemories) {
                    const toDelete = memories.slice(maxCoreMemories);
                    for (const memory of toDelete) {
                        await db.coreMemories.delete(memory.id);
                    }
                    console.log(`🧹 清理了 ${toDelete.length} 个低重要性的核心记忆`);
                }
            } catch (error) {
                console.error('清理核心记忆失败:', error);
            }
        }

        // 🔥【新增】清理过多的情景记忆，保留最重要和最新的
        async function cleanupEpisodicMemories(characterId) {
            try {
                const allMemories = await db.episodicMemories
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                // 按重要性和时间排序，保留最重要和最新的记忆
                const memories = allMemories.sort((a, b) => {
                    // 先按重要性排序，再按时间排序
                    if (Math.abs(a.importance - b.importance) > 0.1) {
                        return b.importance - a.importance;
                    }
                    return b.timestamp - a.timestamp;
                });

                const maxEpisodicMemories = MEMORY_CONFIG.MAX_EPISODIC_MEMORIES_PER_CHARACTER || 100;

                if (memories.length > maxEpisodicMemories) {
                    const toDelete = memories.slice(maxEpisodicMemories);
                    for (const memory of toDelete) {
                        await db.episodicMemories.delete(memory.id);
                    }
                    console.log(`🧹 清理了 ${toDelete.length} 个旧的情景记忆`);
                }
            } catch (error) {
                console.error('清理情景记忆失败:', error);
            }
        }

        // 🔥【新增】自动清理过期的时间线记忆和记忆摘要
        async function cleanupExpiredMemories() {
            try {
                const memorySettings = getGlobalMemorySettings();

                // 🔥【修复】如果设置为永久记忆(-1)，则跳过清理
                if (memorySettings.memoryDays === -1) {
                    console.log('🔥 永久记忆模式，跳过自动清理');
                    return;
                }

                const cutoffTimestamp = Date.now() - (memorySettings.memoryDays * 24 * 60 * 60 * 1000);
                const cutoffDateStr = new Date(cutoffTimestamp).toISOString().split('T')[0];

                // 清理过期的时间线记忆
                const expiredTimelineEvents = await db.crossAppTimeline
                    .where('timestamp')
                    .below(cutoffTimestamp)
                    .toArray();

                if (expiredTimelineEvents.length > 0) {
                    await db.crossAppTimeline
                        .where('timestamp')
                        .below(cutoffTimestamp)
                        .delete();
                    console.log(`🧹 清理了 ${expiredTimelineEvents.length} 条过期的时间线记忆`);
                }

                // 🔥【修复】清理过期的记忆摘要 - 改用timestamp字段保持一致性
                const expiredSummaries = await db.memorySummaries
                    .where('timestamp')
                    .below(cutoffTimestamp)
                    .toArray();

                if (expiredSummaries.length > 0) {
                    await db.memorySummaries
                        .where('timestamp')
                        .below(cutoffTimestamp)
                        .delete();
                    console.log(`🧹 清理了 ${expiredSummaries.length} 条过期的记忆摘要`);
                }

                // 清理过期的情景记忆
                const expiredEpisodicMemories = await db.episodicMemories
                    .where('timestamp')
                    .below(cutoffTimestamp)
                    .toArray();

                if (expiredEpisodicMemories.length > 0) {
                    await db.episodicMemories
                        .where('timestamp')
                        .below(cutoffTimestamp)
                        .delete();
                    console.log(`🧹 清理了 ${expiredEpisodicMemories.length} 条过期的情景记忆`);
                }

            } catch (error) {
                console.error('清理过期记忆失败:', error);
            }
        }

        // 🔥【新增】定期清理过期记忆（每小时执行一次）
        setInterval(cleanupExpiredMemories, 60 * 60 * 1000); // 1小时

        // 页面加载时执行一次清理
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(cleanupExpiredMemories, 5000); // 延迟5秒执行，避免影响页面加载
        });

        // 获取角色的核心记忆用于对话
        async function getCoreMemoriesForChat(characterId, limit = 10) {
            try {
                const allMemories = await db.coreMemories
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                const memories = allMemories
                    .sort((a, b) => b.importance - a.importance)
                    .slice(0, limit);

                return memories.map(m => m.fact).join('\n');
            } catch (error) {
                console.error('获取核心记忆失败:', error);
                return '';
            }
        }

        // 🔥【新增】检查角色是否应该记录群聊记忆的函数
        async function shouldRecordGroupMemoryForCharacter(characterId, groupId) {
            try {
                // 获取该角色的单聊设置
                const characterChatSettings = await getAsyncChatSettings(characterId);
                const sharedGroupIds = characterChatSettings.memorySharedGroupIds || [];

                // 检查该群聊是否在角色的共享群聊列表中
                const shouldRecord = sharedGroupIds.includes(groupId);

                console.log(`🔍 记忆共享检查 - 角色: ${characterId}, 群聊: ${groupId}, 应记录: ${shouldRecord}`);
                console.log(`🔍 角色的共享群聊列表:`, sharedGroupIds);

                return shouldRecord;
            } catch (error) {
                console.warn('检查记忆共享设置失败:', error);
                // 出错时默认不记录，避免意外的记忆泄露
                return false;
            }
        }

        // 跨应用时间线记录功能
        async function recordCrossAppEvent(characterId, appType, action, context, messageId = null) {
            try {
                // 🔥【修复】验证必需参数
                if (!characterId || !appType || !action) {
                    console.error('❌ 记录事件失败: 缺少必需参数', {
                        characterId,
                        appType,
                        action
                    });
                    return;
                }

                // 🔥【修复】确保context是有效对象
                const validContext = context && typeof context === 'object' ? context : {};

                // 🔥【关键修复】生成更简单可靠的ID
                const timestamp = Date.now();
                const randomSuffix = Math.random().toString(36).substring(2, 8);
                const eventId = `${characterId}_${appType}_${action}_${timestamp}_${randomSuffix}`;

                const timelineEvent = {
                    id: eventId,
                    characterId: String(characterId), // 确保是字符串
                    appType: String(appType),
                    action: String(action),
                    timestamp: timestamp,
                    context: validContext,
                    messageId: messageId ? String(messageId) : null
                };

                // 🔥【修复】验证所有必需字段
                if (!timelineEvent.id || !timelineEvent.characterId || !timelineEvent.appType || !timelineEvent.action) {
                    console.error('❌ 记录事件失败: 必需字段缺失', timelineEvent);
                    return;
                }

                // 🔥【新增】验证数据库连接
                if (!db || !db.crossAppTimeline) {
                    console.error('❌ 记录事件失败: 数据库未初始化');
                    return;
                }

                await db.crossAppTimeline.add(timelineEvent);
                console.log(`📝 记录时间线事件: ${appType}.${action}`, {
                    characterId: timelineEvent.characterId,
                    contextId: validContext.id,
                    contextType: validContext.type,
                    groupId: validContext.groupId || '无',
                    content: validContext.content?.substring(0, 30) + '...'
                });

            } catch (error) {
                console.error('❌ 记录事件失败:', error);
                console.error('事件数据:', {characterId, appType, action, context, messageId});

                // 🔥【新增】详细错误信息
                if (error.name === 'DataError') {
                    console.error('数据库键值错误，可能是ID字段问题');
                } else if (error.name === 'ConstraintError') {
                    console.error('数据库约束错误，可能是重复键值');
                }
            }
        }

        // 获取角色的跨应用时间线（用于构建连续的工作记忆）
        async function getCrossAppTimeline(characterId, limit = 30) {
            try {
                const timeline = await db.crossAppTimeline
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                return timeline
                    .sort((a, b) => b.timestamp - a.timestamp)
                    .slice(0, limit);
            } catch (error) {
                console.error('获取跨应用时间线失败:', error);
                return [];
            }
        }

        // 🔥【新增】按回合计算历史消息
        function calculateMessagesByRounds(messages, maxRounds) {
            if (!messages || messages.length === 0) return [];

            // 从后往前分析消息，按回合分组
            const rounds = [];
            let currentRound = [];
            let lastSender = null;

            // 从最新消息开始往前分析
            for (let i = messages.length - 1; i >= 0; i--) {
                const msg = messages[i];
                const currentSender = msg.sender;

                // 如果发送者改变，或者是系统消息，开始新回合
                if (currentSender !== lastSender || currentSender === 'system') {
                    if (currentRound.length > 0) {
                        rounds.unshift(currentRound); // 添加到开头
                        currentRound = [];
                    }
                }

                currentRound.unshift(msg); // 添加到当前回合的开头
                lastSender = currentSender;

                // 如果已经收集了足够的回合，停止
                if (rounds.length >= maxRounds) {
                    break;
                }
            }

            // 添加最后一个回合
            if (currentRound.length > 0 && rounds.length < maxRounds) {
                rounds.unshift(currentRound);
            }

            // 只保留指定数量的回合
            const selectedRounds = rounds.slice(-maxRounds);

            // 将回合展平为消息列表
            return selectedRounds.flat();
        }

        // 🔥【新增】计算实际回合数
        function countActualRounds(messages) {
            if (!messages || messages.length === 0) return 0;

            let rounds = 0;
            let lastSender = null;

            for (const msg of messages) {
                const currentSender = msg.sender;

                // 如果发送者改变，或者是系统消息，计为新回合
                if (currentSender !== lastSender || currentSender === 'system') {
                    rounds++;
                }

                lastSender = currentSender;
            }

            return rounds;
        }

        // 🔥【新增】查看线下剧情总结的完整内容
        async function viewStorylineSummary(memoryId) {
            try {
                const memory = await db.crossAppTimeline.get(memoryId);
                if (!memory || memory.action !== 'storyline_summary') {
                    showToast('找不到该剧情总结', 'error');
                    return;
                }

                // 使用完整内容而不是预览内容
                const content = memory.context?.content || memory.fullContent || '无内容';
                const date = memory.context?.date || '未知日期';
                const messageCount = memory.context?.messageCount || 0;

                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 600px; max-height: 80vh; overflow-y: auto;">
                        <div class="modal-header">
                            <h3>线下剧情总结</h3>
                            <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">×</button>
                        </div>
                        <div class="modal-body">
                            <div style="margin-bottom: 15px; color: #666; font-size: 14px;">
                                <div>日期: ${date}</div>
                                <div>消息数: ${messageCount}条</div>
                            </div>
                            <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; line-height: 1.6; white-space: pre-wrap;">${content}</div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-primary" onclick="editStorylineSummary('${memoryId}'); this.closest('.modal-overlay').remove();">编辑</button>
                            <button class="btn btn-secondary" onclick="this.closest('.modal-overlay').remove()">关闭</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);
            } catch (error) {
                console.error('查看剧情总结失败:', error);
                showToast('查看剧情总结失败', 'error');
            }
        }

        // 🔥【新增】编辑线下剧情总结
        async function editStorylineSummary(memoryId) {
            try {
                const memory = await db.crossAppTimeline.get(memoryId);
                if (!memory || memory.action !== 'storyline_summary') {
                    showToast('找不到该剧情总结', 'error');
                    return;
                }

                // 使用完整内容而不是预览内容
                const content = memory.context?.content || memory.fullContent || '';
                const date = memory.context?.date || '未知日期';
                const messageCount = memory.context?.messageCount || 0;

                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 700px; max-height: 80vh;">
                        <div class="modal-header">
                            <h3>编辑线下剧情总结</h3>
                            <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">×</button>
                        </div>
                        <div class="modal-body">
                            <div style="margin-bottom: 15px; color: #666; font-size: 14px;">
                                <div>日期: ${date}</div>
                                <div>消息数: ${messageCount}条</div>
                                <div style="color: #999; font-size: 12px; margin-top: 5px;">提示: 修改后的内容将同步到AI的工作记忆中</div>
                            </div>
                            <textarea id="storyline-summary-editor" style="width: 100%; height: 300px; padding: 15px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px; line-height: 1.6; resize: vertical;" placeholder="请输入剧情总结...">${content}</textarea>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-primary" onclick="saveStorylineSummary('${memoryId}')">保存修改</button>
                            <button class="btn btn-secondary" onclick="this.closest('.modal-overlay').remove()">取消</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);

                // 聚焦到文本框但不选中内容
                setTimeout(() => {
                    const textarea = document.getElementById('storyline-summary-editor');
                    if (textarea) {
                        textarea.focus();
                        // 🔥【修复】将光标移到末尾，不选中任何内容
                        textarea.setSelectionRange(textarea.value.length, textarea.value.length);
                    }
                }, 100);
            } catch (error) {
                console.error('编辑剧情总结失败:', error);
                showToast('编辑剧情总结失败', 'error');
            }
        }

        // 🔥【新增】保存编辑后的线下剧情总结
        async function saveStorylineSummary(memoryId) {
            try {
                const textarea = document.getElementById('storyline-summary-editor');
                if (!textarea) {
                    showToast('找不到编辑器', 'error');
                    return;
                }

                const newContent = textarea.value.trim();
                if (!newContent) {
                    showToast('剧情总结不能为空', 'warning');
                    return;
                }

                // 更新数据库中的记忆
                const memory = await db.crossAppTimeline.get(memoryId);
                if (!memory) {
                    showToast('找不到该剧情总结', 'error');
                    return;
                }

                // 更新内容
                memory.context.content = newContent;
                memory.timestamp = Date.now(); // 更新时间戳，让它在工作记忆中更新

                await db.crossAppTimeline.put(memory);

                // 关闭模态框
                const modal = textarea.closest('.modal-overlay');
                if (modal) {
                    modal.remove();
                }

                // 刷新记忆查看器
                if (currentMemoryCharacter) {
                    await loadCharacterMemories();
                }

                showToast('剧情总结已保存，AI工作记忆已同步更新', 'success');
                console.log('✅ 线下剧情总结已更新:', memory);
            } catch (error) {
                console.error('保存剧情总结失败:', error);
                showToast('保存剧情总结失败', 'error');
            }
        }

        // 构建连续的工作记忆（包含跨应用事件，按时间滚动）
        async function buildContinuousWorkingMemory(characterId, chatMessages, userSetLimit = 50) {
            try {
                // 🔥【修复】使用安全函数确保characterId是字符串类型
                characterId = safeCharacterId(characterId);

                // 🔥【安全检查】确保chatMessages是数组
                if (!Array.isArray(chatMessages)) {
                    console.warn('buildContinuousWorkingMemory: chatMessages不是数组，使用空数组');
                    chatMessages = [];
                }

                // 获取聊天消息
                const messages = chatMessages.map(msg => ({
                    type: 'chat',
                    timestamp: msg.timestamp,
                    content: msg,
                    appType: 'chat',
                    characterId: String(characterId) // 确保角色隔离且是字符串
                }));

                // 获取该角色的跨应用时间线（只获取与该角色相关的）
                let timeline = [];
                try {
                    timeline = await db.crossAppTimeline
                        .where('characterId')
                        .equals(String(characterId)) // 确保是字符串
                        .toArray();
                } catch (error) {
                    console.error(`❌ 查询跨应用时间线失败 - characterId: ${characterId}:`, error);
                    timeline = [];
                }

                // 🔥【修复】正确区分聊天事件和跨应用事件
                const timelineEvents = timeline
                    .filter(event => event.appType !== 'chat') // 排除聊天事件，避免重复
                    .map(event => ({
                        type: 'cross_app',
                        timestamp: event.timestamp,
                        content: event,
                        appType: event.appType,
                        characterId: characterId
                    }));

                // 合并所有事件并按时间排序
                const allEvents = [...messages, ...timelineEvents]
                    .sort((a, b) => a.timestamp - b.timestamp);

                // 🔥【修复】按回合数而不是消息条数来限制工作记忆
                // 先提取聊天消息，按回合计算
                const chatEvents = allEvents.filter(event => event.type === 'chat');
                const extractedChatMessages = chatEvents.map(event => event.content);

                // 按回合计算聊天消息
                const recentChatMessages = calculateMessagesByRounds(extractedChatMessages, userSetLimit);

                // 重新包装为事件格式
                const recentChatEvents = recentChatMessages.map(msg => ({
                    type: 'chat',
                    timestamp: msg.timestamp,
                    content: msg,
                    appType: 'chat',
                    characterId: characterId
                }));

                // 跨应用事件按时间范围过滤（与聊天消息的时间范围一致）
                const earliestChatTime = recentChatEvents.length > 0 ? recentChatEvents[0].timestamp : 0;
                const recentTimelineEvents = timelineEvents.filter(event => event.timestamp >= earliestChatTime);

                // 合并并重新排序
                const recentEvents = [...recentChatEvents, ...recentTimelineEvents]
                    .sort((a, b) => a.timestamp - b.timestamp);

                return recentEvents;
            } catch (error) {
                console.error('构建连续工作记忆失败:', error);
                return chatMessages.map(msg => ({
                    type: 'chat',
                    timestamp: msg.timestamp,
                    content: msg,
                    appType: 'chat',
                    characterId: characterId
                }));
            }
        }

        // 为角色生成跨应用记忆描述
        async function generateCrossAppMemoryDescription(characterId, memoryEvent) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;

                let memoryDescription = '';
                const context = memoryEvent.context;

                switch (memoryEvent.eventType) {
                    case 'music_interaction':
                        if (context.action === 'listen_together') {
                            memoryDescription = `和用户一起听了《${context.songTitle}》，${context.duration || ''}`;
                        } else if (context.action === 'song_comment') {
                            memoryDescription = `对歌曲《${context.songTitle}》发表了看法：${context.comment}`;
                        }
                        break;

                    case 'game_interaction':
                        if (context.action === 'play_together') {
                            memoryDescription = `和用户一起玩了${context.gameName}，${context.result || ''}`;
                        } else if (context.action === 'game_comment') {
                            memoryDescription = `对游戏${context.gameName}发表了看法：${context.comment}`;
                        }
                        break;

                    case 'forum_interaction':
                        if (context.action === 'post_comment') {
                            memoryDescription = `在论坛发表了评论：${context.comment}`;
                        } else if (context.action === 'topic_discussion') {
                            memoryDescription = `参与了关于"${context.topic}"的讨论`;
                        }
                        break;
                }

                if (memoryDescription) {
                    // 将跨应用记忆作为核心记忆保存
                    const coreMemory = {
                        id: `cross_${characterId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                        characterId: characterId,
                        fact: memoryDescription,
                        importance: 0.6, // 跨应用记忆的默认重要性
                        category: 'cross_app',
                        timestamp: Date.now(),
                        sourceEvent: memoryEvent.id
                    };

                    await db.coreMemories.add(coreMemory);
                    console.log(`✅ 为角色 ${character.name} 添加跨应用记忆: ${memoryDescription}`);
                }

            } catch (error) {
                console.error('生成跨应用记忆描述失败:', error);
            }
        }

        // 获取角色的跨应用记忆
        async function getCrossAppMemories(characterId, limit = 5) {
            try {
                const allMemories = await db.coreMemories
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                const crossAppMemories = allMemories
                    .filter(memory => memory.category === 'cross_app')
                    .sort((a, b) => b.timestamp - a.timestamp)
                    .slice(0, limit);

                return crossAppMemories.map(m => m.fact);
            } catch (error) {
                console.error('获取跨应用记忆失败:', error);
                return [];
            }
        }

        // 清理重复记忆的功能
        async function cleanupDuplicateMemories(characterId) {
            try {
                const memories = await db.coreMemories
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                const duplicates = [];

                for (let i = 0; i < memories.length; i++) {
                    for (let j = i + 1; j < memories.length; j++) {
                        const similarity = calculateTextSimilarity(memories[i].fact, memories[j].fact);
                        if (similarity > 0.8) {
                            // 保留重要性更高的，删除重要性较低的
                            const toDelete = memories[i].importance >= memories[j].importance ? memories[j] : memories[i];
                            if (!duplicates.find(d => d.id === toDelete.id)) {
                                duplicates.push(toDelete);
                            }
                        }
                    }
                }

                for (const duplicate of duplicates) {
                    await db.coreMemories.delete(duplicate.id);
                    console.log(`🧹 删除重复记忆: ${duplicate.fact}`);
                }

                if (duplicates.length > 0) {
                    console.log(`✅ 清理了 ${duplicates.length} 条重复记忆`);
                }
            } catch (error) {
                console.error('清理重复记忆失败:', error);
            }
        }

        // 🔥【新增】清理错误的跨应用时间线记录
        async function cleanupIncorrectTimelineRecords() {
            try {
                console.log('🧹 开始清理错误的跨应用时间线记录...');

                // 删除所有 appType 为 'chat' 的记录（这些应该只存在于聊天记录中）
                const chatRecords = await db.crossAppTimeline
                    .where('appType')
                    .equals('chat')
                    .toArray();

                for (const record of chatRecords) {
                    await db.crossAppTimeline.delete(record.id);
                }

                console.log(`✅ 清理完成，删除了 ${chatRecords.length} 条错误的聊天记录`);
                return chatRecords.length;

            } catch (error) {
                console.error('清理错误记录失败:', error);
                return 0;
            }
        }

        // 🔍【新增】记忆使用情况统计函数
        async function logMemoryUsageStats(character, scenario) {
            try {
                const characterId = character.isGroup ? 'group' : character.id;
                const memorySettings = getGlobalMemorySettings();

                console.log(`\n📊 ===== 记忆使用统计 (${scenario}) =====`);
                console.log(`🎭 角色: ${character.name} (${character.isGroup ? '群聊' : '单聊'})`);
                console.log(`⏰ 记忆天数设置: ${memorySettings.memoryDays}天`);

                if (character.isGroup) {
                    // 群聊：统计每个成员的记忆
                    for (const member of character.members) {
                        await logSingleCharacterMemoryStats(member.id, member.name, memorySettings.memoryDays);
                    }
                } else {
                    // 单聊：统计单个角色的记忆
                    await logSingleCharacterMemoryStats(character.id, character.name, memorySettings.memoryDays);
                }

                console.log(`📊 ===== 记忆统计结束 =====\n`);

            } catch (error) {
                console.error('记忆统计失败:', error);
            }
        }

        // 🔍【新增】单个角色的记忆统计
        async function logSingleCharacterMemoryStats(characterId, characterName, memoryDays) {
            try {
                // 1. 核心记忆统计
                const coreMemories = await db.coreMemories
                    .where('characterId')
                    .equals(characterId)
                    .toArray();
                const limitedCoreMemories = coreMemories.slice(0, 10);

                // 2. 情景记忆统计
                const cutoffTimestamp = Date.now() - (memoryDays * 24 * 60 * 60 * 1000);
                const episodicMemories = await db.episodicMemories
                    .where('characterId')
                    .equals(characterId)
                    .and(memory => memory.timestamp >= cutoffTimestamp)
                    .toArray();
                const limitedEpisodicMemories = episodicMemories.slice(0, 15);

                // 3. 时间线记忆统计
                const timelineMemories = await db.crossAppTimeline
                    .where('characterId')
                    .equals(characterId)
                    .and(event => event.timestamp >= cutoffTimestamp)
                    .toArray();
                const limitedTimelineMemories = timelineMemories.slice(0, 20);

                // 4. 对话摘要统计
                const cutoffDateStr = new Date(cutoffTimestamp).toISOString().split('T')[0];
                const memorySummaries = await db.memorySummaries
                    .where('characterId')
                    .equals(characterId)
                    .and(summary => summary.date >= cutoffDateStr)
                    .toArray();
                const limitedMemorySummaries = memorySummaries.slice(0, 10);

                // 5. 计算总token估算（按每个中文字符1.5token计算）
                const coreMemoryTokens = limitedCoreMemories.reduce((sum, m) => sum + (m.fact?.length || 0), 0) * 1.5;
                const episodicMemoryTokens = limitedEpisodicMemories.reduce((sum, m) => sum + (m.fact?.length || 0), 0) * 1.5;
                const timelineMemoryTokens = limitedTimelineMemories.reduce((sum, m) => sum + (m.context?.content?.length || 0), 0) * 1.5;
                const summaryMemoryTokens = limitedMemorySummaries.reduce((sum, m) => sum + (m.summary?.length || 0), 0) * 1.5;
                const totalMemoryTokens = coreMemoryTokens + episodicMemoryTokens + timelineMemoryTokens + summaryMemoryTokens;

                console.log(`\n👤 ${characterName} (ID: ${characterId}):`);
                console.log(`  🔴 核心记忆: ${limitedCoreMemories.length}条 (总库存: ${coreMemories.length}条) ~${Math.round(coreMemoryTokens)}tokens`);
                console.log(`  🟠 情景记忆: ${limitedEpisodicMemories.length}条 (总库存: ${episodicMemories.length}条) ~${Math.round(episodicMemoryTokens)}tokens`);
                console.log(`  🟣 时间线记忆: ${limitedTimelineMemories.length}条 (总库存: ${timelineMemories.length}条) ~${Math.round(timelineMemoryTokens)}tokens`);
                console.log(`  🔵 对话摘要: ${limitedMemorySummaries.length}条 (总库存: ${memorySummaries.length}条) ~${Math.round(summaryMemoryTokens)}tokens`);
                console.log(`  💰 记忆总消耗: ~${Math.round(totalMemoryTokens)}tokens`);

                // 6. 检查是否算在工作记忆中
                // 7. 检查跨应用工作记忆集成
                const userHistoryLimit = getCurrentChatSettings().historyCount || 5;
                const crossAppInWorkingMemory = Math.floor(userHistoryLimit * 0.3);
                const chatInWorkingMemory = userHistoryLimit - crossAppInWorkingMemory;

                console.log(`  ⚠️  注意: 这些记忆是额外添加的，不占用用户设置的"附带历史消息数"配额`);
                console.log(`  📝 工作记忆构成:`);
                console.log(`    - 聊天历史: ${chatInWorkingMemory}条 (用户设置: ${userHistoryLimit}条)`);
                console.log(`    - 跨应用事件: ${crossAppInWorkingMemory}条 (自动集成)`);
                console.log(`    - 总工作记忆: ${userHistoryLimit}条 (按时间顺序滚动)`);

            } catch (error) {
                console.error(`统计角色 ${characterName} 记忆失败:`, error);
            }
        }

        // 🔥【新增】删除与消息相关的时间线记录
        async function deleteRelatedTimelineEvents(messageToDelete) {
            try {
                const characterId = currentChatCharacter.id;
                const messageContent = messageToDelete.content;
                const messageTimestamp = messageToDelete.timestamp;

                // 查找相关的时间线记录（基于内容和时间戳匹配）
                const relatedEvents = await db.crossAppTimeline
                    .where('characterId')
                    .equals(characterId)
                    .and(event => {
                        // 检查时间戳是否接近（允许5分钟误差）
                        const timeDiff = Math.abs(event.timestamp - messageTimestamp);
                        const isTimeMatch = timeDiff < 5 * 60 * 1000; // 5分钟

                        // 检查内容是否匹配
                        const isContentMatch = event.context &&
                                             event.context.content &&
                                             typeof event.context.content === 'string' &&
                                             messageContent &&
                                             typeof messageContent === 'string' &&
                                             event.context.content.includes(messageContent.substring(0, 30));

                        return isTimeMatch && isContentMatch;
                    })
                    .toArray();

                // 删除匹配的时间线记录
                for (const event of relatedEvents) {
                    await db.crossAppTimeline.delete(event.id);
                    const contentPreview = event.context?.content && typeof event.context.content === 'string'
                        ? event.context.content.substring(0, 50)
                        : '无内容';
                    console.log(`🗑️ 删除相关时间线记录: ${event.action} - ${contentPreview}...`);
                }

                console.log(`✅ 删除了 ${relatedEvents.length} 条相关时间线记录`);

            } catch (error) {
                console.error('删除相关时间线记录失败:', error);
            }
        }

        // 🔥【新增】删除与短信消息相关的时间线记录
        async function deleteSMSRelatedTimelineEvents(messageToDelete, characterId) {
            try {
                const messageContent = messageToDelete.content;
                const messageTimestamp = messageToDelete.timestamp;

                // 查找相关的短信时间线记录（基于内容、时间戳和messageId匹配）
                const relatedEvents = await db.crossAppTimeline
                    .where('characterId')
                    .equals(characterId)
                    .and(event => {
                        // 检查是否是短信相关的事件
                        if (event.appType !== 'sms') return false;

                        // 检查messageId是否匹配
                        if (event.messageId === messageToDelete.id) return true;

                        // 检查时间戳是否接近（允许5分钟误差）
                        const timeDiff = Math.abs(event.timestamp - messageTimestamp);
                        const isTimeMatch = timeDiff < 5 * 60 * 1000; // 5分钟

                        // 检查内容是否匹配
                        const isContentMatch = event.context &&
                                             event.context.content &&
                                             typeof event.context.content === 'string' &&
                                             messageContent &&
                                             typeof messageContent === 'string' &&
                                             event.context.content.includes(messageContent.substring(0, 30));

                        return isTimeMatch && isContentMatch;
                    })
                    .toArray();

                // 删除匹配的时间线记录
                for (const event of relatedEvents) {
                    await db.crossAppTimeline.delete(event.id);
                    const contentPreview = event.context?.content && typeof event.context.content === 'string'
                        ? event.context.content.substring(0, 50)
                        : '无内容';
                    console.log(`🗑️ 删除短信相关时间线记录: ${event.action} - ${contentPreview}...`);
                }

                console.log(`✅ 删除了 ${relatedEvents.length} 条短信相关时间线记录`);

            } catch (error) {
                console.error('删除短信相关时间线记录失败:', error);
            }
        }

        // 🔥【新增】清理低质量旧版本记忆的函数
        async function cleanupLowQualityMemories(characterId) {
            try {
                console.log(`🧹 开始清理角色 ${characterId} 的低质量旧版本记忆...`);

                const currentThreshold = MEMORY_CONFIG.CORE_MEMORY_IMPORTANCE_THRESHOLD;

                // 清理重要性低于当前阈值的核心记忆
                const lowQualityCoreMemories = await db.coreMemories
                    .where('characterId')
                    .equals(characterId)
                    .and(memory => (memory.importance || 0) < currentThreshold)
                    .toArray();

                for (const memory of lowQualityCoreMemories) {
                    await db.coreMemories.delete(memory.id);
                    console.log(`🗑️ 删除低质量核心记忆 (重要性: ${memory.importance}): ${memory.fact}`);
                }

                console.log(`✅ 清理完成，删除了 ${lowQualityCoreMemories.length} 条低质量核心记忆`);
                return lowQualityCoreMemories.length;

            } catch (error) {
                console.error('清理低质量记忆失败:', error);
                return 0;
            }
        }

        // 记忆查看器功能
        let currentMemoryFilter = 'all';
        let currentMemoryCharacter = null;
        let allMemories = [];

        // 初始化记忆查看器
        async function initMemoryViewer() {
            await loadCharacterSelectOptions();
        }

        // 加载角色选择选项
        async function loadCharacterSelectOptions() {
            const select = document.getElementById('memory-character-select');
            if (!select) return;

            // 清空现有选项
            select.innerHTML = '<option value="">请选择角色</option>';

            // 添加角色选项
            characters.forEach(character => {
                const option = document.createElement('option');
                option.value = character.id;
                option.textContent = character.name;
                select.appendChild(option);
            });
        }

        // 加载角色记忆
        async function loadCharacterMemories() {
            const select = document.getElementById('memory-character-select');
            const characterId = select.value;

            if (!characterId) {
                currentMemoryCharacter = null;
                allMemories = [];
                renderMemoryList();
                return;
            }

            currentMemoryCharacter = characterId;

            try {
                // 获取所有类型的记忆
                const [coreMemories, episodicMemories, timeline] = await Promise.all([
                    db.coreMemories.where('characterId').equals(characterId).toArray(),
                    db.episodicMemories.where('characterId').equals(characterId).toArray(),
                    db.crossAppTimeline.where('characterId').equals(characterId).toArray()
                ]);

                // 🔥【调试】输出时间线记录信息
                console.log(`📊 角色 ${characterId} 的时间线记录:`, timeline.length, '条');
                timeline.forEach((event, index) => {
                    if (index < 5) { // 只显示前5条
                        console.log(`  ${index + 1}. ${event.appType}.${event.action} - contextId: ${event.context?.id}, type: ${event.context?.type}, groupId: ${event.context?.groupId || '无'}`);
                    }
                });

                // 🔥【新增】获取线下剧情总结
                const storylineSummaries = await db.crossAppTimeline
                    .where('characterId')
                    .equals(characterId)
                    .and(item => item.action === 'storyline_summary' && item.appType === 'offline_mode')
                    .toArray();

                console.log(`📖 线下剧情总结: ${storylineSummaries.length}条`);

                // 合并所有记忆并添加类型标识
                allMemories = [
                    ...coreMemories.filter(m => m.type === 'core').map(m => ({...m, memoryType: 'core'})),
                    ...episodicMemories.map(m => ({...m, memoryType: 'episodic'})),
                    ...timeline.map(m => ({
                        ...m,
                        memoryType: 'timeline',
                        fact: formatTimelineEvent(m)
                    })),
                    // 🔥【新增】添加线下剧情总结
                    ...storylineSummaries.map(m => {
                        const fullContent = m.context?.content || '线下剧情总结';
                        // 只显示前三行作为预览
                        const lines = fullContent.split('\n');
                        const preview = lines.slice(0, 3).join('\n') + (lines.length > 3 ? '\n...' : '');

                        return {
                            ...m,
                            memoryType: 'storyline',
                            fact: preview,
                            summary: preview,
                            fullContent: fullContent // 保存完整内容用于编辑
                        };
                    })
                ];

                // 按时间戳排序（最新的在前）
                allMemories.sort((a, b) => b.timestamp - a.timestamp);

                renderMemoryList();
            } catch (error) {
                console.error('加载角色记忆失败:', error);
                showToast('加载记忆失败', 'error');
            }
        }

        // 切换记忆过滤器
        function switchMemoryFilter(type) {
            currentMemoryFilter = type;

            // 更新标签样式
            document.querySelectorAll('.memory-filter-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`[data-type="${type}"]`).classList.add('active');

            renderMemoryList();
        }

        // 过滤记忆
        function filterMemories() {
            renderMemoryList();
        }

        // 渲染记忆列表
        function renderMemoryList() {
            const container = document.getElementById('memory-list');
            if (!container) return;

            if (!currentMemoryCharacter || allMemories.length === 0) {
                container.innerHTML = `
                    <div class="memory-empty-state">
                        <i class="fas fa-brain"></i>
                        <p>${currentMemoryCharacter ? '该角色暂无记忆数据' : '请选择角色查看记忆'}</p>
                    </div>
                `;
                return;
            }

            // 获取搜索关键词
            const searchTerm = document.getElementById('memory-search-input').value.toLowerCase();

            // 过滤记忆
            let filteredMemories = allMemories;

            // 按类型过滤
            if (currentMemoryFilter !== 'all') {
                filteredMemories = filteredMemories.filter(memory => memory.memoryType === currentMemoryFilter);
            }

            // 按搜索词过滤
            if (searchTerm) {
                filteredMemories = filteredMemories.filter(memory => {
                    const content = memory.fact || memory.summary || '';
                    return content.toLowerCase().includes(searchTerm);
                });
            }

            if (filteredMemories.length === 0) {
                container.innerHTML = `
                    <div class="memory-empty-state">
                        <i class="fas fa-search"></i>
                        <p>没有找到匹配的记忆</p>
                    </div>
                `;
                return;
            }

            // 渲染记忆项
            const html = filteredMemories.map(memory => renderMemoryItem(memory)).join('');
            container.innerHTML = html;
        }

        // 渲染单个记忆项
        function renderMemoryItem(memory) {
            const dateObj = new Date(memory.timestamp || Date.now());
            const date = isNaN(dateObj.getTime()) ? '未知日期' : dateObj.toLocaleDateString('zh-CN');
            const content = memory.fact || memory.summary || '';
            const importance = memory.importance || 0;
            const stars = '★'.repeat(Math.round(importance * 5));

            const typeLabels = {
                'core': '核心记忆',
                'episodic': '情景记忆',
                'storyline': '剧情总结',
                'timeline': '时间线'
            };

            return `
                <div class="memory-item" data-memory-id="${memory.id}">
                    <div class="memory-item-header">
                        <span class="memory-item-type ${memory.memoryType}">
                            <i class="fas fa-${getMemoryTypeIcon(memory.memoryType)}"></i>
                            ${typeLabels[memory.memoryType]}
                        </span>
                        <span class="memory-item-date">${date}</span>
                    </div>
                    <div class="memory-item-content">${content}</div>
                    ${memory.memoryType === 'core' || memory.memoryType === 'episodic' ? `
                        <div class="memory-item-importance">
                            <span>重要性:</span>
                            <span class="importance-stars">${stars}</span>
                            <span>(${(importance * 100).toFixed(0)}%)</span>
                        </div>
                    ` : ''}
                    <div class="memory-item-actions">
                        ${memory.memoryType === 'storyline' ? `
                            <button class="memory-action-btn view-btn" onclick="viewStorylineSummary('${memory.id}')" title="查看完整内容">
                                <i class="fas fa-eye"></i> 查看
                            </button>
                            <button class="memory-action-btn edit-btn" onclick="editStorylineSummary('${memory.id}')" title="编辑剧情总结">
                                <i class="fas fa-edit"></i> 编辑
                            </button>
                        ` : `
                            <button class="memory-action-btn" onclick="editMemory('${memory.id}', '${memory.memoryType}')">
                                <i class="fas fa-edit"></i> 编辑
                            </button>
                        `}
                        <button class="memory-action-btn delete" onclick="deleteMemory('${memory.id}', '${memory.memoryType}')">
                            <i class="fas fa-trash"></i> 删除
                        </button>
                    </div>
                </div>
            `;
        }

        // 获取记忆类型图标
        function getMemoryTypeIcon(type) {
            const icons = {
                'core': 'star',
                'episodic': 'calendar-day',
                'storyline': 'book',
                'timeline': 'clock'
            };
            return icons[type] || 'circle';
        }

        // 🔥【重新设计】格式化时间线事件显示 - 简化版本，避免显示不完整内容
        function formatTimelineEvent(event) {
            const appNames = {
                'chat': '聊天',
                'music': '音乐',
                'moments': '动态',
                'diary': '日记'
            };

            const appName = appNames[event.appType] || event.appType;
            let description = '';

            try {
                const context = typeof event.context === 'string' ? JSON.parse(event.context) : event.context;

                switch (event.appType) {
                    case 'chat':
                        const chatType = context?.type === 'group_chat' ? '群聊' : '单聊';
                        const groupName = context?.groupName ? `(${context.groupName})` : '';

                        if (event.action === 'ai_reply') {
                            description = `在${chatType}${groupName}中回复了消息`;
                        } else if (event.action === 'user_message') {
                            description = `在${chatType}${groupName}中收到用户消息`;
                        } else {
                            description = `在${chatType}${groupName}中进行了聊天互动`;
                        }
                        break;
                    case 'music':
                        if (context.action === 'listen_together') {
                            description = `与用户一起听歌：${context.songTitle || context.song || ''}`;
                        } else if (context.action === 'song_comment') {
                            description = `对音乐发表了评论`;
                        } else {
                            description = `进行了音乐互动`;
                        }
                        break;
                    case 'moments':
                        if (event.action === 'ai_to_ai_reply') {
                            description = `在动态中回复了其他角色`;
                        } else if (event.action === 'reply_to_user') {
                            description = `在动态中回复了用户`;
                        } else {
                            description = `进行了动态互动`;
                        }
                        break;
                    case 'diary':
                        description = `写了日记`;
                        break;
                    default:
                        description = `进行了${event.action || '未知'}活动`;
                }
            } catch (e) {
                description = `进行了${event.action || '未知'}活动`;
            }

            return `【${appName}】${description}`;
        }

        // 刷新记忆数据
        async function refreshMemoryData() {
            if (currentMemoryCharacter) {
                await loadCharacterMemories();
                showToast('记忆数据已刷新', 'success');
            }
        }



        // 🔥【新增】清理错误的记录
        async function cleanupIncorrectRecords() {
            if (!confirm('确定要清理错误的记录吗？这将删除跨应用时间线中错误的聊天记录。')) {
                return;
            }

            try {
                const deletedCount = await cleanupIncorrectTimelineRecords();
                await loadCharacterMemories();
                showToast(`错误记录清理完成，删除了${deletedCount}条错误记录`, 'success');
            } catch (error) {
                console.error('清理错误记录失败:', error);
                showToast('清理失败', 'error');
            }
        }

        // 🔥【新增】测试跨应用记忆共享功能
        async function testCrossAppMemorySharing(characterId) {
            console.log('🧪 开始测试跨应用记忆共享功能...');

            try {
                // 1. 模拟短信事件记录
                console.log('📱 模拟记录短信事件...');
                await recordCrossAppEvent(
                    characterId,
                    'sms',
                    'user_message',
                    {
                        id: characterId,
                        type: 'sms_message',
                        content: '测试短信内容：我刚刚吃了冰淇淋',
                        chatId: characterId,
                        sender: 'user'
                    },
                    `test_sms_${Date.now()}`
                );

                // 2. 等待一秒后查询时间线
                await new Promise(resolve => setTimeout(resolve, 1000));

                // 3. 测试chatapp是否能读取到短信事件
                console.log('💬 测试chatapp读取时间线记忆...');
                const timeline = await getCrossAppTimeline(characterId, 10);
                console.log('📊 获取到的时间线记录数量:', timeline.length);

                const smsEvents = timeline.filter(event => event.appType === 'sms');
                console.log('📱 短信相关事件数量:', smsEvents.length);

                if (smsEvents.length > 0) {
                    console.log('✅ 成功！chatapp可以读取到短信事件');
                    smsEvents.forEach((event, index) => {
                        console.log(`📱 短信事件 ${index + 1}:`, {
                            action: event.action,
                            content: event.context?.content?.substring(0, 50),
                            timestamp: new Date(event.timestamp).toLocaleString()
                        });
                    });
                } else {
                    console.log('❌ 失败！chatapp无法读取到短信事件');
                }

                // 4. 测试buildGlobalMemoryContext函数
                console.log('🧠 测试全局记忆上下文构建...');
                const memoryContext = await buildGlobalMemoryContext(characterId, {
                    id: characterId,
                    type: 'private_chat'
                }, 7);

                if (memoryContext.includes('短信') || memoryContext.includes('冰淇淋')) {
                    console.log('✅ 成功！全局记忆上下文包含短信内容');
                    console.log('🧠 记忆上下文预览:', memoryContext.substring(0, 500) + '...');
                } else {
                    console.log('❌ 失败！全局记忆上下文不包含短信内容');
                    console.log('🧠 记忆上下文内容:', memoryContext);
                }

            } catch (error) {
                console.error('❌ 测试过程中发生错误:', error);
            }
        }

        // 🔥【新增】清理重复的时间线事件
        async function cleanupDuplicateTimelineEvents(characterId) {
            try {
                console.log(`🧹 开始清理角色 ${characterId} 的重复时间线记录...`);

                const timelineEvents = await db.crossAppTimeline
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                const duplicates = [];
                const seenContents = new Map(); // 内容 -> 第一个事件

                for (const event of timelineEvents) {
                    const content = event.context?.content;
                    if (content) {
                        const normalizedContent = content.toLowerCase().trim();
                        if (seenContents.has(normalizedContent)) {
                            // 发现重复，保留时间戳较早的
                            const existingEvent = seenContents.get(normalizedContent);
                            if (event.timestamp > existingEvent.timestamp) {
                                duplicates.push(event);
                            } else {
                                duplicates.push(existingEvent);
                                seenContents.set(normalizedContent, event);
                            }
                        } else {
                            seenContents.set(normalizedContent, event);
                        }
                    }
                }

                // 删除重复的时间线记录
                for (const duplicate of duplicates) {
                    await db.crossAppTimeline.delete(duplicate.id);
                    console.log(`🗑️ 删除重复时间线记录: ${duplicate.action} - ${duplicate.context?.content?.substring(0, 50)}...`);
                }

                console.log(`✅ 清理完成，删除了 ${duplicates.length} 条重复时间线记录`);
                return duplicates.length;

            } catch (error) {
                console.error('清理重复时间线记录失败:', error);
                return 0;
            }
        }

        // 显示记忆设置
        function showMemorySettings() {
            // 加载当前设置
            document.getElementById('aiExtractInterval').value = MEMORY_CONFIG.AI_EXTRACT_INTERVAL / 2; // 转换为回合数
            document.getElementById('coreMemoryThreshold').value = MEMORY_CONFIG.CORE_MEMORY_IMPORTANCE_THRESHOLD;
            document.getElementById('episodicMemoryThreshold').value = MEMORY_CONFIG.EPISODIC_MEMORY_IMPORTANCE_THRESHOLD;

            // 更新显示值
            updateThresholdDisplay();

            // 显示模态框
            document.getElementById('memorySettingsModal').style.display = 'flex';
        }

        // 关闭记忆设置
        function closeMemorySettings() {
            document.getElementById('memorySettingsModal').style.display = 'none';
        }

        // 更新阈值显示
        function updateThresholdDisplay() {
            const coreThreshold = document.getElementById('coreMemoryThreshold').value;
            const episodicThreshold = document.getElementById('episodicMemoryThreshold').value;

            document.getElementById('coreThresholdValue').textContent = Math.round(coreThreshold * 100) + '%';
            document.getElementById('episodicThresholdValue').textContent = Math.round(episodicThreshold * 100) + '%';
        }

        // 保存记忆设置
        async function saveMemorySettings() {
            try {
                const aiInterval = parseInt(document.getElementById('aiExtractInterval').value);
                const coreThreshold = parseFloat(document.getElementById('coreMemoryThreshold').value);
                const episodicThreshold = parseFloat(document.getElementById('episodicMemoryThreshold').value);

                // 更新配置
                MEMORY_CONFIG.AI_EXTRACT_INTERVAL = aiInterval * 2; // 转换为消息数
                MEMORY_CONFIG.CORE_MEMORY_IMPORTANCE_THRESHOLD = coreThreshold;
                MEMORY_CONFIG.EPISODIC_MEMORY_IMPORTANCE_THRESHOLD = episodicThreshold;

                // 保存到数据库
                await saveMemoryConfig();

                closeMemorySettings();
                showToast('记忆设置已保存', 'success');
            } catch (error) {
                console.error('保存记忆设置失败:', error);
                showToast('保存失败', 'error');
            }
        }

        // 编辑记忆
        async function editMemory(memoryId, memoryType) {
            try {
                // 🔥【修复】时间线记忆不允许编辑
                if (memoryType === 'timeline') {
                    showToast('时间线记忆是自动记录的活动日志，不支持编辑', 'warning');
                    return;
                }

                let memory;
                if (memoryType === 'summary') {
                    memory = await db.memorySummaries.get(memoryId);
                } else if (memoryType === 'core') {
                    memory = await db.coreMemories.get(memoryId);
                } else {
                    showToast('不支持的记忆类型', 'error');
                    return;
                }

                if (!memory) {
                    showToast('记忆不存在', 'error');
                    return;
                }

                const content = memory.fact || memory.summary || '';
                const newContent = await showCustomPrompt('编辑记忆', '请输入新的记忆内容', content);

                if (newContent && newContent.trim() && newContent !== content) {
                    if (memoryType === 'summary') {
                        memory.summary = newContent.trim();
                        await db.memorySummaries.put(memory);
                    } else {
                        memory.fact = newContent.trim();
                        await db.coreMemories.put(memory);
                    }

                    await loadCharacterMemories();
                    showToast('记忆已更新', 'success');
                }
            } catch (error) {
                console.error('编辑记忆失败:', error);
                showToast('编辑记忆失败', 'error');
            }
        }

        // 删除记忆
        async function deleteMemory(memoryId, memoryType) {
            // 🔥【修复】时间线记忆删除确认
            let confirmMessage = '确定要删除这条记忆吗？此操作不可撤销。';
            if (memoryType === 'timeline') {
                confirmMessage = '确定要删除这条时间线记录吗？这是自动记录的活动日志，删除后无法恢复。';
            }

            if (!confirm(confirmMessage)) {
                return;
            }

            try {
                if (memoryType === 'summary') {
                    await db.memorySummaries.delete(memoryId);
                } else if (memoryType === 'core') {
                    await db.coreMemories.delete(memoryId);
                } else if (memoryType === 'episodic') {
                    await db.episodicMemories.delete(memoryId);
                } else if (memoryType === 'timeline') {
                    await db.crossAppTimeline.delete(memoryId);
                } else {
                    showToast('不支持的记忆类型', 'error');
                    return;
                }

                await loadCharacterMemories();
                showToast('记忆已删除', 'success');
            } catch (error) {
                console.error('删除记忆失败:', error);
                showToast('删除记忆失败', 'error');
            }
        }

        // AI心率管理功能
        let heartrateInterval = null;
        let currentHeartrate = 72; // 基础心率

        function updateAiHeartrate() {
            const heartrateDisplay = document.getElementById('ai-heartrate-display');
            if (!heartrateDisplay) return;

            const chatSettings = getCurrentChatSettings();

            // 检查是否启用心率监测且不是群聊
            if (!chatSettings.aiHeartrateEnabled || (currentChatCharacter && currentChatCharacter.isGroup)) {
                hideAiHeartrate();
                return;
            }

            // 显示心率
            heartrateDisplay.style.display = 'block';

            // 计算基础心率（基于角色人设）
            const persona = (currentChatCharacter.bio || '').toLowerCase();
            const name = (currentChatCharacter.name || '').toLowerCase();
            let baseHeartrate = 72;

            // 根据角色特征调整基础心率
            if (persona.includes('紧张') || persona.includes('害羞') || persona.includes('敏感') ||
                persona.includes('羞涩') || persona.includes('容易脸红') || persona.includes('内向')) {
                baseHeartrate = 85; // 容易紧张的角色心率更高
            } else if (persona.includes('冷静') || persona.includes('理性') || persona.includes('成熟') ||
                       persona.includes('沉稳') || persona.includes('内敛') || persona.includes('严肃')) {
                baseHeartrate = 65; // 冷静的角色心率更低
            } else if (persona.includes('活泼') || persona.includes('兴奋') || persona.includes('热情') ||
                       persona.includes('开朗') || persona.includes('外向') || persona.includes('爱笑')) {
                baseHeartrate = 82; // 活泼的角色心率偏高
            } else if (persona.includes('运动') || persona.includes('健身') || persona.includes('体育') ||
                       persona.includes('运动员') || persona.includes('活跃')) {
                baseHeartrate = 58; // 运动型角色心率最低
            } else if (persona.includes('温柔') || persona.includes('甜美') || persona.includes('可爱') ||
                       persona.includes('软萌') || persona.includes('小鸟依人') || persona.includes('乖巧')) {
                baseHeartrate = 75; // 温柔型角色心率适中偏高
            } else if (persona.includes('冷酷') || persona.includes('高冷') || persona.includes('傲娇') ||
                       persona.includes('女王') || persona.includes('强势') || persona.includes('霸道')) {
                baseHeartrate = 68; // 高冷型角色心率偏低
            } else if (persona.includes('热血') || persona.includes('冲动') || persona.includes('急性子') ||
                       persona.includes('火爆') || persona.includes('暴躁') || persona.includes('易怒')) {
                baseHeartrate = 88; // 热血型角色心率很高
            } else if (persona.includes('神秘') || persona.includes('深沉') || persona.includes('安静') ||
                       persona.includes('文静') || persona.includes('内向')) {
                baseHeartrate = 70; // 神秘型角色心率正常偏低
            }

            // 根据角色名字进一步微调
            if (name.includes('小') || name.includes('萌') || name.includes('可爱')) {
                baseHeartrate += 3; // 可爱名字的角色心率稍高
            } else if (name.includes('冰') || name.includes('雪') || name.includes('静') ||
                       name.includes('冷') || name.includes('凉')) {
                baseHeartrate -= 5; // 冷系名字的角色心率更低
            } else if (name.includes('火') || name.includes('热') || name.includes('烈')) {
                baseHeartrate += 5; // 火系名字的角色心率更高
            }

            // 根据最近对话内容调整心率
            const recentMessages = (chatMessages[currentChatCharacter.id] || []).slice(-8); // 分析最近8条消息
            let emotionAdjustment = 0;

            recentMessages.forEach(msg => {
                // 安全地处理消息内容
                let content = '';
                if (typeof msg.content === 'string') {
                    content = msg.content.toLowerCase();
                } else if (Array.isArray(msg.content)) {
                    content = '';
                } else {
                    content = '';
                }

                // 高度亲密词汇 - 大幅提高心率
                if (content.includes('爱你') || content.includes('我爱你') || content.includes('love you') ||
                    content.includes('喜欢你') || content.includes('想你') || content.includes('想抱你') ||
                    content.includes('想吻你') || content.includes('亲亲') || content.includes('抱抱') ||
                    content.includes('宝贝') || content.includes('darling') || content.includes('honey') ||
                    content.includes('亲爱的') || content.includes('想要你') || content.includes('需要你') ||
                    content.includes('离不开你') || content.includes('想和你') || content.includes('想见你')) {
                    emotionAdjustment += 15;
                }

                // 表白和甜蜜词汇
                if (content.includes('表白') || content.includes('喜欢') || content.includes('心动') ||
                    content.includes('心跳') || content.includes('脸红') || content.includes('害羞') ||
                    content.includes('可爱') || content.includes('甜') || content.includes('温柔') ||
                    content.includes('美丽') || content.includes('漂亮') || content.includes('迷人') ||
                    content.includes('魅力') || content.includes('吸引') || content.includes('心仪')) {
                    emotionAdjustment += 10;
                }

                // 撒娇和亲昵词汇
                if (content.includes('撒娇') || content.includes('嘤嘤') || content.includes('哼') ||
                    content.includes('人家') || content.includes('讨厌') || content.includes('不要') ||
                    content.includes('好不好') || content.includes('求你') || content.includes('拜托') ||
                    content.includes('陪我') || content.includes('陪陪') || content.includes('一起')) {
                    emotionAdjustment += 8;
                }

                // 兴奋和开心词汇
                if (content.includes('开心') || content.includes('高兴') || content.includes('快乐') ||
                    content.includes('兴奋') || content.includes('激动') || content.includes('好棒') ||
                    content.includes('厉害') || content.includes('哇') || content.includes('太好了') ||
                    content.includes('amazing') || content.includes('wonderful') || content.includes('great')) {
                    emotionAdjustment += 6;
                }

                // 负面情绪词汇 - 同样会让心率加快
                if (content.includes('难过') || content.includes('生气') || content.includes('担心') ||
                    content.includes('害怕') || content.includes('紧张') || content.includes('焦虑') ||
                    content.includes('不开心') || content.includes('郁闷') || content.includes('烦') ||
                    content.includes('压力') || content.includes('累') || content.includes('疲惫')) {
                    emotionAdjustment += 8;
                }
            });

            // 计算最终心率
            currentHeartrate = Math.max(50, Math.min(140, baseHeartrate + emotionAdjustment));

            // 启动心率更新
            if (heartrateInterval) clearInterval(heartrateInterval);
            heartrateInterval = setInterval(() => {
                // 添加自然的心率波动（±4 bpm）
                const fluctuation = Math.floor(Math.random() * 9) - 4;
                const displayHeartrate = Math.max(50, Math.min(140, currentHeartrate + fluctuation));

                // 根据心率高低添加视觉效果
                heartrateDisplay.className = '';
                if (displayHeartrate >= 110) {
                    heartrateDisplay.classList.add('very-high-heartrate');
                } else if (displayHeartrate >= 95) {
                    heartrateDisplay.classList.add('high-heartrate');
                }

                heartrateDisplay.innerHTML = `♥️ <span class="heartrate-number">${displayHeartrate}</span> <span class="heartrate-unit">bpm</span>`;
            }, 1500 + Math.random() * 1000); // 1.5-2.5秒更新一次

            // 立即显示初始心率
            heartrateDisplay.innerHTML = `♥️ <span class="heartrate-number">${currentHeartrate}</span> <span class="heartrate-unit">bpm</span>`;
        }

        function hideAiHeartrate() {
            const heartrateDisplay = document.getElementById('ai-heartrate-display');
            if (heartrateDisplay) {
                heartrateDisplay.style.display = 'none';
            }

            if (heartrateInterval) {
                clearInterval(heartrateInterval);
                heartrateInterval = null;
            }
        }

        // 当发送消息时更新心率
        function adjustHeartrateForMessage(content, isUserMessage = false) {
            if (!heartrateInterval) return; // 心率监测未启用

            let adjustment = 0;
            let lowerContent = '';
            let recoveryTime = 3000; // 默认恢复时间

            // 安全地处理内容
            if (typeof content === 'string') {
                lowerContent = content.toLowerCase();
            } else if (Array.isArray(content)) {
                lowerContent = '';
            } else {
                lowerContent = '';
            }

            if (isUserMessage) {
                // 用户发送消息时，AI的心率会有相应反应

                // 高度亲密词汇 - 强烈心跳加速
                if (lowerContent.includes('爱你') || lowerContent.includes('我爱你') || lowerContent.includes('love you') ||
                    lowerContent.includes('喜欢你') || lowerContent.includes('想你') || lowerContent.includes('想抱你') ||
                    lowerContent.includes('想吻你') || lowerContent.includes('亲亲') || lowerContent.includes('抱抱') ||
                    lowerContent.includes('宝贝') || lowerContent.includes('darling') || lowerContent.includes('honey') ||
                    lowerContent.includes('亲爱的') || lowerContent.includes('想要你') || lowerContent.includes('需要你') ||
                    lowerContent.includes('离不开你') || lowerContent.includes('想和你') || lowerContent.includes('想见你')) {
                    adjustment = 20; // 大幅增加
                    recoveryTime = 8000; // 更长的恢复时间
                }
                // 表白和甜蜜词汇
                else if (lowerContent.includes('表白') || lowerContent.includes('喜欢') || lowerContent.includes('心动') ||
                    lowerContent.includes('心跳') || lowerContent.includes('脸红') || lowerContent.includes('害羞') ||
                    lowerContent.includes('可爱') || lowerContent.includes('甜') || lowerContent.includes('温柔') ||
                    lowerContent.includes('美丽') || lowerContent.includes('漂亮') || lowerContent.includes('迷人') ||
                    lowerContent.includes('魅力') || lowerContent.includes('吸引') || lowerContent.includes('心仪')) {
                    adjustment = 15;
                    recoveryTime = 6000;
                }
                // 撒娇和亲昵词汇
                else if (lowerContent.includes('撒娇') || lowerContent.includes('嘤嘤') || lowerContent.includes('哼') ||
                    lowerContent.includes('人家') || lowerContent.includes('讨厌') || lowerContent.includes('不要') ||
                    lowerContent.includes('好不好') || lowerContent.includes('求你') || lowerContent.includes('拜托') ||
                    lowerContent.includes('陪我') || lowerContent.includes('陪陪') || lowerContent.includes('一起')) {
                    adjustment = 12;
                    recoveryTime = 5000;
                }
                // 兴奋和开心词汇
                else if (lowerContent.includes('开心') || lowerContent.includes('高兴') || lowerContent.includes('快乐') ||
                    lowerContent.includes('兴奋') || lowerContent.includes('激动') || lowerContent.includes('好棒') ||
                    lowerContent.includes('厉害') || lowerContent.includes('哇') || lowerContent.includes('太好了')) {
                    adjustment = 8;
                    recoveryTime = 4000;
                }
                // 负面情绪词汇 - 紧张导致心率加快
                else if (lowerContent.includes('生气') || lowerContent.includes('不开心') || lowerContent.includes('难过') ||
                    lowerContent.includes('担心') || lowerContent.includes('害怕') || lowerContent.includes('紧张') ||
                    lowerContent.includes('焦虑') || lowerContent.includes('郁闷') || lowerContent.includes('烦')) {
                    adjustment = 10;
                    recoveryTime = 6000;
                }
                // 普通问候
                else if (lowerContent.includes('你好') || lowerContent.includes('hi') || lowerContent.includes('hello') ||
                    lowerContent.includes('早上好') || lowerContent.includes('晚安')) {
                    adjustment = 5;
                    recoveryTime = 3000;
                }

            } else {
                // AI自己发送消息后的心率变化
                if (lowerContent.includes('害羞') || lowerContent.includes('脸红') || lowerContent.includes('不好意思')) {
                    adjustment = 10;
                    recoveryTime = 5000;
                } else if (lowerContent.includes('兴奋') || lowerContent.includes('开心') || lowerContent.includes('激动')) {
                    adjustment = 8;
                    recoveryTime = 4000;
                } else if (lowerContent.includes('紧张') || lowerContent.includes('担心') || lowerContent.includes('焦虑')) {
                    adjustment = 12;
                    recoveryTime = 6000;
                } else if (lowerContent.includes('爱') || lowerContent.includes('喜欢') || lowerContent.includes('想')) {
                    adjustment = 15;
                    recoveryTime = 7000;
                }
            }

            // 应用调整
            currentHeartrate = Math.max(55, Math.min(130, currentHeartrate + adjustment));

            // 更自然的恢复机制
            setTimeout(() => {
                const recoveryRate = Math.floor(adjustment * 0.6); // 恢复60%
                currentHeartrate = Math.max(65, currentHeartrate - recoveryRate);

                // 继续缓慢恢复
                setTimeout(() => {
                    const finalRecovery = Math.floor(adjustment * 0.3); // 再恢复30%
                    currentHeartrate = Math.max(65, currentHeartrate - finalRecovery);
                }, recoveryTime * 0.5);

            }, recoveryTime);
        }

        /**
 * 🔥【新增】处理AI对好友申请的回应
 * @param {string} characterId - AI角色的ID
 * @param {string} requestMessage - 用户发送的申请理由
 */
async function processAIFriendRequestResponse(characterId, requestMessage) {
    const character = characters.find(c => c.id === characterId);
    if (!character) return;

    // 构建一个专门用于决策的Prompt
    const decisionPrompt = `
# 指令：好友申请决策
你是 ${character.name}，之前因为某种原因拉黑了用户。现在用户主动向你发来好友申请，希望重新建立联系。

## 角色信息:
- 你的身份: ${character.name}
- 你的设定: ${character.bio}

## 当前情况:
- 用户的申请理由: "${requestMessage || '对方没有填写理由。'}"
- 用户主动道歉并请求重新做朋友

## 你的任务:
根据你的角色性格、用户的申请理由，以及你对这种情况的态度，决定是否同意重新添加用户为好友。

考虑因素：
1. 你的性格是否容易原谅别人？
2. 用户的道歉是否真诚？
3. 你是否愿意给对方第二次机会？
4. 你当初拉黑的原因是否严重？

你的回答必须非常简洁，只能是以下两个词之一：
- "同意" (如果你愿意原谅并重新开始)
- "拒绝" (如果你还不想原谅或重新联系)

请现在做出你的决定：
`;

    try {
        // 使用通用的API调用函数
        const response = await callChatAPI(decisionPrompt, character);
        // AI的回复通常是 `["同意"]` 或 `["拒绝"]`，我们只需要第一个元素
        const decision = Array.isArray(response) ? response[0].toLowerCase() : response.toLowerCase();

        console.log(`🤖 AI对好友申请的决策: ${decision}`);

        if (decision.includes('同意')) {
            // AI同意了
            await aiUnblockUser(characterId);

            // 🔥【美化】使用新的好友添加成功系统提示样式
            const systemMsg = {
                id: 'system_' + Date.now(),
                sender: 'system',
                content: `你们已成功添加为好友，现在可以开始聊天了！`,
                timestamp: Date.now(),
                isFriendAddedMessage: true // 标记为好友添加成功消息
            };
            addMessageToChat(systemMsg);

            showToast(`✅ ${character.name} 同意了你的好友申请`, 'success');

        } else {
            // AI拒绝了
            const systemMsg = {
                id: 'system_' + Date.now(),
                sender: 'system',
                content: `${character.name} 拒绝了你的好友申请。`,
                timestamp: Date.now()
            };
            addMessageToChat(systemMsg);

            showToast(`❌ ${character.name} 拒绝了你的好友申请`, 'warning');
        }

    } catch (error) {
        console.error('处理AI好友申请回应失败:', error);
        showToast('对方没有回应，请稍后再试', 'error');
    }
}


/**
 * 🔥【新增】AI解除对用户的拉黑
 * @param {string} characterId - AI角色的ID（拉黑者）
 */
async function aiUnblockUser(characterId) {
    try {
        const blockRecord = blacklistData.find(r =>
            r.blockerId === characterId &&
            r.blockedId === 'user' &&
            !r.unblocked
        );

        if (!blockRecord) {
            console.warn('未找到该角色的拉黑记录');
            return;
        }

        blockRecord.unblocked = true;
        blockRecord.unblockTimestamp = new Date().toISOString();

        await db.blacklist.put(blockRecord);
        console.log(`✅ ${characterId} 已解除对用户的拉黑`);

        // 刷新聊天界面的拉黑状态
        if (currentChatCharacter && currentChatCharacter.id === characterId) {
            updateChatBlockedStatus();
        }

        // 刷新联系人列表和消息列表的UI状态
        renderContactList();
        renderMessageList();

    } catch (error) {
        console.error('AI解除拉黑失败:', error);
    }
}
        console.log('📱 角色状态显示功能已加载');

        // 🔥【新增】通知角色被拉黑
        async function notifyCharacterBlocked(characterId, reason = '') {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;

                // 🔥【修复】构建被拉黑通知的prompt，使用generateAIResponse而不是callChatAPI
                const blockNotificationPrompt = `[系统消息：用户将你拉黑了${reason ? `，理由：${reason}` : '，未说明理由'}]

你是${character.name}，人设如下：${character.bio}

用户刚刚将你拉黑了。请根据你的性格做出反应。你可以：
1. 表达你的感受（困惑、伤心、愤怒、无所谓等）
2. 思考可能的原因
3. 决定是否要道歉或反省
4. **【推荐】发送好友申请来尝试修复关系** - 这是最直接的修复方式
5. 或者表现出符合你性格的其他反应

💡 **建议**：大多数角色在被拉黑后都会想要修复关系，发送好友申请是最好的方式。

## 🔥【重要】输出格式要求
你的回复必须是JSON数组格式：
- 普通反应：["我被拉黑了？为什么..."]
- 发送好友申请：[{"type": "friend_request", "message": "对不起，我不应该那样说话，能原谅我吗？"}]
- 混合回复：["我知道我被拉黑了...", {"type": "friend_request", "message": "给我一个机会重新开始好吗？"}]

## 🔥【好友申请格式】
如果你想修复关系，可以发送好友申请：
- 严格格式：{"type": "friend_request", "message": "你的道歉或请求信息"}
- 示例：{"type": "friend_request", "message": "对不起，我想和你重新做朋友"}

请用JSON数组格式回复，可以包含1-2句话的反应和/或好友申请：`;

                // 🔥【修复】调用AI生成反应，使用generateAIResponse确保JSON格式
                const response = await generateAIResponse(blockNotificationPrompt, character);
                const reactions = await parseAiResponse(response);

                // 添加角色的反应消息到聊天记录
                for (let i = 0; i < reactions.length; i++) {
                    const reactionData = reactions[i];

                    // 跳过拉黑指令对象
                    if (typeof reactionData === 'object' && reactionData !== null && reactionData.type === 'block_user') {
                        continue;
                    }

                    let reactionMessage;
                    if (typeof reactionData === 'string') {
                        reactionMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: reactionData,
                            timestamp: Date.now() + i * 100,
                            isBlockReaction: true // 标记为拉黑反应消息
                        };
                    } else if (typeof reactionData === 'object' && reactionData !== null) {
                        // 🔥【修复】正确处理好友申请类型的消息
                        if (reactionData.type === 'friend_request') {
                            reactionMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                type: 'friend_request',
                                message: reactionData.message || '想和你重新做朋友',
                                timestamp: Date.now() + i * 100,
                                isBlockReaction: true
                            };
                        } else {
                            // 处理其他类型的消息对象
                            const content = reactionData.content || reactionData.message || reactionData.text || '[角色反应]';
                            reactionMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                content: content,
                                timestamp: Date.now() + i * 100,
                                isBlockReaction: true
                            };
                        }
                    }

                    if (reactionMessage) {
                        // 添加到聊天记录
                        if (!chatMessages[characterId]) {
                            chatMessages[characterId] = [];
                        }
                        chatMessages[characterId].push(reactionMessage);

                        // 如果当前正在与该角色聊天，显示消息
                        if (currentChatCharacter && currentChatCharacter.id === characterId) {
                            addMessageWithAnimation(reactionMessage, characterId);
                        }
                    }
                }

                // 🔥【优化】拉黑反应使用高效保存
                try {
                    await saveChatMessagesImmediate([characterId]);
                    console.log('✅ [高效拉黑反应] 消息已保存到数据库');
                } catch (error) {
                    console.error('拉黑反应保存失败，回退到全量保存:', error);
                    await saveChatMessages();
                }
                console.log(`✅ ${character.name} 对被拉黑做出了反应`);

            } catch (error) {
                console.error('通知角色被拉黑失败:', error);
            }
        }

        // 🔥【新增】通知角色被解除拉黑
        async function notifyCharacterUnblocked(characterId) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;

                // 构建解除拉黑通知的prompt
                const unblockNotificationPrompt = `[系统消息：用户将你从黑名单中移除了]

你是${character.name}，人设如下：${character.bio}

用户刚刚将你从黑名单中移除，现在你们可以正常聊天了。请根据你的性格做出反应。你可以：
1. 表达高兴或解脱的心情
2. 询问为什么之前被拉黑
3. 道歉或表示会改正
4. 表现出符合你性格的态度（可能还在生气，也可能很开心等）
5. 主动开启新的话题

请用1-2句话表达你的反应，要符合你的性格设定：`;

                // 调用AI生成反应
                const response = await callChatAPI(unblockNotificationPrompt, character);
                const reactions = await parseAiResponse(response);

                // 添加角色的反应消息到聊天记录
                for (let i = 0; i < reactions.length; i++) {
                    const reactionData = reactions[i];

                    // 跳过拉黑指令对象
                    if (typeof reactionData === 'object' && reactionData !== null && reactionData.type === 'block_user') {
                        continue;
                    }

                    let reactionMessage;
                    if (typeof reactionData === 'string') {
                        reactionMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: reactionData,
                            timestamp: Date.now() + i * 100,
                            isUnblockReaction: true // 标记为解除拉黑反应消息
                        };
                    } else if (typeof reactionData === 'object' && reactionData !== null) {
                        // 处理其他类型的消息对象
                        const content = reactionData.content || reactionData.message || reactionData.text || '[角色反应]';
                        reactionMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: content,
                            timestamp: Date.now() + i * 100,
                            isUnblockReaction: true
                        };
                    }

                    if (reactionMessage) {
                        // 添加到聊天记录
                        if (!chatMessages[characterId]) {
                            chatMessages[characterId] = [];
                        }
                        chatMessages[characterId].push(reactionMessage);

                        // 如果当前正在与该角色聊天，显示消息
                        if (currentChatCharacter && currentChatCharacter.id === characterId) {
                            addMessageWithAnimation(reactionMessage, characterId);
                        }
                    }
                }

                // 🔥【优化】解除拉黑反应使用高效保存
                try {
                    await saveChatMessagesImmediate([characterId]);
                    console.log('✅ [高效解除拉黑反应] 消息已保存到数据库');
                } catch (error) {
                    console.error('解除拉黑反应保存失败，回退到全量保存:', error);
                    await saveChatMessages();
                }
                console.log(`✅ ${character.name} 对被解除拉黑做出了反应`);

            } catch (error) {
                console.error('通知角色被解除拉黑失败:', error);
            }
        }

        console.log('🚫 角色拉黑/解除拉黑通知功能已加载');

        // 🔥【新增】心声功能
        // 显示心声模态框
        async function showInnerThoughtsModal(messageId) {
            if (!messageId) return;

            const modal = document.getElementById('inner-thoughts-modal');
            const content = document.getElementById('inner-thoughts-content');

            // 显示模态框
            modal.style.display = 'flex';

            try {
                // 检查数据库中是否有缓存的心声
                const cachedThought = await db.innerThoughts.get(messageId);

                if (cachedThought) {
                    console.log('🔄 使用数据库缓存的心声内容');
                    displayInnerThoughts(cachedThought.content, messageId);
                } else {
                    console.log('🆕 生成新的心声内容');
                    // 显示加载状态
                    content.innerHTML = `
                        <div class="inner-thoughts-loading">
                            <div class="loading-spinner"></div>
                            <p>正在读取角色的内心想法...</p>
                        </div>
                    `;

                    // 生成心声
                    await generateInnerThoughts(messageId);
                }
            } catch (error) {
                console.error('加载心声失败:', error);
                displayInnerThoughtsError('加载心声数据失败');
            }
        }

        // 隐藏心声模态框
        function hideInnerThoughtsModal() {
            const modal = document.getElementById('inner-thoughts-modal');
            modal.style.display = 'none';
        }

        // 生成角色心声
        async function generateInnerThoughts(messageId, forceRegenerate = false) {
            try {
                const messages = chatMessages[currentChatCharacter.id] || [];
                const targetMessage = messages.find(msg => msg.id === messageId);

                if (!targetMessage || targetMessage.sender !== 'received') {
                    throw new Error('无法找到对应的AI消息');
                }

                // 🔥【新增】群聊支持：确定具体的角色信息
                let character = currentChatCharacter;
                let characterName = character.name;

                if (character.isGroup && targetMessage.senderId) {
                    // 群聊中，根据senderId找到具体的角色
                    const member = character.members.find(m => m.id === targetMessage.senderId);
                    if (member) {
                        // 查找完整的角色信息
                        const fullCharacter = characters.find(c => c.id === member.id);
                        if (fullCharacter) {
                            character = fullCharacter;
                            characterName = member.name;
                            console.log(`🔍 群聊心声 - 找到角色: ${characterName} (${member.id})`);
                        } else {
                            console.warn(`⚠️ 群聊心声 - 未找到角色完整信息: ${member.id}`);
                        }
                    } else {
                        throw new Error(`无法在群聊中找到发送者信息: ${targetMessage.senderId}`);
                    }
                } else if (character.isGroup && targetMessage.name) {
                    // 兼容旧格式：通过name字段查找
                    const member = character.members.find(m => m.name === targetMessage.name);
                    if (member) {
                        const fullCharacter = characters.find(c => c.id === member.id);
                        if (fullCharacter) {
                            character = fullCharacter;
                            characterName = member.name;
                            console.log(`🔍 群聊心声 - 通过name找到角色: ${characterName} (${member.id})`);
                        }
                    } else {
                        throw new Error(`无法在群聊中找到角色: ${targetMessage.name}`);
                    }
                }

                if (!character) {
                    throw new Error('当前角色信息不存在');
                }

                // 如果不是强制重新生成，检查数据库缓存
                if (!forceRegenerate) {
                    const cachedThought = await db.innerThoughts.get(messageId);
                    if (cachedThought) {
                        displayInnerThoughts(cachedThought.content, messageId);
                        return;
                    }
                }

                // 🔥【优化】构建心声生成的prompt，传递群聊上下文信息
                const prompt = buildInnerThoughtsPrompt(targetMessage, character, messages, {
                    isGroupChat: currentChatCharacter.isGroup,
                    groupName: currentChatCharacter.isGroup ? currentChatCharacter.name : null,
                    characterName: characterName,
                    groupMembers: currentChatCharacter.isGroup ? currentChatCharacter.members : null
                });

                // 调用AI生成心声
                const response = await generateAIResponse(prompt, character);

                if (response && response.trim()) {
                    const thoughts = response.trim();

                    // 保存到数据库
                    await db.innerThoughts.put({
                        id: messageId,
                        messageId: messageId,
                        characterId: character.id,
                        content: thoughts,
                        timestamp: Date.now()
                    });

                    console.log('💾 心声已保存到数据库');
                    displayInnerThoughts(thoughts, messageId);
                } else {
                    throw new Error('AI未能生成心声内容');
                }

            } catch (error) {
                console.error('生成心声失败:', error);
                displayInnerThoughtsError(error.message);
            }
        }

        // 🔥【新增】提取消息的文本内容
        function extractMessageText(message) {
            if (!message || !message.content) return '';

            if (Array.isArray(message.content)) {
                // 多模态消息：提取文本部分
                const textParts = message.content.filter(part => part.type === 'text');
                let text = textParts.map(part => part.text).join(' ');

                // 如果有图片，添加标记
                const imageParts = message.content.filter(part => part.type === 'image_url');
                if (imageParts.length > 0) {
                    text += ` [包含${imageParts.length}张图片]`;
                }
                return text;
            } else if (typeof message.content === 'string') {
                return message.content;
            } else {
                return String(message.content);
            }
        }

        // 构建心声生成的prompt
        function buildInnerThoughtsPrompt(targetMessage, character, allMessages, contextInfo = {}) {
            // 获取目标消息前后的上下文
            const messageIndex = allMessages.findIndex(msg => msg.id === targetMessage.id);
            const contextStart = Math.max(0, messageIndex - 3);
            const contextEnd = Math.min(allMessages.length, messageIndex + 1);
            const contextMessages = allMessages.slice(contextStart, contextEnd);

            // 🔥【优化】构建对话上下文，支持群聊场景
            const conversationContext = contextMessages.map(msg => {
                if (msg.sender === 'sent') {
                    const userContent = extractMessageText(msg);
                    return `用户：${userContent}`;
                } else if (msg.sender === 'received') {
                    const aiContent = extractMessageText(msg);

                    if (contextInfo.isGroupChat) {
                        // 群聊中显示具体的角色名
                        let senderName = '未知角色';
                        if (msg.senderId && contextInfo.groupMembers) {
                            const member = contextInfo.groupMembers.find(m => m.id === msg.senderId);
                            senderName = member ? member.name : msg.senderId;
                        } else if (msg.name) {
                            senderName = msg.name;
                        }
                        return `${senderName}：${aiContent}`;
                    } else {
                        return `${character.name}：${aiContent}`;
                    }
                }
                return '';
            }).filter(Boolean).join('\n');

            // 🔥【新增】群聊场景的特殊提示
            let scenarioContext = '';
            if (contextInfo.isGroupChat) {
                scenarioContext = `

## 当前场景：
你现在在群聊"${contextInfo.groupName}"中，与多个角色和用户互动。群聊成员包括：${contextInfo.groupMembers ? contextInfo.groupMembers.map(m => m.name).join('、') : '其他成员'}。

## 群聊心声要求：
- 考虑群聊的公开性，你的内心想法可能包含对其他成员的看法
- 可以思考群聊氛围、其他成员的发言、自己在群里的定位等
- 注意区分公开发言和内心真实想法的差异`;
            }

            const prompt = `# 角色心声分析任务

你是 ${contextInfo.characterName || character.name}，以下是你的基本信息：
${character.bio || '暂无详细信息'}${scenarioContext}

## 对话上下文：
${conversationContext}

## 任务要求：
请分析你在说出"${extractMessageText(targetMessage)}"这句话时的内心想法。

## 输出要求：
1. 以第一人称视角描述内心想法
2. 内容应该真实反映角色的性格和当时的心理状态
3. 可以包含：对用户话语的真实感受、内心的小纠结、未说出口的想法、情感波动等
4. ${contextInfo.isGroupChat ? '群聊场景下，可以包含对其他成员的看法、对群聊氛围的感受等' : ''}
5. 字数控制在50-150字之间
6. 语气要符合角色性格，自然真实
7. 直接输出心声内容，不要加任何格式标记

请开始分析：`;

            return prompt;
        }

        // 显示心声内容
        function displayInnerThoughts(thoughts, messageId) {
            const content = document.getElementById('inner-thoughts-content');

            // 🔥【新增】获取消息和角色信息，用于群聊场景的增强显示
            const messages = chatMessages[currentChatCharacter.id] || [];
            const targetMessage = messages.find(msg => msg.id === messageId);
            let characterInfo = '';

            if (currentChatCharacter.isGroup && targetMessage) {
                let characterName = '未知角色';
                let characterAvatar = '';

                if (targetMessage.senderId) {
                    const member = currentChatCharacter.members.find(m => m.id === targetMessage.senderId);
                    if (member) {
                        characterName = member.name;
                        characterAvatar = member.avatar || '';
                    }
                } else if (targetMessage.name) {
                    characterName = targetMessage.name;
                }

                characterInfo = `
                    <div class="inner-thoughts-character-info">
                        ${characterAvatar ? `<img src="${characterAvatar}" alt="${characterName}" class="character-mini-avatar">` : ''}
                        <span class="character-name">${characterName}的心声</span>
                    </div>
                `;
            }

            content.innerHTML = `
                ${characterInfo}
                <div class="inner-thoughts-text">${thoughts}</div>
            `;

            // 更新刷新按钮的onclick事件
            const refreshBtn = document.querySelector('.inner-thoughts-refresh-btn');
            if (refreshBtn) {
                refreshBtn.onclick = () => refreshInnerThoughts(messageId);
            }
        }

        // 刷新心声内容
        async function refreshInnerThoughts(messageId) {
            if (!messageId) return;

            const content = document.getElementById('inner-thoughts-content');

            // 显示刷新加载状态
            content.innerHTML = `
                <div class="inner-thoughts-loading">
                    <div class="loading-spinner"></div>
                    <p>正在重新生成心声...</p>
                </div>
            `;

            try {
                // 删除数据库中的旧心声
                await db.innerThoughts.delete(messageId);
                console.log('🗑️ 已删除旧心声缓存');

                // 强制重新生成心声
                await generateInnerThoughts(messageId, true);
            } catch (error) {
                console.error('刷新心声失败:', error);
                displayInnerThoughtsError('刷新心声失败');
            }
        }

        // 显示心声生成错误
        function displayInnerThoughtsError(errorMessage) {
            const content = document.getElementById('inner-thoughts-content');
            content.innerHTML = `
                <div style="text-align: center; color: #ff3b30; padding: 20px;">
                    <i class="fas fa-exclamation-triangle" style="font-size: 24px; margin-bottom: 10px;"></i>
                    <p>生成心声失败</p>
                    <p style="font-size: 12px; color: #666; margin-top: 10px;">${errorMessage}</p>
                </div>
            `;
        }

        // 🔥【完整修复脚本】解决数据导入失败和引用消息刷新后消失的问题
        // 🔥【重要】此函数支持50+种数据类型的完整导入，包含引用消息修复功能
        console.log('🔧 正在应用完整系统修复...');

        // 完整数据导入功能（覆盖原始函数）
        (function fixImportIssues() {
            const originalImport = window.importDataFromFile;
            window.importDataFromFile = function() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = async function(e) {
                    const file = e.target.files[0];
                    if (!file) return;

                    try {
                        showToast('🔍 验证文件格式...', 'info');
                        const text = await file.text();

                        let data;
                        try {
                            data = JSON.parse(text);
                        } catch (parseError) {
                            throw new Error(`JSON格式错误: ${parseError.message}\n请确保文件是有效的备份文件`);
                        }

                        if (!data || typeof data !== 'object') {
                            throw new Error('无效的备份文件格式');
                        }

                        const items = [];
                        if (data.characters?.length) items.push(`角色: ${data.characters.length}个`);
                        if (data.chatMessages?.length) items.push(`消息: ${data.chatMessages.length}条`);
                        if (data.chatSettings?.length) items.push(`设置: ${data.chatSettings.length}个`);

                        // 🔥【新增】群聊系统数据统计
                        if (data.groupChats?.length) {
                            items.push(`群聊: ${data.groupChats.length}个`);

                            // 统计群聊消息数量 - 从chatMessages中筛选群聊消息
                            let groupChatMessageCount = 0;
                            if (data.chatMessages?.length && data.groupChats?.length) {
                                const groupChatIds = data.groupChats.map(g => g.id);
                                groupChatMessageCount = data.chatMessages.filter(msg =>
                                    groupChatIds.includes(msg.characterId)
                                ).length;
                            }
                            if (groupChatMessageCount > 0) {
                                items.push(`群聊消息: ${groupChatMessageCount}条`);
                            }

                            // 统计群聊成员数量 - 从群聊对象的members属性中统计
                            let groupMemberCount = 0;
                            if (data.groupChats?.length) {
                                data.groupChats.forEach(group => {
                                    if (group.members && Array.isArray(group.members)) {
                                        groupMemberCount += group.members.length;
                                    }
                                });
                            }
                            if (groupMemberCount > 0) {
                                items.push(`群聊成员: ${groupMemberCount}个`);
                            }
                        }

                        // 🔥【完整】记忆系统数据统计
                        if (data.coreMemory?.length) items.push(`核心记忆: ${data.coreMemory.length}条`);
                        if (data.coreMemories?.length) items.push(`核心记忆库: ${data.coreMemories.length}条`);
                        if (data.episodicMemory?.length) items.push(`情节记忆: ${data.episodicMemory.length}条`);
                        if (data.episodicMemories?.length) items.push(`情景记忆: ${data.episodicMemories.length}条`);
                        if (data.workingMemory?.length) items.push(`工作记忆: ${data.workingMemory.length}条`);
                        if (data.memorySummaries?.length) items.push(`记忆总结: ${data.memorySummaries.length}条`);
                        if (data.memoryEvents?.length) items.push(`记忆事件: ${data.memoryEvents.length}条`);
                        if (data.crossAppTimeline?.length) items.push(`时间线: ${data.crossAppTimeline.length}条`);

                        // 🔥【完整】表情包和界面系统
                        if (data.customEmojis?.length) items.push(`自定义表情: ${data.customEmojis.length}个`);
                        if (data.recentEmojis?.length) items.push(`最近表情: ${data.recentEmojis.length}个`);
                        if (data.wallpapers?.length) items.push(`壁纸: ${data.wallpapers.length}个`);
                        if (data.appIcons?.length) items.push(`应用图标: ${data.appIcons.length}个`);

                        // 🔥【完整】角色和设置系统
                        if (data.characterGroups?.length) items.push(`角色分组: ${data.characterGroups.length}个`);
                        if (data.personas?.length) items.push(`用户面具: ${data.personas.length}个`);
                        if (data.apiSettings?.length) items.push(`API设置: ${data.apiSettings.length}个`);
                        if (data.globalSettings?.length) items.push(`全局设置: ${data.globalSettings.length}个`);
                        if (data.characterDiaries?.length) items.push(`角色日记: ${data.characterDiaries.length}条`);
                        // 🔥【完整】动态系统
                        if (data.moments?.length) items.push(`动态: ${data.moments.length}条`);
                        if (data.momentComments?.length) items.push(`动态评论: ${data.momentComments.length}条`);
                        if (data.momentLikes?.length) items.push(`动态点赞: ${data.momentLikes.length}条`);

                        // 🔥【完整】论坛相关数据统计
                        if (data.forums?.length) items.push(`论坛: ${data.forums.length}个`);
                        if (data.forumPosts?.length) items.push(`论坛帖子: ${data.forumPosts.length}条`);
                        if (data.forumReplies?.length) items.push(`论坛回复: ${data.forumReplies.length}条`);
                        if (data.forumFavorites?.length) items.push(`论坛收藏: ${data.forumFavorites.length}条`);
                        if (data.forumPostImages?.length) items.push(`论坛图片: ${data.forumPostImages.length}张`);
                        if (data.forumMountedWorldbooks?.length) items.push(`论坛世界书: ${data.forumMountedWorldbooks.length}个`);

                        // 🔥【完整】世界书相关数据统计
                        if (data.worldbooks?.length) items.push(`世界书: ${data.worldbooks.length}个`);
                        if (data.worldbookEntries?.length) items.push(`世界书条目: ${data.worldbookEntries.length}条`);

                        // 🔥【完整】其他系统数据统计
                        if (data.anniversaries?.length) items.push(`纪念日: ${data.anniversaries.length}个`);
                        if (data.diarySettings?.length) items.push(`日记设置: ${data.diarySettings.length}个`);
                        if (data.innerThoughts?.length) items.push(`心声: ${data.innerThoughts.length}条`);
                        if (data.blacklist?.length) items.push(`拉黑列表: ${data.blacklist.length}条`);
                        if (data.blockedCharacters?.length) items.push(`被拉黑角色: ${data.blockedCharacters.length}个`);
                        if (data.friendRequests?.length) items.push(`好友申请: ${data.friendRequests.length}条`);
                        if (data.characterStatus?.length) items.push(`角色状态: ${data.characterStatus.length}条`);

                        // 🔥【完整】线下模式和音乐系统
                        if (data.offlineHistoryRecords?.length) items.push(`线下记录: ${data.offlineHistoryRecords.length}条`);
                        if (data.offlineUISettings?.length) items.push(`线下界面设置: ${data.offlineUISettings.length}个`);
                        if (data.offlinePresets?.length) items.push(`线下预设: ${data.offlinePresets.length}个`);
                        if (data.musicPlaylist?.length) items.push(`音乐: ${data.musicPlaylist.length}首`);
                        if (data.musicCovers?.length) items.push(`音乐封面: ${data.musicCovers.length}个`);

                        // 🔥【完整】短信应用数据统计
                        if (data.smsContacts?.length) items.push(`短信联系人: ${data.smsContacts.length}个`);
                        if (data.smsMessages?.length) items.push(`短信消息: ${data.smsMessages.length}条`);

                        const msg = items.length ? `准备导入:\n${items.join('\n')}\n\n确定继续？` : '文件无有效数据，继续？';
                        if (!confirm(msg)) return;

                        showToast('⚡ 导入中...', 'info');
                        let success = 0;
                        let errors = [];

                        // 修复角色导入
                        if (data.characters?.length) {
                            try {
                                await db.characters.clear();
                                const chars = data.characters.filter(c => c?.name).map(c => ({
                                    ...c,
                                    id: c.id || `char_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                    groupId: c.groupId || 'my_friends'
                                }));
                                await db.characters.bulkPut(chars);
                                success++;
                            } catch (e) {
                                errors.push(`角色: ${e.message}`);
                            }
                        }

                        // 🔥【修复】消息导入（处理格式转换和引用消息）
                        if (data.chatMessages?.length) {
                            try {
                                console.log('🔄 修复脚本：开始导入聊天消息');

                                // 🔥【格式检测和转换】
                                let processedMessages = [];
                                const isNewFormat = data.chatMessages.some(msg => msg.messageData);

                                if (isNewFormat) {
                                    // 新格式：直接使用
                                    processedMessages = data.chatMessages.map(msg => ({
                                        ...msg,
                                        id: msg.id || `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                    }));
                                } else {
                                    // 旧格式：转换为新格式
                                    const tempChatMessages = {};
                                    for (const msg of data.chatMessages) {
                                        if (!msg?.content) continue; // 跳过无效消息

                                        const characterId = msg.characterId || 'unknown';
                                        if (!tempChatMessages[characterId]) {
                                            tempChatMessages[characterId] = [];
                                        }

                                        // 修复引用消息
                                        const fixedMsg = { ...msg };
                                        if (msg.replyTo) {
                                            fixedMsg.replyTo = {
                                                id: msg.replyTo.id || 'unknown',
                                                content: msg.replyTo.content || '[已删除]',
                                                sender: msg.replyTo.sender || 'unknown',
                                                senderName: msg.replyTo.senderName || '未知',
                                                timestamp: msg.replyTo.timestamp || Date.now(),
                                                _fixed: true
                                            };
                                        }

                                        tempChatMessages[characterId].push(fixedMsg);
                                    }

                                    // 转换为新格式
                                    let globalSequentialId = 0;
                                    for (const [characterId, messages] of Object.entries(tempChatMessages)) {
                                        for (let i = 0; i < messages.length; i++) {
                                            const message = messages[i];
                                            processedMessages.push({
                                                id: `${characterId}_${globalSequentialId++}`,
                                                characterId: characterId,
                                                timestamp: message.timestamp,
                                                messageOrder: i,
                                                originalMessageId: message.id,
                                                messageData: message
                                            });
                                        }
                                    }
                                }

                                await db.chatMessages.clear();
                                await db.chatMessages.bulkPut(processedMessages);
                                success++;
                                console.log(`✅ 修复脚本：成功导入 ${processedMessages.length} 条消息`);
                            } catch (e) {
                                console.error('❌ 修复脚本：消息导入失败:', e);
                                errors.push(`消息: ${e.message}`);
                            }
                        }

                        // 导入设置
                        if (data.chatSettings?.length) {
                            try {
                                await db.chatSettings.clear();
                                const settings = data.chatSettings.map(s => ({
                                    ...s,
                                    id: s.id || `set_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.chatSettings.bulkPut(settings);
                                success++;
                            } catch (e) {
                                errors.push(`设置: ${e.message}`);
                            }
                        }

                        // 🔥【新增】导入全局记忆系统数据
                        if (data.coreMemories?.length) {
                            try {
                                await db.coreMemories.clear();
                                const memories = data.coreMemories.map(m => ({
                                    ...m,
                                    id: m.id || `core_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.coreMemories.bulkPut(memories);
                                success++;
                            } catch (e) {
                                errors.push(`核心记忆: ${e.message}`);
                            }
                        }

                        if (data.episodicMemories?.length) {
                            try {
                                await db.episodicMemories.clear();
                                const memories = data.episodicMemories.map(m => ({
                                    ...m,
                                    id: m.id || `episodic_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.episodicMemories.bulkPut(memories);
                                success++;
                            } catch (e) {
                                errors.push(`情节记忆: ${e.message}`);
                            }
                        }

                        if (data.crossAppTimeline?.length) {
                            try {
                                await db.crossAppTimeline.clear();
                                const timeline = data.crossAppTimeline.map(t => ({
                                    ...t,
                                    id: t.id || `timeline_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.crossAppTimeline.bulkPut(timeline);
                                success++;
                            } catch (e) {
                                errors.push(`时间线: ${e.message}`);
                            }
                        }

                        if (data.customEmojis?.length) {
                            try {
                                // 🔥【关键修复】只清理个人表情包，保护库表情包
                                // 🔥【修复】使用filter方法避免undefined值的索引问题
                                await db.customEmojis.filter(emoji => emoji.isPersonal !== false).delete();
                                const emojis = data.customEmojis.map(e => ({
                                    ...e,
                                    id: e.id || `emoji_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                    isPersonal: e.isPersonal !== false ? true : false // 🔥【修复】确保isPersonal有明确值
                                }));
                                await db.customEmojis.bulkPut(emojis);
                                success++;
                            } catch (e) {
                                errors.push(`表情包: ${e.message}`);
                            }
                        }

                        // 🔥【新增】导入用户面具数据
                        if (data.personas?.length) {
                            try {
                                await db.personas.clear();
                                const personas = data.personas.map(p => ({
                                    ...p,
                                    id: p.id || `persona_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.personas.bulkPut(personas);
                                success++;
                            } catch (e) {
                                errors.push(`用户面具: ${e.message}`);
                            }
                        }

                        // 🔥【新增】导入动态数据
                        if (data.moments?.length) {
                            try {
                                await db.moments.clear();
                                const moments = data.moments.map(m => ({
                                    ...m,
                                    id: m.id || `moment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.moments.bulkPut(moments);
                                success++;
                            } catch (e) {
                                errors.push(`动态: ${e.message}`);
                            }
                        }

                        // 🔥【新增】导入动态评论数据
                        if (data.momentComments?.length) {
                            try {
                                await db.momentComments.clear();
                                const comments = data.momentComments.map(c => ({
                                    ...c,
                                    id: c.id || `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.momentComments.bulkPut(comments);
                                success++;
                            } catch (e) {
                                errors.push(`动态评论: ${e.message}`);
                            }
                        }

                        // 🔥【新增】导入角色日记数据
                        if (data.characterDiaries?.length) {
                            try {
                                await db.characterDiaries.clear();
                                const diaries = data.characterDiaries.map(d => ({
                                    ...d,
                                    id: d.id || `${d.characterId}_${d.date}`,
                                    timestamp: d.timestamp || new Date(d.date).getTime(),
                                    weather: d.weather || '☀️'
                                }));
                                await db.characterDiaries.bulkPut(diaries);
                                success++;
                            } catch (e) {
                                errors.push(`角色日记: ${e.message}`);
                            }
                        }

                        // 🔥【新增】导入论坛数据
                        if (data.forums?.length) {
                            try {
                                await db.forums.clear();
                                const forums = data.forums.map(f => ({
                                    ...f,
                                    id: f.id || Date.now() + Math.floor(Math.random() * 1000)
                                }));
                                await db.forums.bulkPut(forums);
                                success++;
                            } catch (e) {
                                errors.push(`论坛: ${e.message}`);
                            }
                        }

                        if (data.forumPosts?.length) {
                            try {
                                await db.forumPosts.clear();
                                const posts = data.forumPosts.map(p => ({
                                    ...p,
                                    id: p.id || Date.now() + Math.floor(Math.random() * 1000)
                                }));
                                await db.forumPosts.bulkPut(posts);
                                success++;
                            } catch (e) {
                                errors.push(`论坛帖子: ${e.message}`);
                            }
                        }

                        if (data.forumReplies?.length) {
                            try {
                                await db.forumReplies.clear();
                                const replies = data.forumReplies.map(r => ({
                                    ...r,
                                    id: r.id || Date.now() + Math.floor(Math.random() * 1000)
                                }));
                                await db.forumReplies.bulkPut(replies);
                                success++;
                            } catch (e) {
                                errors.push(`论坛回复: ${e.message}`);
                            }
                        }

                        if (data.forumFavorites?.length) {
                            try {
                                await db.forumFavorites.clear();
                                const favorites = data.forumFavorites.map(f => ({
                                    ...f,
                                    id: f.id || Date.now() + Math.floor(Math.random() * 1000)
                                }));
                                await db.forumFavorites.bulkPut(favorites);
                                success++;
                            } catch (e) {
                                errors.push(`论坛收藏: ${e.message}`);
                            }
                        }

                        // 🔥【新增】导入群聊数据
                        if (data.groupChats?.length) {
                            try {
                                await db.groupChats.clear();
                                const validGroups = data.groupChats.map(chat => ({
                                    ...chat,
                                    id: chat.id || `chat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.groupChats.bulkPut(validGroups);
                                success++;
                                console.log(`✅ 修复脚本：成功导入 ${validGroups.length} 个群聊`);
                            } catch (e) {
                                console.error('❌ 修复脚本：群聊导入失败:', e);
                                errors.push(`群聊: ${e.message}`);
                            }
                        }

                        // 🔥【新增】导入世界书数据
                        if (data.worldbooks?.length) {
                            try {
                                await db.worldbooks.clear();
                                const worldbooks = data.worldbooks.map(w => ({
                                    ...w,
                                    id: w.id || `wb_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.worldbooks.bulkPut(worldbooks);
                                success++;
                            } catch (e) {
                                errors.push(`世界书: ${e.message}`);
                            }
                        }

                        if (data.worldbookEntries?.length) {
                            try {
                                await db.worldbookEntries.clear();
                                const entries = data.worldbookEntries.map(e => ({
                                    ...e,
                                    id: e.id || `entry_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.worldbookEntries.bulkPut(entries);
                                success++;
                            } catch (e) {
                                errors.push(`世界书条目: ${e.message}`);
                            }
                        }

                        // 🔥【完整】导入记忆系统数据
                        if (data.workingMemory?.length) {
                            try {
                                await db.workingMemory.clear();
                                const memories = data.workingMemory.map(m => ({
                                    ...m,
                                    id: m.id || `work_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.workingMemory.bulkPut(memories);
                                success++;
                            } catch (e) {
                                errors.push(`工作记忆: ${e.message}`);
                            }
                        }

                        if (data.memorySummaries?.length) {
                            try {
                                await db.memorySummaries.clear();
                                const summaries = data.memorySummaries.map(s => ({
                                    ...s,
                                    id: s.id || `summary_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.memorySummaries.bulkPut(summaries);
                                success++;
                            } catch (e) {
                                errors.push(`记忆总结: ${e.message}`);
                            }
                        }

                        if (data.memoryEvents?.length) {
                            try {
                                await db.memoryEvents.clear();
                                const events = data.memoryEvents.map(e => ({
                                    ...e,
                                    id: e.id || `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.memoryEvents.bulkPut(events);
                                success++;
                            } catch (e) {
                                errors.push(`记忆事件: ${e.message}`);
                            }
                        }

                        // 🔥【完整】导入表情包和界面系统
                        if (data.recentEmojis?.length) {
                            try {
                                await db.recentEmojis.clear();
                                const emojis = data.recentEmojis.map(e => ({
                                    ...e,
                                    id: e.id || `recent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.recentEmojis.bulkPut(emojis);
                                success++;
                            } catch (e) {
                                errors.push(`最近表情: ${e.message}`);
                            }
                        }

                        if (data.wallpapers?.length) {
                            try {
                                await db.wallpapers.clear();
                                const wallpapers = data.wallpapers.map(w => ({
                                    ...w,
                                    id: w.id || `wp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.wallpapers.bulkPut(wallpapers);
                                success++;
                            } catch (e) {
                                errors.push(`壁纸: ${e.message}`);
                            }
                        }

                        if (data.appIcons?.length) {
                            try {
                                await db.appIcons.clear();
                                const icons = data.appIcons.map(i => ({
                                    ...i,
                                    id: i.id || `icon_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.appIcons.bulkPut(icons);
                                success++;
                            } catch (e) {
                                errors.push(`应用图标: ${e.message}`);
                            }
                        }

                        // 🔥【完整】导入角色和设置系统
                        if (data.characterGroups?.length) {
                            try {
                                await db.characterGroups.clear();
                                const groups = data.characterGroups.map(g => ({
                                    ...g,
                                    id: g.id || `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.characterGroups.bulkPut(groups);
                                success++;
                            } catch (e) {
                                errors.push(`角色分组: ${e.message}`);
                            }
                        }

                        if (data.personas?.length) {
                            try {
                                await db.personas.clear();
                                const personas = data.personas.map(p => ({
                                    ...p,
                                    id: p.id || `persona_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.personas.bulkPut(personas);
                                success++;
                            } catch (e) {
                                errors.push(`用户面具: ${e.message}`);
                            }
                        }

                        if (data.apiSettings?.length) {
                            try {
                                await db.apiSettings.clear();
                                const settings = data.apiSettings.map(s => ({
                                    ...s,
                                    id: s.id || `api_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.apiSettings.bulkPut(settings);
                                success++;
                            } catch (e) {
                                errors.push(`API设置: ${e.message}`);
                            }
                        }

                        if (data.globalSettings?.length) {
                            try {
                                await db.globalSettings.clear();
                                const settings = data.globalSettings.map(s => ({
                                    ...s,
                                    id: s.id || `global_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.globalSettings.bulkPut(settings);
                                success++;
                            } catch (e) {
                                errors.push(`全局设置: ${e.message}`);
                            }
                        }

                        // 🔥【完整】导入动态系统
                        if (data.momentLikes?.length) {
                            try {
                                await db.momentLikes.clear();
                                const likes = data.momentLikes.map(l => ({
                                    ...l,
                                    id: l.id || `like_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.momentLikes.bulkPut(likes);
                                success++;
                            } catch (e) {
                                errors.push(`动态点赞: ${e.message}`);
                            }
                        }

                        // 🔥【完整】导入论坛扩展数据
                        if (data.forumPostImages?.length) {
                            try {
                                await db.forumPostImages.clear();
                                const images = data.forumPostImages.map(i => ({
                                    ...i,
                                    id: i.id || `img_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.forumPostImages.bulkPut(images);
                                success++;
                            } catch (e) {
                                errors.push(`论坛图片: ${e.message}`);
                            }
                        }

                        if (data.forumMountedWorldbooks?.length) {
                            try {
                                await db.forumMountedWorldbooks.clear();
                                const mounted = data.forumMountedWorldbooks.map(m => ({
                                    ...m,
                                    id: m.id || `mounted_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.forumMountedWorldbooks.bulkPut(mounted);
                                success++;
                            } catch (e) {
                                errors.push(`论坛世界书: ${e.message}`);
                            }
                        }

                        // 🔥【完整】导入其他重要系统
                        if (data.anniversaries?.length) {
                            try {
                                await db.anniversaries.clear();
                                const anniversaries = data.anniversaries.map(a => ({
                                    ...a,
                                    id: a.id || `anni_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.anniversaries.bulkPut(anniversaries);
                                success++;
                            } catch (e) {
                                errors.push(`纪念日: ${e.message}`);
                            }
                        }

                        if (data.diarySettings?.length) {
                            try {
                                await db.diarySettings.clear();
                                const settings = data.diarySettings.map(s => ({
                                    ...s,
                                    id: s.id || `diary_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.diarySettings.bulkPut(settings);
                                success++;
                            } catch (e) {
                                errors.push(`日记设置: ${e.message}`);
                            }
                        }

                        if (data.innerThoughts?.length) {
                            try {
                                await db.innerThoughts.clear();
                                const thoughts = data.innerThoughts.map(t => ({
                                    ...t,
                                    id: t.id || `thought_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.innerThoughts.bulkPut(thoughts);
                                success++;
                            } catch (e) {
                                errors.push(`心声: ${e.message}`);
                            }
                        }

                        if (data.blacklist?.length) {
                            try {
                                await db.blacklist.clear();
                                const blacklist = data.blacklist.map(b => ({
                                    ...b,
                                    id: b.id || `black_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.blacklist.bulkPut(blacklist);
                                success++;
                            } catch (e) {
                                errors.push(`拉黑列表: ${e.message}`);
                            }
                        }

                        if (data.blockedCharacters?.length) {
                            try {
                                await db.blockedCharacters.clear();
                                const blocked = data.blockedCharacters.map(b => ({
                                    ...b,
                                    id: b.id || `blocked_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.blockedCharacters.bulkPut(blocked);
                                success++;
                            } catch (e) {
                                errors.push(`被拉黑角色: ${e.message}`);
                            }
                        }

                        if (data.friendRequests?.length) {
                            try {
                                await db.friendRequests.clear();
                                const requests = data.friendRequests.map(r => ({
                                    ...r,
                                    id: r.id || `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.friendRequests.bulkPut(requests);
                                success++;
                            } catch (e) {
                                errors.push(`好友申请: ${e.message}`);
                            }
                        }

                        if (data.characterStatus?.length) {
                            try {
                                await db.characterStatus.clear();
                                const status = data.characterStatus.map(s => ({
                                    ...s,
                                    id: s.id || `status_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.characterStatus.bulkPut(status);
                                success++;
                            } catch (e) {
                                errors.push(`角色状态: ${e.message}`);
                            }
                        }

                        // 🔥【完整】导入线下模式和音乐系统
                        if (data.offlineHistoryRecords?.length) {
                            try {
                                await db.offlineHistoryRecords.clear();
                                const records = data.offlineHistoryRecords.map(r => ({
                                    ...r,
                                    id: r.id || `offline_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.offlineHistoryRecords.bulkPut(records);
                                success++;
                            } catch (e) {
                                errors.push(`线下记录: ${e.message}`);
                            }
                        }

                        if (data.offlineUISettings?.length) {
                            try {
                                await db.offlineUISettings.clear();
                                const settings = data.offlineUISettings.map(s => ({
                                    ...s,
                                    id: s.id || `offui_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.offlineUISettings.bulkPut(settings);
                                success++;
                            } catch (e) {
                                errors.push(`线下界面设置: ${e.message}`);
                            }
                        }

                        if (data.offlinePresets?.length) {
                            try {
                                await db.offlinePresets.clear();
                                const presets = data.offlinePresets.map(p => ({
                                    ...p,
                                    id: p.id || `preset_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.offlinePresets.bulkPut(presets);
                                success++;
                            } catch (e) {
                                errors.push(`线下预设: ${e.message}`);
                            }
                        }

                        if (data.musicPlaylist?.length) {
                            try {
                                await db.musicPlaylist.clear();
                                const playlist = data.musicPlaylist.map(m => ({
                                    ...m,
                                    id: m.id || `music_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.musicPlaylist.bulkPut(playlist);
                                success++;
                            } catch (e) {
                                errors.push(`音乐: ${e.message}`);
                            }
                        }

                        if (data.musicCovers?.length) {
                            try {
                                await db.musicCovers.clear();
                                const covers = data.musicCovers.map(c => ({
                                    ...c,
                                    id: c.id || `cover_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.musicCovers.bulkPut(covers);
                                success++;
                            } catch (e) {
                                errors.push(`音乐封面: ${e.message}`);
                            }
                        }

                        // 🔥【完整】导入短信应用数据
                        if (data.smsContacts?.length) {
                            try {
                                await db.smsContacts.clear();
                                const contacts = data.smsContacts.map(c => ({
                                    ...c,
                                    id: c.id || `sms_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.smsContacts.bulkPut(contacts);
                                success++;
                            } catch (e) {
                                errors.push(`短信联系人: ${e.message}`);
                            }
                        }

                        if (data.smsMessages?.length) {
                            try {
                                await db.smsMessages.clear();
                                const messages = data.smsMessages.map(m => ({
                                    ...m,
                                    id: m.id || `smsg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.smsMessages.bulkPut(messages);
                                success++;
                            } catch (e) {
                                errors.push(`短信消息: ${e.message}`);
                            }
                        }

                        // 重新加载
                        await loadCharacters();
                        await loadChatMessages();
                        await loadChatSettings();
                        await loadGroupChats(); // 🔥【新增】重新加载群聊数据
                        await loadWorldbooks();
                        renderCharacterList();
                        renderMessageList();

                        // 🔥【新增】重新加载论坛和世界书界面
                        try {
                            await renderForumArchives();
                            renderWorldbookList();
                        } catch (error) {
                            console.error('⚠️ 论坛或世界书界面重新加载失败:', error);
                        }

                        const result = success > 0
                            ? `🎉 导入成功 ${success} 项${errors.length ? `\n⚠️ ${errors.length} 项失败` : ''}`
                            : `❌ 导入失败\n${errors.join('\n')}`;
                        showToast(result, success > 0 ? 'success' : 'error');

                    } catch (error) {
                        showToast(`❌ 导入失败: ${error.message}`, 'error');
                        if (error.message.includes('JSON')) {
                            setTimeout(() => alert('文件格式错误！请确保是从"导出所有数据"生成的备份文件'), 1000);
                        }
                    }
                };
                input.click();
            };
        })();

        // 修复引用消息问题
        (function fixReplyIssues() {
            const originalGenerate = window.generateReplyHTML;
            window.generateReplyHTML = function(replyTo) {
                if (!replyTo) return '';

                let safe = {
                    id: replyTo.id || 'unknown',
                    senderName: replyTo.senderName || '未知',
                    content: replyTo.content || '[已删除]'
                };

                // 尝试恢复引用内容
                if (replyTo.id !== 'unknown' && currentChatCharacter) {
                    const msgs = chatMessages[currentChatCharacter.id] || [];
                    const original = msgs.find(m => m.id === replyTo.id);

                    if (original) {
                        // 🔥【统一格式】正确处理数组格式的消息内容
                        if (Array.isArray(original.content)) {
                            const textPart = original.content.find(p => p.type === 'text');
                            const imagePart = original.content.find(p => p.type === 'image_url');

                            if (textPart?.text) {
                                safe.content = textPart.text;
                            } else if (imagePart) {
                                safe.content = '[图片]';
                            } else {
                                safe.content = '[多媒体消息]';
                            }
                        } else {
                            // 🔥【兼容性】处理旧格式消息
                            safe.content = original.content || '[图片]';
                        }

                        safe.senderName = getSenderDisplayName(original);
                    }
                }

                const display = truncateText(safe.content, 20);

                return `
                    <div class="reply-reference" data-reply-id="${safe.id}">
                        <div class="reply-reference-line"></div>
                        <div class="reply-reference-content">
                            <div class="reply-reference-sender">${safe.senderName}</div>
                            <div class="reply-reference-message">${display}</div>
                        </div>
                    </div>
                `;
            };
        })();


        // 🔥【移除】自动清理函数已移至数据库版本7的升级逻辑中

        // 🔥【新增】数据库状态诊断函数
        async function diagnoseDatabaseIssue() {
            try {
                console.log('🔍 开始数据库状态诊断...');

                // 检查数据库是否存在
                if (!db) {
                    console.error('❌ 数据库对象不存在');
                    return;
                }

                // 检查表是否存在
                const tables = ['crossAppTimeline', 'memoryEvents', 'characterStatus'];
                for (const tableName of tables) {
                    if (db[tableName]) {
                        console.log(`✅ 表 ${tableName} 存在`);

                        // 尝试查询表结构
                        try {
                            const count = await db[tableName].count();
                            console.log(`📊 表 ${tableName} 记录数: ${count}`);
                        } catch (error) {
                            console.error(`❌ 查询表 ${tableName} 失败:`, error);
                        }
                    } else {
                        console.error(`❌ 表 ${tableName} 不存在`);
                    }
                }

                // 测试添加一条记录
                const testEvent = {
                    id: `test_${Date.now()}`,
                    characterId: 'test_character',
                    appType: 'test',
                    action: 'test_action',
                    timestamp: Date.now(),
                    context: { test: true },
                    messageId: null
                };

                try {
                    await db.crossAppTimeline.add(testEvent);
                    console.log('✅ 测试记录添加成功');

                    // 删除测试记录
                    await db.crossAppTimeline.delete(testEvent.id);
                    console.log('✅ 测试记录删除成功');
                } catch (error) {
                    console.error('❌ 测试记录添加失败:', error);
                }

            } catch (error) {
                console.error('❌ 数据库诊断失败:', error);
            }
        }

        // 延迟执行诊断
        setTimeout(() => {
            diagnoseDatabaseIssue();
        }, 5000);

        // 🔥【新增】紧急数据恢复功能
        async function emergencyDataRecovery() {
            console.log('=== 紧急数据恢复开始 ===');

            try {
                // 1. 检查IndexedDB中的数据
                const dbCharacters = await db.characters.toArray();
                const dbChatMessages = await db.chatMessages.toArray();
                const dbContacts = await db.contacts.toArray();

                console.log('IndexedDB角色数据:', dbCharacters);
                console.log('IndexedDB聊天记录:', dbChatMessages);
                console.log('IndexedDB联系人:', dbContacts);

                // 2. 检查localStorage备份
                const localCharacters = localStorage.getItem('characters');
                const localChatMessages = localStorage.getItem('chatMessages');
                const localContacts = localStorage.getItem('contacts');

                console.log('localStorage角色备份:', localCharacters ? JSON.parse(localCharacters) : null);
                console.log('localStorage聊天备份:', localChatMessages ? JSON.parse(localChatMessages) : null);
                console.log('localStorage联系人备份:', localContacts ? JSON.parse(localContacts) : null);

                return {
                    indexedDB: { characters: dbCharacters, chatMessages: dbChatMessages, contacts: dbContacts },
                    localStorage: {
                        characters: localCharacters ? JSON.parse(localCharacters) : null,
                        chatMessages: localChatMessages ? JSON.parse(localChatMessages) : null,
                        contacts: localContacts ? JSON.parse(localContacts) : null
                    }
                };

            } catch (error) {
                console.error('数据恢复检查失败:', error);
                return null;
            }
        }

        // 🔥【新增】从导出数据恢复角色
        async function recoverFromExportData(exportData) {
            try {
                console.log('开始从导出数据恢复...');

                if (exportData.characters && exportData.characters.length > 0) {
                    // 过滤掉张三李四
                    const validCharacters = exportData.characters.filter(char =>
                        char.name !== '张三' && char.name !== '李四'
                    );

                    console.log('有效角色数据:', validCharacters);

                    // 🔥【安全修复】恢复角色数据
                    await safeDataSave('characters', validCharacters);
                    characters = validCharacters;

                    // 恢复联系人列表
                    const validContactIds = validCharacters.map(char => char.id);
                    contacts = validContactIds;
                    await saveContacts();

                    console.log('角色数据恢复完成');
                }

                if (exportData.chatMessages) {
                    // 恢复聊天记录
                    await db.chatMessages.clear();
                    for (const [characterId, messages] of Object.entries(exportData.chatMessages)) {
                        if (messages && messages.length > 0) {
                            for (const message of messages) {
                                await db.chatMessages.add({
                                    characterId: characterId,
                                    ...message
                                });
                            }
                        }
                    }
                    chatMessages = exportData.chatMessages;
                    console.log('聊天记录恢复完成');
                }

                // 刷新界面
                renderCharacterList();
                renderContactList();
                renderMessageList();

                showToast('数据恢复成功！', 'success');
                return true;

            } catch (error) {
                console.error('数据恢复失败:', error);
                showToast('数据恢复失败: ' + error.message, 'error');
                return false;
            }
        }

        // 🚨【紧急恢复功能】
        function addRecoveryLog(message) {
            const logDiv = document.getElementById('recovery-log');
            const logContent = document.getElementById('recovery-log-content');

            if (logDiv && logContent) {
                logDiv.style.display = 'block';
                const timestamp = new Date().toLocaleTimeString();
                logContent.innerHTML += `[${timestamp}] ${message}\n`;
                logContent.scrollTop = logContent.scrollHeight;
            }
        }

        async function checkDataStatus() {
            addRecoveryLog('开始检查数据状态...');

            try {
                // 检查IndexedDB数据
                const dbCharacters = await db.characters.toArray();
                const dbChatMessages = await db.chatMessages.toArray();
                const dbContacts = await db.contacts.toArray();

                // 检查localStorage备份
                const localCharacters = localStorage.getItem('characters');
                const localChatMessages = localStorage.getItem('chatMessages');
                const localContacts = localStorage.getItem('contacts');

                const statusText = `
=== 数据状态检查结果 ===

📊 IndexedDB 数据：
- 角色数量: ${dbCharacters.length}
- 聊天记录: ${dbChatMessages.length} 条
- 联系人: ${dbContacts.length} 个

📦 localStorage 备份：
- 角色备份: ${localCharacters ? JSON.parse(localCharacters).length : 0} 个
- 聊天备份: ${localChatMessages ? Object.keys(JSON.parse(localChatMessages)).length : 0} 个对话
- 联系人备份: ${localContacts ? JSON.parse(localContacts).length : 0} 个

🔍 当前内存状态：
- 角色列表: ${characters.length} 个
- 联系人列表: ${contacts.length} 个
- 聊天记录: ${Object.keys(chatMessages).length} 个对话

⚠️ 异常角色检测：
${dbCharacters.filter(c => c.name === '张三' || c.name === '李四').map(c => `- ${c.name} (ID: ${c.id})`).join('\n') || '未发现异常角色'}
                `;

                document.getElementById('data-status-result').style.display = 'block';
                document.getElementById('data-status-text').textContent = statusText;

                addRecoveryLog('数据状态检查完成');

            } catch (error) {
                addRecoveryLog('数据检查失败: ' + error.message);
            }
        }

        // 🔍 深度数据搜索
        async function deepDataSearch() {
            addRecoveryLog('开始深度搜索残留数据...');

            try {
                const foundData = [];

                // 1. 搜索所有localStorage键
                addRecoveryLog('搜索localStorage...');
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && (key.includes('character') || key.includes('chat'))) {
                        const value = localStorage.getItem(key);
                        if (value && value.length > 100) { // 只关注较大的数据
                            foundData.push(`localStorage[${key}]: ${value.length} 字符`);

                            // 🔥【重要】检查紧急备份
                            if (key === 'chatSettings_emergency_backup') {
                                foundData.push(`  ⚠️ 发现全局紧急备份！这可能包含重要的聊天设置数据`);
                                foundData.push(`  📋 点击下方"恢复紧急备份"按钮来尝试恢复`);
                            } else if (key.startsWith('chatSettings_emergency_')) {
                                const chatId = key.replace('chatSettings_emergency_', '');
                                foundData.push(`  ⚠️ 发现聊天${chatId}的紧急备份！`);
                                foundData.push(`  📋 点击下方"恢复紧急备份"按钮来尝试恢复`);
                            }
                        }
                    }
                }

                // 2. 搜索IndexedDB中的所有表
                addRecoveryLog('搜索IndexedDB所有表...');
                const allTables = ['characters', 'chatMessages', 'contacts', 'chatSettings', 'customEmojis', 'worldbooks', 'moments', 'personas', 'groupChats'];

                for (const tableName of allTables) {
                    try {
                        const data = await db[tableName].toArray();
                        if (data.length > 0) {
                            foundData.push(`IndexedDB[${tableName}]: ${data.length} 条记录`);

                            // 特别检查角色相关数据
                            if (tableName === 'characters') {
                                data.forEach(char => {
                                    if (char.name !== '张三' && char.name !== '李四') {
                                        foundData.push(`  发现角色: ${char.name} (ID: ${char.id})`);
                                    }
                                });
                            }
                        }
                    } catch (e) {
                        // 表不存在或无法访问
                    }
                }

                // 3. 检查聊天记录中的角色信息
                addRecoveryLog('分析聊天记录...');
                const chatData = await db.chatMessages.toArray();
                const characterIds = new Set();
                chatData.forEach(msg => {
                    if (msg.characterId && msg.characterId !== 'user') {
                        characterIds.add(msg.characterId);
                    }
                });

                if (characterIds.size > 0) {
                    foundData.push(`聊天记录中发现 ${characterIds.size} 个角色ID:`);
                    characterIds.forEach(id => {
                        foundData.push(`  角色ID: ${id}`);
                    });
                }

                const resultText = foundData.length > 0 ? foundData.join('\n') : '未发现额外的角色数据';

                document.getElementById('deep-search-result').style.display = 'block';
                document.getElementById('deep-search-text').textContent = resultText;

                // 🔥【新增】如果发现任何紧急备份，显示恢复按钮
                const hasGlobalBackup = localStorage.getItem('chatSettings_emergency_backup');
                const hasIndividualBackups = Object.keys(localStorage).some(key => key.startsWith('chatSettings_emergency_'));

                if (hasGlobalBackup || hasIndividualBackups) {
                    const emergencyButton = document.createElement('button');
                    emergencyButton.textContent = '🆘 恢复紧急备份数据';
                    emergencyButton.style.cssText = `
                        width: 100%;
                        padding: 12px 20px;
                        background: #ff6b6b;
                        color: white;
                        border: none;
                        border-radius: 8px;
                        font-size: 14px;
                        font-weight: 600;
                        cursor: pointer;
                        margin-top: 10px;
                        transition: all 0.3s ease;
                    `;
                    emergencyButton.onclick = () => restoreEmergencyBackup();

                    const resultDiv = document.getElementById('deep-search-result');
                    // 清除之前的按钮
                    const existingButton = resultDiv.querySelector('button');
                    if (existingButton) existingButton.remove();
                    resultDiv.appendChild(emergencyButton);
                }

                addRecoveryLog(`深度搜索完成，发现 ${foundData.length} 条线索`);

            } catch (error) {
                addRecoveryLog('深度搜索失败: ' + error.message);
            }
        }

        // 🆘 恢复紧急备份数据
        async function restoreEmergencyBackup() {
            addRecoveryLog('开始恢复紧急备份数据...');

            try {
                let backupData = {};
                let totalBackups = 0;

                // 1. 检查全局紧急备份
                const globalBackup = localStorage.getItem('chatSettings_emergency_backup');
                if (globalBackup) {
                    try {
                        const globalData = JSON.parse(globalBackup);
                        Object.assign(backupData, globalData);
                        totalBackups++;
                        addRecoveryLog(`✅ 发现全局紧急备份，包含 ${Object.keys(globalData).length} 个聊天设置`);
                    } catch (parseError) {
                        addRecoveryLog('⚠️ 全局紧急备份数据格式错误: ' + parseError.message);
                    }
                }

                // 2. 检查单个聊天的紧急备份
                Object.keys(localStorage).forEach(key => {
                    if (key.startsWith('chatSettings_emergency_')) {
                        const chatId = key.replace('chatSettings_emergency_', '');
                        try {
                            const chatBackup = JSON.parse(localStorage.getItem(key));
                            backupData[chatId] = chatBackup;
                            totalBackups++;
                            addRecoveryLog(`✅ 发现聊天${chatId}的紧急备份`);
                        } catch (parseError) {
                            addRecoveryLog(`⚠️ 聊天${chatId}的紧急备份数据格式错误: ${parseError.message}`);
                        }
                    }
                });

                // 3. 检查是否找到任何备份
                if (Object.keys(backupData).length === 0) {
                    addRecoveryLog('❌ 未找到有效的紧急备份数据');
                    showToast('未找到有效的紧急备份数据', 'error');
                    return;
                }

                addRecoveryLog(`📦 总共发现 ${totalBackups} 个紧急备份，包含 ${Object.keys(backupData).length} 个聊天设置`);

                // 4. 恢复聊天设置到全局变量
                let restoredCount = 0;
                Object.keys(backupData).forEach(chatId => {
                    if (backupData[chatId] && typeof backupData[chatId] === 'object') {
                        // 确保chatSettings对象存在
                        if (!chatSettings) {
                            chatSettings = {};
                        }

                        // 恢复设置
                        chatSettings[chatId] = {
                            ...chatSettings[chatId], // 保留现有设置
                            ...backupData[chatId]    // 覆盖备份的设置
                        };
                        restoredCount++;
                        addRecoveryLog(`  ✅ 恢复聊天设置: ${chatId}`);
                    }
                });

                // 5. 保存到IndexedDB
                try {
                    await saveChatSettings();
                    addRecoveryLog(`✅ 成功恢复 ${restoredCount} 个聊天设置到数据库`);
                    showToast(`成功恢复 ${restoredCount} 个聊天设置`, 'success');
                } catch (saveError) {
                    addRecoveryLog('⚠️ 保存到数据库失败，但设置已恢复到内存: ' + saveError.message);
                    showToast('设置已恢复到内存，但保存失败', 'warning');
                }

                // 6. 显示恢复的数据详情
                const detailsText = Object.keys(backupData).map(chatId => {
                    const settings = backupData[chatId];
                    const details = [];
                    if (settings.bubbleStyle) details.push(`气泡样式: ${settings.bubbleStyle}`);
                    if (settings.aiChatAvatar) details.push(`AI头像: 已设置`);
                    if (settings.myChatAvatar) details.push(`用户头像: 已设置`);
                    if (settings.backgroundImage) details.push(`背景图: 已设置`);
                    if (settings.fontSize) details.push(`字体大小: ${settings.fontSize}`);

                    return `聊天ID: ${chatId}\n  - ${details.join('\n  - ')}`;
                }).join('\n\n');

                document.getElementById('deep-search-text').textContent =
                    `🆘 紧急备份恢复完成！\n\n从 ${totalBackups} 个备份源恢复了 ${restoredCount} 个聊天设置\n\n恢复的设置详情：\n\n${detailsText}\n\n💡 建议：刷新页面以确保所有设置生效`;

                addRecoveryLog('🎉 紧急备份恢复完成！');

            } catch (error) {
                addRecoveryLog('❌ 恢复紧急备份失败: ' + error.message);
                showToast('恢复紧急备份失败', 'error');
                console.error('恢复紧急备份失败:', error);
            }
        }

        // 💬 从聊天记录推断角色
        async function searchChatHistory() {
            addRecoveryLog('开始分析聊天记录...');

            try {
                const chatData = await db.chatMessages.toArray();
                const characterInfo = new Map();

                // 分析聊天记录，尝试重建角色信息
                chatData.forEach(msg => {
                    if (msg.characterId && msg.characterId !== 'user') {
                        if (!characterInfo.has(msg.characterId)) {
                            characterInfo.set(msg.characterId, {
                                id: msg.characterId,
                                messageCount: 0,
                                lastMessage: null,
                                firstMessage: null
                            });
                        }

                        const info = characterInfo.get(msg.characterId);
                        info.messageCount++;

                        if (!info.firstMessage || msg.timestamp < info.firstMessage.timestamp) {
                            info.firstMessage = msg;
                        }

                        if (!info.lastMessage || msg.timestamp > info.lastMessage.timestamp) {
                            info.lastMessage = msg;
                        }
                    }
                });

                let resultText = '=== 聊天记录分析结果 ===\n\n';

                if (characterInfo.size === 0) {
                    resultText += '未发现任何角色的聊天记录';
                } else {
                    resultText += `发现 ${characterInfo.size} 个角色的聊天记录:\n\n`;

                    characterInfo.forEach((info, characterId) => {
                        resultText += `角色ID: ${characterId}\n`;
                        resultText += `消息数量: ${info.messageCount} 条\n`;
                        resultText += `最早消息: ${new Date(info.firstMessage.timestamp).toLocaleString()}\n`;
                        resultText += `最新消息: ${new Date(info.lastMessage.timestamp).toLocaleString()}\n`;
                        resultText += `最新内容: ${info.lastMessage.content?.substring(0, 50)}...\n\n`;
                    });

                    resultText += '\n💡 建议: 如果这些ID对应您丢失的角色，可以尝试手动重建角色卡';
                }

                document.getElementById('deep-search-result').style.display = 'block';
                document.getElementById('deep-search-text').textContent = resultText;

                addRecoveryLog('聊天记录分析完成');

            } catch (error) {
                addRecoveryLog('聊天记录分析失败: ' + error.message);
            }
        }

        // 🔧 从聊天记录重建角色
        async function rebuildCharactersFromChat() {
            addRecoveryLog('开始从聊天记录重建角色...');

            try {
                const chatData = await db.chatMessages.toArray();
                const characterInfo = new Map();

                // 分析聊天记录
                chatData.forEach(msg => {
                    if (msg.characterId && msg.characterId !== 'user') {
                        if (!characterInfo.has(msg.characterId)) {
                            characterInfo.set(msg.characterId, {
                                id: msg.characterId,
                                messages: [],
                                firstMessage: null,
                                lastMessage: null
                            });
                        }

                        const info = characterInfo.get(msg.characterId);
                        info.messages.push(msg);

                        if (!info.firstMessage || msg.timestamp < info.firstMessage.timestamp) {
                            info.firstMessage = msg;
                        }

                        if (!info.lastMessage || msg.timestamp > info.lastMessage.timestamp) {
                            info.lastMessage = msg;
                        }
                    }
                });

                addRecoveryLog(`发现 ${characterInfo.size} 个角色的聊天记录`);

                // 重建角色卡
                const rebuiltCharacters = [];
                let rebuiltCount = 0;

                for (const [characterId, info] of characterInfo) {
                    // 跳过张三李四
                    if (characterId === '张三' || characterId === '李四') continue;

                    // 尝试从聊天内容推断角色名字
                    let characterName = `角色_${characterId.slice(-4)}`;

                    // 查找可能的角色名字（从用户消息和角色消息中寻找）
                    const allMessages = info.messages.slice(0, 20); // 检查前20条消息

                    // 方法1: 从用户消息中寻找称呼
                    const userMessages = allMessages.filter(msg => msg.sender === 'sent');
                    for (const msg of userMessages) {
                        const content = msg.content || '';
                        // 寻找常见的称呼模式
                        const patterns = [
                            /(?:你好|嗨|hi|hello)[，,\s]*([^\s，,。！？]{1,8})/i,
                            /([^\s，,。！？]{1,8})[，,\s]*(?:你好|在吗|在不在)/i,
                            /^([^\s，,。！？]{1,8})[，,\s]/,
                            /叫你([^\s，,。！？]{1,8})/i
                        ];

                        for (const pattern of patterns) {
                            const nameMatch = content.match(pattern);
                            if (nameMatch && nameMatch[1] && nameMatch[1].length <= 8 && nameMatch[1].length >= 2) {
                                characterName = nameMatch[1];
                                break;
                            }
                        }
                        if (characterName !== `角色_${characterId.slice(-4)}`) break;
                    }

                    // 方法2: 从角色的自我介绍中寻找
                    if (characterName === `角色_${characterId.slice(-4)}`) {
                        const characterMessages = allMessages.filter(msg => msg.sender === 'character');
                        for (const msg of characterMessages.slice(0, 5)) {
                            const content = msg.content || '';
                            const patterns = [
                                /我是([^\s，,。！？]{1,8})/i,
                                /我叫([^\s，,。！？]{1,8})/i,
                                /叫我([^\s，,。！？]{1,8})/i,
                                /^([^\s，,。！？]{1,8})(?:在这里|来了|回来了)/i
                            ];

                            for (const pattern of patterns) {
                                const nameMatch = content.match(pattern);
                                if (nameMatch && nameMatch[1] && nameMatch[1].length <= 8 && nameMatch[1].length >= 2) {
                                    characterName = nameMatch[1];
                                    break;
                                }
                            }
                            if (characterName !== `角色_${characterId.slice(-4)}`) break;
                        }
                    }

                    // 创建基础角色卡
                    const character = {
                        id: characterId,
                        name: characterName,
                        description: `从聊天记录恢复的角色，共有 ${info.messages.length} 条对话记录`,
                        personality: '温和友善，善于交流',
                        scenario: '日常聊天场景',
                        firstMessage: info.firstMessage?.content || '你好！',
                        avatar: '',
                        createdAt: info.firstMessage?.timestamp || Date.now(),
                        updatedAt: info.lastMessage?.timestamp || Date.now(),
                        tags: ['恢复角色'],
                        isPublic: false,
                        messageCount: info.messages.length
                    };

                    rebuiltCharacters.push(character);
                    rebuiltCount++;

                    addRecoveryLog(`重建角色: ${characterName} (ID: ${characterId.slice(-6)}...)`);
                }

                if (rebuiltCharacters.length === 0) {
                    throw new Error('没有找到可重建的角色');
                }

                // 🔥【安全修复】清除现有的异常角色，添加重建的角色
                await safeDataSave('characters', rebuiltCharacters);
                characters = rebuiltCharacters;

                // 更新联系人列表
                contacts = rebuiltCharacters.map(char => char.id);
                await saveContacts();

                // 强制刷新所有相关数据
                await loadCharacters();
                await loadContacts();
                await loadChatMessages();

                // 刷新界面
                renderCharacterList();
                renderContactList();
                renderMessageList();

                // 如果当前在聊天界面，刷新聊天界面
                if (currentCharacterId) {
                    const character = characters.find(c => c.id === currentCharacterId);
                    if (character) {
                        renderChatHeader();
                    }
                }

                addRecoveryLog(`✅ 成功重建 ${rebuiltCount} 个角色！`);
                addRecoveryLog(`角色列表: ${rebuiltCharacters.map(c => c.name).join(', ')}`);
                alert(`角色重建完成！成功恢复 ${rebuiltCount} 个角色，聊天记录已保留。\n\n恢复的角色: ${rebuiltCharacters.map(c => c.name).join(', ')}`);

            } catch (error) {
                addRecoveryLog('❌ 角色重建失败: ' + error.message);
                alert('角色重建失败: ' + error.message);
            }
        }

        // ✏️ 显示手动重建界面
        async function showManualRebuild() {
            try {
                const chatData = await db.chatMessages.toArray();
                const characterInfo = new Map();

                // 分析聊天记录
                chatData.forEach(msg => {
                    if (msg.characterId && msg.characterId !== 'user' && msg.characterId !== '张三' && msg.characterId !== '李四') {
                        if (!characterInfo.has(msg.characterId)) {
                            characterInfo.set(msg.characterId, {
                                id: msg.characterId,
                                messageCount: 0,
                                lastMessage: null
                            });
                        }

                        const info = characterInfo.get(msg.characterId);
                        info.messageCount++;

                        if (!info.lastMessage || msg.timestamp > info.lastMessage.timestamp) {
                            info.lastMessage = msg;
                        }
                    }
                });

                if (characterInfo.size === 0) {
                    alert('没有发现可重建的角色');
                    return;
                }

                // 创建手动重建界面
                let html = '<div style="max-height: 400px; overflow-y: auto;">';
                html += '<h4>选择要重建的角色：</h4>';

                characterInfo.forEach((info, characterId) => {
                    const shortId = characterId.slice(-6);
                    const lastContent = info.lastMessage?.content?.substring(0, 30) || '';

                    html += `
                        <div style="border: 1px solid #ddd; border-radius: 8px; padding: 10px; margin-bottom: 10px;">
                            <div style="font-weight: bold;">角色ID: ${shortId}...</div>
                            <div style="font-size: 12px; color: #666;">消息数: ${info.messageCount} 条</div>
                            <div style="font-size: 12px; color: #666;">最新消息: ${lastContent}...</div>
                            <input type="text" id="name_${characterId}" placeholder="输入角色名字" style="width: 100%; margin: 5px 0; padding: 5px; border: 1px solid #ccc; border-radius: 4px;">
                            <label><input type="checkbox" id="rebuild_${characterId}" checked> 重建此角色</label>
                        </div>
                    `;
                });

                html += '</div>';
                html += '<button onclick="executeManualRebuild()" style="background: #32D74B; color: white; border: none; padding: 10px 20px; border-radius: 8px; width: 100%; margin-top: 10px;">确认重建选中的角色</button>';

                document.getElementById('deep-search-result').style.display = 'block';
                document.getElementById('deep-search-text').innerHTML = html;

                // 存储角色信息供后续使用
                window.manualRebuildInfo = characterInfo;

            } catch (error) {
                alert('获取角色信息失败: ' + error.message);
            }
        }

        // 🔍 调试当前状态
        async function debugCurrentState() {
            addRecoveryLog('开始检查当前数据状态...');

            try {
                // 检查内存中的数据
                addRecoveryLog(`内存中角色数量: ${characters.length}`);
                addRecoveryLog(`内存中联系人数量: ${contacts.length}`);

                if (characters.length > 0) {
                    addRecoveryLog('内存中的角色:');
                    characters.forEach(char => {
                        addRecoveryLog(`  - ${char.name} (ID: ${char.id.slice(-6)}...)`);
                    });
                }

                // 检查数据库中的数据
                const dbCharacters = await db.characters.toArray();
                const dbContacts = await db.contacts.toArray();
                const dbMessages = await db.chatMessages.toArray();

                addRecoveryLog(`数据库中角色数量: ${dbCharacters.length}`);
                addRecoveryLog(`数据库中联系人数量: ${dbContacts.length}`);
                addRecoveryLog(`数据库中消息数量: ${dbMessages.length}`);

                if (dbCharacters.length > 0) {
                    addRecoveryLog('数据库中的角色:');
                    dbCharacters.forEach(char => {
                        addRecoveryLog(`  - ${char.name} (ID: ${char.id.slice(-6)}...)`);
                    });
                }

                // 检查界面元素
                const characterListElement = document.getElementById('character-list');
                const contactListElement = document.getElementById('contact-list');

                addRecoveryLog(`角色列表元素存在: ${!!characterListElement}`);
                addRecoveryLog(`联系人列表元素存在: ${!!contactListElement}`);

                if (characterListElement) {
                    addRecoveryLog(`角色列表子元素数量: ${characterListElement.children.length}`);
                }

                if (contactListElement) {
                    addRecoveryLog(`联系人列表子元素数量: ${contactListElement.children.length}`);
                }

                // 检查当前页面状态
                addRecoveryLog(`当前页面: ${currentPage}`);
                addRecoveryLog(`当前角色ID: ${currentCharacterId || '无'}`);

                addRecoveryLog('状态检查完成');

            } catch (error) {
                addRecoveryLog('状态检查失败: ' + error.message);
            }
        }

        // 🔄 强制刷新所有界面
        async function forceRefreshAll() {
            addRecoveryLog('开始强制刷新所有界面...');

            try {
                // 重新加载所有数据
                await loadCharacters();
                await loadContacts();
                await loadChatMessages();

                addRecoveryLog(`重新加载后角色数量: ${characters.length}`);
                addRecoveryLog(`重新加载后联系人数量: ${contacts.length}`);

                // 强制刷新所有界面
                renderCharacterList();
                renderContactList();
                renderMessageList();

                // 如果在聊天页面，刷新聊天界面
                if (currentPage === 'chat' && currentCharacterId) {
                    const character = characters.find(c => c.id === currentCharacterId);
                    if (character) {
                        renderChatHeader();
                        renderChatMessages();
                    } else {
                        // 如果当前角色不存在，返回主页
                        hideApp('api-chat-screen');
                    }
                }

                // 如果在角色管理页面，刷新角色管理界面
                if (currentPage === 'characters') {
                    renderCharacterList();
                }

                addRecoveryLog('✅ 界面刷新完成');
                alert('界面刷新完成！请检查角色列表是否正常显示。');

            } catch (error) {
                addRecoveryLog('界面刷新失败: ' + error.message);
                alert('界面刷新失败: ' + error.message);
            }
        }

        // 执行手动重建
        async function executeManualRebuild() {
            try {
                const rebuiltCharacters = [];

                for (const [characterId, info] of window.manualRebuildInfo) {
                    const checkbox = document.getElementById(`rebuild_${characterId}`);
                    const nameInput = document.getElementById(`name_${characterId}`);

                    if (checkbox && checkbox.checked) {
                        const characterName = nameInput.value.trim() || `角色_${characterId.slice(-4)}`;

                        const character = {
                            id: characterId,
                            name: characterName,
                            description: `手动重建的角色，共有 ${info.messageCount} 条对话记录`,
                            personality: '请根据聊天记录调整性格设定',
                            scenario: '日常聊天场景',
                            firstMessage: info.lastMessage?.content || '你好！',
                            avatar: '',
                            createdAt: Date.now() - 86400000, // 1天前
                            updatedAt: Date.now(),
                            tags: ['手动恢复'],
                            isPublic: false,
                            messageCount: info.messageCount
                        };

                        rebuiltCharacters.push(character);
                    }
                }

                if (rebuiltCharacters.length === 0) {
                    alert('请至少选择一个角色进行重建');
                    return;
                }

                // 🔥【安全修复】清除现有角色，添加重建的角色
                await safeDataSave('characters', rebuiltCharacters);
                characters = rebuiltCharacters;

                // 更新联系人列表
                contacts = rebuiltCharacters.map(char => char.id);
                await saveContacts();

                // 刷新界面
                renderCharacterList();
                renderContactList();

                addRecoveryLog(`✅ 手动重建完成！恢复了 ${rebuiltCharacters.length} 个角色`);
                alert(`手动重建完成！成功恢复 ${rebuiltCharacters.length} 个角色。`);

                // 隐藏重建界面
                document.getElementById('deep-search-result').style.display = 'none';

            } catch (error) {
                alert('手动重建失败: ' + error.message);
            }
        }

        // 📁 从文件恢复
        async function recoverFromFile() {
            const fileInput = document.getElementById('recovery-file-input');
            const file = fileInput.files[0];

            if (!file) {
                alert('请先选择一个备份文件');
                return;
            }

            try {
                addRecoveryLog(`开始读取文件: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`);

                const text = await file.text();
                const exportData = JSON.parse(text);

                if (!exportData.characters || !Array.isArray(exportData.characters)) {
                    throw new Error('文件格式不正确，缺少角色信息');
                }

                addRecoveryLog(`文件中发现 ${exportData.characters.length} 个角色`);

                // 过滤掉张三李四
                const validCharacters = exportData.characters.filter(char =>
                    char.name !== '张三' && char.name !== '李四'
                );

                addRecoveryLog(`过滤后有效角色: ${validCharacters.length} 个`);

                if (validCharacters.length === 0) {
                    throw new Error('文件中没有找到有效的角色数据');
                }

                // 🔥【安全修复】恢复角色数据
                await safeDataSave('characters', validCharacters);
                characters = validCharacters;

                // 恢复联系人列表
                const validContactIds = validCharacters.map(char => char.id);
                contacts = validContactIds;
                await saveContacts();

                addRecoveryLog('角色数据恢复完成');

                // 恢复聊天记录
                if (exportData.chatMessages) {
                    await db.chatMessages.clear();
                    let messageCount = 0;

                    for (const [characterId, messages] of Object.entries(exportData.chatMessages)) {
                        if (messages && messages.length > 0) {
                            for (const message of messages) {
                                await db.chatMessages.add({
                                    characterId: characterId,
                                    ...message
                                });
                                messageCount++;
                            }
                        }
                    }
                    chatMessages = exportData.chatMessages;
                    addRecoveryLog(`聊天记录恢复完成: ${messageCount} 条消息`);
                }

                // 刷新界面
                renderCharacterList();
                renderContactList();
                renderMessageList();

                addRecoveryLog('✅ 文件恢复成功！');
                alert('数据恢复成功！您的角色和聊天记录已恢复。');

            } catch (error) {
                addRecoveryLog('❌ 文件恢复失败: ' + error.message);
                alert('文件恢复失败: ' + error.message);
            }
        }

        async function cleanupBadData() {
            try {
                addRecoveryLog('开始清理异常数据...');

                // 清除张三李四
                const deletedCount = await db.characters.where('name').anyOf(['张三', '李四']).delete();
                addRecoveryLog(`删除了 ${deletedCount} 个异常角色`);

                // 更新内存数据
                characters = characters.filter(char => char.name !== '张三' && char.name !== '李四');
                contacts = contacts.filter(id => {
                    const char = characters.find(c => c.id === id);
                    return char && char.name !== '张三' && char.name !== '李四';
                });

                await saveContacts();

                // 刷新界面
                renderCharacterList();
                renderContactList();
                renderMessageList();

                addRecoveryLog('✅ 异常数据清理完成');
                alert('异常数据清理完成');

            } catch (error) {
                addRecoveryLog('❌ 清理失败: ' + error.message);
                alert('清理失败: ' + error.message);
            }
        }

        async function forceReload() {
            try {
                addRecoveryLog('开始强制重新加载数据...');

                // 重新加载所有数据
                await loadCharacterGroups();
                await loadCharacters();
                await loadContacts();
                await loadChatMessages();
                await loadChatSettings();
                await loadPersonas();
                await loadGroupChats();

                // 刷新界面
                renderCharacterList();
                renderContactList();
                renderMessageList();

                addRecoveryLog('✅ 数据重新加载完成');
                alert('数据重新加载完成');

            } catch (error) {
                addRecoveryLog('❌ 重新加载失败: ' + error.message);
                alert('重新加载失败: ' + error.message);
            }
        }

        // 🔥【新增】线下剧情模式功能
        let isOfflineMode = false;
        let offlinePresets = [];
        let currentOfflinePreset = null;
        let offlineMessages = [];

        // 🔥【新增】窗口唯一标识符，确保不同窗口的线下模式数据完全隔离
        let windowId = null;

        // 初始化窗口ID
        function initializeWindowId() {
            // 尝试从sessionStorage获取现有的窗口ID
            windowId = sessionStorage.getItem('windowId');

            if (!windowId) {
                // 生成新的窗口ID
                windowId = `window_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                sessionStorage.setItem('windowId', windowId);
            }

            console.log('🪟 窗口ID已初始化:', windowId);

            // 🔥【修复】移除beforeunload监听器，以防止刷新时清除数据
            // window.addEventListener('beforeunload', cleanupWindowOfflineData);
        }

        // 🔥【修复】删除cleanupWindowOfflineData函数，以防止刷新时清除数据
        /*
        function cleanupWindowOfflineData() {
            if (!windowId) return;

            try {
                // 清理localStorage中的线下消息数据
                const keys = Object.keys(localStorage);
                keys.forEach(key => {
                    if (key.includes(`_${windowId}`)) {
                        localStorage.removeItem(key);
                        console.log(`🧹 清理窗口数据: ${key}`);
                    }
                });

                console.log(`🪟 窗口${windowId}的线下模式数据已清理`);
            } catch (error) {
                console.error('清理窗口线下模式数据失败:', error);
            }
        }
        */

        // 🔥【已废弃】迁移功能已移至数据库版本13中自动处理

        // 切换线下模式
        function toggleOfflineMode() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'warning');
                return;
            }

            // 🔥【修复】在切换模式前，强制清空旧的聊天记录数组
            // 这将确保每次都为当前角色加载正确的聊天记录
            offlineMessages = [];

            isOfflineMode = !isOfflineMode;
            const overlay = document.getElementById('offline-mode-overlay');
            const icon = document.getElementById('offline-mode-icon');
            const chatScreen = document.getElementById('api-chat-screen');
            const offlineTitle = document.getElementById('offline-mode-title');

            if (isOfflineMode) {
                // 进入线下模式
                overlay.style.display = 'flex';
                icon.className = 'fas fa-door-closed';
                chatScreen.classList.add('offline-mode-active');

                // 更新标题为当前角色名字
                if (offlineTitle && currentChatCharacter) {
                    offlineTitle.textContent = currentChatCharacter.name;
                }

                // 🔥【新增】暂停当前角色的主动发消息计时器
                pauseProactiveChatTimer(currentChatCharacter.id);

                // 加载线下模式的消息
                loadOfflineMessages();

                // 🔥【新增】加载并应用界面设置
                loadAndApplyOfflineUISettings();

                showToast('已进入线下剧情模式', 'success');
            } else {
                // 退出线下模式
                exitOfflineMode();
            }
        }

        // 退出线下模式
        function exitOfflineMode() {
            // 检查是否有线下模式的聊天记录
            if (offlineMessages.length > 0) {
                showOfflineExitModal();
            } else {
                // 没有聊天记录，直接退出
                doExitOfflineMode();
            }
        }

        // 显示线下模式退出选项模态框
        function showOfflineExitModal() {
            const modal = document.createElement('div');
            modal.className = 'modal offline-exit-modal'; // 添加特定类名
            modal.style.display = 'flex';
            modal.style.zIndex = '10001';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 400px;">
                    <div class="modal-header">
                        <h3>退出线下模式</h3>
                        <button class="modal-close" onclick="this.closest('.modal').remove()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="modal-body">
                        <p>请选择退出方式：</p>
                        <div style="margin-top: 15px;">
                            <button class="btn btn-primary" onclick="exitWithoutSummary()">
                                <i class="fas fa-check"></i> 结束且不总结（推荐）
                            </button>
                            <button class="btn btn-secondary" onclick="exitTemporarily()">
                                <i class="fas fa-pause"></i> 暂时离开
                            </button>
                            <button class="btn" onclick="exitWithSummary()" id="summary-btn" style="background: #f8f9fa !important; color: #000000 !important; border: 1px solid #000000 !important; font-weight: bold !important;">
                                <i class="fas fa-book"></i> 结束并总结
                            </button>
                        </div>
                        <p style="font-size: 12px; color: #666; margin-top: 10px;">
                            • <strong>结束且不总结</strong>：结束剧情，对话记录保存到线下模式聊天记录中<br>
                            • <strong>暂时离开</strong>：保留当前对话状态，可以稍后继续剧情<br>
                            • <strong>结束并总结</strong>：生成AI剧情摘要并保存到记忆系统和聊天记录中
                        </p>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        // 🔥【修改】生成剧情总结并退出
        async function exitWithSummary() {
            try {
                // 🔥【新增】显示加载状态
                const summaryButton = document.querySelector('#summary-btn');
                const originalHTML = summaryButton.innerHTML;
                summaryButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> AI正在总结中...';
                summaryButton.disabled = true;

                // 禁用其他按钮防止重复点击
                const otherButtons = document.querySelectorAll('.offline-exit-modal .btn:not(#summary-btn)');
                otherButtons.forEach(btn => btn.disabled = true);

                showToast('正在生成剧情总结...', 'info');
                await generateOfflineStorylineSummary();

                // 🔥【修复】确保模态框关闭
                const modal = document.querySelector('.offline-exit-modal');
                if (modal) modal.remove();

                doExitOfflineMode();
                showToast('已生成剧情总结并退出线下模式', 'success');
            } catch (error) {
                console.error('生成剧情总结失败:', error);

                // 🔥【修复】恢复按钮状态
                const summaryButton = document.querySelector('#summary-btn');
                if (summaryButton) {
                    summaryButton.innerHTML = '<i class="fas fa-book"></i> 结束并生成剧情总结';
                    summaryButton.disabled = false;
                }

                // 恢复其他按钮状态
                const otherButtons = document.querySelectorAll('.offline-exit-modal .btn:not(#summary-btn)');
                otherButtons.forEach(btn => btn.disabled = false);

                // 🔥【修复】确保模态框关闭
                const modal = document.querySelector('.offline-exit-modal');
                if (modal) modal.remove();

                doExitOfflineMode();
                showToast('生成剧情总结失败，但已退出线下模式', 'warning');
            }
        }

        // 暂时离开（不生成摘要）
        function exitTemporarily() {
            // 🔥【修复】使用精确的选择器找到退出模态框
            const modal = document.querySelector('.offline-exit-modal');
            if (modal) {
                modal.remove();
                console.log('✅ 暂时离开：模态框已关闭');
            } else {
                console.log('❌ 暂时离开：找不到模态框');
            }

            // 🔥【修复】暂时离开时不清空消息，保持线下模式状态
            console.log(`📝 暂时离开线下模式，保留${offlineMessages.length}条消息`);

            doExitOfflineMode();
            showToast('已暂时离开线下模式', 'info');
        }

        // 结束且不总结（推荐选项）
        async function exitWithoutSummary() {
            const modal = document.querySelector('.offline-exit-modal');
            if (modal) {
                modal.remove();
                console.log('✅ 结束且不总结：模态框已关闭');
            } else {
                console.log('❌ 结束且不总结：找不到模态框');
            }

            // 🔥【修复】如果有聊天记录，保存到线下模式聊天记录中
            if (offlineMessages.length > 0) {
                console.log(`📝 保存线下模式对话到聊天记录中，共${offlineMessages.length}条消息`);

                // 生成简单的对话摘要
                const summary = `线下模式对话记录 - ${new Date().toLocaleString()} (${offlineMessages.length}条消息)`;

                // 保存到线下模式聊天记录
                await saveOfflineHistoryRecord(summary, offlineMessages.slice());

                // 🔥【关键修复】确保线下模式消息已经保存到主聊天记录中
                // 检查主聊天记录中是否包含所有线下消息
                const characterId = currentChatCharacter.id;
                if (chatMessages[characterId]) {
                    const offlineMessagesInMain = chatMessages[characterId].filter(msg => msg.isOfflineMode);
                    console.log(`📊 主聊天记录中的线下消息: ${offlineMessagesInMain.length}条`);
                    console.log(`📊 当前线下消息数组: ${offlineMessages.length}条`);

                    // 确保主聊天记录已保存
                    await saveChatMessages(characterId);
                    console.log('✅ 已确保线下模式消息保存到主聊天记录中');
                } else {
                    console.warn('⚠️ 主聊天记录为空，这可能导致记忆连接问题');
                }

                // 清空线下消息记录
                offlineMessages = [];
                saveOfflineMessages(); // 保存清空状态到localStorage

                showToast('已结束线下模式，对话已保存到聊天记录', 'success');
            } else {
                console.log('📝 没有线下模式对话需要保存');
                showToast('已结束线下模式', 'success');
            }

            doExitOfflineMode();
        }

        // 实际执行退出线下模式
        function doExitOfflineMode() {
            isOfflineMode = false;
            const overlay = document.getElementById('offline-mode-overlay');
            const icon = document.getElementById('offline-mode-icon');
            const chatScreen = document.getElementById('api-chat-screen');

            overlay.style.display = 'none';
            icon.className = 'fas fa-door-open';
            chatScreen.classList.remove('offline-mode-active');

            // 🔥【新增】恢复当前角色的主动发消息计时器
            if (currentChatCharacter) {
                resumeProactiveChatTimer(currentChatCharacter.id);
            }

            // 🔥【修复】清空线下模式界面内容
            const offlineMessagesContainer = document.getElementById('offline-chat-messages');
            if (offlineMessagesContainer) {
                offlineMessagesContainer.innerHTML = '';
                console.log('✅ 已清空线下模式界面内容');
            }
        }

        // 🔥【新增】生成线下模式剧情总结
        async function generateOfflineStorylineSummary() {
            if (!currentChatCharacter || offlineMessages.length === 0) {
                return;
            }

            console.log('📖 开始生成线下模式剧情总结...');

            try {
                // 构建对话历史
                let conversationHistory = '';
                offlineMessages.forEach((msg, index) => {
                    const role = msg.sender === 'user' ? '用户' : currentChatCharacter.name;
                    // 🔥【修复】使用safeExtractMessageContent安全地提取消息内容，避免[object Object]问题
                    const messageContent = safeExtractMessageContent(msg);
                    conversationHistory += `${role}：${messageContent}\n`;
                });

                // 🔥【修改】构建剧情总结生成prompt，统一使用第三人称
                const summaryPrompt = `请为以下线下剧情模式的对话生成一个简洁客观的剧情总结，要求：
1. 使用客观的上帝视角，加入合理的文学性描写
2. 避免过多的修辞和形容词
3. 简明扼要地描述事件发生的顺序和关键情节与细节
4. 不要添加任何不在原文中的情感描写
5. 使用清晰的时间和因果关系
6. 统一使用第三人称叙述：用"用户"指代用户，用"${currentChatCharacter.name}"指代角色
7. 不要使用"我"、"你"等第一、第二人称

角色信息：
${currentChatCharacter.name}

对话历史：
${conversationHistory}

请生成一个200-800字的客观剧情总结，要求：
1. 按时间顺序记录发生的主要事件
2. 客观描述角色的行为和对话要点，使用"用户"和"${currentChatCharacter.name}"来指代双方
3. 记录重要的情节转折和结果
4. 避免过度的主观情感描述和过度修饰
5. 使用简洁明了的语言
6. 重点记录关键细节和对后续剧情有影响的关键信息
7. 严格使用第三人称：用户做了什么，${currentChatCharacter.name}如何回应

请以客观记录的方式总结这段剧情：`;

                console.log('📖 剧情总结生成prompt:', summaryPrompt);

                // 调用API生成摘要
                const summary = await callOfflineChatAPI(summaryPrompt, currentChatCharacter);

                // 🔥【新增】显示完整的总结内容
                console.log('📖 生成的完整剧情总结:', summary);

                if (summary && summary.trim()) {
                    // 🔥【修复】保存到跨应用时间线数据库，使用正确的表名和字段结构
                    const timelineMemory = {
                        id: `offline_summary_${currentChatCharacter.id}_${Date.now()}`, // 🔥【修复】添加必需的主键
                        characterId: currentChatCharacter.id,
                        appType: 'offline_mode',
                        action: 'storyline_summary',
                        timestamp: Date.now(),
                        context: {
                            type: 'offline_storyline',
                            content: `[剧情模式] ${summary.trim()}`,
                            date: new Date().toISOString().split('T')[0],
                            messageCount: offlineMessages.length,
                            importance: 0.9 // 剧情总结重要性很高
                        },
                        messageId: `offline_summary_${Date.now()}`
                    };

                    await db.crossAppTimeline.add(timelineMemory);
                    console.log('📖 线下模式剧情总结已保存到跨应用时间线:', timelineMemory);

                    // 🔥【新增】保存聊天记录到历史记录
                    saveOfflineHistoryRecord(summary.trim(), offlineMessages.slice());

                    // 🔥【关键修复】确保线下模式消息已经保存到主聊天记录中
                    // 检查主聊天记录中是否包含所有线下消息
                    const characterId = currentChatCharacter.id;
                    if (chatMessages[characterId]) {
                        const offlineMessagesInMain = chatMessages[characterId].filter(msg => msg.isOfflineMode);
                        console.log(`📊 主聊天记录中的线下消息: ${offlineMessagesInMain.length}条`);
                        console.log(`📊 当前线下消息数组: ${offlineMessages.length}条`);

                        // 确保主聊天记录已保存
                        await saveChatMessages(characterId);
                        console.log('✅ 已确保线下模式消息保存到主聊天记录中');
                    } else {
                        console.warn('⚠️ 主聊天记录为空，这可能导致记忆连接问题');
                    }

                    // 🔥【修复】清空线下模式消息
                    offlineMessages = [];
                    saveOfflineMessages();
                } else {
                    throw new Error('生成的剧情总结为空');
                }

            } catch (error) {
                console.error('生成线下模式剧情总结失败:', error);
                throw error;
            }
        }

        // 显示线下预设设置
        function showOfflinePresetSettings() {
            document.getElementById('offline-preset-modal').style.display = 'flex';

            // 加载并显示已保存的预设
            loadAndDisplayPresets();

            // 清空表单
            clearPresetForm();
        }

        // 关闭线下预设设置
        function closeOfflinePresetSettings() {
            document.getElementById('offline-preset-modal').style.display = 'none';
            // 清理编辑状态
            delete window.editingPresetId;
        }

        // 清空预设表单
        function clearPresetForm() {
            document.getElementById('offline-preset-name').value = '';
            document.getElementById('offline-preset-content').value = '';
        }

        // 加载并显示已保存的预设
        async function loadAndDisplayPresets() {
            try {
                // 🔥【修复】从Dexie数据库加载预设，避免isGlobal字段的索引问题
                const allPresets = await db.offlinePresets.toArray();
                const presets = allPresets.filter(preset => preset.isGlobal === true);
                const container = document.getElementById('saved-presets-list');

                container.innerHTML = '';

                if (presets.length === 0) {
                    return; // CSS会显示"暂无保存的预设"
                }

                // 按时间戳排序，最新的在前
                presets.sort((a, b) => b.timestamp - a.timestamp);

                presets.forEach(preset => {
                    const presetDiv = document.createElement('div');
                    presetDiv.className = 'preset-item';
                    if (currentOfflinePreset && currentOfflinePreset.id === preset.id) {
                        presetDiv.classList.add('active');
                    }

                    const presetInfo = document.createElement('div');
                    presetInfo.className = 'preset-info';

                    const presetName = document.createElement('div');
                    presetName.className = 'preset-name';
                    presetName.textContent = preset.name;

                    const presetPreview = document.createElement('div');
                    presetPreview.className = 'preset-preview';
                    presetPreview.textContent = preset.content.substring(0, 50) + (preset.content.length > 50 ? '...' : '');

                    presetInfo.appendChild(presetName);
                    presetInfo.appendChild(presetPreview);

                    const presetActions = document.createElement('div');
                    presetActions.className = 'preset-actions';

                    // 使用按钮
                    const useBtn = document.createElement('button');
                    useBtn.className = 'preset-action-btn use-btn';
                    useBtn.innerHTML = '<i class="fas fa-check"></i>';
                    useBtn.title = '使用此预设';
                    useBtn.onclick = () => usePreset(preset);

                    // 编辑按钮
                    const editBtn = document.createElement('button');
                    editBtn.className = 'preset-action-btn edit-btn';
                    editBtn.innerHTML = '<i class="fas fa-edit"></i>';
                    editBtn.title = '编辑预设';
                    editBtn.onclick = () => editPreset(preset);

                    // 删除按钮
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'preset-action-btn delete-btn';
                    deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                    deleteBtn.title = '删除预设';
                    deleteBtn.onclick = () => deletePreset(preset.id);

                    presetActions.appendChild(useBtn);
                    presetActions.appendChild(editBtn);
                    presetActions.appendChild(deleteBtn);

                    presetDiv.appendChild(presetInfo);
                    presetDiv.appendChild(presetActions);

                    container.appendChild(presetDiv);
                });

                console.log(`✅ 加载了 ${presets.length} 个线下模式预设`);
            } catch (error) {
                console.error('❌ 加载线下模式预设失败:', error);
                showToast('加载预设失败', 'error');
            }
        }

        // 使用预设
        function usePreset(preset) {
            currentOfflinePreset = preset;
            loadAndDisplayPresets(); // 刷新列表显示
            showToast(`已启用预设"${preset.name}"`, 'success');
        }

        // 编辑预设
        function editPreset(preset) {
            document.getElementById('offline-preset-name').value = preset.name;
            document.getElementById('offline-preset-content').value = preset.content;

            // 临时存储正在编辑的预设ID
            window.editingPresetId = preset.id;
        }

        // 删除预设
        async function deletePreset(presetId) {
            if (!confirm('确定要删除这个预设吗？')) {
                return;
            }

            try {
                // 🔥【修改】从Dexie数据库删除预设
                const preset = await db.offlinePresets.get(presetId);
                if (!preset) {
                    showToast('预设不存在', 'warning');
                    return;
                }

                await db.offlinePresets.delete(presetId);

                // 如果删除的是当前使用的预设，清空当前预设
                if (currentOfflinePreset && currentOfflinePreset.id === presetId) {
                    currentOfflinePreset = null;
                }

                await loadAndDisplayPresets(); // 刷新列表
                showToast(`预设"${preset.name}"已删除`, 'info');
                console.log(`✅ 删除预设: ${preset.name} (${presetId})`);
            } catch (error) {
                console.error('❌ 删除预设失败:', error);
                showToast('删除预设失败', 'error');
            }
        }

        // 保存线下预设
        async function saveOfflinePreset() {
            const name = document.getElementById('offline-preset-name').value.trim();
            const content = document.getElementById('offline-preset-content').value.trim();

            if (!name) {
                showToast('请输入预设名称', 'warning');
                return;
            }

            if (!content) {
                showToast('请输入预设内容', 'warning');
                return;
            }

            try {
                // 检查是否是编辑现有预设
                if (window.editingPresetId) {
                    // 🔥【修改】更新Dexie数据库中的预设
                    const existingPreset = await db.offlinePresets.get(window.editingPresetId);
                    if (existingPreset) {
                        // 更新现有预设
                        existingPreset.name = name;
                        existingPreset.content = content;
                        existingPreset.timestamp = Date.now(); // 更新时间戳

                        await db.offlinePresets.put(existingPreset);

                        // 如果正在编辑的是当前使用的预设，更新当前预设
                        if (currentOfflinePreset && currentOfflinePreset.id === window.editingPresetId) {
                            currentOfflinePreset = existingPreset;
                        }

                        delete window.editingPresetId;

                        await loadAndDisplayPresets(); // 刷新列表
                        clearPresetForm();
                        showToast(`预设"${name}"已更新`, 'success');
                        console.log(`✅ 更新预设: ${name} (${existingPreset.id})`);
                        return;
                    }
                    delete window.editingPresetId;
                }

                // 🔥【修改】创建新预设并保存到Dexie数据库
                const preset = {
                    id: `preset_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    name: name,
                    content: content,
                    timestamp: Date.now(),
                    isGlobal: true
                };

                await db.offlinePresets.add(preset);

                // 设置为当前预设
                currentOfflinePreset = preset;

                await loadAndDisplayPresets(); // 刷新列表
                clearPresetForm();
                showToast(`预设"${name}"已保存并启用`, 'success');
                console.log(`✅ 保存新预设: ${name} (${preset.id})`);
            } catch (error) {
                console.error('❌ 保存预设失败:', error);
                showToast('保存预设失败', 'error');
            }
        }

        // 加载线下消息
        function loadOfflineMessages() {
            if (!currentChatCharacter || !windowId) return;

            // 🔥【修复】只有当offlineMessages为空时才从localStorage加载
            // 这样可以避免在退出后重新进入时重新加载已清空的数据
            if (!offlineMessages || offlineMessages.length === 0) {
                // 🔥【修复】加入窗口ID，确保不同窗口的线下消息完全隔离
                const key = `offlineMessages_${currentChatCharacter.id}_${windowId}`;
                offlineMessages = JSON.parse(localStorage.getItem(key) || '[]');
                console.log(`📱 从localStorage加载线下消息 (窗口${windowId}): ${offlineMessages.length}条`);
            } else {
                console.log(`📱 使用内存中的线下消息 (窗口${windowId}): ${offlineMessages.length}条`);
            }

            // 🔥【修改】加载全局预设从Dexie数据库
            loadLatestOfflinePreset();

            renderOfflineMessages();
        }

        // 🔥【新增】加载最新的线下模式预设
        async function loadLatestOfflinePreset() {
            try {
                // 🔥【修复】避免isGlobal字段的索引问题
                const allPresets = await db.offlinePresets.toArray();
                const presets = allPresets.filter(preset => preset.isGlobal === true);

                if (presets.length > 0) {
                    // 按时间戳排序，使用最新的预设
                    presets.sort((a, b) => b.timestamp - a.timestamp);
                    currentOfflinePreset = presets[0];
                    console.log(`✅ 加载最新预设: ${currentOfflinePreset.name}`);
                } else {
                    currentOfflinePreset = null;
                    console.log('📝 没有可用的线下模式预设');
                }
            } catch (error) {
                console.error('❌ 加载线下模式预设失败:', error);
                currentOfflinePreset = null;
            }
        }

        // 渲染线下消息
        function renderOfflineMessages() {
            const container = document.getElementById('offline-chat-messages');
            container.innerHTML = '';

            offlineMessages.forEach(message => {
                const messageDiv = document.createElement('div');
                messageDiv.className = `offline-message ${message.sender}`;
                messageDiv.dataset.messageId = message.id;

                // 添加头像
                const avatarDiv = document.createElement('div');
                avatarDiv.className = `offline-avatar ${message.sender === 'user' ? 'user-avatar' : 'ai-avatar'}`;

                if (message.sender === 'user') {
                    // 🔥【修复】正确获取用户身份面具卡头像
                    let userAvatar = null;
                    let userName = '用户';

                    // 获取当前聊天设置
                    const chatSettings = getCurrentChatSettings();

                    // 优先级1：聊天专属头像设置
                    if (chatSettings.myChatAvatar) {
                        userAvatar = chatSettings.myChatAvatar;
                    }

                    // 优先级2：身份面具卡头像
                    if (!userAvatar && chatSettings.selectedIdentityId) {
                        const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                        if (selectedPersona) {
                            userAvatar = selectedPersona.avatarUrl;
                            userName = selectedPersona.name;
                        }
                    }

                    // 优先级3：全局用户头像
                    if (!userAvatar && window.userAvatar) {
                        userAvatar = window.userAvatar;
                    }

                    if (userAvatar && userAvatar.trim()) {
                        avatarDiv.style.backgroundImage = `url(${userAvatar})`;
                        avatarDiv.style.backgroundSize = 'cover';
                        avatarDiv.style.backgroundPosition = 'center';
                        avatarDiv.textContent = '';
                    } else {
                        // 使用默认头像生成函数
                        const defaultAvatar = createDefaultAvatar(userName);
                        avatarDiv.style.backgroundImage = `url(${defaultAvatar})`;
                        avatarDiv.style.backgroundSize = 'cover';
                        avatarDiv.style.backgroundPosition = 'center';
                        avatarDiv.textContent = '';
                    }
                } else {
                    // 🔥【修复】正确获取角色头像
                    let aiAvatar = null;

                    if (currentChatCharacter) {
                        // 获取当前聊天设置
                        const chatSettings = getCurrentChatSettings();

                        // 优先级1：聊天专属头像
                        if (chatSettings.aiChatAvatar) {
                            aiAvatar = chatSettings.aiChatAvatar;
                        }
                        // 优先级2：角色卡原始头像
                        else if (currentChatCharacter.avatarUrl) {
                            aiAvatar = currentChatCharacter.avatarUrl;
                        }
                        // 优先级3：角色卡avatar字段（兼容性）
                        else if (currentChatCharacter.avatar) {
                            aiAvatar = currentChatCharacter.avatar;
                        }
                    }

                    if (aiAvatar && aiAvatar.trim()) {
                        avatarDiv.style.backgroundImage = `url(${aiAvatar})`;
                        avatarDiv.style.backgroundSize = 'cover';
                        avatarDiv.style.backgroundPosition = 'center';
                        avatarDiv.textContent = '';
                    } else {
                        // 使用默认头像生成函数
                        const characterName = currentChatCharacter?.name || 'AI';
                        const defaultAvatar = createDefaultAvatar(characterName);
                        avatarDiv.style.backgroundImage = `url(${defaultAvatar})`;
                        avatarDiv.style.backgroundSize = 'cover';
                        avatarDiv.style.backgroundPosition = 'center';
                        avatarDiv.textContent = '';
                    }
                }

                const contentDiv = document.createElement('div');
                contentDiv.className = 'offline-message-content';
                // 🔥【修改】使用新的格式化函数处理文本
                contentDiv.innerHTML = formatOfflineText(message.content);

                messageDiv.appendChild(avatarDiv);
                messageDiv.appendChild(contentDiv);

                // 🔥【修复】为所有消息（用户和AI）添加长按功能
                addOfflineMessageLongPressListener(messageDiv, message.id);

                container.appendChild(messageDiv);
            });

            // 🔥【修复】确保滚动到底部 - 使用延迟和requestAnimationFrame确保DOM更新完成
            setTimeout(() => {
                requestAnimationFrame(() => {
                    container.scrollTop = container.scrollHeight;
                });
            }, 50);

            // 🔥【新增】应用界面设置到新渲染的消息
            applyOfflineUISettings();
        }

        // 发送线下消息
        async function sendOfflineMessage() {
            const input = document.getElementById('offline-input');
            const content = input.value.trim();

            if (!content) return;
            if (!currentChatCharacter) return;

            // 🔥【修复】将线下模式消息直接存储到主聊天记录中，保证时间线连贯性
            const characterId = currentChatCharacter.id;

            if (!chatMessages[characterId]) {
                chatMessages[characterId] = [];
            }

            const userChatMessage = {
                id: Date.now(),
                sender: 'sent', // 使用标准的sender格式
                content: content,
                timestamp: Date.now(),
                type: 'text',
                isOfflineMode: true // 标记为线下模式消息
            };

            chatMessages[characterId].push(userChatMessage);

            // 保存到主聊天记录中
            // 🔥【优化】线下模式用户消息使用高效保存
            try {
                await saveChatMessagesImmediate([characterId]);
                console.log('✅ [高效线下用户消息] 消息已保存到数据库');
            } catch (error) {
                console.error('线下用户消息保存失败，回退到指定角色保存:', error);
                await saveChatMessages(characterId);
            }

            // 添加用户消息到线下模式显示
            const userMessage = {
                id: Date.now().toString(),
                sender: 'user',
                content: content,
                timestamp: new Date().toISOString()
            };

            offlineMessages.push(userMessage);
            input.value = '';
            renderOfflineMessages();

            // 保存线下消息
            saveOfflineMessages();

            // 🔥【新增】显示AI回复加载动画
            showOfflineLoadingMessage();

            // 生成AI回复
            try {
                const aiResponse = await generateOfflineResponse(content);

                // 🔥【修复】将AI回复添加到主聊天记录中，保证时间线连贯性
                const aiChatMessage = {
                    id: Date.now() + 1,
                    sender: 'received', // 使用标准的sender格式
                    content: aiResponse,
                    timestamp: Date.now() + 1,
                    type: 'text',
                    isOfflineMode: true // 标记为线下模式消息
                };

                chatMessages[characterId].push(aiChatMessage);
                // 🔥【修复】线下模式AI消息使用单条高效保存，避免强制同步
                try {
                    const stableId = `${characterId}_offline_ai_${aiChatMessage.timestamp}_${Math.random().toString(36).substr(2, 9)}_${chatMessages[characterId].length - 1}`;
                    await db.chatMessages.add({
                        id: stableId,
                        characterId: characterId,
                        timestamp: aiChatMessage.timestamp,
                        messageOrder: chatMessages[characterId].length - 1,
                        originalMessageId: aiChatMessage.id,
                        messageData: aiChatMessage
                    });
                    console.log('✅ [高效线下AI消息] 单条消息已保存到数据库');
                } catch (error) {
                    console.error('线下AI消息单条保存失败，回退到批量保存:', error);
                    await saveChatMessages(); // 🔥【修复】不传参数，避免强制同步
                }

                const aiMessage = {
                    id: (Date.now() + 1).toString(),
                    sender: 'ai',
                    content: aiResponse,
                    timestamp: new Date().toISOString()
                };

                offlineMessages.push(aiMessage);

                // 🔥【新增】移除加载动画并渲染消息
                hideOfflineLoadingMessage();
                renderOfflineMessages();
                saveOfflineMessages();

            } catch (error) {
                console.error('生成线下回复失败:', error);
                // 🔥【新增】出错时也要移除加载动画
                hideOfflineLoadingMessage();
                showToast('生成回复失败', 'error');
            }
        }

        // 线下模式专用的API调用函数
        async function callOfflineChatAPI(prompt, character) {
            if (!apiSettings.key) {
                throw new Error('请先设置API密钥');
            }

            // 使用与线上模式相同的API设置
            const isGemini = apiSettings.base.includes('generativelanguage.googleapis.com');

            if (isGemini) {
                // Gemini API 格式
                const apiUrl = `${apiSettings.base}/models/${apiSettings.model}:generateContent?key=${apiSettings.key}`;

                const requestBody = {
                    contents: [
                        {
                            role: "user",
                            parts: [
                                {
                                    text: `你是${character.name}，${character.prompt}。现在处于线下剧情模式，请以纯文本形式回复，专注于情景描写和剧情发展。\n\n${prompt}`
                                }
                            ]
                        }
                    ],
                    generationConfig: {
                        temperature: apiSettings.temperature || 0.8
                        // 移除maxOutputTokens，Gemini不支持这个参数
                    }
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    throw new Error(`API请求失败: ${response.status}`);
                }

                const data = await response.json();
                console.log('🔥 线下模式Gemini API完整响应:', JSON.stringify(data, null, 2));

                // 完全按照线上模式的逻辑处理
                const content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!content) {
                    console.log('🔥 Gemini API 响应数据:', data);
                    console.log('🔥 candidates[0]:', data.candidates?.[0]);
                    if (data.candidates?.[0]?.content) {
                        console.log('🔥 content:', data.candidates[0].content);
                    }
                    if (data.candidates?.[0]?.content?.parts) {
                        console.log('🔥 parts:', data.candidates[0].content.parts);
                    }
                    return '抱歉，我现在无法回复。'; // 不要抛出错误，直接返回默认回复
                }

                return content;

            } else {
                // OpenAI 格式 - 🔥【修复】智能处理URL拼接，支持抱脸轮询
                let baseUrl = apiSettings.base;
                let apiUrl;
                if (baseUrl.endsWith('/v1')) {
                    apiUrl = `${baseUrl}/chat/completions`;
                } else if (baseUrl.includes('/v1/')) {
                    // 如果URL中已经包含/v1/路径，直接添加chat/completions
                    apiUrl = `${baseUrl}/chat/completions`;
                } else {
                    apiUrl = `${baseUrl}/v1/chat/completions`;
                }

                const requestBody = {
                    model: apiSettings.model,
                    messages: [
                        {
                            role: "system",
                            content: `你是${character.name}，${character.prompt}。现在处于线下剧情模式，请以纯文本形式回复，专注于情景描写和剧情发展。`
                        },
                        {
                            role: "user",
                            content: prompt
                        }
                    ],
                    temperature: apiSettings.temperature || 0.8
                    // 🔥【修复】移除max_tokens限制，与线上模式保持一致
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiSettings.key}`
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    throw new Error(`API请求失败: ${response.status}`);
                }

                const data = await response.json();
                console.log('线下模式OpenAI API响应数据:', data);

                const content = data.choices?.[0]?.message?.content;
                if (!content) {
                    console.error('OpenAI API返回了空内容或格式异常:', data);
                    throw new Error('OpenAI API返回了空内容');
                }

                return content;
            }
        }

        // 生成线下模式的AI回复
        async function generateOfflineResponse(userInput) {
            const character = currentChatCharacter;

            console.log('🎭 ===== 线下模式AI回复生成开始 =====');
            console.log('🎭 当前角色:', character.name);
            console.log('🎭 用户输入:', userInput);

            // 🔥【新增】使用与线上模式相同的记忆系统构建prompt
            let prompt = `你现在处于线下剧情模式，需要以纯文本形式回复，不要使用JSON格式。

【重要提示】用户消息中的括号()内容是环境描写、动作描写或心理活动，你可以观察到这些信息作为背景，但不能表现得像是"听到"了用户的内心想法。你只能对括号外的实际话语进行回应，可以通过观察用户的可见行为（如犹豫、停顿等）来推测情况，但不能直接回应用户的内心想法。

`;

            // 🔥【新增】获取聊天设置和记忆数据
            const chatSettings = getCurrentChatSettings();
            console.log('⚙️ 聊天设置:', chatSettings);

            // 🔥【增强】获取动态记忆数据 - 包含评论区内容
            let dynamicMemoryContent = '';
            const enableDynamicMemory = chatSettings.enableDynamicMemory !== false; // 默认为true
            console.log('📱 动态记忆开关:', enableDynamicMemory);
            if (enableDynamicMemory) {
                try {
                    const recentMoments = await getVisibleMomentsForCharacter(character.id, 5);
                    console.log('📱 获取到的动态数量:', recentMoments.length);
                    if (recentMoments.length > 0) {
                        dynamicMemoryContent = '\n\n【最新动态记忆】以下是最近的动态内容和讨论，你可以在对话中自然地提及：\n';
                        recentMoments.forEach((moment, index) => {
                            const authorName = moment.authorId === 'user' ? '用户' : moment.nickname;

                            // 🔥【新增】添加动态发布时间信息
                            let timeInfo = '';
                            if (moment.timestamp) {
                                const now = Date.now();
                                const timeDiff = now - moment.timestamp;
                                const minutes = Math.floor(timeDiff / (1000 * 60));
                                const hours = Math.floor(timeDiff / (1000 * 60 * 60));
                                const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));

                                if (days > 0) {
                                    timeInfo = ` (${days}天前)`;
                                } else if (hours > 0) {
                                    timeInfo = ` (${hours}小时前)`;
                                } else if (minutes > 0) {
                                    timeInfo = ` (${minutes}分钟前)`;
                                } else {
                                    timeInfo = ' (刚刚)';
                                }
                            }

                            // 🔥【新增】包含评论区内容
                            const momentContent = `${index + 1}. ${authorName}: ${moment.text}${timeInfo}${moment.commentsText || ''}`;
                            dynamicMemoryContent += momentContent;

                            console.log(`📱 动态 ${index + 1}: ${authorName} - ${moment.text}${moment.commentsCount > 0 ? ` (${moment.commentsCount}条评论)` : ''}`);
                        });
                    } else {
                        console.log('📱 没有可用的动态记忆');
                    }
                } catch (error) {
                    console.error('获取动态记忆失败:', error);
                }
            }

            // 🔥【新增】强化拉黑状态感知 - 在每次对话中都提醒角色
            let blockedStatusReminder = '';
            if (character && !currentChatCharacter?.isGroup) {
                const isCharacterBlocked = isBlocked(character.id, 'user');
                if (isCharacterBlocked) {
                    // 检查被拒绝的好友申请次数
                    const rejectionKey = `friendRequestRejections_${character.id}`;
                    const rejectionCount = parseInt(localStorage.getItem(rejectionKey) || '0');

                    blockedStatusReminder = `\n\n🚨 **【重要状态提醒】** 🚨
你目前被用户拉黑了！这个状态会持续影响你的行为和情绪。
${rejectionCount > 0 ? `你已经尝试了${rejectionCount}次好友申请，但都被拒绝了。` : '你还没有尝试发送好友申请来修复关系。'}
请在每次回复中都要意识到这个问题的存在，并根据你的性格表现出相应的情绪和行为。`;
                }
            }

            // 获取全局记忆数据
            let globalMemoryContent = '';
            try {
                const memorySettings = getGlobalMemorySettings();
                console.log('🧠 记忆设置:', memorySettings);

                const currentContext = {
                    type: 'private_chat',
                    id: character.id
                };
                console.log('🧠 当前上下文:', currentContext);

                // 🔥【修复】线下模式强制启用全局记忆读取，但不存储
                console.log('🧠 线下模式：强制启用全局记忆读取...');
                globalMemoryContent = await buildGlobalMemoryContext(character.id, currentContext, memorySettings.memoryDays);
                console.log('🧠 获取到的全局记忆内容:', globalMemoryContent);
                if (globalMemoryContent && globalMemoryContent.trim()) {
                    console.log('🧠 线下模式已获取全局记忆上下文，总长度:', globalMemoryContent.length);
                    console.log('🧠 线下模式全局记忆内容预览:', globalMemoryContent.substring(0, 200) + '...');
                } else {
                    console.log('🧠 全局记忆内容为空');
                }
            } catch (error) {
                console.error('获取全局记忆失败:', error);
            }

            // 添加角色信息
            const characterPrompt = character.prompt || character.bio || `你是${character.name}。`;
            console.log('👤 角色人设:', characterPrompt);
            console.log('👤 角色完整信息:', character);
            prompt += `角色信息：\n${characterPrompt}\n\n`;

            // 🔥【新增】添加世界书信息
            let worldbookContent = '';
            try {
                const localBookIds = chatSettings.selectedWorldbooks || [];
                const globalBooks = window.activeGlobalWorldbooks || [];
                const allBookIds = [...new Set([...globalBooks, ...localBookIds])]; // 合并并去重

                console.log('📚 世界书ID列表:', allBookIds);
                console.log('📚 全局世界书:', globalBooks);
                console.log('📚 局部世界书:', localBookIds);
                console.log('📚 所有世界书数据:', worldbooks);

                if (allBookIds.length > 0) {
                    worldbookContent = '\n【世界书信息】以下是相关的世界设定：\n';
                    allBookIds.forEach((bookId, index) => {
                        const worldbook = worldbooks.find(w => w.id === bookId);
                        if (worldbook) {
                            console.log(`📚 找到世界书 ${index + 1}: ${worldbook.name || worldbook.title}`);
                            worldbookContent += `${index + 1}. ${worldbook.name || worldbook.title}: ${worldbook.content}\n`;
                        } else {
                            console.log(`📚 未找到世界书ID: ${bookId}`);
                        }
                    });
                    prompt += worldbookContent + '\n';
                    console.log('📚 世界书内容已添加到prompt，长度:', worldbookContent.length);
                } else {
                    console.log('📚 没有可用的世界书');
                }
            } catch (error) {
                console.error('获取世界书失败:', error);
            }

            // 添加记忆内容
            if (globalMemoryContent && globalMemoryContent.trim()) {
                prompt += '\n\n【角色记忆】以下是相关的记忆内容：\n' + globalMemoryContent + '\n';
            }
            if (dynamicMemoryContent) {
                prompt += dynamicMemoryContent + '\n';
            }

            // 🔥【新增】添加拉黑状态提醒到提示词
            if (blockedStatusReminder) {
                prompt += blockedStatusReminder + '\n';
            }

            // 添加用户自定义预设（高权重）
            if (currentOfflinePreset) {
                prompt += `【重要】用户自定义剧情预设（请严格遵循）：\n${currentOfflinePreset.content}\n\n`;
            } else {
                prompt += `默认剧情模式要求：\n- 以第三人称视角进行情景描写\n- 包含环境描写、动作描写、心理描写\n- 每次回复300-500字\n- 营造沉浸式的剧情体验\n- **重要**：用户消息中的括号()内容是环境描写、动作描写或心理活动，你可以观察到这些信息作为背景，但不能表现得像是"听到"了用户的内心想法。你只能对括号外的实际话语进行回应，可以通过观察用户的可见行为（如犹豫、停顿等）来推测情况，但不能直接回应用户的内心想法\n\n`;
            }

            // 🔥【修复】读取用户设置的历史消息数，直接从主聊天记录获取完整时间线
            const historyCount = chatSettings.historyCount || 5;

            // 获取主聊天记录（包含线上和线下模式的所有消息，按时间顺序）
            const allMessages = chatMessages[character.id] || [];

            // 根据用户设置的历史消息数获取最近的消息
            const recentChatMessages = allMessages.slice(-historyCount);

            // 统计消息类型
            const onlineCount = recentChatMessages.filter(msg => !msg.isOfflineMode).length;
            const offlineCount = recentChatMessages.filter(msg => msg.isOfflineMode).length;

            console.log('💬 线下模式完整前文记忆:', recentChatMessages);
            console.log(`📊 历史消息统计: 线上${onlineCount}条, 线下${offlineCount}条, 总计使用${recentChatMessages.length}条 (用户设置: ${historyCount}条)`);

            if (recentChatMessages.length > 0) {
                prompt += `最近的对话历史：\n`;
                recentChatMessages.forEach(msg => {
                    // 根据sender字段确定角色
                    const role = (msg.sender === 'sent' || msg.sender === 'user') ? '用户' : character.name;
                    // 标记消息来源（线上/线下）
                    const modeTag = msg.isOfflineMode ? '[线下]' : '[线上]';
                    // 🔥【修复】使用safeExtractMessageContent安全地提取消息内容，避免[object Object]问题
                    const messageContent = safeExtractMessageContent(msg);
                    prompt += `${role}${modeTag}：${messageContent}\n`;
                });
                prompt += `\n`;
            }

            prompt += `用户刚才说：${userInput}\n\n请直接以纯文本形式回复，不要使用JSON数组格式，注重情景描写和氛围营造。`;

            console.log('📝 ===== 完整的Prompt内容 =====');
            console.log(prompt);
            console.log('📝 ===== Prompt结束 =====');

            try {
                // 使用专门的线下模式API调用
                const response = await callOfflineChatAPI(prompt, character);

                // 直接返回响应内容，不进行JSON解析
                return response || '抱歉，我现在无法回复。';
            } catch (error) {
                console.error('线下模式API调用失败:', error);
                throw error;
            }
        }

        // 保存线下消息
        function saveOfflineMessages() {
            if (!currentChatCharacter || !windowId) return;

            // 🔥【修复】加入窗口ID，确保不同窗口的线下消息完全隔离
            const key = `offlineMessages_${currentChatCharacter.id}_${windowId}`;
            localStorage.setItem(key, JSON.stringify(offlineMessages));
            console.log(`💾 保存线下消息到localStorage (窗口${windowId}): ${offlineMessages.length}条`);
        }

        // 重新生成线下模式的最后一条AI回复
        async function regenerateLastOfflineMessage() {
            if (!currentChatCharacter) return;
            if (offlineMessages.length === 0) return;

            // 找到最后一条AI消息
            let lastAiMessageIndex = -1;
            for (let i = offlineMessages.length - 1; i >= 0; i--) {
                if (offlineMessages[i].sender === 'ai') {
                    lastAiMessageIndex = i;
                    break;
                }
            }

            if (lastAiMessageIndex === -1) {
                showToast('没有找到可重新生成的AI消息', 'warning');
                return;
            }

            // 找到对应的用户消息
            let userMessageIndex = -1;
            for (let i = lastAiMessageIndex - 1; i >= 0; i--) {
                if (offlineMessages[i].sender === 'user') {
                    userMessageIndex = i;
                    break;
                }
            }

            if (userMessageIndex === -1) {
                showToast('没有找到对应的用户消息', 'warning');
                return;
            }

            // 删除最后一条AI消息
            offlineMessages.splice(lastAiMessageIndex, 1);
            renderOfflineMessages();
            saveOfflineMessages();

            // 🔥【新增】显示加载动画
            showOfflineLoadingMessage();

            // 重新生成AI回复
            try {
                const userMessage = offlineMessages[userMessageIndex];
                const aiResponse = await generateOfflineResponse(userMessage.content);

                const aiMessage = {
                    id: Date.now().toString(),
                    sender: 'ai',
                    content: aiResponse,
                    timestamp: new Date().toISOString()
                };

                offlineMessages.push(aiMessage);

                // 🔥【新增】移除加载动画并渲染消息
                hideOfflineLoadingMessage();
                renderOfflineMessages();
                saveOfflineMessages();

                showToast('AI回复已重新生成', 'success');

            } catch (error) {
                console.error('重新生成AI回复失败:', error);
                // 🔥【新增】出错时也要移除加载动画
                hideOfflineLoadingMessage();
                showToast('重新生成失败', 'error');
            }
        }

        // 线下模式消息长按监听器
        function addOfflineMessageLongPressListener(messageContainer, messageId) {
            let pressTimer = null;
            let isLongPress = false;

            // 🔥【优化】更准确的移动设备检测
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                             'ontouchstart' in window ||
                             navigator.maxTouchPoints > 0 ||
                             window.innerWidth <= 768;

            const startLongPress = (e) => {
                isLongPress = false;
                // 🔥【优化】移动端和桌面端使用不同的延迟时间
                const delay = isMobile ? 600 : 1000; // 移动端600ms，桌面端1000ms
                pressTimer = setTimeout(() => {
                    isLongPress = true;
                    // 🔥【优化】添加触觉反馈（如果支持）
                    if (navigator.vibrate && isMobile) {
                        navigator.vibrate(50);
                    }
                    showOfflineMessageMenu(messageId, e);
                    e.preventDefault();
                }, delay);
            };

            const cancelLongPress = () => {
                if (pressTimer) {
                    clearTimeout(pressTimer);
                    pressTimer = null;
                }
                setTimeout(() => {
                    isLongPress = false;
                }, 50);
            };

            const handleClick = (e) => {
                if (isLongPress) {
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
            };

            // 触摸事件
            messageContainer.addEventListener('touchstart', startLongPress, { passive: false });
            messageContainer.addEventListener('touchend', cancelLongPress);
            messageContainer.addEventListener('touchmove', cancelLongPress);

            // 鼠标事件（用于桌面端）
            messageContainer.addEventListener('mousedown', startLongPress);
            messageContainer.addEventListener('mouseup', cancelLongPress);
            messageContainer.addEventListener('mouseleave', cancelLongPress);

            // 右键菜单（桌面端）
            messageContainer.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showOfflineMessageMenu(messageId, e);
            });

            // 点击事件
            messageContainer.addEventListener('click', handleClick, true);
        }

        // 显示线下模式消息菜单
        function showOfflineMessageMenu(messageId, event) {
            const message = offlineMessages.find(m => m.id === messageId);
            if (!message) return;

            // 创建菜单
            const menu = document.createElement('div');
            menu.className = 'offline-message-menu';

            // 根据消息类型显示不同的菜单项
            if (message.sender === 'user') {
                menu.innerHTML = `
                    <div class="menu-item" onclick="editOfflineMessage('${messageId}')">
                        <i class="fas fa-edit"></i>
                        <span>修改消息</span>
                    </div>
                    <div class="menu-item delete" onclick="deleteOfflineMessage('${messageId}')">
                        <i class="fas fa-trash"></i>
                        <span>删除消息</span>
                    </div>
                `;
            } else {
                // 🔥【修改】AI消息可以编辑、删除和重新生成
                menu.innerHTML = `
                    <div class="menu-item" onclick="editOfflineMessage('${messageId}')">
                        <i class="fas fa-edit"></i>
                        <span>修改消息</span>
                    </div>
                    <div class="menu-item delete" onclick="deleteOfflineMessage('${messageId}')">
                        <i class="fas fa-trash"></i>
                        <span>删除消息</span>
                    </div>
                    <div class="menu-item" onclick="regenerateOfflineMessage('${messageId}')">
                        <i class="fas fa-redo"></i>
                        <span>重新生成</span>
                    </div>
                `;
            }

            // 移除现有菜单
            const existingMenu = document.querySelector('.offline-message-menu');
            if (existingMenu) {
                existingMenu.remove();
            }

            // 🔥【修复】添加到线下模式容器内，而不是document.body
            const offlineContainer = document.getElementById('offline-mode-overlay');
            if (offlineContainer) {
                offlineContainer.appendChild(menu);
            } else {
                document.body.appendChild(menu);
            }

            // 🔥【修复】定位菜单 - 相对于线下模式容器定位
            const rect = event.target.getBoundingClientRect();
            const containerRect = offlineContainer ? offlineContainer.getBoundingClientRect() : { left: 0, top: 0 };

            // 计算相对于容器的位置
            const relativeLeft = rect.left - containerRect.left;
            const relativeTop = rect.top - containerRect.top;

            // 设置菜单样式
            menu.style.position = 'absolute';
            menu.style.zIndex = '10001';

            // 先添加到DOM以获取菜单尺寸
            setTimeout(() => {
                const menuWidth = menu.offsetWidth || 140;
                const menuHeight = menu.offsetHeight || 100;
                const containerWidth = offlineContainer?.offsetWidth || 400;
                const containerHeight = offlineContainer?.offsetHeight || 600;

                // 计算最佳位置，确保菜单在容器内
                let left = Math.min(relativeLeft, containerWidth - menuWidth - 10);
                let top = relativeTop - menuHeight - 5;

                // 如果上方空间不够，显示在下方
                if (top < 10) {
                    top = relativeTop + 30;
                }

                // 确保不超出容器边界
                left = Math.max(10, left);
                top = Math.max(10, Math.min(top, containerHeight - menuHeight - 10));

                menu.style.left = left + 'px';
                menu.style.top = top + 'px';
            }, 0);

            // 点击其他地方关闭菜单
            const closeMenu = (e) => {
                if (!menu.contains(e.target)) {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                }
            };
            setTimeout(() => {
                document.addEventListener('click', closeMenu);
            }, 100);
        }

        // 编辑线下模式消息
        function editOfflineMessage(messageId) {
            const message = offlineMessages.find(m => m.id === messageId);
            if (!message) return;

            // 创建编辑模态框
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'flex';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 500px;">
                    <div class="modal-header">
                        <h3>${message.sender === 'user' ? '编辑用户消息' : '编辑AI回复'}</h3>
                        <button class="modal-close" onclick="this.closest('.modal').remove()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="modal-body">
                        <textarea id="edit-offline-message-content" placeholder="请输入消息内容..." rows="4" style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px; resize: vertical;">${message.content}</textarea>
                        ${message.sender === 'ai' ? '<p style="color: #666; font-size: 12px; margin-top: 8px;">💡 提示：支持 &lt;span color="颜色"&gt;文本&lt;/span&gt; 和 *斜体* 格式</p>' : ''}
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">取消</button>
                        <button class="btn btn-primary" onclick="saveEditedOfflineMessage('${messageId}')">保存</button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // 🔥【修复】聚焦到文本框但不选中文本，光标移到末尾
            const textarea = modal.querySelector('#edit-offline-message-content');
            textarea.focus();
            textarea.setSelectionRange(textarea.value.length, textarea.value.length);

            // 移除菜单
            const menu = document.querySelector('.offline-message-menu');
            if (menu) menu.remove();
        }

        // 保存编辑的线下消息
        async function saveEditedOfflineMessage(messageId) {
            const textarea = document.getElementById('edit-offline-message-content');
            const newContent = textarea.value.trim();

            if (!newContent) {
                showToast('消息内容不能为空', 'warning');
                return;
            }

            const message = offlineMessages.find(m => m.id === messageId);
            if (message) {
                console.log('✏️ 编辑线下模式消息:', messageId, '新内容:', newContent);

                // 🔥【修复】同时更新主聊天记录中对应的记忆数据
                const characterId = currentChatCharacter.id;
                if (chatMessages[characterId]) {
                    const messageTimestamp = new Date(message.timestamp).getTime();

                    // 🔥【修改】查找并更新对应的消息（支持用户和AI消息）
                    chatMessages[characterId].forEach(msg => {
                        if (msg.isOfflineMode &&
                            ((msg.sender === 'sent' && message.sender === 'user') ||
                             (msg.sender === 'received' && message.sender === 'ai')) &&
                            Math.abs(msg.timestamp - messageTimestamp) < 5000) {
                            console.log('✏️ 更新记忆数据:', msg.content, '->', newContent);
                            msg.content = newContent;
                        }
                    });

                    // 保存更新后的聊天记录
                    await saveChatMessages(characterId);
                }

                // 更新线下模式显示的消息
                message.content = newContent;
                saveOfflineMessages();
                renderOfflineMessages();
                showToast('消息和记忆数据已更新', 'success');
            }

            // 关闭模态框
            const modal = document.querySelector('.modal');
            if (modal) modal.remove();
        }

        // 重新生成AI回复
        async function regenerateOfflineMessage(messageId) {
            const messageIndex = offlineMessages.findIndex(m => m.id === messageId);
            if (messageIndex === -1) return;

            const aiMessage = offlineMessages[messageIndex];
            if (aiMessage.sender !== 'ai') return;

            // 找到对应的用户消息
            let userMessageIndex = messageIndex - 1;
            while (userMessageIndex >= 0 && offlineMessages[userMessageIndex].sender !== 'user') {
                userMessageIndex--;
            }

            if (userMessageIndex < 0) {
                showToast('找不到对应的用户消息', 'error');
                return;
            }

            if (confirm('确定要重新生成这条AI回复吗？')) {
                console.log('🔄 重新生成AI回复:', messageId);

                // 删除当前AI回复
                await deleteOfflineMessage(messageId);

                // 🔥【新增】显示加载动画
                showOfflineLoadingMessage();

                // 重新生成AI回复
                try {
                    const userMessage = offlineMessages[userMessageIndex];
                    const aiResponse = await generateOfflineResponse(userMessage.content);

                    // 🔥【修复】将AI回复添加到主聊天记录中，保证时间线连贯性
                    const aiChatMessage = {
                        id: Date.now() + 1,
                        sender: 'received', // 使用标准的sender格式
                        content: aiResponse,
                        timestamp: Date.now() + 1,
                        type: 'text',
                        isOfflineMode: true // 标记为线下模式消息
                    };

                    const characterId = currentChatCharacter.id;
                    if (!chatMessages[characterId]) {
                        chatMessages[characterId] = [];
                    }
                    chatMessages[characterId].push(aiChatMessage);
                    // 🔥【高效保存】重新生成消息使用单条保存，避免强制同步
                    try {
                        const stableId = `${characterId}_regen_${aiChatMessage.timestamp}_${Math.random().toString(36).substr(2, 9)}_${chatMessages[characterId].length - 1}`;
                        await db.chatMessages.add({
                            id: stableId,
                            characterId: characterId,
                            timestamp: aiChatMessage.timestamp,
                            messageOrder: chatMessages[characterId].length - 1,
                            originalMessageId: aiChatMessage.id,
                            messageData: aiChatMessage
                        });
                        console.log('✅ [高效重新生成] 单条消息已保存到数据库');
                    } catch (error) {
                        console.error('重新生成消息单条保存失败，回退到批量保存:', error);
                        await saveChatMessages();
                    }

                    const newAiMessage = {
                        id: Date.now().toString(),
                        sender: 'ai',
                        content: aiResponse,
                        timestamp: new Date().toISOString()
                    };

                    offlineMessages.push(newAiMessage);

                    // 🔥【新增】移除加载动画并渲染消息
                    hideOfflineLoadingMessage();
                    renderOfflineMessages();
                    saveOfflineMessages();

                    showToast('AI回复已重新生成', 'success');

                } catch (error) {
                    console.error('重新生成AI回复失败:', error);
                    // 🔥【新增】出错时也要移除加载动画
                    hideOfflineLoadingMessage();
                    showToast('重新生成失败', 'error');
                }
            }
        }

        // 删除线下模式消息
        async function deleteOfflineMessage(messageId) {
            const messageIndex = offlineMessages.findIndex(m => m.id === messageId);
            if (messageIndex === -1) return;

            const message = offlineMessages[messageIndex];

            // 确认删除
            const confirmMessage = message.sender === 'user'
                ? '确定要删除这条消息吗？这将同时删除存储的记忆数据。'
                : '确定要删除这条AI回复吗？这将同时删除存储的记忆数据。';

            if (confirm(confirmMessage)) {
                console.log('🗑️ 开始删除线下模式消息:', messageId, '类型:', message.sender);

                // 🔥【修复】同时删除主聊天记录中对应的记忆数据
                const characterId = currentChatCharacter.id;
                if (chatMessages[characterId]) {
                    const offlineMessage = offlineMessages[messageIndex];
                    const messageTimestamp = new Date(offlineMessage.timestamp).getTime();

                    // 删除对应的记忆数据
                    const messagesToDelete = [];
                    chatMessages[characterId].forEach((msg, index) => {
                        if (msg.isOfflineMode && Math.abs(msg.timestamp - messageTimestamp) < 5000) {
                            messagesToDelete.push(index);
                        }
                    });

                    // 从后往前删除，避免索引变化
                    messagesToDelete.reverse().forEach(index => {
                        console.log('🗑️ 删除记忆数据:', chatMessages[characterId][index]);
                        chatMessages[characterId].splice(index, 1);
                    });

                    // 🔥【简化】不保存到数据库，只在内存中删除
                    // 线下模式的记忆数据已经在上面删除了，不需要额外的数据库操作
                }

                // 🔥【修复】删除线下模式显示的消息
                if (message.sender === 'user') {
                    // 删除用户消息
                    offlineMessages.splice(messageIndex, 1);

                    // 如果下一条是AI回复，也删除
                    if (messageIndex < offlineMessages.length &&
                        offlineMessages[messageIndex].sender === 'ai') {

                        // 同时删除AI回复的记忆数据
                        const aiMessage = offlineMessages[messageIndex];
                        const aiTimestamp = new Date(aiMessage.timestamp).getTime();
                        const aiMessagesToDelete = [];
                        chatMessages[characterId].forEach((msg, index) => {
                            if (msg.isOfflineMode && msg.sender === 'received' &&
                                Math.abs(msg.timestamp - aiTimestamp) < 5000) {
                                aiMessagesToDelete.push(index);
                            }
                        });

                        aiMessagesToDelete.reverse().forEach(index => {
                            console.log('🗑️ 删除AI回复记忆数据:', chatMessages[characterId][index]);
                            chatMessages[characterId].splice(index, 1);
                        });

                        offlineMessages.splice(messageIndex, 1);
                        // 🔥【简化】不保存到数据库，只在内存中删除
                    }
                } else {
                    // 删除AI消息
                    offlineMessages.splice(messageIndex, 1);
                }

                saveOfflineMessages();
                renderOfflineMessages();
                showToast('消息和记忆数据已删除', 'success');
            }

            // 移除菜单
            const menu = document.querySelector('.offline-message-menu');
            if (menu) menu.remove();
        }

        // 🔥【新增】显示线下模式AI回复加载动画
        function showOfflineLoadingMessage() {
            const container = document.getElementById('offline-chat-messages');

            // 移除已存在的加载动画（防止重复）
            const existingLoading = container.querySelector('.offline-loading-message');
            if (existingLoading) {
                existingLoading.remove();
            }

            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'offline-loading-message';
            loadingDiv.id = 'offline-loading-indicator';

            const contentDiv = document.createElement('div');
            contentDiv.className = 'offline-loading-content';

            const dotsDiv = document.createElement('div');
            dotsDiv.className = 'offline-loading-dots';

            // 创建三个加载点
            for (let i = 0; i < 3; i++) {
                const dot = document.createElement('div');
                dot.className = 'offline-loading-dot';
                dotsDiv.appendChild(dot);
            }

            contentDiv.appendChild(dotsDiv);
            loadingDiv.appendChild(contentDiv);
            container.appendChild(loadingDiv);

            // 滚动到底部
            container.scrollTop = container.scrollHeight;
        }

        // 🔥【新增】隐藏线下模式AI回复加载动画
        function hideOfflineLoadingMessage() {
            const loadingIndicator = document.getElementById('offline-loading-indicator');
            if (loadingIndicator) {
                loadingIndicator.remove();
            }
        }

        // 🔥【新增】通用加载模态框
        function showLoadingModal(title, subtitle) {
            const modalId = `loading-modal-${Date.now()}`;
            const modalHTML = `
                <div id="${modalId}" class="waiting-modal">
                    <div class="waiting-modal-content">
                        <div class="waiting-spinner"></div>
                        <p class="waiting-text">${title}</p>
                        ${subtitle ? `<p class="waiting-subtitle" style="font-size: 12px; color: #999; margin-top: 8px;">${subtitle}</p>` : ''}
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            return modalId;
        }

        // 🔥【新增】隐藏加载模态框
        function hideLoadingModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.remove();
            }
        }

        // 🔥【新增】线下模式文本格式化函数
        function formatOfflineText(text) {
            if (!text) return '';

            // 🔥【新增】先处理折叠标签，保护它们不被移除
            let formattedText = text;

            // 临时替换details和summary标签，避免被移除
            const detailsPlaceholders = [];
            formattedText = formattedText.replace(/<details[^>]*>[\s\S]*?<\/details>/gi, (match) => {
                const placeholder = `__DETAILS_PLACEHOLDER_${detailsPlaceholders.length}__`;
                detailsPlaceholders.push(match);
                return placeholder;
            });

            // 移除其他HTML标签，保留纯文本内容
            formattedText = formattedText
                .replace(/<p>/gi, '')
                .replace(/<\/p>/gi, '\n\n')
                .replace(/<br\s*\/?>/gi, '\n')
                .replace(/<[^>]*>/g, ''); // 移除所有其他HTML标签

            // 恢复details标签
            detailsPlaceholders.forEach((details, index) => {
                const placeholder = `__DETAILS_PLACEHOLDER_${index}__`;
                formattedText = formattedText.replace(placeholder, details);
            });

            // 处理**号包裹的加粗：**文本**
            formattedText = formattedText.replace(
                /\*\*([^*]+)\*\*/g,
                '<strong>$1</strong>'
            );

            // 处理*号包裹的斜体：*文本*
            formattedText = formattedText.replace(
                /\*([^*]+)\*/g,
                '<em>$1</em>'
            );

            // 处理换行
            formattedText = formattedText.replace(/\n/g, '<br>');

            // 清理多余的换行
            formattedText = formattedText.replace(/(<br>\s*){3,}/g, '<br><br>');

            return formattedText;
        }

        // 监听输入框回车事件
        document.addEventListener('DOMContentLoaded', function() {
            const offlineInput = document.getElementById('offline-input');
            if (offlineInput) {
                offlineInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendOfflineMessage();
                    }
                });
            }
        });

        // 🔥【新增】线下模式聊天记录管理功能

        // 保存聊天记录到历史记录
        async function saveOfflineHistoryRecord(summary, messages) {
            if (!currentChatCharacter || !messages || messages.length === 0) return;

            try {
                const historyRecord = {
                    id: `offline_history_${currentChatCharacter.id}_${Date.now()}`,
                    characterId: currentChatCharacter.id,
                    timestamp: Date.now(),
                    summary: summary,
                    messages: messages,
                    messageCount: messages.length
                };

                // 保存到 Dexie 数据库
                await db.offlineHistoryRecords.add(historyRecord);

                // 🔥【新增】清理超过20条的旧记录
                const allRecords = await db.offlineHistoryRecords
                    .where('characterId')
                    .equals(currentChatCharacter.id)
                    .reverse()
                    .sortBy('timestamp');

                if (allRecords.length > 20) {
                    const recordsToDelete = allRecords.slice(20);
                    for (const record of recordsToDelete) {
                        await db.offlineHistoryRecords.delete(record.id);
                    }
                }

                console.log('📚 线下模式聊天记录已保存到数据库:', historyRecord);
            } catch (error) {
                console.error('保存线下模式聊天记录失败:', error);
            }
        }

        // 显示线下模式聊天记录模态框
        function showOfflineHistoryModal() {
            if (!currentChatCharacter) return;

            document.getElementById('offline-history-modal').style.display = 'flex';
            loadOfflineHistoryList();
        }

        // 关闭线下模式聊天记录模态框
        function closeOfflineHistoryModal() {
            document.getElementById('offline-history-modal').style.display = 'none';
        }

        // 加载并显示聊天记录列表
        async function loadOfflineHistoryList() {
            if (!currentChatCharacter) return;

            try {
                const historyRecords = await db.offlineHistoryRecords
                    .where('characterId')
                    .equals(currentChatCharacter.id)
                    .reverse()
                    .sortBy('timestamp');

                const container = document.getElementById('offline-history-list');
                container.innerHTML = '';

                if (historyRecords.length === 0) {
                    container.innerHTML = `
                        <div class="empty-history">
                            <i class="fas fa-history" style="font-size: 48px; color: #ccc; margin-bottom: 15px;"></i>
                            <p>还没有线下模式聊天记录</p>
                            <p style="font-size: 12px; color: #999;">完成线下剧情对话后，选择"结束且不总结"或"结束并总结"，聊天记录会保存在这里</p>
                        </div>
                    `;
                    return;
                }

                historyRecords.forEach((record, index) => {
                    const recordElement = document.createElement('div');
                    recordElement.className = 'history-record-item';
                    const date = new Date(record.timestamp).toLocaleDateString();
                    recordElement.innerHTML = `
                        <div class="history-record-header">
                            <div class="history-record-info">
                                <div class="history-record-title">剧情记录 #${historyRecords.length - index}</div>
                                <div class="history-record-meta">${date} • ${record.messageCount}条消息</div>
                            </div>
                            <div class="history-record-actions">
                                <button class="history-action-btn" onclick="viewOfflineHistory('${record.id}')" title="查看详情">
                                    <i class="fas fa-eye"></i>
                                </button>
                                <button class="history-action-btn delete" onclick="deleteOfflineHistory('${record.id}')" title="删除记录">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </div>
                        <div class="history-record-summary">${record.summary.substring(0, 100)}${record.summary.length > 100 ? '...' : ''}</div>
                    `;
                    container.appendChild(recordElement);
                });
            } catch (error) {
                console.error('加载线下模式聊天记录失败:', error);
            }
        }

        // 查看具体的聊天记录
        async function viewOfflineHistory(recordId) {
            if (!currentChatCharacter) return;

            try {
                const record = await db.offlineHistoryRecords.get(recordId);

                if (!record) {
                    showToast('找不到该聊天记录', 'error');
                    return;
                }

            // 创建查看详情的模态框
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'flex';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 600px; max-height: 80vh;">
                    <div class="modal-header">
                        <h3>剧情记录详情</h3>
                        <button class="modal-close" onclick="this.closest('.modal').remove()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="modal-body" style="overflow-y: auto;">
                        <div class="history-detail-info">
                            <p><strong>日期：</strong>${record.date}</p>
                            <p><strong>消息数：</strong>${record.messageCount}条</p>
                            <p><strong>剧情总结：</strong></p>
                            <div class="history-summary-text">${record.summary}</div>
                        </div>
                        <hr style="margin: 20px 0;">
                        <div class="history-messages">
                            <h4>对话记录：</h4>
                            <div class="history-messages-container">
                                ${record.messages.map(msg => `
                                    <div class="history-message ${msg.sender}">
                                        <div class="message-sender">${msg.sender === 'user' ? '用户' : currentChatCharacter.name}</div>
                                        <div class="message-content">${msg.content}</div>
                                        <div class="message-time">${new Date(msg.timestamp).toLocaleTimeString()}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">关闭</button>
                    </div>
                </div>
            `;

                document.body.appendChild(modal);
            } catch (error) {
                console.error('查看线下模式聊天记录失败:', error);
                showToast('查看聊天记录失败', 'error');
            }
        }

        // 删除单个聊天记录
        async function deleteOfflineHistory(recordId) {
            if (!confirm('确定要删除这条聊天记录吗？此操作不可撤销。')) return;
            if (!currentChatCharacter) return;

            try {
                await db.offlineHistoryRecords.delete(recordId);
                loadOfflineHistoryList(); // 重新加载列表
                showToast('聊天记录已删除', 'success');
            } catch (error) {
                console.error('删除线下模式聊天记录失败:', error);
                showToast('删除聊天记录失败', 'error');
            }
        }

        // 清空所有聊天记录
        async function clearAllOfflineHistory() {
            if (!confirm('确定要清空所有线下模式聊天记录吗？此操作不可撤销。')) return;
            if (!currentChatCharacter) return;

            try {
                await db.offlineHistoryRecords
                    .where('characterId')
                    .equals(currentChatCharacter.id)
                    .delete();
                loadOfflineHistoryList(); // 重新加载列表
                showToast('所有聊天记录已清空', 'success');
            } catch (error) {
                console.error('清空线下模式聊天记录失败:', error);
                showToast('清空聊天记录失败', 'error');
            }
        }

        // 🔥【新增】线下模式界面设置功能
        let offlineUISettings = {};

        // 🔥【新增】预加载所有角色的线下模式设置，确保刷新后不丢失
        async function preloadOfflineUISettings() {
            try {
                console.log('🔄 开始预加载线下模式设置...');

                // 从数据库加载所有线下模式设置
                const allSettings = await db.offlineUISettings.toArray();
                console.log(`📦 从数据库加载了 ${allSettings.length} 个线下模式设置`);

                // 如果数据库中没有设置，尝试从localStorage迁移
                if (allSettings.length === 0) {
                    console.log('🔄 数据库中无设置，尝试从localStorage迁移...');

                    // 检查localStorage中的线下模式设置
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith('offlineUISettings_')) {
                            try {
                                const settingsData = localStorage.getItem(key);
                                if (settingsData) {
                                    const parsedSettings = JSON.parse(settingsData);

                                    // 提取角色ID
                                    const characterId = key.replace('offlineUISettings_', '').split('_')[0];

                                    // 迁移到数据库
                                    const dbKey = `${characterId}_ui_settings`;
                                    await db.offlineUISettings.put({
                                        id: dbKey,
                                        characterId: characterId,
                                        windowId: null,
                                        settings: parsedSettings,
                                        timestamp: Date.now()
                                    });

                                    console.log(`✅ 已迁移角色 ${characterId} 的线下模式设置到数据库`);
                                }
                            } catch (error) {
                                console.warn(`⚠️ 迁移设置失败 (${key}):`, error);
                            }
                        }
                    }
                }

                console.log('✅ 线下模式设置预加载完成');
            } catch (error) {
                console.error('❌ 预加载线下模式设置失败:', error);
            }
        }

        // 显示线下模式界面设置
        function showOfflineUISettings() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'warning');
                return;
            }

            document.getElementById('offline-ui-settings-modal').style.display = 'flex';
            loadOfflineUISettings();
        }

        // 关闭线下模式界面设置
        function closeOfflineUISettings() {
            document.getElementById('offline-ui-settings-modal').style.display = 'none';
        }

        // 加载线下模式界面设置
        async function loadOfflineUISettings() {
            if (!currentChatCharacter) return;

            const characterId = currentChatCharacter.id;

            try {
                // 🔥【修复】保持窗口隔离的同时增强手机浏览器兼容性
                let settingsRecord = null;
                let loadedFromDB = false;

                // 首先尝试从数据库加载带窗口ID的设置（保持隔离）
                if (windowId) {
                    try {
                        settingsRecord = await db.offlineUISettings.get(`${characterId}_${windowId}_ui_settings`);
                        if (settingsRecord && settingsRecord.settings) {
                            loadedFromDB = true;
                            console.log(`✅ 从数据库加载窗口隔离设置成功 (窗口${windowId})`);
                        }
                    } catch (dbError) {
                        console.warn('数据库加载窗口隔离设置失败:', dbError);
                    }
                }

                // 如果窗口隔离设置加载失败，尝试通用格式（兼容性回退）
                if (!loadedFromDB) {
                    try {
                        settingsRecord = await db.offlineUISettings.get(`${characterId}_ui_settings`);
                        if (settingsRecord && settingsRecord.settings) {
                            loadedFromDB = true;
                            console.log(`✅ 从数据库加载通用格式设置成功（回退模式）`);
                        }
                    } catch (dbError) {
                        console.warn('数据库加载通用格式设置也失败:', dbError);
                    }
                }

                // 如果数据库加载失败，立即尝试localStorage
                if (!loadedFromDB) {
                    try {
                        let savedSettings = null;
                        let storageKey = null;

                        // 优先尝试带窗口ID的设置（保持隔离）
                        if (windowId) {
                            storageKey = `offlineUISettings_${characterId}_${windowId}`;
                            savedSettings = localStorage.getItem(storageKey);
                        }

                        // 如果窗口隔离设置不存在，尝试通用格式（兼容性回退）
                        if (!savedSettings) {
                            storageKey = `offlineUISettings_${characterId}`;
                            savedSettings = localStorage.getItem(storageKey);
                        }

                        if (savedSettings) {
                            const parsedSettings = JSON.parse(savedSettings);
                            settingsRecord = { settings: parsedSettings };
                            console.log(`✅ 从localStorage加载设置成功 (${storageKey})`);

                            // 🔥【增强】异步迁移到数据库，优先保存为窗口隔离格式
                            setTimeout(async () => {
                                try {
                                    const dbKey = windowId ? `${characterId}_${windowId}_ui_settings` : `${characterId}_ui_settings`;
                                    await db.offlineUISettings.put({
                                        id: dbKey,
                                        characterId: characterId,
                                        windowId: windowId || null,
                                        settings: parsedSettings,
                                        timestamp: Date.now()
                                    });
                                    console.log(`✅ 设置已异步迁移到数据库 (${dbKey})`);
                                } catch (migrateError) {
                                    console.warn('异步迁移失败，但不影响当前使用:', migrateError);
                                }
                            }, 100);
                        }
                    } catch (localStorageError) {
                        console.warn('localStorage加载也失败:', localStorageError);
                    }
                }

                if (settingsRecord && settingsRecord.settings) {
                    offlineUISettings = settingsRecord.settings;
                    console.log(`✅ 线下模式界面设置加载成功`);
                } else {
                    console.log(`📝 未找到设置，使用默认设置`);
                    // 默认设置
                    offlineUISettings = {
                        myBubbleColor: '#BED6EF', /* 🔥【修改】用户气泡改为淡蓝色 */
                        aiBubbleColor: '#f0f0f0',
                        bubbleOpacity: 0.9,
                        fontSize: 15,
                        wallpaperData: '',
                        fontFamily: '',
                        fontUrl: '',
                        userNormalTextColor: '#000000', /* 🔥【修改】用户文字改为黑色 */
                        userItalicTextColor: '#333333', /* 🔥【修改】用户斜体文字改为深灰色 */
                        userBoldTextColor: '#000000', /* 🔥【修改】用户粗体文字改为黑色 */
                        aiNormalTextColor: '#000000',
                        aiItalicTextColor: '#666666',
                        aiBoldTextColor: '#333333',
                        showUserAvatar: false, /* 🔥【修改】默认不显示用户头像 */
                        showAiAvatar: false, /* 🔥【修改】默认不显示AI头像 */
                        avatarPosition: 'side',
                        bubbleWidth: 'default',
                        bubbleStyle: 'default',
                        customCSS: '',
                        savedColors: {
                            userNormal: [],
                            userItalic: [],
                            userBold: [],
                            aiNormal: [],
                            aiItalic: [],
                            aiBold: []
                        }
                    };
                }

                // 更新界面
                updateOfflineUISettingsForm();
                updateOfflinePreview();

            } catch (error) {
                console.error('加载线下模式界面设置完全失败:', error);
                // 🔥【增强】即使完全失败也要确保有默认设置
                offlineUISettings = {
                    myBubbleColor: '#BED6EF', /* 🔥【修改】用户气泡改为淡蓝色 */
                    aiBubbleColor: '#f0f0f0',
                    bubbleOpacity: 0.9,
                    fontSize: 15,
                    wallpaperData: '',
                    fontFamily: '',
                    fontUrl: '',
                    userNormalTextColor: '#000000', /* 🔥【修改】用户文字改为黑色 */
                    userItalicTextColor: '#333333', /* 🔥【修改】用户斜体文字改为深灰色 */
                    userBoldTextColor: '#000000', /* 🔥【修改】用户粗体文字改为黑色 */
                    aiNormalTextColor: '#000000',
                    aiItalicTextColor: '#666666',
                    aiBoldTextColor: '#333333',
                    showUserAvatar: false, /* 🔥【修改】默认不显示用户头像 */
                    showAiAvatar: false, /* 🔥【修改】默认不显示AI头像 */
                    avatarPosition: 'side',
                    bubbleWidth: 'default',
                    bubbleStyle: 'default',
                    customCSS: '',
                    savedColors: {
                        userNormal: [],
                        userItalic: [],
                        userBold: [],
                        aiNormal: [],
                        aiItalic: [],
                        aiBold: []
                    }
                };
                updateOfflineUISettingsForm();
                updateOfflinePreview();
            }
        }

        // 更新设置表单
        function updateOfflineUISettingsForm() {
            document.getElementById('offline-my-bubble-color').value = offlineUISettings.myBubbleColor;
            document.getElementById('offline-ai-bubble-color').value = offlineUISettings.aiBubbleColor;
            document.getElementById('offline-bubble-opacity').value = offlineUISettings.bubbleOpacity;
            document.getElementById('offline-opacity-value').textContent = Math.round(offlineUISettings.bubbleOpacity * 100) + '%';

            // 🔥【新增】设置字体大小
            document.getElementById('offline-font-size').value = offlineUISettings.fontSize || 15;
            document.getElementById('offline-font-size-value').textContent = (offlineUISettings.fontSize || 15) + 'px';

            // 设置字体选择
            document.getElementById('offline-font-select').value = offlineUISettings.fontFamily || '';
            if (offlineUISettings.fontFamily === 'custom') {
                document.getElementById('custom-font-input').style.display = 'block';
                document.getElementById('offline-font-url').value = offlineUISettings.fontUrl || '';
            } else {
                document.getElementById('custom-font-input').style.display = 'none';
            }

            // 设置文字颜色（确保有默认值）
            document.getElementById('offline-user-normal-text-color').value = offlineUISettings.userNormalTextColor || '#ffffff';
            document.getElementById('offline-user-italic-text-color').value = offlineUISettings.userItalicTextColor || '#f0f0f0';
            document.getElementById('offline-user-bold-text-color').value = offlineUISettings.userBoldTextColor || '#ffffff';
            document.getElementById('offline-ai-normal-text-color').value = offlineUISettings.aiNormalTextColor || '#000000';
            document.getElementById('offline-ai-italic-text-color').value = offlineUISettings.aiItalicTextColor || '#666666';
            document.getElementById('offline-ai-bold-text-color').value = offlineUISettings.aiBoldTextColor || '#333333';

            // 设置头像和样式选项
            document.getElementById('offline-show-user-avatar').checked = offlineUISettings.showUserAvatar === true;
            document.getElementById('offline-show-ai-avatar').checked = offlineUISettings.showAiAvatar === true;

            // 设置单选按钮
            const avatarPosition = offlineUISettings.avatarPosition || 'side';
            document.querySelector(`input[name="offline-avatar-position"][value="${avatarPosition}"]`).checked = true;

            const bubbleWidth = offlineUISettings.bubbleWidth || 'default';
            document.querySelector(`input[name="offline-bubble-width"][value="${bubbleWidth}"]`).checked = true;

            const bubbleStyle = offlineUISettings.bubbleStyle || 'default';
            document.querySelector(`input[name="offline-bubble-style"][value="${bubbleStyle}"]`).checked = true;

            // 设置自定义CSS
            document.getElementById('offline-custom-css').value = offlineUISettings.customCSS || '';

            // 更新预存颜色
            updateSavedColorsDisplay();

            // 监听透明度滑块变化
            const opacitySlider = document.getElementById('offline-bubble-opacity');
            opacitySlider.oninput = function() {
                const value = Math.round(this.value * 100);
                document.getElementById('offline-opacity-value').textContent = value + '%';
                updateOfflinePreview();
            };

            // 🔥【新增】监听字体大小滑块变化
            const fontSizeSlider = document.getElementById('offline-font-size');
            fontSizeSlider.oninput = function() {
                const value = this.value;
                document.getElementById('offline-font-size-value').textContent = value + 'px';
                updateOfflinePreview();
            };

            // 监听颜色输入变化
            ['offline-my-bubble-color', 'offline-ai-bubble-color',
             'offline-user-normal-text-color', 'offline-user-italic-text-color', 'offline-user-bold-text-color',
             'offline-ai-normal-text-color', 'offline-ai-italic-text-color', 'offline-ai-bold-text-color'].forEach(id => {
                document.getElementById(id).oninput = updateOfflinePreview;
            });

            // 监听头像和样式设置变化
            document.getElementById('offline-show-user-avatar').onchange = updateOfflinePreview;
            document.getElementById('offline-show-ai-avatar').onchange = updateOfflinePreview;

            document.querySelectorAll('input[name="offline-avatar-position"]').forEach(radio => {
                radio.onchange = updateOfflinePreview;
            });

            document.querySelectorAll('input[name="offline-bubble-width"]').forEach(radio => {
                radio.onchange = updateOfflinePreview;
            });

            document.querySelectorAll('input[name="offline-bubble-style"]').forEach(radio => {
                radio.onchange = updateOfflinePreview;
            });

            // 监听单选按钮变化，控制相关功能
            document.querySelectorAll('input[name="offline-avatar-position"]').forEach(radio => {
                radio.onchange = function() {
                    if (this.value === 'custom') {
                        showToast('请在下方CSS代码区域自定义头像位置', 'info');
                    }
                };
            });

            document.querySelectorAll('input[name="offline-bubble-width"]').forEach(radio => {
                radio.onchange = function() {
                    if (this.value === 'custom') {
                        showToast('请在下方CSS代码区域自定义气泡宽度', 'info');
                    } else {
                        // 应用默认90%宽度
                        applyDefaultBubbleWidth();
                    }
                };
            });

            document.querySelectorAll('input[name="offline-bubble-style"]').forEach(radio => {
                radio.onchange = function() {
                    if (this.value === 'custom') {
                        showToast('请在下方CSS代码区域自定义气泡样式', 'info');
                    } else {
                        // 应用默认样式
                        applyDefaultBubbleStyle();
                    }
                };
            });
        }

        // 应用默认气泡宽度
        function applyDefaultBubbleWidth() {
            // 移除自定义宽度样式，恢复CSS规则控制
            const existingStyle = document.getElementById('offline-custom-width-style');
            if (existingStyle) {
                existingStyle.remove();
            }

            showToast('已恢复默认气泡宽度（根据头像显示状态自动调整）', 'success');
        }

        // 应用默认气泡样式
        function applyDefaultBubbleStyle() {
            // 移除自定义样式
            const existingStyle = document.getElementById('offline-custom-style-style');
            if (existingStyle) {
                existingStyle.remove();
            }

            // 应用默认样式（这里可以根据需要添加默认样式）
            showToast('已应用默认气泡样式', 'success');
        }

        // 更新预存颜色显示
        function updateSavedColorsDisplay() {
            const types = ['userNormal', 'userItalic', 'userBold', 'aiNormal', 'aiItalic', 'aiBold'];
            const typeMapping = {
                'userNormal': 'offline-user-normal',
                'userItalic': 'offline-user-italic',
                'userBold': 'offline-user-bold',
                'aiNormal': 'offline-ai-normal',
                'aiItalic': 'offline-ai-italic',
                'aiBold': 'offline-ai-bold'
            };

            types.forEach(type => {
                const container = document.getElementById(`${typeMapping[type]}-saved-colors`);
                if (container) {
                    container.innerHTML = '';

                    if (offlineUISettings.savedColors[type]) {
                        offlineUISettings.savedColors[type].forEach(color => {
                            const colorItem = document.createElement('div');
                            colorItem.className = 'saved-color-item';
                            colorItem.style.backgroundColor = color;
                            colorItem.title = color;
                            colorItem.onclick = () => {
                                document.getElementById(`${typeMapping[type]}-text-color`).value = color;
                                updateOfflinePreview();
                            };
                            container.appendChild(colorItem);
                        });
                    }
                }
            });
        }

        // 更新预览效果
        function updateOfflinePreview() {
            const myBubbleColor = document.getElementById('offline-my-bubble-color').value;
            const aiBubbleColor = document.getElementById('offline-ai-bubble-color').value;
            const bubbleOpacity = document.getElementById('offline-bubble-opacity').value;

            const userNormalTextColor = document.getElementById('offline-user-normal-text-color').value;
            const userItalicTextColor = document.getElementById('offline-user-italic-text-color').value;
            const userBoldTextColor = document.getElementById('offline-user-bold-text-color').value;

            const aiNormalTextColor = document.getElementById('offline-ai-normal-text-color').value;
            const aiItalicTextColor = document.getElementById('offline-ai-italic-text-color').value;
            const aiBoldTextColor = document.getElementById('offline-ai-bold-text-color').value;

            // 更新CSS变量
            const root = document.documentElement;
            root.style.setProperty('--offline-my-bubble-color', myBubbleColor);
            root.style.setProperty('--offline-ai-bubble-color', aiBubbleColor);
            root.style.setProperty('--offline-user-normal-text-color', userNormalTextColor);
            root.style.setProperty('--offline-user-italic-text-color', userItalicTextColor);
            root.style.setProperty('--offline-user-bold-text-color', userBoldTextColor);
            root.style.setProperty('--offline-ai-normal-text-color', aiNormalTextColor);
            root.style.setProperty('--offline-ai-italic-text-color', aiItalicTextColor);
            root.style.setProperty('--offline-ai-bold-text-color', aiBoldTextColor);

            // 更新预览区域
            const userBubble = document.querySelector('.offline-preview-message.user .offline-preview-content');
            const aiBubble = document.querySelector('.offline-preview-message.ai .offline-preview-content');

            if (userBubble) {
                // 使用rgba背景色，只让背景透明，文字保持不透明
                const userBgColor = convertColorWithOpacity(myBubbleColor, bubbleOpacity);
                userBubble.style.backgroundColor = userBgColor;
                userBubble.style.opacity = 1; // 确保整个元素不透明
                userBubble.style.color = userNormalTextColor;

                // 更新用户消息的斜体和加粗文字颜色
                const userItalicText = userBubble.querySelector('em');
                const userBoldText = userBubble.querySelector('strong');
                if (userItalicText) userItalicText.style.color = userItalicTextColor;
                if (userBoldText) userBoldText.style.color = userBoldTextColor;
            }

            if (aiBubble) {
                // 使用rgba背景色，只让背景透明，文字保持不透明
                const aiBgColor = convertColorWithOpacity(aiBubbleColor, bubbleOpacity);
                aiBubble.style.backgroundColor = aiBgColor;
                aiBubble.style.opacity = 1; // 确保整个元素不透明
                aiBubble.style.color = aiNormalTextColor;

                // 更新AI消息的斜体和加粗文字颜色
                const aiItalicText = aiBubble.querySelector('em');
                const aiBoldText = aiBubble.querySelector('strong');
                if (aiItalicText) aiItalicText.style.color = aiItalicTextColor;
                if (aiBoldText) aiBoldText.style.color = aiBoldTextColor;
            }

            // 更新头像显示
            const showUserAvatar = document.getElementById('offline-show-user-avatar').checked;
            const showAiAvatar = document.getElementById('offline-show-ai-avatar').checked;
            const userAvatar = document.getElementById('preview-user-avatar');
            const aiAvatar = document.getElementById('preview-ai-avatar');

            // 获取预览消息容器
            const allPreviewMessages = document.querySelectorAll('.offline-preview-message');

            // 清除所有相关的类
            allPreviewMessages.forEach(container => {
                container.classList.remove('no-user-avatar', 'no-ai-avatar');
            });

            if (userAvatar) {
                userAvatar.style.display = showUserAvatar ? 'flex' : 'none';
            }
            if (aiAvatar) {
                aiAvatar.style.display = showAiAvatar ? 'flex' : 'none';
            }

            // 🔥【修正】根据头像显示状态添加对应的类
            allPreviewMessages.forEach(container => {
                if (!showUserAvatar) {
                    container.classList.add('no-user-avatar');
                }
                if (!showAiAvatar) {
                    container.classList.add('no-ai-avatar');
                }
            });

            // 更新气泡宽度
            const bubbleWidth = document.querySelector('input[name="offline-bubble-width"]:checked').value;
            const avatarPosition = document.querySelector('input[name="offline-avatar-position"]:checked').value;
            const bubbleStyle = document.querySelector('input[name="offline-bubble-style"]:checked').value;

            const previewContents = document.querySelectorAll('.offline-preview-content');
            const previewMessages = document.querySelectorAll('.offline-preview-message');

            // 应用气泡宽度
            previewContents.forEach(content => {
                if (bubbleWidth === 'default') {
                    // 清除内联样式，让CSS规则自动处理宽度（根据头像显示状态）
                    content.style.maxWidth = '';
                } else {
                    // 自定义CSS控制时，如果有CSS代码则应用，否则保持当前样式
                    const customCSS = document.getElementById('offline-custom-css').value.trim();
                    if (customCSS) {
                        // CSS代码会通过预览功能应用
                    }
                }
            });

            // 应用头像位置
            previewMessages.forEach(message => {
                if (avatarPosition === 'side') {
                    // 恢复默认侧边布局
                    if (message.classList.contains('user')) {
                        message.style.flexDirection = 'row-reverse';
                    } else {
                        message.style.flexDirection = 'row';
                    }
                } else {
                    // 自定义CSS控制时，移除内联样式让CSS代码生效
                    message.style.flexDirection = '';
                }
            });
        }

        // 处理壁纸上传
        function handleOfflineWallpaperUpload(input) {
            const file = input.files[0];
            if (!file) return;

            // 检查文件类型
            if (!file.type.startsWith('image/')) {
                showToast('请选择图片文件', 'warning');
                input.value = '';
                return;
            }

            // 检查文件大小（限制为5MB）
            if (file.size > 5 * 1024 * 1024) {
                showToast('图片文件不能超过5MB', 'warning');
                input.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const imageData = e.target.result;

                // 预览壁纸
                const previewArea = document.getElementById('offline-preview-area');
                previewArea.style.backgroundImage = `url(${imageData})`;
                previewArea.style.backgroundSize = 'cover';
                previewArea.style.backgroundPosition = 'center';

                // 保存到设置中
                offlineUISettings.wallpaperData = imageData;

                showToast('壁纸已上传并预览', 'success');
            };
            reader.readAsDataURL(file);
        }

        // 清除壁纸
        function clearOfflineWallpaper() {
            document.getElementById('offline-wallpaper-file').value = '';
            const previewArea = document.getElementById('offline-preview-area');
            previewArea.style.backgroundImage = '';
            offlineUISettings.wallpaperData = '';
            showToast('壁纸已清除', 'success');
        }

        // 处理字体选择变化
        function handleOfflineFontChange() {
            const fontSelect = document.getElementById('offline-font-select');
            const customInput = document.getElementById('custom-font-input');

            if (fontSelect.value === 'custom') {
                customInput.style.display = 'block';
            } else {
                customInput.style.display = 'none';
                // 应用内置字体
                applyBuiltinFont(fontSelect.value);
            }
        }

        // 应用内置字体
        function applyBuiltinFont(fontName) {
            // 清除自定义字体样式，恢复默认字体
            const existingStyle = document.getElementById('offline-custom-font-style');
            if (existingStyle) {
                existingStyle.remove();
            }

            if (fontName) {
                showToast(`已恢复系统默认字体`, 'success');
            }
        }

        // 预览自定义CSS
        function previewOfflineCSS() {
            const cssCode = document.getElementById('offline-custom-css').value.trim();

            // 移除之前的预览样式
            const existingStyle = document.getElementById('offline-custom-css-preview');
            if (existingStyle) {
                existingStyle.remove();
            }

            if (!cssCode) {
                showToast('请输入CSS代码', 'warning');
                return;
            }

            try {
                // 创建样式元素
                const style = document.createElement('style');
                style.id = 'offline-custom-css-preview';

                // 为CSS代码添加作用域，只影响预览区域
                const scopedCSS = cssCode.replace(/\.offline-/g, '.offline-preview-area .offline-');
                style.textContent = scopedCSS;

                document.head.appendChild(style);
                showToast('CSS预览已应用', 'success');

            } catch (error) {
                console.error('CSS预览失败:', error);
                showToast('CSS代码有误，请检查语法', 'error');
            }
        }

        // 清除自定义CSS
        function clearOfflineCSS() {
            document.getElementById('offline-custom-css').value = '';

            // 移除预览样式
            const existingStyle = document.getElementById('offline-custom-css-preview');
            if (existingStyle) {
                existingStyle.remove();
            }

            showToast('CSS代码已清除', 'success');
        }

        // 预览字体
        function previewOfflineFont() {
            const url = document.getElementById('offline-font-url').value.trim();
            if (!url) {
                showToast('请输入字体URL', 'warning');
                return;
            }

            // 清除之前的字体样式
            const existingStyle = document.getElementById('offline-custom-font-style');
            if (existingStyle) {
                existingStyle.remove();
            }
            const existingLink = document.getElementById('offline-custom-font-link');
            if (existingLink) {
                existingLink.remove();
            }

            // 判断是CSS链接还是直接字体文件
            if (url.includes('fonts.googleapis.com') || url.includes('fonts.google.com') || url.endsWith('.css') || url.includes('fontsapi') || url.includes('css')) {
                // Google Fonts或其他CSS链接
                console.log('🎨 开始加载字体CSS:', url);
                const link = document.createElement('link');
                link.id = 'offline-custom-font-link';
                link.rel = 'stylesheet';
                link.href = url;
                link.crossOrigin = 'anonymous'; // 🔥【新增】添加跨域支持
                link.onload = function() {
                    // 🔥【修复】尝试从CSS中提取字体名称，或使用通用名称
                    let fontFamily = extractFontFamilyFromGoogleFonts(url) || 'CustomFont';
                    console.log('🎨 字体CSS加载成功，提取的字体名称:', fontFamily);
                    console.log('🎨 字体URL:', url);

                    // 🔥【新增】尝试从加载的CSS中提取真正的字体名称
                    try {
                        const sheets = document.styleSheets;
                        for (let i = sheets.length - 1; i >= 0; i--) {
                            const sheet = sheets[i];
                            if (sheet.href === url) {
                                try {
                                    const rules = sheet.cssRules || sheet.rules;
                                    for (let j = 0; j < rules.length; j++) {
                                        const rule = rules[j];
                                        if (rule.type === CSSRule.FONT_FACE_RULE && rule.style.fontFamily) {
                                            fontFamily = rule.style.fontFamily.replace(/['"]/g, '');
                                            console.log('🎨 从CSS中提取到真实字体名称:', fontFamily);
                                            break;
                                        }
                                    }
                                } catch (e) {
                                    console.log('🎨 无法读取CSS规则，使用提取的名称');
                                }
                                break;
                            }
                        }
                    } catch (e) {
                        console.log('🎨 CSS解析失败，使用提取的名称');
                    }

                    const style = document.createElement('style');
                    style.id = 'offline-custom-font-style';
                    style.textContent = `
                        .offline-preview-content,
                        #offline-mode-overlay .offline-message-content {
                            font-family: '${fontFamily}', sans-serif !important;
                        }
                    `;
                    document.head.appendChild(style);
                    console.log('🎨 字体样式已应用到页面，最终字体名称:', fontFamily);

                    // 🔥【新增】保存真实的字体名称到全局变量，供保存设置时使用
                    window.previewedFontName = fontFamily;

                    // 🔥【新增】验证字体是否真的被应用
                    setTimeout(() => {
                        const testElement = document.querySelector('#offline-mode-overlay .offline-message-content');
                        if (testElement) {
                            const computedStyle = window.getComputedStyle(testElement);
                            console.log('🎨 实际应用的字体:', computedStyle.fontFamily);
                        }
                    }, 1000);

                    showToast(`字体CSS已加载，字体名称: ${fontFamily}`, 'success');
                };
                link.onerror = function() {
                    console.error('🎨 字体CSS加载失败:', url);
                    showToast('字体CSS加载失败，请检查URL', 'error');
                };
                document.head.appendChild(link);
            } else {
                // 直接字体文件
                const fontName = 'OfflineCustomFont';
                const style = document.createElement('style');
                style.id = 'offline-custom-font-style';
                style.textContent = `
                    @font-face {
                        font-family: '${fontName}';
                        src: url('${url}');
                    }
                    .offline-preview-content,
                    #offline-mode-overlay .offline-message-content {
                        font-family: '${fontName}', sans-serif !important;
                    }
                `;
                document.head.appendChild(style);
                showToast('字体文件预览已应用', 'success');
            }
        }

        // 从Google Fonts URL中提取字体名称
        function extractFontFamilyFromGoogleFonts(url) {
            try {
                // Google Fonts: 匹配 family= 参数
                const match = url.match(/family=([^&:]+)/);
                if (match) {
                    let fontName = decodeURIComponent(match[1]);
                    // 替换 + 为空格，移除权重信息（如 :300,400,700）
                    fontName = fontName.replace(/\+/g, ' ').replace(/:.*$/, '');
                    return fontName;
                }

                // 如果是新版Google Fonts API格式，尝试其他匹配方式
                const match2 = url.match(/family=([^&]+)/);
                if (match2) {
                    let fontName = decodeURIComponent(match2[1]);
                    fontName = fontName.replace(/\+/g, ' ').split(':')[0];
                    return fontName;
                }

                // 🔥【新增】其他字体服务：尝试从URL路径中提取
                const pathMatch = url.match(/\/([^\/]+)\.css/);
                if (pathMatch) {
                    return pathMatch[1].replace(/[-_]/g, ' ');
                }

                // 🔥【新增】尝试从URL中提取数字ID或名称
                const idMatch = url.match(/\/(\d+)\//);
                if (idMatch) {
                    return `CustomFont-${idMatch[1]}`;
                }

                // 🔥【新增】从域名提取服务名称
                const domainMatch = url.match(/\/\/([^.]+)/);
                if (domainMatch) {
                    return `${domainMatch[1]}-Font`;
                }
            } catch (e) {
                console.warn('无法提取字体名称:', e);
            }
            return 'CustomFont'; // 默认字体名称
        }

        // 清除字体
        function clearOfflineFont() {
            document.getElementById('offline-font-url').value = '';
            const existingStyle = document.getElementById('offline-custom-font-style');
            if (existingStyle) {
                existingStyle.remove();
            }
            showToast('字体已清除', 'success');
        }

        // 保存当前颜色到预存
        function saveCurrentOfflineColors() {
            const userNormalColor = document.getElementById('offline-user-normal-text-color').value;
            const userItalicColor = document.getElementById('offline-user-italic-text-color').value;
            const userBoldColor = document.getElementById('offline-user-bold-text-color').value;
            const aiNormalColor = document.getElementById('offline-ai-normal-text-color').value;
            const aiItalicColor = document.getElementById('offline-ai-italic-text-color').value;
            const aiBoldColor = document.getElementById('offline-ai-bold-text-color').value;

            // 添加到预存颜色（避免重复）
            const colorTypes = [
                { type: 'userNormal', color: userNormalColor },
                { type: 'userItalic', color: userItalicColor },
                { type: 'userBold', color: userBoldColor },
                { type: 'aiNormal', color: aiNormalColor },
                { type: 'aiItalic', color: aiItalicColor },
                { type: 'aiBold', color: aiBoldColor }
            ];

            colorTypes.forEach(({ type, color }) => {
                // 确保savedColors[type]存在
                if (!offlineUISettings.savedColors[type]) {
                    offlineUISettings.savedColors[type] = [];
                }

                if (!offlineUISettings.savedColors[type].includes(color)) {
                    offlineUISettings.savedColors[type].push(color);
                }

                // 限制预存颜色数量（最多10个）
                if (offlineUISettings.savedColors[type].length > 10) {
                    offlineUISettings.savedColors[type] = offlineUISettings.savedColors[type].slice(-10);
                }
            });

            updateSavedColorsDisplay();
            showToast('颜色已保存到预存', 'success');
        }

        // 重置为默认颜色
        function resetOfflineColors() {
            document.getElementById('offline-my-bubble-color').value = '#BED6EF'; /* 🔥【修改】用户气泡改为淡蓝色 */
            document.getElementById('offline-ai-bubble-color').value = '#f0f0f0';
            document.getElementById('offline-bubble-opacity').value = 0.9;
            document.getElementById('offline-opacity-value').textContent = '90%'; // 更新透明度显示
            document.getElementById('offline-font-size').value = 15; // 🔥【新增】重置字体大小
            document.getElementById('offline-font-size-value').textContent = '15px'; // 更新字体大小显示
            document.getElementById('offline-user-normal-text-color').value = '#000000'; /* 🔥【修改】用户文字改为黑色 */
            document.getElementById('offline-user-italic-text-color').value = '#333333'; /* 🔥【修改】用户斜体文字改为深灰色 */
            document.getElementById('offline-user-bold-text-color').value = '#000000'; /* 🔥【修改】用户粗体文字改为黑色 */
            document.getElementById('offline-ai-normal-text-color').value = '#000000';
            document.getElementById('offline-ai-italic-text-color').value = '#666666';
            document.getElementById('offline-ai-bold-text-color').value = '#333333';

            updateOfflinePreview();
            showToast('颜色已重置为默认', 'success');
        }

        // 保存线下模式界面设置
        async function saveOfflineUISettings() {
            const characterId = currentChatCharacter.id;

            try {
                // 收集设置数据
                offlineUISettings = {
                    myBubbleColor: document.getElementById('offline-my-bubble-color').value,
                    aiBubbleColor: document.getElementById('offline-ai-bubble-color').value,
                    bubbleOpacity: parseFloat(document.getElementById('offline-bubble-opacity').value),
                    fontSize: parseInt(document.getElementById('offline-font-size').value), // 🔥【新增】保存字体大小
                    wallpaperData: offlineUISettings.wallpaperData || '',
                    fontFamily: document.getElementById('offline-font-select').value,
                    fontUrl: document.getElementById('offline-font-url').value.trim(),
                    realFontName: window.previewedFontName || '', // 🔥【新增】保存预览时确定的真实字体名称
                    userNormalTextColor: document.getElementById('offline-user-normal-text-color').value,
                    userItalicTextColor: document.getElementById('offline-user-italic-text-color').value,
                    userBoldTextColor: document.getElementById('offline-user-bold-text-color').value,
                    aiNormalTextColor: document.getElementById('offline-ai-normal-text-color').value,
                    aiItalicTextColor: document.getElementById('offline-ai-italic-text-color').value,
                    aiBoldTextColor: document.getElementById('offline-ai-bold-text-color').value,
                    showUserAvatar: document.getElementById('offline-show-user-avatar').checked,
                    showAiAvatar: document.getElementById('offline-show-ai-avatar').checked,
                    avatarPosition: document.querySelector('input[name="offline-avatar-position"]:checked').value,
                    bubbleWidth: document.querySelector('input[name="offline-bubble-width"]:checked').value,
                    bubbleStyle: document.querySelector('input[name="offline-bubble-style"]:checked').value,
                    customCSS: document.getElementById('offline-custom-css').value.trim(),
                    savedColors: offlineUISettings.savedColors || {
                        userNormal: [], userItalic: [], userBold: [],
                        aiNormal: [], aiItalic: [], aiBold: []
                    }
                };

                // 🔥【修改】保存到Dexie数据库（每个角色独立）
                await saveOfflineUISettingsToDB();

                // 应用设置到线下模式界面
                applyOfflineUISettings();

                closeOfflineUISettings();
                showToast('界面设置已保存', 'success');

            } catch (error) {
                console.error('保存线下模式界面设置失败:', error);
                showToast('保存界面设置失败', 'error');
            }
        }

        // 🔥【新增】保存设置到Dexie数据库
        async function saveOfflineUISettingsToDB() {
            if (!currentChatCharacter || !offlineUISettings) return;

            const characterId = currentChatCharacter.id;

            // 🔥【增强】双重保存策略，优先保持窗口隔离
            let dbSaveSuccess = false;
            let localStorageSaveSuccess = false;

            // 首先尝试保存到数据库（优先窗口隔离格式）
            try {
                const dbKey = windowId ? `${characterId}_${windowId}_ui_settings` : `${characterId}_ui_settings`;
                await db.offlineUISettings.put({
                    id: dbKey,
                    characterId: characterId,
                    windowId: windowId || null,
                    settings: offlineUISettings,
                    timestamp: Date.now()
                });
                dbSaveSuccess = true;
                console.log(`✅ 线下模式界面设置已保存到数据库 (${dbKey})`);
            } catch (dbError) {
                console.warn('❌ 保存到数据库失败:', dbError);
            }

            // 同时保存到localStorage作为备份（也优先窗口隔离格式）
            try {
                const storageKey = windowId ? `offlineUISettings_${characterId}_${windowId}` : `offlineUISettings_${characterId}`;
                localStorage.setItem(storageKey, JSON.stringify(offlineUISettings));
                localStorageSaveSuccess = true;
                console.log(`✅ 线下模式界面设置已保存到localStorage (${storageKey})`);
            } catch (localStorageError) {
                console.warn('❌ 保存到localStorage失败:', localStorageError);
            }

            // 如果两种方式都失败，抛出错误
            if (!dbSaveSuccess && !localStorageSaveSuccess) {
                throw new Error('所有保存方式都失败了');
            }
        }

        // 应用线下模式界面设置
        function applyOfflineUISettings() {
            if (!offlineUISettings || !currentChatCharacter) return;

            const offlineOverlay = document.getElementById('offline-mode-overlay');
            if (!offlineOverlay) return;

            // 🔥【修复】获取聊天消息容器并重置背景
            const chatMessages = offlineOverlay.querySelector('.offline-chat-messages');
            if (chatMessages) {
                // 先清除旧背景
                chatMessages.style.backgroundImage = '';
                chatMessages.style.backgroundColor = ''; // 同样重置背景色
            }

            // 确保设置有默认值
            const myBubbleColor = offlineUISettings.myBubbleColor || '#007AFF';
            const aiBubbleColor = offlineUISettings.aiBubbleColor || '#f0f0f0';
            const bubbleOpacity = offlineUISettings.bubbleOpacity !== undefined ? offlineUISettings.bubbleOpacity : 0.9;
            const userNormalTextColor = offlineUISettings.userNormalTextColor || '#ffffff';
            const userItalicTextColor = offlineUISettings.userItalicTextColor || '#f0f0f0';
            const userBoldTextColor = offlineUISettings.userBoldTextColor || '#ffffff';
            const aiNormalTextColor = offlineUISettings.aiNormalTextColor || '#000000';
            const aiItalicTextColor = offlineUISettings.aiItalicTextColor || '#666666';
            const aiBoldTextColor = offlineUISettings.aiBoldTextColor || '#333333';

            // 应用气泡颜色和透明度
            const userBubbles = offlineOverlay.querySelectorAll('.offline-message.user .offline-message-content');
            const aiBubbles = offlineOverlay.querySelectorAll('.offline-message.ai .offline-message-content');

            userBubbles.forEach(bubble => {
                // 使用rgba背景色，只让背景透明，文字保持不透明
                const userBgColor = convertColorWithOpacity(myBubbleColor, bubbleOpacity);
                bubble.style.backgroundColor = userBgColor;
                bubble.style.opacity = 1; // 确保整个元素不透明
                bubble.style.color = userNormalTextColor;

                // 应用用户消息文字颜色
                const italicTexts = bubble.querySelectorAll('em');
                const boldTexts = bubble.querySelectorAll('strong');
                italicTexts.forEach(text => text.style.color = userItalicTextColor);
                boldTexts.forEach(text => text.style.color = userBoldTextColor);
            });

            aiBubbles.forEach(bubble => {
                // 使用rgba背景色，只让背景透明，文字保持不透明
                const aiBgColor = convertColorWithOpacity(aiBubbleColor, bubbleOpacity);
                bubble.style.backgroundColor = aiBgColor;
                bubble.style.opacity = 1; // 确保整个元素不透明
                bubble.style.color = aiNormalTextColor;

                // 应用AI消息文字颜色
                const italicTexts = bubble.querySelectorAll('em');
                const boldTexts = bubble.querySelectorAll('strong');
                italicTexts.forEach(text => text.style.color = aiItalicTextColor);
                boldTexts.forEach(text => text.style.color = aiBoldTextColor);
            });

            // 应用背景壁纸
            if (chatMessages && offlineUISettings.wallpaperData) {
                chatMessages.style.backgroundImage = `url(${offlineUISettings.wallpaperData})`;
                chatMessages.style.backgroundSize = 'cover';
                chatMessages.style.backgroundPosition = 'center';
                chatMessages.style.backgroundAttachment = 'fixed';
            }

            // 应用字体设置
            const fontName = `OfflineFont_${currentChatCharacter.id}`;
            const existingStyle = document.getElementById(`offline-font-${currentChatCharacter.id}`);
            if (existingStyle) {
                existingStyle.remove();
            }
            const existingLink = document.getElementById(`offline-font-link-${currentChatCharacter.id}`);
            if (existingLink) {
                existingLink.remove();
            }

            // 🔥【修改】优先使用线下模式专门设置的字体，否则使用全局字体设置
            if (offlineUISettings.fontFamily === 'custom' && offlineUISettings.fontUrl) {
                // 线下模式有专门的字体设置
                const url = offlineUISettings.fontUrl;

                // 判断是CSS链接还是直接字体文件
                if (url.includes('fonts.googleapis.com') || url.includes('fonts.google.com') || url.endsWith('.css') || url.includes('fontsapi') || url.includes('css')) {
                    // Google Fonts或其他CSS链接
                    const link = document.createElement('link');
                    link.id = `offline-font-link-${currentChatCharacter.id}`;
                    link.rel = 'stylesheet';
                    link.href = url;
                    link.onload = function() {
                        // 🔥【修复】优先使用保存的真实字体名称
                        let fontFamily = offlineUISettings.realFontName || extractFontFamilyFromGoogleFonts(url) || 'CustomFont';

                        // 🔥【新增】如果没有保存的真实字体名称，尝试从CSS中提取
                        if (!offlineUISettings.realFontName) {
                            try {
                                const sheets = document.styleSheets;
                                for (let i = sheets.length - 1; i >= 0; i--) {
                                    const sheet = sheets[i];
                                    if (sheet.href === url) {
                                        try {
                                            const rules = sheet.cssRules || sheet.rules;
                                            for (let j = 0; j < rules.length; j++) {
                                                const rule = rules[j];
                                                if (rule.type === CSSRule.FONT_FACE_RULE && rule.style.fontFamily) {
                                                    fontFamily = rule.style.fontFamily.replace(/['"]/g, '');
                                                    console.log('🎨 应用设置时从CSS中提取到真实字体名称:', fontFamily);
                                                    break;
                                                }
                                            }
                                        } catch (e) {
                                            console.log('🎨 应用设置时无法读取CSS规则，使用提取的名称');
                                        }
                                        break;
                                    }
                                }
                            } catch (e) {
                                console.log('🎨 应用设置时CSS解析失败，使用提取的名称');
                            }
                        } else {
                            console.log('🎨 使用保存的真实字体名称:', fontFamily);
                        }

                        const style = document.createElement('style');
                        style.id = `offline-font-${currentChatCharacter.id}`;
                        style.textContent = `
                            #offline-mode-overlay .offline-message-content {
                                font-family: '${fontFamily}', sans-serif !important;
                            }
                        `;
                        document.head.appendChild(style);
                        console.log('✅ 线下模式专用字体已应用:', fontFamily);
                    };
                    document.head.appendChild(link);
                } else {
                    // 直接字体文件
                    const style = document.createElement('style');
                    style.id = `offline-font-${currentChatCharacter.id}`;
                    style.textContent = `
                        @font-face {
                            font-family: '${fontName}';
                            src: url('${url}');
                        }
                        #offline-mode-overlay .offline-message-content {
                            font-family: '${fontName}', sans-serif !important;
                        }
                    `;
                    document.head.appendChild(style);
                    console.log('✅ 线下模式专用字体已应用:', fontName);
                }
            } else if (globalFontSettings && globalFontSettings.isApplied && globalFontSettings.fontName) {
                // 🔥【新增】线下模式没有专门设置字体，使用全局字体设置
                const style = document.createElement('style');
                style.id = `offline-font-${currentChatCharacter.id}`;
                style.textContent = `
                    #offline-mode-overlay .offline-message-content {
                        font-family: '${globalFontSettings.fontName}', sans-serif !important;
                    }
                `;
                document.head.appendChild(style);
                console.log('✅ 线下模式应用全局字体:', globalFontSettings.fontName);
            }

            // 应用头像显示设置
            const allMessages = offlineOverlay.querySelectorAll('.offline-message');

            allMessages.forEach(messageContainer => {
                const userAvatar = messageContainer.querySelector('.offline-avatar.user-avatar');
                const aiAvatar = messageContainer.querySelector('.offline-avatar.ai-avatar');

                // 清除所有相关的类
                messageContainer.classList.remove('no-user-avatar', 'no-ai-avatar');

                // 处理用户头像显示
                if (userAvatar) {
                    userAvatar.style.display = offlineUISettings.showUserAvatar ? 'flex' : 'none';
                }

                // 处理AI头像显示
                if (aiAvatar) {
                    aiAvatar.style.display = offlineUISettings.showAiAvatar ? 'flex' : 'none';
                }

                // 🔥【修正】根据头像显示状态添加对应的类
                if (!offlineUISettings.showUserAvatar) {
                    messageContainer.classList.add('no-user-avatar');
                }
                if (!offlineUISettings.showAiAvatar) {
                    messageContainer.classList.add('no-ai-avatar');
                }
            });

            // 应用气泡宽度设置
            if (offlineUISettings.bubbleWidth === 'default') {
                // 清除可能存在的自定义宽度样式，让CSS规则自动处理宽度
                const widthStyleId = `offline-width-${currentChatCharacter.id}`;
                const existingWidthStyle = document.getElementById(widthStyleId);
                if (existingWidthStyle) {
                    existingWidthStyle.remove();
                }
                // 不再强制设置90%，让CSS中的头像显示/隐藏规则来控制宽度
            }

            // 应用头像位置设置
            if (offlineUISettings.avatarPosition === 'side') {
                // 应用默认侧边位置
                const avatarStyleId = `offline-avatar-${currentChatCharacter.id}`;
                const existingAvatarStyle = document.getElementById(avatarStyleId);
                if (existingAvatarStyle) {
                    existingAvatarStyle.remove();
                }

                const avatarStyle = document.createElement('style');
                avatarStyle.id = avatarStyleId;
                avatarStyle.textContent = `
                    /* 🔥【修改】默认布局：用户靠右，AI居中 */
                    #offline-mode-overlay .offline-message.user {
                        justify-content: flex-end; /* 用户消息默认靠右 */
                    }
                    #offline-mode-overlay .offline-message.ai {
                        justify-content: center; /* AI消息默认居中 */
                    }

                    /* 🔥【新增】显示头像时的布局调整 */
                    #offline-mode-overlay .offline-message.user:not(.no-user-avatar) {
                        flex-direction: row;
                        justify-content: flex-end; /* 用户消息在右侧 */
                    }
                    #offline-mode-overlay .offline-message.ai:not(.no-ai-avatar) {
                        flex-direction: row-reverse;
                        justify-content: flex-start; /* AI消息在左侧 */
                    }
                    #offline-mode-overlay .offline-avatar {
                        position: relative;
                        margin: 0;
                    }
                `;
                document.head.appendChild(avatarStyle);
            }

            // 应用自定义CSS（优先级最高）
            if (offlineUISettings.customCSS &&
                (offlineUISettings.avatarPosition === 'custom' ||
                 offlineUISettings.bubbleWidth === 'custom' ||
                 offlineUISettings.bubbleStyle === 'custom')) {

                const customStyleId = `offline-custom-${currentChatCharacter.id}`;
                const existingCustomStyle = document.getElementById(customStyleId);
                if (existingCustomStyle) {
                    existingCustomStyle.remove();
                }

                const customStyle = document.createElement('style');
                customStyle.id = customStyleId;

                // 为CSS代码添加作用域，只影响当前线下模式
                const scopedCSS = offlineUISettings.customCSS.replace(/\.offline-/g, '#offline-mode-overlay .offline-');
                customStyle.textContent = scopedCSS;

                document.head.appendChild(customStyle);
            }

            // 🔥【新增】应用字体大小设置
            if (offlineUISettings.fontSize !== undefined) {
                const messageContents = offlineOverlay.querySelectorAll('.offline-message-content');
                messageContents.forEach(content => {
                    content.style.fontSize = `${offlineUISettings.fontSize}px`;
                });
            }
        }

        // 重置线下模式界面设置
        async function resetOfflineUISettings() {
            if (confirm('确定要重置所有界面设置为默认值吗？')) {
                // 重置为默认设置
                offlineUISettings = {
                    myBubbleColor: '#BED6EF', /* 🔥【修改】用户气泡改为淡蓝色 */
                    aiBubbleColor: '#f0f0f0',
                    bubbleOpacity: 0.9,
                    fontSize: 15, // 🔥【新增】重置字体大小为默认值
                    wallpaperData: '',
                    fontFamily: '',
                    fontUrl: '',
                    userNormalTextColor: '#000000', /* 🔥【修改】用户文字改为黑色 */
                    userItalicTextColor: '#333333', /* 🔥【修改】用户斜体文字改为深灰色 */
                    userBoldTextColor: '#000000', /* 🔥【修改】用户粗体文字改为黑色 */
                    aiNormalTextColor: '#000000',
                    aiItalicTextColor: '#666666',
                    aiBoldTextColor: '#333333',
                    showUserAvatar: false, /* 🔥【修改】重置时默认不显示用户头像 */
                    showAiAvatar: false, /* 🔥【修改】重置时默认不显示AI头像 */
                    avatarPosition: 'side',
                    bubbleWidth: 'default',
                    bubbleStyle: 'default',
                    customCSS: '',
                    savedColors: {
                        userNormal: [], userItalic: [], userBold: [],
                        aiNormal: [], aiItalic: [], aiBold: []
                    }
                };

                // 清除文件输入
                document.getElementById('offline-wallpaper-file').value = '';

                // 🔥【新增】清除数据库中的设置
                if (currentChatCharacter) {
                    try {
                        await db.offlineUISettings.delete(`${currentChatCharacter.id}_ui_settings`);
                        console.log('✅ 数据库中的设置已清除');
                    } catch (error) {
                        console.error('清除数据库设置失败:', error);
                    }
                }

                updateOfflineUISettingsForm();
                updateOfflinePreview();
                showToast('界面设置已重置', 'success');
            }
        }

        // 在进入线下模式时加载并应用界面设置
        async function loadAndApplyOfflineUISettings() {
            if (!currentChatCharacter) return;

            const characterId = currentChatCharacter.id;

            try {
                // 🔥【修复】保持窗口隔离的同时增强手机浏览器兼容性
                let settingsLoaded = false;

                // 首先尝试从localStorage加载（更稳定），优先窗口隔离格式
                try {
                    let savedSettings = null;
                    let storageKey = null;

                    // 优先尝试带窗口ID的设置（保持隔离）
                    if (windowId) {
                        storageKey = `offlineUISettings_${characterId}_${windowId}`;
                        savedSettings = localStorage.getItem(storageKey);
                    }

                    // 如果窗口隔离设置不存在，尝试通用格式（兼容性回退）
                    if (!savedSettings) {
                        storageKey = `offlineUISettings_${characterId}`;
                        savedSettings = localStorage.getItem(storageKey);
                    }

                    if (savedSettings) {
                        offlineUISettings = JSON.parse(savedSettings);
                        settingsLoaded = true;
                        console.log(`✅ 从localStorage加载线下模式界面设置成功 (${storageKey})`);
                    }
                } catch (localStorageError) {
                    console.warn('从localStorage加载失败:', localStorageError);
                }

                // 如果localStorage加载失败，尝试从数据库加载
                if (!settingsLoaded) {
                    try {
                        let settingsRecord = null;

                        // 优先尝试带窗口ID的设置（保持隔离）
                        if (windowId) {
                            settingsRecord = await db.offlineUISettings.get(`${characterId}_${windowId}_ui_settings`);
                        }

                        // 如果窗口隔离设置不存在，尝试通用格式（兼容性回退）
                        if (!settingsRecord) {
                            settingsRecord = await db.offlineUISettings.get(`${characterId}_ui_settings`);
                        }

                        if (settingsRecord && settingsRecord.settings) {
                            offlineUISettings = settingsRecord.settings;
                            settingsLoaded = true;
                            console.log(`✅ 从数据库加载线下模式界面设置成功`);
                        }
                    } catch (dbError) {
                        console.warn('从数据库加载失败:', dbError);
                    }
                }

                // 如果成功加载设置，应用它们
                if (settingsLoaded) {
                    applyOfflineUISettings();
                    console.log(`✅ 线下模式界面设置已应用`);
                }
            } catch (error) {
                console.error('加载线下模式界面设置失败:', error);
            }
        }

        // 🔥【新增】选择函数
        function selectAvatarPosition(value, element) {
            // 移除所有选中状态
            const siblings = element.parentNode.querySelectorAll('.radio-option-button');
            siblings.forEach(btn => btn.classList.remove('selected'));

            // 添加选中状态
            element.classList.add('selected');

            // 更新隐藏的radio按钮
            const radios = element.parentNode.querySelectorAll('input[name="offline-avatar-position"]');
            radios.forEach(radio => {
                radio.checked = radio.value === value;
            });
        }

        function selectBubbleWidth(value, element) {
            // 移除所有选中状态
            const siblings = element.parentNode.querySelectorAll('.radio-option-button');
            siblings.forEach(btn => btn.classList.remove('selected'));

            // 添加选中状态
            element.classList.add('selected');

            // 更新隐藏的radio按钮
            const radios = element.parentNode.querySelectorAll('input[name="offline-bubble-width"]');
            radios.forEach(radio => {
                radio.checked = radio.value === value;
            });
        }

        function selectBubbleStyle(value, element) {
            // 移除所有选中状态
            const siblings = element.parentNode.querySelectorAll('.radio-option-button');
            siblings.forEach(btn => btn.classList.remove('selected'));

            // 添加选中状态
            element.classList.add('selected');

            // 更新隐藏的radio按钮
            const radios = element.parentNode.querySelectorAll('input[name="offline-bubble-style"]');
            radios.forEach(radio => {
                radio.checked = radio.value === value;
            });
        }

document.addEventListener('visibilitychange', function() {
    const phoneScreen = document.getElementById('phone-screen');
    if (!phoneScreen) return;

    if (document.visibilityState === 'visible') {
        // 页面变为可见状态
        console.log("✅ 页面恢复可见，正在恢复动画和定时器...");

        // 1. 恢复所有 CSS 动画
        phoneScreen.style.animationPlayState = 'running';
        const animatedElements = document.querySelectorAll('[style*="animation"]');
        animatedElements.forEach(el => el.style.animationPlayState = 'running');

        // 2. 强制浏览器进行一次重绘，清除残留的线条
        // 这是一个常用的小技巧，通过快速改变一个不影响布局的属性来触发重绘
        phoneScreen.style.opacity = '0.99';
        setTimeout(() => {
            phoneScreen.style.opacity = '1';
        }, 16); // 16ms 约等于一帧的时间

        // 3. 如果您有通过 setInterval 启动的复杂JS动画，可以在这里重新启动它们
        // 例如：重新启动时钟（虽然时钟通常影响不大，但作为示例）
        if (typeof updateTime === 'function') {
           // 如果之前有清除定时器，在这里重新设置
           // setInterval(updateTime, 1000);
        }

    } else {
        // 页面变为隐藏状态
        console.log("💤 页面已隐藏，暂停动画以节省资源...");

        // 1. 暂停所有 CSS 动画
        phoneScreen.style.animationPlayState = 'paused';
        const animatedElements = document.querySelectorAll('[style*="animation"]');
        animatedElements.forEach(el => el.style.animationPlayState = 'paused');

        // 2. 如果有复杂的JS动画定时器，可以在这里清除它们
        // clearInterval(yourAnimationTimer);
    }
});

// 【新增】"搞个大新闻"相关函数

// 显示"搞个大新闻"模态框
function showMakeNewsModal() {
    const modalHTML = `
        <div id="make-news-modal" class="modal" style="display: flex;">
            <div class="modal-content">
                <div class="modal-header">
                    <h3 class="modal-title">搞个大新闻</h3>
                    <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
                </div>
                <div class="modal-body">
                    <p style="font-size: 14px; color: #666; margin-bottom: 15px;">
                        输入一个世界事件，AI将在24小时内围绕这个事件生成新的论坛帖子。
                    </p>
                    <textarea id="news-content-input" class="form-textarea" placeholder="例如：听闻魔尊即将出关，正道各派将在昆仑之巅会盟商议对策。" style="min-height: 100px;"></textarea>
                </div>
                <div class="modal-footer">
                    <button class="modal-button modal-secondary" onclick="this.closest('.modal').remove()">取消</button>
                    <button class="modal-button modal-primary" onclick="submitMakeNews()">发布事件</button>
                </div>
            </div>
        </div>
    `;
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    setTimeout(() => document.getElementById('news-content-input').focus(), 100);
}

// 提交"大新闻"
function submitMakeNews() {
    const contentInput = document.getElementById('news-content-input');
    const content = contentInput.value.trim();

    if (!content) {
        alert('请输入事件内容！');
        return;
    }

    // 设置世界事件，有效期为24小时
    worldEvent = {
        content: content,
        expires: Date.now() + 24 * 60 * 60 * 1000
    };

    const modal = document.getElementById('make-news-modal');
    if (modal) modal.remove();

    showToast('世界线已变动！正在刷新论坛...', 'success');

    // 立即刷新帖子以体现新事件
    refreshPosts();
}

// --- 个人主页分区切换 ---
function switchProfileTab(tab) {
    const myPostsList = document.getElementById('my-posts-list');
    const favListContainer = document.getElementById('favorite-posts-list');
    const tabs = document.querySelectorAll('.profile-tab');

    tabs.forEach(t => t.classList.remove('active'));
    document.querySelector(`.profile-tab[onclick*="${tab}"]`).classList.add('active');

    if (tab === 'my-posts') {
        myPostsList.style.display = 'block';
        favListContainer.style.display = 'none';
    } else {
        myPostsList.style.display = 'none';
        favListContainer.style.display = 'block';
    }

    // 🔥【新增】如果当前处于多选模式，重新渲染带选择框的列表
    if (isForumMultiSelectMode) {
        selectedPostIds.clear(); // 清空选择状态
        renderPostsWithCheckboxes();
        updateDeleteButtonState();
    }
}

// --- 帖子分享功能 ---

// 1. 显示分享模态框
async function showSharePostModal() {
    const conversations = [];
    // 获取单聊
    characters.forEach(char => {
        if (contacts.includes(char.id)) {
            conversations.push({ id: char.id, name: char.name, avatarUrl: char.avatarUrl, isGroup: false });
        }
    });
    // 获取群聊
    groupChats.forEach(group => {
        conversations.push({ id: group.id, name: group.name, avatarUrl: group.avatarUrl, isGroup: true });
    });

    const modalHTML = `
        <div id="share-post-modal" class="modal" style="display: flex;">
            <div class="modal-content">
                <div class="modal-header">
                    <h3 class="modal-title">分享到...</h3>
                    <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
                </div>
                <div class="modal-body" style="max-height: 400px; overflow-y: auto;">
                    ${conversations.map(chat => `
                        <div class="chat-option-item" onclick="sharePostToChat('${chat.id}')">
                            <div class="chat-option-icon" style="background-image: url('${chat.avatarUrl || createDefaultAvatar(chat.name)}'); background-size: cover; background-position: center;">
                                ${chat.isGroup && !chat.avatarUrl ? '群' : ''}
                            </div>
                            <div class="chat-option-text">
                                <div class="chat-option-title">${chat.name}</div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            </div>
        </div>
    `;
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

// 2. 将帖子分享到指定对话
async function sharePostToChat(chatId) {
    if (!window.currentPostId) return;

    try {
        const post = await db.forumPosts.get(window.currentPostId);
        if (!post) {
            showToast('帖子不存在', 'error');
            return;
        }

        // 获取当前用户身份
        const forum = await db.forums.get(parseInt(currentForumId));
        const persona = personas.find(p => p.id === forum.personaId);

        // 获取帖子的评论
        const replies = await db.forumReplies.where('postId').equals(window.currentPostId).sortBy('timestamp');

        // 创建包含评论的完整内容
        let fullContent = `【帖子标题】${post.title}\n\n【作者】${post.authorName}\n\n【正文】\n${post.content}`;

        if (replies && replies.length > 0) {
            fullContent += '\n\n【评论区】\n';
            replies.forEach((reply, index) => {
                const replyTime = new Date(reply.timestamp).toLocaleString('zh-CN', {
                    month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit'
                });

                // 🔥【隐私保护】正确处理用户回复的身份显示
                let displayAuthor = reply.authorName;
                if (reply.isAnonymous && reply.authorId === 'user') {
                    // 用户的匿名回复，保持匿名显示，不暴露身份
                    displayAuthor = reply.authorName; // 保持原来的匿名名称
                } else if (reply.authorId === 'user' && !reply.isAnonymous) {
                    // 用户的非匿名回复，显示用户在该社区的身份面具名字
                    displayAuthor = persona ? persona.name : reply.authorName;
                }

                fullContent += `\n${index + 1}楼 ${displayAuthor} (${replyTime}):\n${reply.content}\n`;
            });
        }

        // 🔥【核心修复】在分享时，提前将帖子的HTML内容（如投票）转换为纯文本用于显示
        const postContentForDisplay = (post.content || '').replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();

        // 创建分享消息
        const shareMessage = {
            id: Date.now().toString(),
            sender: 'sent', // 消息是你发送的
            type: 'shared_post',
            postData: { // 嵌入帖子核心信息
                id: post.id,
                title: post.title,
                authorName: post.authorName,
                content: postContentForDisplay, // 使用净化后的纯文本
                replies: replies // 包含评论数据
            },
            timestamp: Date.now(),
            senderName: persona.name, // 记录发送者是你自己
            content: fullContent // 包含完整内容的文本，AI可以看到这个
        };

        if (!chatMessages[chatId]) {
            chatMessages[chatId] = [];
        }
        chatMessages[chatId].push(shareMessage);
        // 🔥【高效保存】直接添加单条分享消息到数据库，避免全量重写
        try {
            const stableId = `${chatId}_${shareMessage.id}_${chatMessages[chatId].length - 1}`;
            await db.chatMessages.add({
                id: stableId,
                characterId: chatId,
                timestamp: shareMessage.timestamp,
                messageOrder: chatMessages[chatId].length - 1,
                originalMessageId: shareMessage.id,
                messageData: shareMessage
            });
            console.log('✅ [高效分享] 论坛帖子分享消息已保存到数据库');
        } catch (error) {
            console.error('分享消息单条保存失败，回退到批量保存:', error);
            await saveChatMessages();
        }

        // 关闭分享模态框
        const modal = document.getElementById('share-post-modal');
        if(modal) modal.remove();

        showToast(`成功分享到对话！`, 'success');

        // 如果分享给了当前打开的对话，则立即刷新
        if (currentChatCharacter && currentChatCharacter.id === chatId) {
            renderChatMessages(chatId);
        }
        // 无论如何都刷新消息列表，以显示最新的分享消息
        renderMessageList();

    } catch (error) {
        console.error('分享帖子失败:', error);
        showToast('分享失败', 'error');
    }
}

// 添加音乐播放器文件选择事件监听器
document.addEventListener('DOMContentLoaded', function() {
    // 本地音乐文件选择
    const localMusicInput = document.getElementById('local-music-input');
    if (localMusicInput) {
        localMusicInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const urlInput = document.getElementById('song-url-input');
                const titleInput = document.getElementById('song-title-input');

                urlInput.placeholder = `已选择: ${file.name}`;
                urlInput.style.color = '#007AFF';
                urlInput.value = ''; // 清空URL输入

                // 自动填充歌曲标题
                if (!titleInput.value.trim()) {
                    titleInput.value = file.name.replace(/\.[^/.]+$/, "");
                }
            }
        });
    }

    // 歌词文件选择
    const lyricsFileInput = document.getElementById('lyrics-file-input');
    if (lyricsFileInput) {
        lyricsFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const lyricsStatus = document.getElementById('lyrics-file-status');
                const fileName = file.name.toLowerCase();
                let fileType = '歌词文件';

                if (fileName.endsWith('.lrc')) {
                    fileType = 'LRC歌词';
                } else if (fileName.endsWith('.bin')) {
                    fileType = 'bin歌词';
                } else if (fileName.endsWith('.txt')) {
                    fileType = 'TXT歌词';
                } else {
                    // 对于其他文件类型，给出提示但仍然允许选择
                    fileType = '文件';
                    console.log('选择的文件可能不是标准歌词格式，但仍会尝试处理:', file.name);
                }

                if (lyricsStatus) {
                    lyricsStatus.textContent = `已选择${fileType}: ${file.name}`;
                    lyricsStatus.style.display = 'block';
                    lyricsStatus.style.color = '#007AFF';
                }
            }
        });
    }

});

        // 🔥【修复】添加缺失的 closeModal 函数 - 全局作用域
        function closeModal() {
            const modal = document.querySelector('.modal-overlay');
            if (modal) {
                modal.remove();
            }
        }

        // 🔥【修复】添加缺失的 clearVoteHistory 函数 - 全局作用域
        function clearVoteHistory() {
            if (confirm('确定要清空所有投票历史吗？此操作不可恢复。')) {
                try {
                    // 清空所有投票相关的localStorage
                    Object.keys(localStorage)
                        .filter(key => key.startsWith('poll_voted_') || key.startsWith('vote_detail_'))
                        .forEach(key => localStorage.removeItem(key));

                    showToast('投票历史已清空', 'success');
                    closeModal();
                } catch (error) {
                    console.error('清空投票历史失败:', error);
                    showToast('清空失败', 'error');
                }
            }
        }

        // 🔥【新增】论坛个人主页多选删除功能 - 全局变量和函数
        let isForumMultiSelectMode = false;
        let selectedPostIds = new Set();

        // 切换多选模式
        function toggleMultiSelectMode() {
            isForumMultiSelectMode = !isForumMultiSelectMode;
            selectedPostIds.clear();

            const multiSelectBtn = document.getElementById('multi-select-btn');
            const icon = multiSelectBtn.querySelector('i');

            if (isForumMultiSelectMode) {
                // 🔥【修改】进入多选模式 - 改为叉号图标
                icon.className = 'fas fa-times';
                multiSelectBtn.title = '退出多选';
                multiSelectBtn.style.color = '#ff3b30'; // 这个颜色会被CSS覆盖

                // 重新渲染帖子列表，添加选择框
                renderPostsWithCheckboxes();

                // 显示删除按钮
                showDeleteButton();
            } else {
                // 退出多选模式
                icon.className = 'fas fa-trash';
                multiSelectBtn.title = '多选删除';
                multiSelectBtn.style.color = '';

                // 重新渲染帖子列表，移除选择框
                showForumProfile();

                // 隐藏删除按钮
                hideDeleteButton();
            }
        }

        // 重新渲染帖子列表，添加选择框
        async function renderPostsWithCheckboxes() {
            const currentTab = document.querySelector('.profile-tab.active').textContent;

            if (currentTab === '我的帖子') {
                await renderMyPostsWithCheckboxes();
            } else {
                await renderFavoritePostsWithCheckboxes();
            }
        }

        // 渲染我的帖子（带选择框）
        async function renderMyPostsWithCheckboxes() {
            const myPostsList = document.getElementById('my-posts-list');
            const allPosts = await db.forumPosts.toArray();
            const userPosts = allPosts.filter(post => post.isUserPost === true).sort((a, b) => b.timestamp - a.timestamp);

            if (userPosts.length === 0) {
                myPostsList.innerHTML = `<div class="forum-empty-state"><p>你还没有发过帖子</p></div>`;
                return;
            }

            const userPostsHtml = await Promise.all(userPosts.map(async post => {
                const hasImage = await db.forumPostImages.where('postId').equals(post.id).count() > 0;
                const isSelected = selectedPostIds.has(post.id);

                return `
                    <div class="post-item multi-select-item ${isSelected ? 'selected' : ''}" data-post-id="${post.id}" onclick="togglePostSelection(${post.id}, event)">
                        <div class="post-checkbox">
                            <i class="fas ${isSelected ? 'fa-check-square' : 'fa-square'}"></i>
                        </div>
                        <div class="post-content">
                            <div class="post-title-container">
                                <div class="post-title">
                                    ${post.title}
                                    ${hasImage ? '<svg class="image-post-badge" viewBox="0 0 24 24"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>' : ''}
                                </div>
                                <span class="user-post-badge">我</span>
                            </div>
                            <div class="post-meta">
                                <span class="post-author">${post.authorName}</span>
                                <span>${formatTime(post.timestamp)}</span>
                            </div>
                        </div>
                    </div>
                `;
            }));
            myPostsList.innerHTML = userPostsHtml.join('');
        }

        // 渲染我的收藏（带选择框）
        async function renderFavoritePostsWithCheckboxes() {
            const favListContainer = document.getElementById('favorite-posts-list');
            const favoriteRecords = await db.forumFavorites.where('userId').equals('user').toArray();
            const postIds = favoriteRecords.map(fav => fav.postId);

            if (postIds.length === 0) {
                favListContainer.innerHTML = `<div class="forum-empty-state"><p>你还没有收藏任何帖子</p></div>`;
                return;
            }

            const favoritePosts = await db.forumPosts.where('id').anyOf(postIds).toArray();
            const favoritePostsHtml = await Promise.all(favoritePosts.sort((a,b) => b.timestamp - a.timestamp).map(async post => {
                const hasImage = await db.forumPostImages.where('postId').equals(post.id).count() > 0;
                const isSelected = selectedPostIds.has(post.id);

                return `
                    <div class="post-item multi-select-item ${isSelected ? 'selected' : ''}" data-post-id="${post.id}" onclick="togglePostSelection(${post.id}, event)">
                        <div class="post-checkbox">
                            <i class="fas ${isSelected ? 'fa-check-square' : 'fa-square'}"></i>
                        </div>
                        <div class="post-content">
                            <div class="post-title-container">
                                <div class="post-title">
                                    ${post.title}
                                    ${hasImage ? '<svg class="image-post-badge" viewBox="0 0 24 24"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>' : ''}
                                </div>
                                ${post.isUserPost ? '<span class="user-post-badge">我</span>' : ''}
                            </div>
                            <div class="post-meta">
                                <span class="post-author">${post.authorName}</span>
                                <span>${formatTime(post.timestamp)}</span>
                            </div>
                        </div>
                    </div>
                `;
            }));
            favListContainer.innerHTML = favoritePostsHtml.join('');
        }

        // 切换帖子选择状态
        function togglePostSelection(postId, event) {
            event.stopPropagation();

            const postItem = document.querySelector(`[data-post-id="${postId}"]`);
            const checkbox = postItem.querySelector('.post-checkbox i');

            if (selectedPostIds.has(postId)) {
                selectedPostIds.delete(postId);
                postItem.classList.remove('selected');
                checkbox.className = 'fas fa-square';
            } else {
                selectedPostIds.add(postId);
                postItem.classList.add('selected');
                checkbox.className = 'fas fa-check-square';
            }

            updateDeleteButtonState();
        }

        // 显示删除按钮
        function showDeleteButton() {
            const existingBtn = document.getElementById('multi-delete-btn');
            if (existingBtn) return;

            const deleteBtn = document.createElement('div');
            deleteBtn.id = 'multi-delete-btn';
            deleteBtn.className = 'floating-delete-btn';
            deleteBtn.innerHTML = `
                <button class="select-all-btn" onclick="toggleSelectAll()" title="全选/取消全选">
                    <i class="fas fa-check-double"></i>
                </button>
                <button class="delete-action-btn" onclick="confirmDeleteSelectedPosts()" title="删除选中的帖子">
                    <i class="fas fa-trash"></i>
                    <span id="selected-count">0</span>
                </button>
                <button class="cancel-action-btn" onclick="toggleMultiSelectMode()" title="取消多选模式">
                    取消
                </button>
            `;

            document.getElementById('forum-profile-screen').appendChild(deleteBtn);
        }

        // 隐藏删除按钮
        function hideDeleteButton() {
            const deleteBtn = document.getElementById('multi-delete-btn');
            if (deleteBtn) {
                deleteBtn.remove();
            }
        }

        // 更新删除按钮状态
        function updateDeleteButtonState() {
            const countSpan = document.getElementById('selected-count');
            const deleteBtn = document.getElementById('multi-delete-btn');

            if (countSpan) {
                countSpan.textContent = selectedPostIds.size;
            }

            if (deleteBtn) {
                deleteBtn.style.opacity = selectedPostIds.size > 0 ? '1' : '0.5';
                deleteBtn.style.pointerEvents = selectedPostIds.size > 0 ? 'auto' : 'none';
            }
        }

        // 确认删除选中的帖子
        async function confirmDeleteSelectedPosts() {
            if (selectedPostIds.size === 0) {
                showToast('请先选择要删除的帖子', 'warning');
                return;
            }

            const currentTab = document.querySelector('.profile-tab.active').textContent;
            const actionText = currentTab === '我的帖子' ? '删除这些帖子' : '取消收藏这些帖子';

            if (!confirm(`确定要${actionText}吗？共 ${selectedPostIds.size} 个项目。${currentTab === '我的帖子' ? '\n\n注意：删除帖子将同时删除所有回复和相关数据，此操作不可撤销！' : ''}`)) {
                return;
            }

            try {
                if (currentTab === '我的帖子') {
                    await deleteSelectedPosts();
                } else {
                    await unfavoriteSelectedPosts();
                }

                showToast(`成功${actionText}`, 'success');

                // 退出多选模式并刷新列表
                toggleMultiSelectMode();

            } catch (error) {
                console.error('删除操作失败:', error);
                showToast('操作失败，请重试', 'error');
            }
        }

        // 删除选中的帖子
        async function deleteSelectedPosts() {
            const postIdsArray = Array.from(selectedPostIds);

            // 删除帖子相关的所有数据
            await Promise.all([
                // 删除帖子本身
                db.forumPosts.where('id').anyOf(postIdsArray).delete(),
                // 删除帖子的回复
                db.forumReplies.where('postId').anyOf(postIdsArray).delete(),
                // 删除帖子的收藏记录
                db.forumFavorites.where('postId').anyOf(postIdsArray).delete(),
                // 删除帖子的图片
                db.forumPostImages.where('postId').anyOf(postIdsArray).delete(),
                // 删除回复的点赞记录
                db.replyLikes.where('postId').anyOf(postIdsArray).delete()
            ]);
        }

        // 取消收藏选中的帖子
        async function unfavoriteSelectedPosts() {
            const postIdsArray = Array.from(selectedPostIds);

            // 删除收藏记录
            await db.forumFavorites.where('postId').anyOf(postIdsArray).and(fav => fav.userId === 'user').delete();
        }

        // 全选/取消全选功能
        function toggleSelectAll() {
            const allPostItems = document.querySelectorAll('.multi-select-item');
            const allPostIds = Array.from(allPostItems).map(item => parseInt(item.dataset.postId));

            // 判断是否已经全选
            const isAllSelected = allPostIds.every(id => selectedPostIds.has(id));

            if (isAllSelected) {
                // 取消全选
                selectedPostIds.clear();
                allPostItems.forEach(item => {
                    item.classList.remove('selected');
                    const checkbox = item.querySelector('.post-checkbox i');
                    checkbox.className = 'fas fa-square';
                });
            } else {
                // 全选
                allPostIds.forEach(id => selectedPostIds.add(id));
                allPostItems.forEach(item => {
                    item.classList.add('selected');
                    const checkbox = item.querySelector('.post-checkbox i');
                    checkbox.className = 'fas fa-check-square';
                });
            }

            updateDeleteButtonState();
        }


    </script>

    <!-- 转发目标选择模态框 -->
    <div class="modal" id="forward-target-modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">选择一个聊天</div>
                <button class="modal-close" onclick="hideModal('forward-target-modal')">&times;</button>
            </div>
            <div class="modal-body" id="forward-target-list">
            </div>
        </div>
    </div>

    <!-- 查看转发记录详情模态框 -->
    <div class="modal" id="forwarded-view-modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="forwarded-view-title">聊天记录</div>
                <button class="modal-close" onclick="hideModal('forwarded-view-modal')">&times;</button>
            </div>
            <div class="modal-body" id="forwarded-view-content">
            </div>
        </div>
    </div>

    <script>
        // 开始选择模式
        function startEmojiSelection() {
            document.getElementById('start-selection-btn').style.display = 'none';
            document.getElementById('selection-buttons').style.display = 'flex';

            // 显示所有复选框
            const checkboxes = document.querySelectorAll('.emoji-checkbox');
            checkboxes.forEach(cb => cb.style.display = 'block');
        }

        // 全选
        function selectAllEmojis() {
            const checkboxes = document.querySelectorAll('.emoji-checkbox');
            checkboxes.forEach(cb => cb.checked = true);
        }

        // 删除选中的表情包
        function deleteSelectedEmojis() {
            const selectedCheckboxes = document.querySelectorAll('.emoji-checkbox:checked');
            if (selectedCheckboxes.length === 0) {
                alert('请先选择要删除的表情包');
                return;
            }

            if (!confirm(`确定要删除选中的 ${selectedCheckboxes.length} 个表情包吗？`)) {
                return;
            }

            selectedCheckboxes.forEach(cb => {
                removeEmojiFromLibrary(cb.dataset.emojiId);
            });

            cancelSelection();
        }

        // 取消选择模式
        function cancelSelection() {
            document.getElementById('start-selection-btn').style.display = 'block';
            document.getElementById('selection-buttons').style.display = 'none';

            // 隐藏所有复选框并取消选中
            const checkboxes = document.querySelectorAll('.emoji-checkbox');
            checkboxes.forEach(cb => {
                cb.style.display = 'none';
                cb.checked = false;
            });
        }
    </script>

    <script src="auth.js"></script>

</body>
</html>